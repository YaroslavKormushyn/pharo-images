[31m#close was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #close
[ "operationWindow createWindowGroup addWindow: resultWindow"
operationProcess terminate.
operationWindow close.
resultWindow close ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ "operationWindow createWindowGroup addWindow: re...etc...
[ :event | aBlock value ] in TRCanvas>>addMenu:callback: in Block: [ :event | aBlock value ]
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31mHalt
[0mCOOSparseMatrix(Object)>>halt
[ leftSavedMatrixMarker := leftMatrixMarker := first.
self activate: leftMatrixMarker in: #left on: composer.
rightMatrixMarker := transposed first.
self activate: rightMatrixMarker in: #right on: composer.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
composer view signalUpdate.
self halt.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								self activate: leftMatrixMarker in: #left on: composer.
								self activate: rightMatrixMarker in: #right on: composer.
								leftMarkerElement model: leftMatrixMarker.
								rightMarkerElement model: rightMatrixMarker.
								composer view signalUpdate.
								(Delay forSeconds: 1) wait ].
						"reset left marker to row beginning"
						self deactivate: leftMatrixMarker in: #left on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						leftMarkerElement model: leftMatrixMarker.
						composer view signalUpdate.
						(Delay forSeconds: 1) wait.
						currentLeftRow := leftMatrixMarker row.
						currentRightColumn := rightMatrixMarker row.
						self
							withEscaper: [ :next | 
								[ leftMatrixMarker isNotNil
									and: [ rightMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
									whileTrue: [ priorityColumn := {leftMatrixMarker column.
										rightMatrixMarker column} max.
										"Find same column as prioritized or higher in left"
										[ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ leftMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												self activate: leftMatrixMarker in: #left on: composer.
												leftMarkerElement model: leftMatrixMarker.
												composer view signalUpdate.
												(Delay forSeconds: 1) wait ].
										leftMatrixMarker isNil
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement model: rightMatrixMarker.
																composer view signalUpdate.
																(Delay forSeconds: 1) wait ] ].

												"If no intersection - end"
												rightMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										leftMatrixMarker row ~= currentLeftRow
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement model: rightMatrixMarker.
																composer view signalUpdate.
																(Delay forSeconds: 1) wait ] ].
												next value ].
										priorityColumn := leftMatrixMarker column.

										"Find same column as prioritized or higher in right"
										[ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn
													and: [ rightMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMarkerElement model: rightMatrixMarker.
												composer view signalUpdate.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ].
										rightMatrixMarker isNil
											ifTrue: [ [ leftMatrixMarker isNotNil
													and: [ leftMatrixMarker row = currentLeftRow ] ]
													whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
														(Delay forSeconds: 1) wait.
														leftMatrixMarker := leftMatrixMarker rightNeighbour.
														self activate: leftMatrixMarker in: #left on: composer.
														leftMarkerElement model: leftMatrixMarker.
														composer view signalUpdate.
														(Delay forSeconds: 1) wait ].

												"If no intersections - end"
												leftMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										rightMatrixMarker row ~= currentRightColumn
											ifTrue: [ next value ].
										leftMatrixMarker column = rightMatrixMarker column
											ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
												self highlight: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												sum := sum
													+ (leftMatrixMarker value * rightMatrixMarker value).
												self deactivate: leftMatrixMarker in: #left on: composer.
												self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												leftMarkerElement model: leftMatrixMarker.
												rightMarkerElement model: rightMatrixMarker.
												composer view signalUpdate.
												self activate: leftMatrixMarker in: #left on: composer.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ]
											ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
						sum = 0
							ifFalse: [ newNode := COOSparseMatrixNode
									row: currentLeftRow
									column: currentRightColumn
									value: sum.
								result last rightNeighbour: newNode.
								newNode leftNeighbour: result last.
								result last: newNode.
								sum := 0 ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ] ].
"nil the reference to dummy head"
result first rightNeighbour leftNeighbour: nil.
result first: result first rightNeighbour.
result ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ leftSavedMatrixMarker := leftMatrixMarker := fir...etc...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mCOOSparseMatrix(Object)>>halt
[ leftSavedMatrixMarker := leftMatrixMarker := first.
self activate: leftMatrixMarker in: #left on: composer.
rightMatrixMarker := transposed first.
self activate: rightMatrixMarker in: #right on: composer.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
composer view signalUpdate.
self halt.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								self activate: leftMatrixMarker in: #left on: composer.
								self activate: rightMatrixMarker in: #right on: composer.
								leftMarkerElement model: leftMatrixMarker.
								rightMarkerElement model: rightMatrixMarker.
								composer view signalUpdate.
								(Delay forSeconds: 1) wait ].
						"reset left marker to row beginning"
						self deactivate: leftMatrixMarker in: #left on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						leftMarkerElement model: leftMatrixMarker.
						composer view signalUpdate.
						(Delay forSeconds: 1) wait.
						currentLeftRow := leftMatrixMarker row.
						currentRightColumn := rightMatrixMarker row.
						self
							withEscaper: [ :next | 
								[ leftMatrixMarker isNotNil
									and: [ rightMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
									whileTrue: [ priorityColumn := {leftMatrixMarker column.
										rightMatrixMarker column} max.
										"Find same column as prioritized or higher in left"
										[ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ leftMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												self activate: leftMatrixMarker in: #left on: composer.
												leftMarkerElement model: leftMatrixMarker.
												composer view signalUpdate.
												(Delay forSeconds: 1) wait ].
										leftMatrixMarker isNil
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement model: rightMatrixMarker.
																composer view signalUpdate.
																(Delay forSeconds: 1) wait ] ].

												"If no intersection - end"
												rightMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										leftMatrixMarker row ~= currentLeftRow
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement model: rightMatrixMarker.
																composer view signalUpdate.
																(Delay forSeconds: 1) wait ] ].
												next value ].
										priorityColumn := leftMatrixMarker column.

										"Find same column as prioritized or higher in right"
										[ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn
													and: [ rightMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMarkerElement model: rightMatrixMarker.
												composer view signalUpdate.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ].
										rightMatrixMarker isNil
											ifTrue: [ [ leftMatrixMarker isNotNil
													and: [ leftMatrixMarker row = currentLeftRow ] ]
													whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
														(Delay forSeconds: 1) wait.
														leftMatrixMarker := leftMatrixMarker rightNeighbour.
														self activate: leftMatrixMarker in: #left on: composer.
														leftMarkerElement model: leftMatrixMarker.
														composer view signalUpdate.
														(Delay forSeconds: 1) wait ].

												"If no intersections - end"
												leftMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										rightMatrixMarker row ~= currentRightColumn
											ifTrue: [ next value ].
										leftMatrixMarker column = rightMatrixMarker column
											ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
												self highlight: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												sum := sum
													+ (leftMatrixMarker value * rightMatrixMarker value).
												self deactivate: leftMatrixMarker in: #left on: composer.
												self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												leftMarkerElement model: leftMatrixMarker.
												rightMarkerElement model: rightMatrixMarker.
												composer view signalUpdate.
												self activate: leftMatrixMarker in: #left on: composer.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ]
											ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
						sum = 0
							ifFalse: [ newNode := COOSparseMatrixNode
									row: currentLeftRow
									column: currentRightColumn
									value: sum.
								result last rightNeighbour: newNode.
								newNode leftNeighbour: result last.
								result last: newNode.
								sum := 0 ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ] ].
"nil the reference to dummy head"
result first rightNeighbour leftNeighbour: nil.
result first: result first rightNeighbour.
result ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ leftSavedMatrixMarker := leftMatrixMarker := fir...etc...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of RTElement did not understand #do:
[0mRTElement(Object)>>doesNotUnderstand: #do:
RTView>>addAll:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31m#close was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #close
[ "operationWindow createWindowGroup addWindow: resultWindow"
operationProcess terminate.
operationWindow close.
resultWindow close ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ "operationWindow createWindowGroup addWindow: re...etc...
[ :event | aBlock value ] in TRCanvas>>addMenu:callback: in Block: [ :event | aBlock value ]
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31m#close was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #close
[ "operationWindow createWindowGroup addWindow: resultWindow"
operationProcess terminate.
operationWindow close.
resultWindow close ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ "operationWindow createWindowGroup addWindow: re...etc...
[ :event | aBlock value ] in TRCanvas>>addMenu:callback: in Block: [ :event | aBlock value ]
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31mError: cannot remove an element that is not part of a view
[0mRTElement(Object)>>error:
RTElement>>remove
ByteSymbol(Symbol)>>value:
RTGroup(OrderedCollection)>>do:
RTView>>removeElements:
RTComposer>>replaceExistingGroup:
COOSparseMatrix>>replaceElementsInGroup:with:on:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ rightMatrixMarker := transposed first.
		leftSavedMatrixMarker := leftMatrixMarker.
		self activate: leftMatrixMarker in: #left on: composer.
		self activate: rightMatrixMarker in: #right on: composer.
		leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
		rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
		(Delay forSeconds: 1) wait ].
"reset left marker to row beginning"
self deactivate: leftMatrixMarker in: #left on: composer.
(Delay forSeconds: 1) wait.
leftMatrixMarker := leftSavedMatrixMarker.
self activate: leftMatrixMarker in: #left on: composer.
leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
(Delay forSeconds: 1) wait.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						self activate: leftMatrixMarker in: #left on: composer.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: 1) wait ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
								(Delay forSeconds: 1) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: 1) wait ] ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
								(Delay forSeconds: 1) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: 1) wait ] ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
						(Delay forSeconds: 1) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						self activate: rightMatrixMarker in: #right on: composer.
						(Delay forSeconds: 1) wait ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
								(Delay forSeconds: 1) wait.
								leftMatrixMarker := leftMatrixMarker rightNeighbour.
								self activate: leftMatrixMarker in: #left on: composer.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								(Delay forSeconds: 1) wait ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
						self highlight: rightMatrixMarker in: #right on: composer.
						(Delay forSeconds: 1) wait.
						sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						self deactivate: leftMatrixMarker in: #left on: composer.
						self deactivate: rightMatrixMarker in: #right on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						self activate: rightMatrixMarker in: #right on: composer.
						(Delay forSeconds: 1) wait ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0.
		self replaceElementsInGroup: #result with: result on: composer ] ] in [ :end | 
[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ rightMatrixMarker := transposed first.
						leftSavedMatrixMarker := leftMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						self activate: rightMatrixMarker in: #right on: composer.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						(Delay forSeconds: 1) wait ].
				"reset left marker to row beginning"
				self deactivate: leftMatrixMarker in: #left on: composer.
				(Delay forSeconds: 1) wait.
				leftMatrixMarker := leftSavedMatrixMarker.
				self activate: leftMatrixMarker in: #left on: composer.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: 1) wait.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
										(Delay forSeconds: 1) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										self activate: leftMatrixMarker in: #left on: composer.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										(Delay forSeconds: 1) wait ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: 1) wait ] ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: 1) wait ] ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
										(Delay forSeconds: 1) wait.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										self activate: rightMatrixMarker in: #right on: composer.
										(Delay forSeconds: 1) wait ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												self activate: leftMatrixMarker in: #left on: composer.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: 1) wait ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
										self highlight: rightMatrixMarker in: #right on: composer.
										(Delay forSeconds: 1) wait.
										sum := sum
											+ (leftMatrixMarker value * rightMatrixMarker value).
										self deactivate: leftMatrixMarker in: #left on: composer.
										self deactivate: rightMatrixMarker in: #right on: composer.
										(Delay forSeconds: 1) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										self activate: leftMatrixMarker in: #left on: composer.
										self activate: rightMatrixMarker in: #right on: composer.
										(Delay forSeconds: 1) wait ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						self replaceElementsInGroup: #result with: result on: composer ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0.
				self replaceElementsInGroup: #result with: result on: composer ] ] ] in [ leftSavedMatrixMarker := leftMatrixMarker := first.
self activate: leftMatrixMarker in: #left on: composer.
rightMatrixMarker := transposed first.
self activate: rightMatrixMarker in: #right on: composer.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
composer view signalUpdate.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								self activate: leftMatrixMarker in: #left on: composer.
								self activate: rightMatrixMarker in: #right on: composer.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: 1) wait ].
						"reset left marker to row beginning"
						self deactivate: leftMatrixMarker in: #left on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: 1) wait.
						currentLeftRow := leftMatrixMarker row.
						currentRightColumn := rightMatrixMarker row.
						self
							withEscaper: [ :next | 
								[ leftMatrixMarker isNotNil
									and: [ rightMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
									whileTrue: [ priorityColumn := {leftMatrixMarker column.
										rightMatrixMarker column} max.
										"Find same column as prioritized or higher in left"
										[ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ leftMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												self activate: leftMatrixMarker in: #left on: composer.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: 1) wait ].
										leftMatrixMarker isNil
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].

												"If no intersection - end"
												rightMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										leftMatrixMarker row ~= currentLeftRow
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].
												next value ].
										priorityColumn := leftMatrixMarker column.

										"Find same column as prioritized or higher in right"
										[ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn
													and: [ rightMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ].
										rightMatrixMarker isNil
											ifTrue: [ [ leftMatrixMarker isNotNil
													and: [ leftMatrixMarker row = currentLeftRow ] ]
													whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
														(Delay forSeconds: 1) wait.
														leftMatrixMarker := leftMatrixMarker rightNeighbour.
														self activate: leftMatrixMarker in: #left on: composer.
														leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
														(Delay forSeconds: 1) wait ].

												"If no intersections - end"
												leftMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										rightMatrixMarker row ~= currentRightColumn
											ifTrue: [ next value ].
										leftMatrixMarker column = rightMatrixMarker column
											ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
												self highlight: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												sum := sum
													+ (leftMatrixMarker value * rightMatrixMarker value).
												self deactivate: leftMatrixMarker in: #left on: composer.
												self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: leftMatrixMarker in: #left on: composer.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ]
											ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
						sum = 0
							ifFalse: [ newNode := COOSparse[31m#close was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #close
[ "operationWindow createWindowGroup addWindow: resultWindow"
operationProcess terminate.
operationWindow close.
resultWindow close ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ "operationWindow createWindowGroup addWindow: re...etc...
[ :event | aBlock value ] in TRCanvas>>addMenu:callback: in Block: [ :event | aBlock value ]
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31mHalt
[0mCOOSparseMatrix(Object)>>halt
[ leftSavedMatrixMarker := leftMatrixMarker := first.
self activate: leftMatrixMarker in: #left on: composer.
rightMatrixMarker := transposed first.
self activate: rightMatrixMarker in: #right on: composer.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
composer view signalUpdate.
self halt.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								self activate: leftMatrixMarker in: #left on: composer.
								self activate: rightMatrixMarker in: #right on: composer.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: 1) wait ].
						"reset left marker to row beginning"
						self deactivate: leftMatrixMarker in: #left on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: 1) wait.
						currentLeftRow := leftMatrixMarker row.
						currentRightColumn := rightMatrixMarker row.
						self
							withEscaper: [ :next | 
								[ leftMatrixMarker isNotNil
									and: [ rightMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
									whileTrue: [ priorityColumn := {leftMatrixMarker column.
										rightMatrixMarker column} max.
										"Find same column as prioritized or higher in left"
										[ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ leftMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												self activate: leftMatrixMarker in: #left on: composer.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: 1) wait ].
										leftMatrixMarker isNil
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].

												"If no intersection - end"
												rightMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										leftMatrixMarker row ~= currentLeftRow
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].
												next value ].
										priorityColumn := leftMatrixMarker column.

										"Find same column as prioritized or higher in right"
										[ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn
													and: [ rightMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ].
										rightMatrixMarker isNil
											ifTrue: [ [ leftMatrixMarker isNotNil
													and: [ leftMatrixMarker row = currentLeftRow ] ]
													whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
														(Delay forSeconds: 1) wait.
														leftMatrixMarker := leftMatrixMarker rightNeighbour.
														self activate: leftMatrixMarker in: #left on: composer.
														leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
														(Delay forSeconds: 1) wait ].

												"If no intersections - end"
												leftMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										rightMatrixMarker row ~= currentRightColumn
											ifTrue: [ next value ].
										leftMatrixMarker column = rightMatrixMarker column
											ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
												self highlight: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												sum := sum
													+ (leftMatrixMarker value * rightMatrixMarker value).
												self deactivate: leftMatrixMarker in: #left on: composer.
												self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: leftMatrixMarker in: #left on: composer.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ]
											ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
						sum = 0
							ifFalse: [ newNode := COOSparseMatrixNode
									row: currentLeftRow
									column: currentRightColumn
									value: sum.
								result last rightNeighbour: newNode.
								newNode leftNeighbour: result last.
								result last: newNode.
								sum := 0.
								self replaceElementsInGroup: #result with: result on: composer ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						self replaceElementsInGroup: #result with: result on: composer ] ] ].
"nil the reference to dummy head"
result first rightNeighbour leftNeighbour: nil.
result first: result first rightNeighbour.
result ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ leftSavedMatrixMarker := leftMatrixMarker := fir...etc...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mCOOSparseMatrix(Object)>>halt
[ leftSavedMatrixMarker := leftMatrixMarker := first.
self activate: leftMatrixMarker in: #left on: composer.
rightMatrixMarker := transposed first.
self activate: rightMatrixMarker in: #right on: composer.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
composer view signalUpdate.
self halt.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								self activate: leftMatrixMarker in: #left on: composer.
								self activate: rightMatrixMarker in: #right on: composer.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: 1) wait ].
						"reset left marker to row beginning"
						self deactivate: leftMatrixMarker in: #left on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: 1) wait.
						currentLeftRow := leftMatrixMarker row.
						currentRightColumn := rightMatrixMarker row.
						self
							withEscaper: [ :next | 
								[ leftMatrixMarker isNotNil
									and: [ rightMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
									whileTrue: [ priorityColumn := {leftMatrixMarker column.
										rightMatrixMarker column} max.
										"Find same column as prioritized or higher in left"
										[ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ leftMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												self activate: leftMatrixMarker in: #left on: composer.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: 1) wait ].
										leftMatrixMarker isNil
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].

												"If no intersection - end"
												rightMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										leftMatrixMarker row ~= currentLeftRow
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].
												next value ].
										priorityColumn := leftMatrixMarker column.

										"Find same column as prioritized or higher in right"
										[ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn
													and: [ rightMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ].
										rightMatrixMarker isNil
											ifTrue: [ [ leftMatrixMarker isNotNil
													and: [ leftMatrixMarker row = currentLeftRow ] ]
													whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
														(Delay forSeconds: 1) wait.
														leftMatrixMarker := leftMatrixMarker rightNeighbour.
														self activate: leftMatrixMarker in: #left on: composer.
														leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
														(Delay forSeconds: 1) wait ].

												"If no intersections - end"
												leftMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										rightMatrixMarker row ~= currentRightColumn
											ifTrue: [ next value ].
										leftMatrixMarker column = rightMatrixMarker column
											ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
												self highlight: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												sum := sum
													+ (leftMatrixMarker value * rightMatrixMarker value).
												self deactivate: leftMatrixMarker in: #left on: composer.
												self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: leftMatrixMarker in: #left on: composer.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ]
											ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
						sum = 0
							ifFalse: [ newNode := COOSparseMatrixNode
									row: currentLeftRow
									column: currentRightColumn
									value: sum.
								result last rightNeighbour: newNode.
								newNode leftNeighbour: result last.
								result last: newNode.
								sum := 0.
								self replaceElementsInGroup: #result with: result on: composer ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						self replaceElementsInGroup: #result with: result on: composer ] ] ].
"nil the reference to dummy head"
result first rightNeighbour leftNeighbour: nil.
result first: result first rightNeighbour.
result ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ leftSavedMatrixMarker := leftMatrixMarker := fir...etc...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
GLMPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
GLMPluggableButtonMorph(Morph)>>handleEvent:
GLMPluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
GLMPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
GLMPluggableButtonMorph(Morph)>>handleEvent:
GLMPluggableButtonMorph(Morph)>>handleFocusEvent:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
GLMPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
GLMPluggableButtonMorph(Morph)>>handleEvent:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
GLMPluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
GLMPluggableButtonMorph(Morph)>>handleMouseUp:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in GLMPluggableButtonMorph(PluggableButtonMorph)>>mouseUp: in Block: [ :m | ...
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
GLMPluggableButtonMorph(PluggableButtonMorph)>>performAction:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
GLMGenericAction(GLMAction)>>morphicActOn:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
GLMGenericAction(GLMAction)>>actOn:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
BlockClosure>>glamourValueWithArgs:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[ self execute ] in StepOverDebugAction(DebugAction)>>asGlamourAction in Block: [ self execute ]
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
StepOverDebugAction(DebugAction)>>execute
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
StepOverDebugAction>>executeAction
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
DebugSession>>stepOver:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
Process>>completeStep:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
Process>>step
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
Process>>evaluate:onBehalfOf:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
BlockClosure>>ensure:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[ suspendedContext := suspendedContext step ] in Process>>step in Block: [ suspendedContext := suspendedContext step ]
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
Context>>step
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
Context(InstructionStream)>>interpretNextInstructionFor:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
EncoderForV3PlusClosures class>>interpretNextInstructionFor:in:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
Context(InstructionStream)>>interpretNextV3PlusClosureInstructionFor:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
Context>>methodReturnTop
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
Context>>return:from:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>push:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
[0m[31mSubscriptOutOfBounds: 0
[0mContext(Object)>>errorSubscriptBounds:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
Context>>at:put:
[0m[31mUser Interrupt
[0mWeakSet>>scanFor:
WeakSet>>like:
Symbol class>>lookup:
Symbol class>>intern:
ByteString(String)>>asSymbol
ByteSymbol(Symbol)>>value:
Array(SequenceableCollection)>>collect:
RBMessageNode>>selectorParts
BIConfigurableFormatter>>formatMessageNodeInAMessageStreamFor:
BIConfigurableFormatter>>isMultiLineMessage:
BIConfigurableFormatter>>formatSelectorAndArguments:
BIConfigurableFormatter>>visitMessageNode:
RBMessageNode>>acceptVisitor:
BIConfigurableFormatter(RBProgramNodeVisitor)>>visitNode:
[ needsParenthesis
	ifTrue: [ codeStream nextPutAll: self stringInsideParentheses ].
super visitNode: aNode.
(self formatCommentWithStatements
	or: [ aNode isMethod or: [ aNode isSequence ] ])
	ifFalse: [ self formatCommentsFor: aNode ].
needsParenthesis
	ifTrue: [ codeStream nextPutAll: self stringInsideParentheses ] ] in BIConfigurableFormatter>>visitNode: in Block: [ needsParenthesis...
BIConfigurableFormatter>>bracketWith:around:
BIConfigurableFormatter>>visitNode:
BIConfigurableFormatter>>formatSequenceNodeStatementsFor:
BIConfigurableFormatter>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
BIConfigurableFormatter(RBProgramNodeVisitor)>>visitNode:
[ needsParenthesis
	ifTrue: [ codeStream nextPutAll: self stringInsideParentheses ].
super visitNode: aNode.
(self formatCommentWithStatements
	or: [ aNode isMethod or: [ aNode isSequence ] ])
	ifFalse: [ self formatCommentsFor: aNode ].
needsParenthesis
	ifTrue: [ codeStream nextPutAll: self stringInsideParentheses ] ] in BIConfigurableFormatter>>visitNode: in Block: [ needsParenthesis...
BIConfigurableFormatter>>bracketWith:around:
BIConfigurableFormatter>>visitNode:
BIConfigurableFormatter>>formatBlock:
[ self formatBlock: aBlockNode ] in BIConfigurableFormatter>>visitBlockNode: in Block: [ self formatBlock: aBlockNode ]
BlockClosure>>ensure:
BIConfigurableFormatter>>bracketWith:around:
BIConfigurableFormatter>>visitBlockNode:
RBBlockNode>>acceptVisitor:
[0m[31m#swapSender: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #swapSender:
[ self suspend.
suspendedContext := suspendedContext swapSender: nil.
aList class == Semaphore
	ifTrue: [ aList isSignaled
			ifTrue:
				[ aList wait.	"Consume the signal that would have restarted the receiver"
				self resume ]
			ifFalse: [ "Add us back to the Semaphore's list (and remain blocked)"
				myList := aList.
				aList add: self ] ]
	ifFalse: [ self resume ] ] in Process>>pvtSignal:list: in Block: [ self suspend....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mProcess>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
Process>>pvtSignal:list:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[ self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn: in Block: [ self transmissionStrategy transmitIn: aContext....
GLMPane>>notingPresentationChangeDo:
GLMPanePort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
[ :each | each transmitIn: aPortEvent transmissionContext copy ] in GLMTabulator(GLMExplicitBrowser)>>innerPortEvent: in Block: [ :each | each transmitIn: aPortEvent transmission...etc...
OrderedCollection>>do:
GLMTabulator(GLMExplicitBrowser)>>innerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
[ :each | each value: nil in: aContext copy ] in [ self presentations clear.
self ports do: [ :each | each value: nil in: aContext copy ] ] in GLMPane>>clearIn: in Block: [ :each | each value: nil in: aContext copy ]
OrderedCollection>>do:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[ self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn: in Block: [ self transmissionStrategy transmitIn: aContext....
GLMPane>>notingPresentationChangeDo:
GLMPanePort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
[ :each | each transmitIn: aPortEvent transmissionContext copy ] in GLMTabulator(GLMExplicitBrowser)>>innerPortEvent: in Block: [ :each | each transmitIn: aPortEvent transmission...etc...
OrderedCollection>>do:
GLMTabulator(GLMExplicitBrowser)>>innerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[ self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn: in Block: [ self transmissionStrategy transmitIn: aContext....
GLMPane>>notingPresentationChangeDo:
GLMPanePort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
[ :each | each transmitIn: aPortEvent transmissionContext copy ] in GLMTabulator(GLMExplicitBrowser)>>innerPortEvent: in Block: [ :each | each transmitIn: aPortEvent transmission...etc...
OrderedCollection>>do:
GLMTabulator(GLMExplicitBrowser)>>innerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[ self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn: in Block: [ self transmissionStrategy transmitIn: aContext....
GLMPane>>notingPresentationChangeDo:
GLMPanePort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
[ :each | each transmitIn: aPortEvent transmissionContext copy ] in GLMTabulator(GLMExplicitBrowser)>>innerPortEvent: in Block: [ :each | each transmitIn: aPortEvent transmission...etc...
OrderedCollection>>do:
GLMTabulator(GLMExplicitBrowser)>>innerPortEvent:
GLMPane>>portEvent:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[ self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn: in Block: [ self transmissionStrategy transmitIn: aContext....
GLMPane>>notingPresentationChangeDo:
GLMPanePort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
[ :each | each transmitIn: aPortEvent transmissionContext copy ] in GLMTabulator(GLMExplicitBrowser)>>innerPortEvent: in Block: [ :each | each transmitIn: aPortEvent transmission...etc...
OrderedCollection>>do:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[ self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn: in Block: [ self transmissionStrategy transmitIn: aContext....
GLMPane>>notingPresentationChangeDo:
GLMPanePort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[ self transmissionStrategy transmitIn: aContext.
self destination receive: self in: aContext ] in GLMTransmission>>transmitIn: in Block: [ self transmissionStrategy transmitIn: aContext....
GLMPane>>notingPresentationChangeDo:
[0m[31m#suspendedContext was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #suspendedContext
DebugSession>>isLatestContext:
DebugSession>>pcRangeForContext:
DebugSession>>selectedCodeRangeForContext:
[ :code | 
code
	selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ] in GTGenericStackDebugger>>methodCodeIn:forContext: in Block: [ :code | ...
GLMPharoMethodPresentation(GLMPresentation)>>initializePresentation
[ :each | each initializePresentation ] in GLMCompositePresentation>>initializePresentation in Block: [ :each | each initializePresentation ]
OrderedCollection>>do:
GLMCompositePresentation>>do:
GLMCompositePresentation>>initializePresentation
[ presentations pane: nil.
presentations resetAnnouncer.
aCompositePresentation pane: self.
presentations := aCompositePresentation.
presentations initializePresentation ] in GLMPane>>presentations: in Block: [ presentations pane: nil....
GLMPane>>notingPresentationChangeDo:
GLMPane>>presentations:
[ self transmission destination pane clearIn: aContext.
self transmission destination pane
	presentations: self presentations copy ] in GLMReplacePresentationsStrategy>>transmitIn: in Block: [ self transmission destination pane clearIn: aCon...etc...
GLMPane>>notingPresentationChangeDo:
GLMReplacePresentationsStrategy>>transmitIn:
[0m[31mUser Interrupt
[0m[ self class open: name utf8Encoded writable: writeMode ] in File>>basicOpenForWrite: in Block: [ self class open: name utf8Encoded writable: writ...etc...
File class>>retryWithGC:until:forFileNamed:
File>>basicOpenForWrite:
File>>openForWrite:
File>>openForWrite
File>>writeStream
[ ZnNewLineWriterStream
	on:
		(ZnCharacterWriteStream
			on:
				((File named: Smalltalk logFileName) writeStream
					setToEnd;
					yourself)
			encoding: 'utf8') ] in SmalltalkImage>>openLog in Block: [ ZnNewLineWriterStream...
BlockClosure>>on:do:
SmalltalkImage>>openLog
[ logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring: in Block: [ logStream := self openLog....
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
SmalltalkImage>>logError:inContext:
[ Smalltalk logError: name inContext: interruptedContext ] in [ [ Smalltalk logError: name inContext: interruptedContext ]
	ifError: [  ] ] in DebugSession>>logStackToFileIfNeeded in Block: [ Smalltalk logError: name inContext: interruptedC...etc...
BlockClosure>>on:do:
BlockClosure>>ifError:
[ [ Smalltalk logError: name inContext: interruptedContext ]
	ifError: [  ] ] in DebugSession>>logStackToFileIfNeeded in Block: [ [ Smalltalk logError: name inContext: interrupte...etc...
BlockClosure>>ensure:
[ watchdog resume.	"start up the watchdog"
self
	ensure: [ "evaluate the receiver"
		theProcess := nil.	"it has completed, so ..."
		delay delaySemaphore signal	"arrange for the watchdog to exit" ] ] in BlockClosure>>valueWithin:onTimeout: in Block: [ watchdog resume.	"start up the watchdog"...
BlockClosure>>on:do:
BlockClosure>>valueWithin:onTimeout:
DebugSession>>logStackToFileIfNeeded
MorphicUIManager>>debugProcess:context:label:fullView:notification:
MorphicUIManager(UIManager)>>debugProcess:context:label:fullView:
Process>>debug:title:full:
Process>>debug:title:
MessageNotUnderstood>>debug
MorphicUIManager>>unhandledErrorDefaultAction:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
[0m[31mHalt
[0mCOOSparseMatrix(Object)>>halt
[ leftSavedMatrixMarker := leftMatrixMarker := first.
self activate: leftMatrixMarker in: #left on: composer.
rightMatrixMarker := transposed first.
self activate: rightMatrixMarker in: #right on: composer.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
composer view signalUpdate.
self halt.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								self activate: leftMatrixMarker in: #left on: composer.
								self activate: rightMatrixMarker in: #right on: composer.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: 1) wait ].
						"reset left marker to row beginning"
						self deactivate: leftMatrixMarker in: #left on: composer.
						(Delay forSeconds: 1) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						self activate: leftMatrixMarker in: #left on: composer.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: 1) wait.
						currentLeftRow := leftMatrixMarker row.
						currentRightColumn := rightMatrixMarker row.
						self
							withEscaper: [ :next | 
								[ leftMatrixMarker isNotNil
									and: [ rightMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
									whileTrue: [ priorityColumn := {leftMatrixMarker column.
										rightMatrixMarker column} max.
										"Find same column as prioritized or higher in left"
										[ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ leftMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												self activate: leftMatrixMarker in: #left on: composer.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: 1) wait ].
										leftMatrixMarker isNil
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].

												"If no intersection - end"
												rightMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										leftMatrixMarker row ~= currentLeftRow
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
														(Delay forSeconds: 1) wait.
														rightMatrixMarker := rightMatrixMarker rightNeighbour.
														rightMatrixMarker isNotNil
															ifTrue: [ self activate: rightMatrixMarker in: #right on: composer.
																rightMarkerElement
																	updateModelAndRedraw: rightMatrixMarker.
																(Delay forSeconds: 1) wait ] ].
												next value ].
										priorityColumn := leftMatrixMarker column.

										"Find same column as prioritized or higher in right"
										[ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn
													and: [ rightMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ].
										rightMatrixMarker isNil
											ifTrue: [ [ leftMatrixMarker isNotNil
													and: [ leftMatrixMarker row = currentLeftRow ] ]
													whileTrue: [ self deactivate: leftMatrixMarker in: #left on: composer.
														(Delay forSeconds: 1) wait.
														leftMatrixMarker := leftMatrixMarker rightNeighbour.
														self activate: leftMatrixMarker in: #left on: composer.
														leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
														(Delay forSeconds: 1) wait ].

												"If no intersections - end"
												leftMatrixMarker isNil
													ifTrue: [ end value ].
												"Else - continue loop"
												next value ].
										rightMatrixMarker row ~= currentRightColumn
											ifTrue: [ next value ].
										leftMatrixMarker column = rightMatrixMarker column
											ifTrue: [ self highlight: leftMatrixMarker in: #left on: composer.
												self highlight: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												sum := sum
													+ (leftMatrixMarker value * rightMatrixMarker value).
												self deactivate: leftMatrixMarker in: #left on: composer.
												self deactivate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
												self activate: leftMatrixMarker in: #left on: composer.
												self activate: rightMatrixMarker in: #right on: composer.
												(Delay forSeconds: 1) wait ]
											ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
						sum = 0
							ifFalse: [ newNode := COOSparseMatrixNode
									row: currentLeftRow
									column: currentRightColumn
									value: sum.
								result last rightNeighbour: newNode.
								newNode leftNeighbour: result last.
								result last: newNode.
								sum := 0.
								self replaceElementsInGroup: #result with: result on: composer ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						self replaceElementsInGroup: #result with: result on: composer ] ] ].
"nil the reference to dummy head"
result first rightNeighbour leftNeighbour: nil.
result first: result first rightNeighbour.
result ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ leftSavedMatrixMarker := leftMatrixMarker := fir...etc...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#close was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #close
[ "operationWindow createWindowGroup addWindow: resultWindow"
operationProcess terminate.
operationWindow close.
resultWindow close ] in COOSparseMatrix>>byMatrixAnimated: in Block: [ "operationWindow createWindowGroup addWindow: re...etc...
[ :event | aBlock value ] in TRCanvas>>addMenu:callback: in Block: [ :event | aBlock value ]
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31mUser Interrupt
[0m[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mError: genJumpLong: distance index -1033 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
[0m[31mError: genJumpLong: distance index -1032 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
[0mt := self...
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
GTSpecPreDebugWindow(ComposablePresenter)>>adapterFrom:model:
GTSpecPreDebugWindow(ComposablePresenter)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[0m[31mUser Interrupt
[0m[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
Object class(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :stream | Pragma withPragmasIn: aClass do: [ :pragma | stream nextPut: pragma ] ] in SpecPragmaCollector>>allPragmasIn: in Block: [ :stream | Pragma withPragmasIn: aClass do: [ :pr...etc...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
SpecPragmaCollector>>allPragmasIn:
SpecPragmaCollector>>allPragmas
[ self collected copy do: [ :pragma | self removePragma: pragma ].
self allPragmas do: [ :pragma | self addPragma: pragma ] ] in SpecPragmaCollector>>reset in Block: [ self collected copy do: [ :pragma | self removeP...etc...
[ oldAnnouncing := announcing.
announcing := false.
aBlock value ] in SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile: in Block: [ oldAnnouncing := announcing....
BlockClosure>>ensure:
SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter:
		[ :pragma | pragma keyword = 'spec:' and: [ pragma arguments includes: #default ] ])
	reset;
	collected) ifNotEmpty: [ :pragmas | ^ pragmas first method selector ] ] in GTDebugActionButton(ComposablePresenter)>>defaultSpecSelector in Block: [ :class | ...
Object class(Behavior)>>withAllSuperclassesDo:
Behavior class(Behavior)>>withAllSuperclassesDo:
ClassDescription class(Behavior)>>withAllSuperclassesDo:
Class class(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
GTDebugActionButton(ComposablePresenter)>>defaultSpecSelector
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
[0m[31mUser Interrupt
[0mMargin>>fromNumber:
Margin class>>fromNumber:
SmallInteger(Number)>>asMargin
Rectangle>>insetBy:
PanelMorph(Morph)>>innerBounds
PanelMorph(Morph)>>clippingBounds
PanelMorph(Morph)>>invalidRect:from:
PanelMorph(Morph)>>invalidRect:from:
PluggableButtonMorph(Morph)>>invalidRect:from:
PluggableButtonMorph(Morph)>>invalidRect:
[ :r | self invalidRect: r ] in PluggableButtonMorph(Morph)>>focusChanged in Block: [ :r | self invalidRect: r ]
Array(SequenceableCollection)>>do:
PluggableButtonMorph(Morph)>>focusChanged
PluggableButtonMorph>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
PluggableButtonMorph(Morph)>>takeKeyboardFocus
MorphicButtonAdapter(AbstractAdapter)>>takeKeyboardFocus
MorphicButtonAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in GTDebugActionButton(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
GTDebugActionButton(Model)>>changed:with:
GTDebugActionButton(ComposablePresenter)>>takeKeyboardFocus
[ :focus | ^ focus first takeKeyboardFocus ] in GTSpecPreDebugWindow(ComposablePresenter)>>takeKeyboardFocus in Block: [ :focus | ^ focus first takeKeyboardFocus ]
BlockClosure>>cull:
OrderedCollection(Collection)>>ifNotEmpty:
GTSpecPreDebugWindow(ComposablePresenter)>>takeKeyboardFocus
GTSpecPreDebugWindow>>rebuildWidget
[ :aDebugger | aDebugger ifNil: [ self clearWidget ] ifNotNil: [ self rebuildWidget ] ] in GTSpecPreDebugWindow>>initializePresenter in Block: [ :aDebugger | aDebugger ifNil: [ self clearWidget...etc...
BlockClosure>>cull:
BlockClosure>>cull:cull:
[0m[31mUser Interrupt
[0mSmallInteger(Magnitude)>>min:
Point>>min:
[ :rect | 
| a |
((a := (rect intersect: newRect ifNone: [ zeroRect ]) area) > 40
	and: [ "Avoid combining a vertical and horizontal rects.
				  Can make a big diff and we only test when likely." a > (newRect area // 4) or: [ a > (rect area // 4) ] ])
	ifTrue:
		[ "merge rectangle in place (see note below) if there is significant overlap"
		rect
			setPoint: (rect origin min: newRect origin) truncated
			point: (rect corner max: newRect corner) truncated.
		^ self ] ] in DamageRecorder>>recordInvalidRect: in Block: [ :rect | ...
OrderedCollection>>do:
DamageRecorder>>recordInvalidRect:
WorldState>>recordDamagedRect:
WorldMorph>>invalidRect:from:
SpecWindow(Morph)>>invalidRect:from:
PanelMorph(Morph)>>invalidRect:from:
PanelMorph(Morph)>>invalidRect:from:
PanelMorph(Morph)>>invalidRect:from:
PluggableButtonMorph(Morph)>>invalidRect:from:
PluggableButtonMorph(Morph)>>invalidRect:
PluggableButtonMorph(Morph)>>changed
PluggableButtonMorph>>changed
PluggableButtonMorph(Morph)>>extent:
PluggableButtonMorph(Morph)>>bounds:
PluggableButtonMorph(Morph)>>layoutInBounds:
PluggableButtonMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
[0m[31mUser Interrupt
[0mArray class(ArrayedCollection class)>>with:
PanelMorph(Morph)>>privateAddMorph:atIndex:
PanelMorph(Morph)>>addMorphFront:
PanelMorph(Morph)>>addMorph:
PanelMorph(Morph)>>ensureLayoutAndAddMorph:
[ :w | w ensureLayoutAndAddMorph: aWidget asWidget ] in MorphicContainerAdapter(AbstractMorphicAdapter)>>add: in Block: [ :w | w ensureLayoutAndAddMorph: aWidget asWidget...etc...
BlockClosure>>cull:
PanelMorph(ProtoObject)>>ifNotNil:
MorphicContainerAdapter(AbstractAdapter)>>widgetDo:
MorphicContainerAdapter(AbstractMorphicAdapter)>>add:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | 
self class
	private_interpretASpec: each
	model: model
	selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex in Block: [ :each | ...
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ result := self
	private_interpretASpec: aPresenter
	model: aModel
	selector: aSelector ] in SpecInterpreter class>>interpretASpec:model:selector: in Block: [ result := self...
BlockClosure>>ensure:
SpecInterpreter class>>interpretASpec:model:selector:
SpecInterpreter class>>interpretASpec:model:
[0m[31mUser Interrupt
[0mSmallInteger(Number)>>negative
SmallFloat64(Float)>>asTrueFraction
SmallFloat64(Float)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><
SmallInteger>><
Rectangle>>quickMerge:
SpecWindow(Morph)>>privateFullBounds
SpecWindow(Morph)>>changed
SpecWindow(SystemWindow)>>basicActivate
SpecWindow(SystemWindow)>>activate
SpecWindow(SystemWindow)>>openAsIsIn:
SpecWindow(StandardWindow)>>openAsIsIn:
SpecWindow(SystemWindow)>>openInWorld:
SpecWindow(Morph)>>openInWorld
MorphicWindowAdapter>>open
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowPresenter(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
WindowPresenter(Model)>>changed:with:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
GTGenericStackDebugger>>openWithNotification:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
[0m[31mUser Interrupt
[0mMorphicEventHandler class(Behavior)>>new
BorderedMorph(Morph)>>on:send:to:
ScrollBar(Slider)>>initializeSlider
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>hResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[0m[31mUser Interrupt
[0mBorderedMorph(Morph)>>hasDropShadow
BorderedMorph(Morph)>>outerBounds
BorderedMorph(Morph)>>privateFullBounds
BorderedMorph(Morph)>>changed
BorderedMorph(Morph)>>extent:
BorderedMorph(Morph)>>height:
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>vResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
[0m[31mUser Interrupt
[0mGTGenericStackDebugger(GLMCompositePresentation)>>presentations
GTGenericStackDebugger(GTMoldableDebugger)>>browser
GTGenericStackDebugger>>selectedContext
GTGenericStackDebugger>>textAttributesForStackEntry:
GTGenericStackDebugger>>formatStackClassColumnForContext:
GTSpecPreDebugWindow>>columnsFor:
[ :aContext | self columnsFor: aContext ] in GTSpecPreDebugWindow>>initializeStackPane in Block: [ :aContext | self columnsFor: aContext ]
BlockClosure>>cull:
BlockClosure>>cull:cull:
MultiColumnListPresenter(ListPresenter)>>wrapItem:index:
MultiColumnListPresenter>>listElementAt:
MorphicMultiColumnListAdapter(MorphicListAdapter)>>listElementAt:
PluggableMultiColumnListMorph>>getListRow:
MulticolumnLazyListMorph>>getListItem:
MulticolumnLazyListMorph>>hUnadjustedScrollRange
MulticolumnLazyListMorph(LazyListMorph)>>adjustWidth
MulticolumnLazyListMorph(LazyListMorph)>>listChanged
MulticolumnLazyListMorph>>listChanged
PluggableMultiColumnListMorph(PluggableListMorph)>>updateList
PluggableMultiColumnListMorph(PluggableListMorph)>>getListElementSelector:
MorphicMultiColumnListAdapter>>buildWidget
MorphicMultiColumnListAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
MultiColumnListPresenter(ComposablePresenter)>>privateAdapterFromModel:withSpec:
MultiColumnListPresenter(ComposablePresenter)>>private_buildWithSpec:
[0m[31mUser Interrupt
[0mIdentitySet(HashedCollection)>>atNewIndex:put:
IdentitySet(Set)>>add:
[ subscriptions add: subscription ] in SubscriptionRegistry>>add: in Block: [ subscriptions add: subscription ]
[ aBlock value ] in SubscriptionRegistry>>protected: in Block: [ aBlock value ]
[ caught := true.
self wait.
blockValue := mutuallyExcludedBlock value ] in Semaphore>>critical: in Block: [ caught := true....
BlockClosure>>ensure:
Semaphore>>critical:
SubscriptionRegistry>>protected:
SubscriptionRegistry>>add:
GTGenericStackDebugger(Announcer)>>subscribe:do:
GTGenericStackDebugger(Announcer)>>subscribe:send:to:
GTGenericStackDebugger(Announcer)>>when:send:to:
GTGenericStackDebugger(GTMoldableDebugger)>>registerActions
GTGenericStackDebugger(GTMoldableDebugger)>>compose
GTGenericStackDebugger(GLMCompositePresentation)>>initialize
GTGenericStackDebugger class(Behavior)>>new
GTGenericStackDebugger class(GTMoldableDebugger class)>>on:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRectangle>>insetBy:
TextMorph(Morph)>>innerBounds
TextMorph>>compositionRectangle
TextMorph>>container
TextMorph>>paragraph
TextMorph>>fit
TextMorph>>extent:
PharoLightTheme(UITheme)>>buttonLabelForText:
PharoLightTheme(UITheme)>>buttonLabelFor:
PluggableButtonMorph>>newLabel
PluggableButtonMorph>>newLabel:
PluggableButtonMorph>>label:font:
PluggableButtonMorph>>label:
PluggableButtonMorph>>update:
PluggableButtonMorph>>on:getState:action:label:icon:menu:
PluggableButtonMorph class>>on:getState:action:label:menu:
MorphicButtonAdapter>>buildWidget
MorphicButtonAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
GTDebugActionButton(ComposablePresenter)>>privateAdapterFromModel:withSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
[0m[31mUser Interrupt
[0mArray(Collection)>>isEmpty
AlignmentMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in AlignmentMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
AlignmentMorph(Morph)>>computeFullBounds
AlignmentMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in SpecWindow(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphBounds
SpecWindow(Morph)>>privateFullBounds
SpecWindow(Morph)>>changed
SpecWindow(Morph)>>fillStyle:
SpecWindow(SystemWindow)>>setStripeColorsFrom:
SpecWindow(SystemWindow)>>passivate
SpecWindow(SystemWindow)>>privateBePassive
SpecWindow(SystemWindow)>>beTopWindow
SpecWindow(SystemWindow)>>basicActivate
SpecWindow(SystemWindow)>>activate
SpecWindow(SystemWindow)>>openAsIsIn:
SpecWindow(StandardWindow)>>openAsIsIn:
SpecWindow(SystemWindow)>>openInWorld:
SpecWindow(Morph)>>openInWorld
MorphicWindowAdapter>>open
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowPresenter(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
WindowPresenter(Model)>>changed:with:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
[0m[31mUser Interrupt
[0mAssociation>>key:value:
Association class>>key:value:
Dictionary>>at:put:
MorphicAdapterBindings>>initializeBindings
MorphicAdapterBindings(SpecAdapterBindings)>>initialize
MorphicAdapterBindings class(Behavior)>>new
SpecInterpreter class>>defaultBindings
SpecInterpreter class>>bindings
SpecInterpreter>>bindings
SpecInterpreter>>convertSymbolOfClassToInstance:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
GTDebugActionButton(ComposablePresenter)>>privateAdapterFromModel:withSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | 
self class
	private_interpretASpec: each
	model: model
	selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex in Block: [ :each | ...
Array(SequenceableCollection)>>collect:
[0m[31mUser Interrupt
[0mByteString class(ProtoObject)>>identityHash
ByteString class(Object)>>hash
ByteSymbol(String)>>hash
Dictionary>>scanFor:
Dictionary>>includesKey:
MorphicEventHandler>>addSubscription:toEvent:
MorphicEventHandler>>on:send:to:
BorderedMorph(Morph)>>on:send:to:
ScrollBar>>initializeUpButton
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>vResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
[0m[31mUser Interrupt
[0mCompiledMethod>>pragmas
[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
ClassDescription class(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :stream | Pragma withPragmasIn: aClass do: [ :pragma | stream nextPut: pragma ] ] in SpecPragmaCollector>>allPragmasIn: in Block: [ :stream | Pragma withPragmasIn: aClass do: [ :pr...etc...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
SpecPragmaCollector>>allPragmasIn:
SpecPragmaCollector>>allPragmas
[ self collected copy do: [ :pragma | self removePragma: pragma ].
self allPragmas do: [ :pragma | self addPragma: pragma ] ] in SpecPragmaCollector>>reset in Block: [ self collected copy do: [ :pragma | self removeP...etc...
[ oldAnnouncing := announcing.
announcing := false.
aBlock value ] in SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile: in Block: [ oldAnnouncing := announcing....
BlockClosure>>ensure:
SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter:
		[ :pragma | pragma keyword = 'spec:' and: [ pragma arguments includes: #default ] ])
	reset;
	collected) ifNotEmpty: [ :pragmas | ^ pragmas first method selector ] ] in ContainerPresenter(ComposablePresenter)>>defaultSpecSelector in Block: [ :class | ...
ClassDescription class(Behavior)>>withAllSuperclassesDo:
Class class(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
ContainerPresenter(ComposablePresenter)>>defaultSpecSelector
ContainerPresenter>>buildAdapterWithSpec
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
[0m[31mUser Interrupt
[0mCompiledMethod>>markerOrNil
CompiledMethod>>isAbstract
[ :each | 
each isAbstract
	ifTrue: [ ^ true ] ] in CopyToClipboardDebugAction class(Behavior)>>hasAbstractMethods in Block: [ :each | ...
MethodDictionary>>valuesDo:
CopyToClipboardDebugAction class(Behavior)>>methodsDo:
CopyToClipboardDebugAction class(Behavior)>>hasAbstractMethods
CopyToClipboardDebugAction class(Class)>>hasAbstractMethods
[ :each | each hasAbstractMethods ] in DebugSession class>>debuggingActionsForPragma:for: in Block: [ :each | each hasAbstractMethods ]
OrderedCollection>>reject:
DebugSession class>>debuggingActionsForPragma:for:
[ :currentActions :aSymbol | 
currentActions
	addAll: (self debuggingActionsForPragma: aSymbol for: aDebugger);
	yourself ] in DebugSession class>>debuggingActionsForPragmas:for: in Block: [ :currentActions :aSymbol | ...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in Array(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
Array(SequenceableCollection)>>do:
Array(Collection)>>inject:into:
DebugSession class>>debuggingActionsForPragmas:for:
GTSpecPreDebugWindow>>actionsForPragmas:
GTSpecPreDebugWindow>>preDebuggingActions
GTSpecPreDebugWindow>>rebuildWidget
[ :aDebugger | aDebugger ifNil: [ self clearWidget ] ifNotNil: [ self rebuildWidget ] ] in GTSpecPreDebugWindow>>initializePresenter in Block: [ :aDebugger | aDebugger ifNil: [ self clearWidget...etc...
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder(Model)>>whenChangedDo: in Block: [ :announcement :ann | ...
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>do:
[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
Class class(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :stream | Pragma withPragmasIn: aClass do: [ :pragma | stream nextPut: pragma ] ] in SpecPragmaCollector>>allPragmasIn: in Block: [ :stream | Pragma withPragmasIn: aClass do: [ :pr...etc...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
SpecPragmaCollector>>allPragmasIn:
SpecPragmaCollector>>allPragmas
[ self collected copy do: [ :pragma | self removePragma: pragma ].
self allPragmas do: [ :pragma | self addPragma: pragma ] ] in SpecPragmaCollector>>reset in Block: [ self collected copy do: [ :pragma | self removeP...etc...
[ oldAnnouncing := announcing.
announcing := false.
aBlock value ] in SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile: in Block: [ oldAnnouncing := announcing....
BlockClosure>>ensure:
SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter:
		[ :pragma | pragma keyword = 'spec:' and: [ pragma arguments includes: #default ] ])
	reset;
	collected) ifNotEmpty: [ :pragmas | ^ pragmas first method selector ] ] in ContainerPresenter(ComposablePresenter)>>defaultSpecSelector in Block: [ :class | ...
Class class(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
ContainerPresenter(ComposablePresenter)>>defaultSpecSelector
ContainerPresenter>>buildAdapterWithSpec
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[0m[31mUser Interrupt
[0mWriteStream(PositionableStream)>>on:
WriteStream>>on:
WriteStream class(PositionableStream class)>>on:
AdditionalMethodState>>pragmas
CompiledMethod>>pragmas
[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
Object class(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :stream | Pragma withPragmasIn: aClass do: [ :pragma | stream nextPut: pragma ] ] in SpecPragmaCollector>>allPragmasIn: in Block: [ :stream | Pragma withPragmasIn: aClass do: [ :pr...etc...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
SpecPragmaCollector>>allPragmasIn:
SpecPragmaCollector>>allPragmas
[ self collected copy do: [ :pragma | self removePragma: pragma ].
self allPragmas do: [ :pragma | self addPragma: pragma ] ] in SpecPragmaCollector>>reset in Block: [ self collected copy do: [ :pragma | self removeP...etc...
[ oldAnnouncing := announcing.
announcing := false.
aBlock value ] in SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile: in Block: [ oldAnnouncing := announcing....
BlockClosure>>ensure:
SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter:
		[ :pragma | pragma keyword = 'spec:' and: [ pragma arguments includes: #default ] ])
	reset;
	collected) ifNotEmpty: [ :pragmas | ^ pragmas first method selector ] ] in ContainerPresenter(ComposablePresenter)>>defaultSpecSelector in Block: [ :class | ...
Object class(Behavior)>>withAllSuperclassesDo:
Behavior class(Behavior)>>withAllSuperclassesDo:
ClassDescription class(Behavior)>>withAllSuperclassesDo:
Class class(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
[0m[31mUser Interrupt
[0mBottomLeftGripMorph(Morph)>>activate
[ :m | m activate ] in SpecWindow(Morph)>>activate in Block: [ :m | m activate ]
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphsDo:
SpecWindow(Morph)>>activate
SpecWindow(SystemWindow)>>activate
SpecWindow(SystemWindow)>>openAsIsIn:
SpecWindow(StandardWindow)>>openAsIsIn:
SpecWindow(SystemWindow)>>openInWorld:
SpecWindow(Morph)>>openInWorld
MorphicWindowAdapter>>open
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowPresenter(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
WindowPresenter(Model)>>changed:with:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
GTGenericStackDebugger>>openWithNotification:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
[0m[31mUser Interrupt
[0mSmallFloat64(Magnitude)>>min:
Rectangle>>setPoint:point:
Rectangle class>>origin:corner:
Rectangle>>translateBy:
TextMorph(Morph)>>privateMoveBy:
TextMorph>>privateMoveBy:
TextMorph(Morph)>>privateFullMoveBy:
TextMorph(Morph)>>position:
TextMorph(Morph)>>layoutInBounds:
TableLayout>>layoutLeftToRight:in:
TableLayout>>layout:in:
AlignmentMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in AlignmentMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
AlignmentMorph(Morph)>>computeFullBounds
AlignmentMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PluggableButtonMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PluggableButtonMorph(Morph)>>submorphBounds
PluggableButtonMorph(Morph)>>privateFullBounds
PluggableButtonMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PluggableButtonMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PluggableButtonMorph(Morph)>>computeFullBounds
PluggableButtonMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[0m[31mUser Interrupt
[0mSmallFloat64(Magnitude)>>min:max:
Color>>adjustSaturation:brightness:
Color>>slightlyLighter
ScrollBar>>sliderColor:
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>hResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
[0m[31mUser Interrupt
[0mSmallInteger>>lowBit
SmallFloat64(Float)>>asTrueFraction
SmallFloat64(Float)>>adaptToInteger:andCompare:
SmallInteger(Integer)>>>
SmallInteger>>>
Rectangle>>quickMerge:
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:ifAbsent:
Array(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
PanelMorph(Morph)>>valueOfProperty:
PanelMorph(Morph)>>theme
PanelMorph(Morph)>>theme
PluggableButtonMorph(Morph)>>theme
PluggableButtonMorph>>normalColor
PluggableButtonMorph>>changed
PluggableButtonMorph(Morph)>>extent:
PluggableButtonMorph(Morph)>>bounds:
PluggableButtonMorph(Morph)>>layoutInBounds:
PluggableButtonMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[0m[31mUser Interrupt
[0mDictionary>>at:
MorphicEventHandler>>addSubscription:toEvent:
MorphicEventHandler>>on:send:to:
ScrollBar(Morph)>>on:send:to:
ScrollBar>>initializePagingArea
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>hResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
[0m[31mUser Interrupt
[0mPanelMorph(Morph)>>clipSubmorphs
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in SpecWindow(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphBounds
SpecWindow(Morph)>>privateFullBounds
SpecWindow(Morph)>>doLayoutIn:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:ifAbsent:
Array(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
PluggableButtonMorph(Morph)>>valueOfProperty:
PluggableButtonMorph(Morph)>>theme
PluggableButtonMorph>>disabledBorderStyle
PluggableButtonMorph>>borderStyleToUse
PluggableButtonMorph>>changed
PluggableButtonMorph(Morph)>>extent:
PluggableButtonMorph(Morph)>>bounds:
PluggableButtonMorph(Morph)>>layoutInBounds:
PluggableButtonMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
[0m[31mUser Interrupt
[0mMorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
AlignmentMorph(Morph)>>valueOfProperty:
AlignmentMorph(Morph)>>snapToEdgeIfAppropriate
AlignmentMorph(Morph)>>ownerChanged
[ :m | m ownerChanged ] in PluggableButtonMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
PluggableButtonMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PluggableButtonMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PluggableButtonMorph(Morph)>>computeFullBounds
PluggableButtonMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[0m[31mUser Interrupt
[0mTopLeftGripMorph(Morph)>>layoutInBounds:
TopLeftGripMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
SpecWindow(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in SpecWindow(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
SpecWindow(Morph)>>computeFullBounds
SpecWindow(Morph)>>fullBounds
SpecWindow(Morph)>>position:
SpecWindow(SystemWindow)>>position:
SpecWindow(Morph)>>bounds:
SpecWindow(SystemWindow)>>openInWorld:
SpecWindow(Morph)>>openInWorld
MorphicWindowAdapter>>open
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowPresenter(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
WindowPresenter(Model)>>changed:with:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
GTGenericStackDebugger>>openWithNotification:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[0m[31mUser Interrupt
[0m[ :v | self nextPut: v ] in WriteStream(Stream)>>nextPutAll: in Block: [ :v | self nextPut: v ]
ByteSymbol(SequenceableCollection)>>do:
WriteStream(Stream)>>nextPutAll:
WriteStream>>nextPutAll:
[ :aStream | 
class := outer receiver class.
aStream nextPutAll: class name.
methodClass := outer methodClass.
methodClass == class
	ifFalse: [ aStream
			nextPut: $(;
			nextPutAll: methodClass name;
			nextPut: $) ] ] in GTGenericStackDebugger>>printStackClassColumnForContext: in Block: [ :aStream | ...
String class(SequenceableCollection class)>>new:streamContents:
String class(SequenceableCollection class)>>streamContents:
GTGenericStackDebugger>>printStackClassColumnForContext:
GTGenericStackDebugger>>formatStackClassColumnForContext:
GTSpecPreDebugWindow>>columnsFor:
[ :aContext | self columnsFor: aContext ] in GTSpecPreDebugWindow>>initializeStackPane in Block: [ :aContext | self columnsFor: aContext ]
BlockClosure>>cull:
BlockClosure>>cull:cull:
MultiColumnListPresenter(ListPresenter)>>wrapItem:index:
MultiColumnListPresenter>>listElementAt:
MorphicMultiColumnListAdapter(MorphicListAdapter)>>listElementAt:
PluggableMultiColumnListMorph>>getListRow:
MulticolumnLazyListMorph>>getListItem:
MulticolumnLazyListMorph>>hUnadjustedScrollRange
MulticolumnLazyListMorph(LazyListMorph)>>adjustWidth
MulticolumnLazyListMorph(LazyListMorph)>>listChanged
MulticolumnLazyListMorph>>listChanged
PluggableMultiColumnListMorph(PluggableListMorph)>>updateList
PluggableMultiColumnListMorph(PluggableListMorph)>>getListElementSelector:
MorphicMultiColumnListAdapter>>buildWidget
MorphicMultiColumnListAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
[0m[31mUser Interrupt
[0mRectangle>>topRight
ScrollBar>>totalSliderArea
ScrollBar>>initializePagingArea
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>vResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[0m[31mUser Interrupt
[0mPanelMorph(Morph)>>theme
PluggableMultiColumnListMorph(Morph)>>theme
PluggableMultiColumnListMorph(ScrollPane)>>scrollBarThickness
PluggableMultiColumnListMorph(ScrollPane)>>hResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[0m[31mUser Interrupt
[0mCompiledMethod>>pragmas
[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
Class class(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :stream | Pragma withPragmasIn: aClass do: [ :pragma | stream nextPut: pragma ] ] in SpecPragmaCollector>>allPragmasIn: in Block: [ :stream | Pragma withPragmasIn: aClass do: [ :pr...etc...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
SpecPragmaCollector>>allPragmasIn:
SpecPragmaCollector>>allPragmas
[ self collected copy do: [ :pragma | self removePragma: pragma ].
self allPragmas do: [ :pragma | self addPragma: pragma ] ] in SpecPragmaCollector>>reset in Block: [ self collected copy do: [ :pragma | self removeP...etc...
[ oldAnnouncing := announcing.
announcing := false.
aBlock value ] in SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile: in Block: [ oldAnnouncing := announcing....
BlockClosure>>ensure:
SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter: [ :pragma | pragma keyword = #spec ])
	reset;
	collected) collect: [ :pragmas | pragmas method selector ] ] in ContainerPresenter class(ComposablePresenter class)>>specSelectors in Block: [ :class | ...
[ :each | stream nextPutAll: (aBlock value: each) ] in OrderedCollection(SequenceableCollection)>>flatCollect: in Block: [ :each | stream nextPutAll: (aBlock value: each) ...etc...
OrderedCollection>>do:
OrderedCollection(SequenceableCollection)>>flatCollect:
ContainerPresenter class(ComposablePresenter class)>>specSelectors
ContainerPresenter(ComposablePresenter)>>specSelectors
ContainerPresenter(ComposablePresenter)>>defaultSpecSelector
ContainerPresenter>>buildAdapterWithSpec
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
[0m[31mUser Interrupt
[0m[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
Behavior class(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :stream | Pragma withPragmasIn: aClass do: [ :pragma | stream nextPut: pragma ] ] in SpecPragmaCollector>>allPragmasIn: in Block: [ :stream | Pragma withPragmasIn: aClass do: [ :pr...etc...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
SpecPragmaCollector>>allPragmasIn:
SpecPragmaCollector>>allPragmas
[ self collected copy do: [ :pragma | self removePragma: pragma ].
self allPragmas do: [ :pragma | self addPragma: pragma ] ] in SpecPragmaCollector>>reset in Block: [ self collected copy do: [ :pragma | self removeP...etc...
[ oldAnnouncing := announcing.
announcing := false.
aBlock value ] in SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile: in Block: [ oldAnnouncing := announcing....
BlockClosure>>ensure:
SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter:
		[ :pragma | pragma keyword = 'spec:' and: [ pragma arguments includes: #default ] ])
	reset;
	collected) ifNotEmpty: [ :pragmas | ^ pragmas first method selector ] ] in GTDebugActionButton(ComposablePresenter)>>defaultSpecSelector in Block: [ :class | ...
Behavior class(Behavior)>>withAllSuperclassesDo:
ClassDescription class(Behavior)>>withAllSuperclassesDo:
Class class(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
GTDebugActionButton(ComposablePresenter)>>defaultSpecSelector
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
[0m[31mUser Interrupt
[0mGLMFastTablePresentation(GLMPresentation)>>condition
GLMFastTablePresentation(GLMPresentation)>>matches
[ :each | each matches ] in GLMCompositePresentation>>matchingPresentations in Block: [ :each | each matches ]
OrderedCollection>>select:
GLMCompositePresentation>>matchingPresentations
GLMPane>>matchingPresentations
GLMPane>>notingPresentationChangeDo:
GLMPanePort(GLMBoundPort)>>notingPresentationChangeDo:
GLMTransmission>>transmitIn:
[ :each | each transmitIn: aPortEvent transmissionContext copy ] in GLMTabulator(GLMBrowser)>>outerPortEvent: in Block: [ :each | each transmitIn: aPortEvent transmission...etc...
OrderedCollection>>do:
GLMTabulator(GLMBrowser)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTGenericStackDebugger(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTGenericStackDebugger(GLMCompositePresentation)>>do:
GTGenericStackDebugger(GLMCompositePresentation)>>outerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
GLMPanePort(GLMPort)>>value:
GTGenericStackDebugger(GTMoldableDebugger)>>session:
GTGenericStackDebugger class(GTMoldableDebugger class)>>on:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDictionary>>at:put:
MorphicEventHandler>>addSubscription:toEvent:
MorphicEventHandler>>on:send:to:
BorderedMorph(Morph)>>on:send:to:
ScrollBar>>initializeSlider
ScrollBar(Slider)>>initialize
ScrollBar>>initialize
ScrollBar class(Behavior)>>new
PluggableMultiColumnListMorph(ScrollPane)>>initializeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>initialize
PluggableMultiColumnListMorph(PluggableListMorph)>>initialize
PluggableMultiColumnListMorph class(Behavior)>>new
MorphicMultiColumnListAdapter>>buildWidget
MorphicMultiColumnListAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
MultiColumnListPresenter(ComposablePresenter)>>privateAdapterFromModel:withSpec:
MultiColumnListPresenter(ComposablePresenter)>>private_buildWithSpec:
MultiColumnListPresenter(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mKMNamedCharKeyCombination class>>specialKeys
KMNamedCharKeyCombination class>>ifSpecialKey:do:
KMSingleKeyCombination class>>from:
Character>>asKeyCombination
PluggableButtonMorph(Morph)>>bindKeyCombination:toAction:
[ :association | 
aWidget
	bindKeyCombination: association key
	toAction: association value ] in GTDebugActionButton(ComposablePresenter)>>ensureKeyBindingsFor: in Block: [ :association | ...
[ :each | each ifNotNil: [ aBlock value: each ] ] in Dictionary>>associationsDo: in Block: [ :each | each ifNotNil: [ aBlock value: each ] ]
Array(SequenceableCollection)>>do:
Dictionary>>associationsDo:
GTDebugActionButton(ComposablePresenter)>>ensureKeyBindingsFor:
GTDebugActionButton(ButtonPresenter)>>ensureKeyBindingsFor:
GTDebugActionButton(ComposablePresenter)>>setExtentAndBindingTo:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | 
self class
	private_interpretASpec: each
	model: model
	selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex in Block: [ :each | ...
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mAlignmentMorph(Morph)>>outerBounds
AlignmentMorph(Morph)>>privateFullBounds
AlignmentMorph(Morph)>>changed
AlignmentMorph(BorderedMorph)>>borderWidth:
TaskbarItemMorph(PluggableButtonMorph)>>label:font:
TaskbarItemMorph>>initializeFor:
PharoLightTheme(UITheme)>>newTaskbarButtonIn:for:
SpecWindow(SystemWindow)>>taskbarButtonFor:
TaskbarTask>>taskbarButtonFor:
[ :t | 
| button |
button := t taskbarButtonFor: self.
button ifNotNil: [ self addMorphBack: button ] ] in TaskbarMorph>>updateTaskButtons in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTaskButtons
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mSmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
SpecWindow(Morph)>>valueOfProperty:
SpecWindow(SystemWindow)>>unexpandedFrame
SpecWindow(SystemWindow)>>isMaximized
SpecWindow(SystemWindow)>>taskbarState
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mWriteStream class(PositionableStream class)>>on:
AdditionalMethodState>>pragmas
CompiledMethod>>pragmas
[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
Metaclass(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :class | 
self
	withPragmasIn: class
	do: [ :pragma | 
		pragma keyword = aSymbol
			ifTrue: [ stream nextPut: pragma ] ].
aSuperClass = class
	ifTrue: [ ^ stream contents ] ] in [ :stream | 
aSubClass
	withAllSuperclassesDo: [ :class | 
		self
			withPragmasIn: class
			do: [ :pragma | 
				pragma keyword = aSymbol
					ifTrue: [ stream nextPut: pragma ] ].
		aSuperClass = class
			ifTrue: [ ^ stream contents ] ] ] in Pragma class>>allNamed:from:to: in Block: [ :class | ...
Metaclass(Behavior)>>withAllSuperclassesDo:
[ :stream | 
aSubClass
	withAllSuperclassesDo: [ :class | 
		self
			withPragmasIn: class
			do: [ :pragma | 
				pragma keyword = aSymbol
					ifTrue: [ stream nextPut: pragma ] ].
		aSuperClass = class
			ifTrue: [ ^ stream contents ] ] ] in Pragma class>>allNamed:from:to: in Block: [ :stream | ...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
Pragma class>>allNamed:from:to:
DebugSession class>>debuggingActionsFromClass:forPragma:forDebugger:
[ :currentActions :aClass | 
currentActions
	addAll:
		(self
			debuggingActionsFromClass: aClass
			forPragma: aSymbol
			forDebugger: aDebugger);
	yourself ] in DebugSession class>>debuggingActionsForPragma:for: in Block: [ :currentActions :aClass | ...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
DebugSession class>>debuggingActionsForPragma:for:
[ :currentActions :aSymbol | 
currentActions
	addAll: (self debuggingActionsForPragma: aSymbol for: aDebugger);
	yourself ] in DebugSession class>>debuggingActionsForPragmas:for: in Block: [ :currentActions :aSymbol | ...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in Array(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
Array(SequenceableCollection)>>do:
Array(Collection)>>inject:into:
DebugSession class>>debuggingActionsForPragmas:for:
GTSpecPreDebugWindow>>actionsForPragmas:
GTSpecPreDebugWindow>>preDebuggingActions
GTSpecPreDebugWindow>>rebuildWidget
[ :aDebugger | aDebugger ifNil: [ self clearWidget ] ifNotNil: [ self rebuildWidget ] ] in GTSpecPreDebugWindow>>initializePresenter in Block: [ :aDebugger | aDebugger ifNil: [ self clearWidget...etc...
BlockClosure>>cull:
BlockClosure>>cull:cull:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRectangle>>extent
RowLayout>>layout:in:
AlignmentMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in AlignmentMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
AlignmentMorph(Morph)>>computeFullBounds
AlignmentMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in SpecWindow(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphBounds
SpecWindow(Morph)>>privateFullBounds
SpecWindow(Morph)>>changed
SpecWindow(Morph)>>fillStyle:
SpecWindow(SystemWindow)>>setStripeColorsFrom:
SpecWindow(SystemWindow)>>passivate
SpecWindow(SystemWindow)>>privateBePassive
SpecWindow(SystemWindow)>>beTopWindow
SpecWindow(SystemWindow)>>basicActivate
SpecWindow(SystemWindow)>>activate
SpecWindow(SystemWindow)>>openAsIsIn:
SpecWindow(StandardWindow)>>openAsIsIn:
SpecWindow(SystemWindow)>>openInWorld:
SpecWindow(Morph)>>openInWorld
MorphicWindowAdapter>>open
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowPresenter(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
WindowPresenter(Model)>>changed:with:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
[0m[31mUser Interrupt
[0mBorderStyle>>frameRectangle:on:
FormCanvas(Canvas)>>fillRectangle:fillStyle:borderStyle:
WorldMorph(Morph)>>drawOn:
WorldMorph(PasteUpMorph)>>drawOn:
[ :r | 
| mm rect i c remnantIntersects remnants rectToFill |
"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
rectToFill := r.
remnants := OrderedCollection with: r.
i := 1.
[ remnants isEmpty or: [ i > n ] ]
	whileFalse: [ mm := submorphs at: i.
		((remnantIntersects := remnants
			select: [ :each | mm fullBounds intersects: each ]) notEmpty
			and: [ mm visible ])
			ifTrue: [ morphs addLast: mm.
				rects
					addLast:
						(Rectangle
							merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
				remnants removeAll: remnantIntersects.
				remnantIntersects
					do:
						[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
				remnants size = 1
					ifTrue: [ rectToFill := remnants first ].
				remnants isEmpty
					ifTrue: [ rectToFill := nil ] ].
		i := i + 1 ].
"Now paint from bottom to top, but using the reduced rectangles."
rectToFill
	ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
[ morphs isEmpty ]
	whileFalse: [ (rect := rects removeLast) == rectToFill
			ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
		c fullDrawMorph: morphs removeLast ].
morphs reset.
rects reset.
validList add: r ] in [ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ mm := submorphs at: i.
				((remnantIntersects := remnants
					select: [ :each | mm fullBounds intersects: each ]) notEmpty
					and: [ mm visible ])
					ifTrue: [ morphs addLast: mm.
						rects
							addLast:
								(Rectangle
									merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects
							do:
								[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].
		"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill
			ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ (rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in WorldState>>drawWorld:submorphs:invalidAreasOn: in Block: [ :r | ...
Rectangle>>allAreasOutsideList:startingAt:do:
Rectangle>>allAreasOutsideList:do:
[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ mm := submorphs at: i.
				((remnantIntersects := remnants
					select: [ :each | mm fullBounds intersects: each ]) notEmpty
					and: [ mm visible ])
					ifTrue: [ morphs addLast: mm.
						rects
							addLast:
								(Rectangle
									merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects
							do:
								[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].
		"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill
			ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ (rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in WorldState>>drawWorld:submorphs:invalidAreasOn: in Block: [ :dirtyRect | ...
Array(SequenceableCollection)>>do:
WorldState>>drawWorld:submorphs:invalidAreasOn:
[ | worldDamageRects handDamageRects |
worldDamageRects := self
	drawWorld: aWorld
	submorphs: submorphs
	invalidAreasOn: canvas.	"repair world's damage on canvas"
"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw
	collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw
	reverseDo: [ :h | "draw hands onto world canvas" canvas fullDrawMorph: h ] ] in WorldState>>displayWorld:submorphs: in Block: [ | worldDamageRects handDamageRects |...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
WorldState>>displayWorld:submorphs:
WorldMorph>>displayWorld
TaskbarMorph(Morph)>>snapToEdgeIfAppropriate
TaskbarMorph>>updateBounds
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mPoint>>asMargin
Rectangle>>insetBy:
TaskbarItemMorph(Morph)>>layoutBounds
[ self doLayoutIn: self layoutBounds ] in TaskbarItemMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
TaskbarItemMorph(Morph)>>computeFullBounds
TaskbarItemMorph(Morph)>>fullBounds
TaskbarItemMorph(Morph)>>clipSubmorphs:
TaskbarItemMorph(PluggableButtonMorph)>>initialize
TaskbarItemMorph>>initialize
TaskbarItemMorph class(Behavior)>>new
TaskbarItemMorph class(PluggableButtonMorph class)>>on:getState:action:
PharoLightTheme(UITheme)>>newTaskbarButtonIn:for:
SpecWindow(SystemWindow)>>taskbarButtonFor:
TaskbarTask>>taskbarButtonFor:
[ :t | 
| button |
button := t taskbarButtonFor: self.
button ifNotNil: [ self addMorphBack: button ] ] in TaskbarMorph>>updateTaskButtons in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTaskButtons
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mMultistateButtonMorph(Morph)>>privateOwner:
AlignmentMorph(Morph)>>privateAddMorph:atIndex:
AlignmentMorph(Morph)>>addMorphBack:
SpecWindow(SystemWindow)>>addCloseBox
PharoLightTheme(UITheme)>>configureWindowLabelAreaFor:
SpecWindow(SystemWindow)>>replaceBoxes
SpecWindow(SystemWindow)>>initializeLabelArea
SpecWindow(SystemWindow)>>initialize
SpecWindow(StandardWindow)>>initialize
SpecWindow class(Behavior)>>new
MorphicWindowAdapter>>buildWidget
MorphicWindowAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
WindowPresenter(ComposablePresenter)>>privateAdapterFromModel:withSpec:
WindowPresenter>>buildWithSpecLayout:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
GTGenericStackDebugger>>openWithNotification:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mLabelMorph(Morph)>>privateFullMoveBy:
LabelMorph(Morph)>>position:
LabelMorph(Morph)>>align:with:
SpecWindow(SystemWindow)>>setLabel:
SpecWindow(StandardWindow)>>title:
MorphicWindowAdapter>>title:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowPresenter(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
WindowPresenter(Model)>>changed:with:
WindowPresenter>>title:
WindowPresenter>>updateTitle
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
GTGenericStackDebugger>>openWithNotification:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mMorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
TaskbarItemMorph(Morph)>>valueOfProperty:
TaskbarItemMorph(Morph)>>highlightedForDrop
TaskbarItemMorph(Morph)>>drawDropHighlightOn:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in TaskbarItemMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in TaskbarItemMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
BlockClosure>>on:do:
TaskbarItemMorph(Morph)>>fullDrawOn:
FormCanvas(Canvas)>>fullDraw:
FormCanvas(Canvas)>>fullDrawMorph:
[ :m | canvas fullDrawMorph: m ] in [ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in TaskbarMorph(Morph)>>drawSubmorphsOn: in Block: [ :m | canvas fullDrawMorph: m ]
Array(SequenceableCollection)>>reverseDo:
[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in TaskbarMorph(Morph)>>drawSubmorphsOn: in Block: [ :canvas | submorphs reverseDo: [ :m | canvas ful...etc...
FormCanvas>>clipBy:during:
TaskbarMorph(Morph)>>drawSubmorphsOn:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in TaskbarMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in TaskbarMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
BlockClosure>>on:do:
TaskbarMorph(Morph)>>fullDrawOn:
FormCanvas(Canvas)>>fullDraw:
FormCanvas(Canvas)>>fullDrawMorph:
[ :r | 
| mm rect i c remnantIntersects remnants rectToFill |
"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
rectToFill := r.
remnants := OrderedCollection with: r.
i := 1.
[ remnants isEmpty or: [ i > n ] ]
	whileFalse: [ mm := submorphs at: i.
		((remnantIntersects := remnants
			select: [ :each | mm fullBounds intersects: each ]) notEmpty
			and: [ mm visible ])
			ifTrue: [ morphs addLast: mm.
				rects
					addLast:
						(Rectangle
							merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
				remnants removeAll: remnantIntersects.
				remnantIntersects
					do:
						[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
				remnants size = 1
					ifTrue: [ rectToFill := remnants first ].
				remnants isEmpty
					ifTrue: [ rectToFill := nil ] ].
		i := i + 1 ].
"Now paint from bottom to top, but using the reduced rectangles."
rectToFill
	ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
[ morphs isEmpty ]
	whileFalse: [ (rect := rects removeLast) == rectToFill
			ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
		c fullDrawMorph: morphs removeLast ].
morphs reset.
rects reset.
validList add: r ] in [ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ mm := submorphs at: i.
				((remnantIntersects := remnants
					select: [ :each | mm fullBounds intersects: each ]) notEmpty
					and: [ mm visible ])
					ifTrue: [ morphs addLast: mm.
						rects
							addLast:
								(Rectangle
									merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects
							do:
								[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].
		"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill
			ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ (rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in WorldState>>drawWorld:submorphs:invalidAreasOn: in Block: [ :r | ...
Rectangle>>allAreasOutsideList:startingAt:do:
Rectangle>>allAreasOutsideList:do:
[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ mm := submorphs at: i.
				((remnantIntersects := remnants
					select: [ :each | mm fullBounds intersects: each ]) notEmpty
					and: [ mm visible ])
					ifTrue: [ morphs addLast: mm.
						rects
							addLast:
								(Rectangle
									merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects
							do:
								[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].
		"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill
			ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ (rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in WorldState>>drawWorld:submorphs:invalidAreasOn: in Block: [ :dirtyRect | ...
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ ^ aBlock value ] in MorphExtension>>valueOfProperty:ifAbsent: in Block: [ ^ aBlock value ]
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
PluggableMultiColumnListMorph(Morph)>>valueOfProperty:ifAbsent:
PluggableMultiColumnListMorph(ScrollPane)>>hResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
PanelMorph(Morph)>>position:
PanelMorph(Morph)>>bounds:
PanelMorph(Morph)>>layoutInBounds:
PanelMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
[0m[31mUser Interrupt
[0mKeyedTree(Dictionary)>>do:
[ :enableds | enableds do: [ :overs | overs do: [ :fs | styles add: fs ] ] ] in [ :actives | 
actives
	do:
		[ :enableds | enableds do: [ :overs | overs do: [ :fs | styles add: fs ] ] ] ] in MultistateButtonMorph>>fillStyles in Block: [ :enableds | enableds do: [ :overs | overs do: [ ...etc...
KeyedTree(Dictionary)>>valuesDo:
KeyedTree(Dictionary)>>do:
[ :actives | 
actives
	do:
		[ :enableds | enableds do: [ :overs | overs do: [ :fs | styles add: fs ] ] ] ] in MultistateButtonMorph>>fillStyles in Block: [ :actives | ...
KeyedTree(Dictionary)>>valuesDo:
KeyedTree(Dictionary)>>do:
MultistateButtonMorph>>fillStyles
MultistateButtonMorph>>extent:
PharoLightTheme(UITheme)>>createCloseBoxFor:
SpecWindow(SystemWindow)>>createCloseBox
SpecWindow(SystemWindow)>>initializeLabelArea
SpecWindow(SystemWindow)>>initialize
SpecWindow(StandardWindow)>>initialize
SpecWindow class(Behavior)>>new
MorphicWindowAdapter>>buildWidget
MorphicWindowAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
WindowPresenter(ComposablePresenter)>>privateAdapterFromModel:withSpec:
WindowPresenter>>buildWithSpecLayout:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRectangle>>insetBy:
PanelMorph(Morph)>>innerBounds
PanelMorph(Morph)>>layoutBounds
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in SpecWindow(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphBounds
SpecWindow(Morph)>>privateFullBounds
SpecWindow(Morph)>>doLayoutIn:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mLabelMorph(Morph)>>submorphsDo:
LabelMorph(Morph)>>outOfWorld:
[ :m | m outOfWorld: aWorld ] in PanelMorph(Morph)>>outOfWorld: in Block: [ :m | m outOfWorld: aWorld ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
PanelMorph(Morph)>>outOfWorld:
[ :m | m outOfWorld: aWorld ] in AlignmentMorph(Morph)>>outOfWorld: in Block: [ :m | m outOfWorld: aWorld ]
Array(SequenceableCollection)>>do:
AlignmentMorph(Morph)>>submorphsDo:
AlignmentMorph(Morph)>>outOfWorld:
[ :m | m outOfWorld: aWorld ] in TaskbarItemMorph(Morph)>>outOfWorld: in Block: [ :m | m outOfWorld: aWorld ]
Array(SequenceableCollection)>>do:
TaskbarItemMorph(Morph)>>submorphsDo:
TaskbarItemMorph(Morph)>>outOfWorld:
[ :m | 
myWorld ifNotNil: [ m outOfWorld: myWorld ].
m privateOwner: nil ] in TaskbarMorph(Morph)>>removeAllMorphs in Block: [ :m | ...
Array(SequenceableCollection)>>do:
TaskbarMorph(Morph)>>removeAllMorphs
TaskbarMorph>>updateTaskButtons
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
[0m[31mUser Interrupt
[0mForm(ProtoObject)>>identityHash
Form(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mForm(ProtoObject)>>identityHash
Form(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mRectangle class>>origin:corner:
Rectangle>>intersect:ifNone:
WorldMorph>>invalidRect:from:
SpecWindow(Morph)>>invalidRect:from:
PanelMorph(Morph)>>invalidRect:from:
PanelMorph(Morph)>>invalidRect:from:
PanelMorph(Morph)>>invalidRect:from:
PluggableButtonMorph(Morph)>>invalidRect:from:
AlignmentMorph(Morph)>>invalidRect:from:
AlignmentMorph(Morph)>>invalidRect:
AlignmentMorph(Morph)>>changed
AlignmentMorph(Morph)>>extent:
AlignmentMorph(Morph)>>bounds:
AlignmentMorph(Morph)>>layoutInBounds:
TableLayout>>layoutTopToBottom:in:
TableLayout>>layout:in:
PluggableButtonMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PluggableButtonMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PluggableButtonMorph(Morph)>>computeFullBounds
PluggableButtonMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRectangle>>insetBy:
TransformMorph(Morph)>>innerBounds
TransformMorph(Morph)>>clippingBounds
TransformMorph(Morph)>>privateFullBounds
TransformMorph(Morph)>>changed
TransformMorph>>offset:
PluggableMultiColumnListMorph(ScrollPane)>>hHideScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>hHideOrShowScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>hideOrShowScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mSmallInteger(Number)>>negative
SmallFloat64(Float)>>asTrueFraction
SmallFloat64(Float)>>adaptToInteger:andCompare:
SmallInteger(Integer)>>=
SmallInteger>>=
Point>>=
TopRightGripMorph(Morph)>>layoutInBounds:
TopRightGripMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
SpecWindow(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in SpecWindow(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
SpecWindow(Morph)>>computeFullBounds
SpecWindow(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in WorldMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>submorphBounds
WorldMorph(Morph)>>privateFullBounds
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:ifAbsent:
Array(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
SpecWindow(Morph)>>valueOfProperty:
SpecWindow(Morph)>>snapToEdgeIfAppropriate
SpecWindow(Morph)>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>do:
ScrollBar(Morph)>>submorphBounds
ScrollBar(Morph)>>privateFullBounds
ScrollBar(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in ScrollBar(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
ScrollBar(Morph)>>computeFullBounds
ScrollBar(Morph)>>fullBounds
ScrollBar(Morph)>>position:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>hResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
[0m[31mUser Interrupt
[0mPanelMorph(Morph)>>vResizing
PanelMorph(Morph)>>layoutInBounds:
PanelMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in SpecWindow(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphBounds
SpecWindow(Morph)>>privateFullBounds
SpecWindow(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in SpecWindow(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
SpecWindow(Morph)>>computeFullBounds
SpecWindow(Morph)>>fullBounds
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mSet>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mSpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
[0m[31mUser Interrupt
[0mArray(Collection)>>isEmpty
ImageMorph(Morph)>>privateFullBounds
ImageMorph(Morph)>>changed
ImageMorph(Morph)>>extent:
ImageMorph>>form:
ImageMorph>>initialize
ImageMorph class(Behavior)>>new
ScrollBar>>updateDownButtonImage
ScrollBar>>initializeDownButton
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>hResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
[0m[31mUser Interrupt
[0mMorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
SpecWindow(Morph)>>valueOfProperty:
SpecWindow(Morph)>>snapToEdgeIfAppropriate
SpecWindow(Morph)>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
[0m[31mUser Interrupt
[0mRectangle class>>origin:corner:
Rectangle>>truncated
TransformMorph>>submorphBounds
TransformMorph(Morph)>>privateFullBounds
TransformMorph(Morph)>>changed
TransformMorph>>extent:
TransformMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>resizeScroller
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
[0m[31mUser Interrupt
[0mMorphExtension>>valueOfProperty:
SpecWindow(Morph)>>valueOfProperty:
SpecWindow(Morph)>>snapToEdgeIfAppropriate
SpecWindow(Morph)>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
SpecWindow(Morph)>>valueOfProperty:ifAbsent:
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>do:
TextMorph(Morph)>>privateFullMoveBy:
TextMorph(Morph)>>position:
TextMorph(Morph)>>layoutInBounds:
TableLayout>>layoutLeftToRight:in:
TableLayout>>layout:in:
AlignmentMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in AlignmentMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
AlignmentMorph(Morph)>>computeFullBounds
AlignmentMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PluggableButtonMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PluggableButtonMorph(Morph)>>submorphBounds
PluggableButtonMorph(Morph)>>privateFullBounds
PluggableButtonMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PluggableButtonMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PluggableButtonMorph(Morph)>>computeFullBounds
PluggableButtonMorph(Morph)>>fullBounds
PluggableButtonMorph(Morph)>>position:
PluggableButtonMorph(Morph)>>bounds:
PluggableButtonMorph(Morph)>>layoutInBounds:
PluggableButtonMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
[0m[31mUser Interrupt
[0mSet>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mUser Interrupt
[0mSmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
PluggableButtonMorph(Morph)>>valueOfProperty:
PluggableButtonMorph>>interactionState
PluggableButtonMorph>>borderStyleToUse
PluggableButtonMorph>>changed
PluggableButtonMorph(Morph)>>extent:
PluggableButtonMorph(Morph)>>bounds:
PluggableButtonMorph(Morph)>>layoutInBounds:
PluggableButtonMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
[0m[31mUser Interrupt
[0mMorphExtension>>valueOfProperty:
SpecWindow(Morph)>>valueOfProperty:
SpecWindow(Morph)>>snapToEdgeIfAppropriate
SpecWindow(Morph)>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mUser Interrupt
[0mSmallFloat64>>*
LayoutFrame>>transform:
LayoutFrame>>layout:in:
PluggableButtonMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
[0m[31mUser Interrupt
[0mIdentityDictionary(Dictionary)>>at:ifPresent:
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mSet>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSmallFloat64(Float)>>isNaN
SmallFloat64(Float)>>asTrueFraction
SmallFloat64(Float)>>adaptToInteger:andCompare:
SmallInteger(Integer)>>>
SmallInteger>>>
Rectangle>>quickMerge:
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in WorldMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>submorphBounds
WorldMorph(Morph)>>privateFullBounds
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mUser Interrupt
[0m[ :each | each name = aSymbol ] in GLMTabulator(GLMExplicitBrowser)>>paneNamed: in Block: [ :each | each name = aSymbol ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
OrderedCollection(Collection)>>detect:
GLMTabulator(GLMExplicitBrowser)>>paneNamed:
GLMTabulator(GLMBrowser)>>resolvePort:defaultPortName:
GLMTabulator(GLMBrowser)>>resolveDestinationPort:
GLMTransmission>>to:
GTGenericStackDebugger>>debuggerTransmissionsIn:
[ :browser | 
self debuggerStructureIn: browser.
self debuggerTransmissionsIn: browser ] in GTGenericStackDebugger(GTMoldableDebugger)>>compose in Block: [ :browser | ...
GLMTabulator(GLMPresentation)>>with:
GTGenericStackDebugger(GTMoldableDebugger)>>compose
GTGenericStackDebugger(GLMCompositePresentation)>>initialize
GTGenericStackDebugger class(Behavior)>>new
GTGenericStackDebugger class(GTMoldableDebugger class)>>on:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mPanelMorph(Morph)>>visible
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in SpecWindow(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphBounds
SpecWindow(Morph)>>privateFullBounds
SpecWindow(Morph)>>changed
SpecWindow(Morph)>>extent:
SpecWindow(SystemWindow)>>extent:
WindowPresenter(ComposablePresenter)>>ensureExtentFor:
WindowPresenter>>buildWithSpecLayout:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
GTGenericStackDebugger>>openWithNotification:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRectangle>>setPoint:point:
Rectangle class>>origin:corner:
Point>>corner:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>adjustLayoutBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
PanelMorph(Morph)>>position:
PanelMorph(Morph)>>bounds:
PanelMorph(Morph)>>layoutInBounds:
TableLayout>>layoutLeftToRight:in:
TableLayout>>layout:in:
AlignmentMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in AlignmentMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
AlignmentMorph(Morph)>>computeFullBounds
AlignmentMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in TaskbarItemMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
TaskbarItemMorph(Morph)>>submorphBounds
TaskbarItemMorph(Morph)>>privateFullBounds
TaskbarItemMorph(Morph)>>changed
TaskbarItemMorph(PluggableButtonMorph)>>changed
TaskbarItemMorph(Morph)>>extent:
TaskbarItemMorph>>initializeFor:
PharoLightTheme(UITheme)>>newTaskbarButtonIn:for:
SpecWindow(SystemWindow)>>taskbarButtonFor:
[0m[31mUser Interrupt
[0mByteString class(Object)>>hash
ByteString(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mMorphExtension>>valueOfProperty:
SpecWindow(Morph)>>valueOfProperty:
SpecWindow(Morph)>>snapToEdgeIfAppropriate
SpecWindow(Morph)>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mUser Interrupt
[0mRectangle>>center
TaskbarItemMorph(Morph)>>layoutInBounds:
TableLayout>>placeCells:in:horizontal:target:
TableLayout>>layout:in:
TaskbarMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in TaskbarMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
TaskbarMorph(Morph)>>computeFullBounds
TaskbarMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in WorldMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>submorphBounds
WorldMorph(Morph)>>privateFullBounds
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mByteString class(Object)>>hash
ByteSymbol(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mThemeIcons>>icons
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mBorderedMorph(Morph)>>assureExtension
BorderedMorph>>borderStyle:
ScrollBar>>adoptGradientColor:
ScrollBar>>sliderColor:
ScrollBar>>initializeSlider
ScrollBar(Slider)>>extent:
ScrollBar>>extent:
ScrollBar(Morph)>>bounds:
PluggableMultiColumnListMorph(ScrollPane)>>vResizeScrollBar
PluggableMultiColumnListMorph(ScrollPane)>>resizeScrollBars
PluggableMultiColumnListMorph(PluggableListMorph)>>resizeScrollBars
PluggableMultiColumnListMorph(ScrollPane)>>extent:
PluggableMultiColumnListMorph(PluggableListMorph)>>extent:
PluggableMultiColumnListMorph(Morph)>>bounds:
PluggableMultiColumnListMorph(Morph)>>layoutInBounds:
PluggableMultiColumnListMorph(Morph)>>layoutProportionallyIn:
PluggableMultiColumnListMorph(ScrollPane)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in PanelMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphBounds
PanelMorph(Morph)>>privateFullBounds
[0m[31mUser Interrupt
[0mBorderStyle>>frameRectangle:on:
FormCanvas(Canvas)>>fillRectangle:fillStyle:borderStyle:
GLMPanelMorph(Morph)>>drawOn:
FormCanvas(Canvas)>>draw:
FormCanvas(Canvas)>>drawMorph:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in GLMPanelMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in GLMPanelMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
BlockClosure>>on:do:
GLMPanelMorph(Morph)>>fullDrawOn:
FormCanvas(Canvas)>>fullDraw:
FormCanvas(Canvas)>>fullDrawMorph:
[ :m | canvas fullDrawMorph: m ] in [ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in GLMPanelMorph(Morph)>>drawSubmorphsOn: in Block: [ :m | canvas fullDrawMorph: m ]
Array(SequenceableCollection)>>reverseDo:
[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in GLMPanelMorph(Morph)>>drawSubmorphsOn: in Block: [ :canvas | submorphs reverseDo: [ :m | canvas ful...etc...
FormCanvas>>clipBy:during:
GLMPanelMorph(Morph)>>drawSubmorphsOn:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in GLMPanelMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in GLMPanelMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
BlockClosure>>on:do:
GLMPanelMorph(Morph)>>fullDrawOn:
FormCanvas(Canvas)>>fullDraw:
FormCanvas(Canvas)>>fullDrawMorph:
[ :m | canvas fullDrawMorph: m ] in [ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in GLMPanelMorph(Morph)>>drawSubmorphsOn: in Block: [ :m | canvas fullDrawMorph: m ]
Array(SequenceableCollection)>>reverseDo:
[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in GLMPanelMorph(Morph)>>drawSubmorphsOn: in Block: [ :canvas | submorphs reverseDo: [ :m | canvas ful...etc...
FormCanvas>>clipBy:during:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mColor class>>h:s:v:alpha:
Color>>adjustSaturation:brightness:
Color>>slightlyLighter
ScrollBar>>sliderColor:
ScrollBar>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in PluggableMultiColumnListMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
PluggableMultiColumnListMorph(Morph)>>submorphsDo:
PluggableMultiColumnListMorph(Morph)>>adoptPaneColor:
PluggableMultiColumnListMorph(ScrollPane)>>adoptPaneColor:
PluggableMultiColumnListMorph(PluggableListMorph)>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in PanelMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
PanelMorph(Morph)>>adoptPaneColor:
PanelMorph>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in PanelMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
PanelMorph(Morph)>>adoptPaneColor:
PanelMorph>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in PanelMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
PanelMorph(Morph)>>submorphsDo:
PanelMorph(Morph)>>adoptPaneColor:
PanelMorph>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in SpecWindow(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
SpecWindow(Morph)>>submorphsDo:
SpecWindow(Morph)>>adoptPaneColor:
[0m[31mUser Interrupt
[0mAlignmentMorph(BorderedMorph)>>borderWidth:
AlignmentMorph>>setAsRow
PluggableButtonMorph>>label:font:
PluggableButtonMorph>>label:
PluggableButtonMorph>>update:
PluggableButtonMorph>>on:getState:action:label:icon:menu:
PluggableButtonMorph class>>on:getState:action:label:menu:
MorphicButtonAdapter>>buildWidget
MorphicButtonAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
GTDebugActionButton(ComposablePresenter)>>privateAdapterFromModel:withSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | 
self class
	private_interpretASpec: each
	model: model
	selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex in Block: [ :each | ...
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
[0m[31mUser Interrupt
[0mSpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseMove:
MouseMoveEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
[0m[31mUser Interrupt
[0mSet>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mUser Interrupt
[0mReadStream class(PositionableStream class)>>on:
ByteString(SequenceableCollection)>>readStream
NumberParser>>on:
NumberParser class>>on:
Integer class>>readFrom:base:
Color class>>fromHexString:
PharoLightTheme>>taskbarItemNormalBorderStyleFor:
TaskbarItemMorph>>initialize
TaskbarItemMorph class(Behavior)>>new
TaskbarItemMorph class(PluggableButtonMorph class)>>on:getState:action:
PharoLightTheme(UITheme)>>newTaskbarButtonIn:for:
SpecWindow(SystemWindow)>>taskbarButtonFor:
TaskbarTask>>taskbarButtonFor:
[ :t | 
| button |
button := t taskbarButtonFor: self.
button ifNotNil: [ self addMorphBack: button ] ] in TaskbarMorph>>updateTaskButtons in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTaskButtons
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mThemeIcons>>icons
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mAnnouncer>>announce:
SpecPragmaCollector(PragmaCollector)>>announce:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter:
		[ :pragma | pragma keyword = 'spec:' and: [ pragma arguments includes: #default ] ])
	reset;
	collected) ifNotEmpty: [ :pragmas | ^ pragmas first method selector ] ] in ContainerPresenter(ComposablePresenter)>>defaultSpecSelector in Block: [ :class | ...
ProtoObject class(Behavior)>>withAllSuperclassesDo:
Object class(Behavior)>>withAllSuperclassesDo:
Behavior class(Behavior)>>withAllSuperclassesDo:
ClassDescription class(Behavior)>>withAllSuperclassesDo:
Class class(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
Metaclass(Behavior)>>withAllSuperclassesDo:
ContainerPresenter(ComposablePresenter)>>defaultSpecSelector
ContainerPresenter>>buildAdapterWithSpec
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
[ :each | 
self class
	private_interpretASpec: each
	model: model
	selector: spec selector ] in SpecInterpreter>>performNextSelectorAndIncrementIndex in Block: [ :each | ...
Array(SequenceableCollection)>>collect:
SpecInterpreter>>performNextSelectorAndIncrementIndex
[0m[31mUser Interrupt
[0mTextMorph(Morph)>>hasDropShadow
TextMorph(Morph)>>outerBounds
TextMorph(Morph)>>privateFullBounds
TextMorph(Morph)>>changed
TextMorph(Morph)>>extent:
TextMorph>>fit
TextMorph>>paragraph
TextMorph>>newContents:
PharoLightTheme(UITheme)>>buttonLabelForText:
PharoLightTheme(UITheme)>>buttonLabelFor:
PluggableButtonMorph>>newLabel
PluggableButtonMorph>>newLabel:
PluggableButtonMorph>>label:font:
PluggableButtonMorph>>label:
PluggableButtonMorph>>update:
PluggableButtonMorph>>on:getState:action:label:icon:menu:
PluggableButtonMorph class>>on:getState:action:label:menu:
MorphicButtonAdapter>>buildWidget
MorphicButtonAdapter(AbstractAdapter)>>adapt:
SpecInterpreter>>actionToPerformWithSelector:arguments:
SpecInterpreter>>performNextSelectorAndIncrementIndex
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
SpecInterpreter class>>private_interpretASpec:model:selector:
SpecInterpreter class>>private_buildWidgetFor:withSpec:
GTDebugActionButton(ComposablePresenter)>>privateAdapterFromModel:withSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec:
GTDebugActionButton(ComposablePresenter)>>private_buildWithSpec
SpecInterpreter>>returnInterpretationOf:
SpecInterpreter>>interpretASpec:selector:
[0m[31mUser Interrupt
[0mAlignmentMorph(Morph)>>drawMouseDownHighlightOn:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in AlignmentMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in AlignmentMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
BlockClosure>>on:do:
AlignmentMorph(Morph)>>fullDrawOn:
FormCanvas(Canvas)>>fullDraw:
FormCanvas(Canvas)>>fullDrawMorph:
[ :m | canvas fullDrawMorph: m ] in [ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in SpecWindow(Morph)>>drawSubmorphsOn: in Block: [ :m | canvas fullDrawMorph: m ]
Array(SequenceableCollection)>>reverseDo:
[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in SpecWindow(Morph)>>drawSubmorphsOn: in Block: [ :canvas | submorphs reverseDo: [ :m | canvas ful...etc...
FormCanvas>>clipBy:during:
SpecWindow(Morph)>>drawSubmorphsOn:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in SpecWindow(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in SpecWindow(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
BlockClosure>>on:do:
SpecWindow(Morph)>>fullDrawOn:
FormCanvas(Canvas)>>fullDraw:
FormCanvas(Canvas)>>fullDrawMorph:
[ :r | 
| mm rect i c remnantIntersects remnants rectToFill |
"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
rectToFill := r.
remnants := OrderedCollection with: r.
i := 1.
[ remnants isEmpty or: [ i > n ] ]
	whileFalse: [ mm := submorphs at: i.
		((remnantIntersects := remnants
			select: [ :each | mm fullBounds intersects: each ]) notEmpty
			and: [ mm visible ])
			ifTrue: [ morphs addLast: mm.
				rects
					addLast:
						(Rectangle
							merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
				remnants removeAll: remnantIntersects.
				remnantIntersects
					do:
						[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
				remnants size = 1
					ifTrue: [ rectToFill := remnants first ].
				remnants isEmpty
					ifTrue: [ rectToFill := nil ] ].
		i := i + 1 ].
"Now paint from bottom to top, but using the reduced rectangles."
rectToFill
	ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
[ morphs isEmpty ]
	whileFalse: [ (rect := rects removeLast) == rectToFill
			ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
		c fullDrawMorph: morphs removeLast ].
morphs reset.
rects reset.
validList add: r ] in [ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ mm := submorphs at: i.
				((remnantIntersects := remnants
					select: [ :each | mm fullBounds intersects: each ]) notEmpty
					and: [ mm visible ])
					ifTrue: [ morphs addLast: mm.
						rects
							addLast:
								(Rectangle
									merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects
							do:
								[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].
		"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill
			ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ (rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in WorldState>>drawWorld:submorphs:invalidAreasOn: in Block: [ :r | ...
Rectangle>>allAreasOutsideList:startingAt:do:
Rectangle>>allAreasOutsideList:do:
[ :dirtyRect | 
dirtyRect
	allAreasOutsideList: validList
	do: [ :r | 
		| mm rect i c remnantIntersects remnants rectToFill |
		"Experimental top-down drawing --
			Traverses top to bottom, stopping if the entire area is filled.
			If only a single rectangle remains, then continue with the reduced rectangle."
		rectToFill := r.
		remnants := OrderedCollection with: r.
		i := 1.
		[ remnants isEmpty or: [ i > n ] ]
			whileFalse: [ mm := submorphs at: i.
				((remnantIntersects := remnants
					select: [ :each | mm fullBounds intersects: each ]) notEmpty
					and: [ mm visible ])
					ifTrue: [ morphs addLast: mm.
						rects
							addLast:
								(Rectangle
									merging: (remnantIntersects collect: [ :each | mm fullBounds intersect: each ])).
						remnants removeAll: remnantIntersects.
						remnantIntersects
							do:
								[ :eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect) ].
						remnants size = 1
							ifTrue: [ rectToFill := remnants first ].
						remnants isEmpty
							ifTrue: [ rectToFill := nil ] ].
				i := i + 1 ].
		"Now paint from bottom to top, but using the reduced rectangles."
		rectToFill
			ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].
		[ morphs isEmpty ]
			whileFalse: [ (rect := rects removeLast) == rectToFill
					ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].
				c fullDrawMorph: morphs removeLast ].
		morphs reset.
		rects reset.
		validList add: r ] ] in WorldState>>drawWorld:submorphs:invalidAreasOn: in Block: [ :dirtyRect | ...
Array(SequenceableCollection)>>do:
WorldState>>drawWorld:submorphs:invalidAreasOn:
[ | worldDamageRects handDamageRects |
worldDamageRects := self
	drawWorld: aWorld
	submorphs: submorphs
	invalidAreasOn: canvas.	"repair world's damage on canvas"
"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."
handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.
handDamageRects := handsToDraw
	collect: [ :h | h savePatchFrom: canvas ].
allDamage := worldDamageRects , handDamageRects.
handsToDraw
	reverseDo: [ :h | "draw hands onto world canvas" canvas fullDrawMorph: h ] ] in WorldState>>displayWorld:submorphs: in Block: [ | worldDamageRects handDamageRects |...
FormCanvas>>roundCornersOf:in:during:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSet>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
[0m[31mUser Interrupt
[0mByteSymbol(Symbol)>>=
WeakSet>>scanFor:
WeakSet>>like:
Symbol class>>lookup:
Symbol class>>intern:
ByteString(String)>>asSymbol
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[0m[31mUser Interrupt
[0mByteSymbol(Symbol)>>=
WeakSet>>scanFor:
WeakSet>>like:
Symbol class>>lookup:
Symbol class>>intern:
ByteString(String)>>asSymbol
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mIdentityDictionary>>scanFor:
IdentityDictionary(HashedCollection)>>findElementOrNil:
IdentityDictionary(Dictionary)>>at:ifPresent:
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mIdentityDictionary(Dictionary)>>at:ifPresent:
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mBlockClosure>>cull:
IdentityDictionary(Dictionary)>>at:ifPresent:
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSet>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSpecWindow(ProtoObject)>>identityHash
SpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:ifAbsent:
Array(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
SpecWindow(Morph)>>valueOfProperty:ifAbsent:
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mSpecWindow(ProtoObject)>>identityHash
SpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mByteSymbol(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mByteSymbol(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mGTSpecPreDebugWindow(ComposablePresenter)>>windowIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mByteString(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mWorldMorph class(Behavior)>>inheritsFrom:
WorldMorph(Object)>>isKindOf:
SpecWindow(StandardWindow)>>isFullscreen
SpecWindow(StandardWindow)>>isActive
SpecWindow(SystemWindow)>>taskbarState
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mSet>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mSet>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSet>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mThemeIcons>>icons
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mByteString(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mForm(ProtoObject)>>identityHash
Form(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
SpecWindow(Morph)>>valueOfProperty:
SpecWindow(SystemWindow)>>unexpandedFrame
SpecWindow(SystemWindow)>>isMaximized
SpecWindow(SystemWindow)>>taskbarState
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
[0m[31mUser Interrupt
[0mSet>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSet>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mSet>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mThemeIcons>>icons
ThemeIcons>>iconNamed:ifNone:
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
SpecWindow(Morph)>>valueOfProperty:ifAbsent:
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSet>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
[0m[31mUser Interrupt
[0mByteString(String)>>compare:with:collated:
ByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
[0m[31mUser Interrupt
[0mSmallInteger(Number)>>adaptToPoint:andSend:
Point>>*
Form>>scaledByDisplayScaleFactor
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
[0m[31mUser Interrupt
[0mByteString class(Object)>>hash
ByteString(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mByteString class(ProtoObject)>>identityHash
ByteString class(Object)>>hash
ByteString(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mByteString(String)>>=
TaskbarTask>>=
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mSmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
SpecWindow(Morph)>>valueOfProperty:ifAbsent:
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mSet>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mForm(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mByteSymbol class>>stringHash:initialHash:
ByteSymbol(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mByteString(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set(HashedCollection)>>findElementOrNil:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mGTSpecPreDebugWindow(ComposablePresenter)>>windowIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mTaskbarTask>>=
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSet>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mForm>>scaledToSize:
Form>>scaledByDisplayScaleFactor
ThemeIcons>>iconNamed:
GTSpecPreDebugWindow class(ComposablePresenter class)>>iconNamed:
GTSpecPreDebugWindow class(Object class)>>taskbarIcon
GTSpecPreDebugWindow(Object)>>taskbarIcon
WindowPresenter>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarIcon
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mForm(ProtoObject)>>identityHash
Form(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
OrderedCollection>>do:
Set(Collection)>>addAll:
Set class(Collection class)>>withAll:
OrderedCollection(Collection)>>asSet
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mByteString(String)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0mSmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
SpecWindow(Morph)>>valueOfProperty:ifAbsent:
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mSet>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mSet>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:ifAbsent:
Array(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
SpecWindow(Morph)>>valueOfProperty:ifAbsent:
SpecWindow(SystemWindow)>>taskbarTask
[ :m | m taskbarTask ] in TaskbarMorph>>updateTasks in Block: [ :m | m taskbarTask ]
Array(SequenceableCollection)>>collect:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0mOrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
[0m[31mUser Interrupt
[0m[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
MouseOverHandler>>processMouseOver:
[0m[31mUser Interrupt
[0mSpecWindow(Object)>>hash
TaskbarTask>>hash
Set>>scanFor:
Set>>fixCollisionsFrom:
Set>>remove:ifAbsent:
[ :each | set remove: each ifAbsent: [  ] ] in OrderedCollection(Collection)>>difference: in Block: [ :each | set remove: each ifAbsent: [  ] ]
OrderedCollection>>do:
OrderedCollection(Collection)>>difference:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31mUser Interrupt
[0m[ :ot | ot morph = t morph ] in [ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :ot | ot morph = t morph ]
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in OrderedCollection(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
OrderedCollection>>do:
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifFound:
[ :t | 
self orderedTasks
	detect: [ :ot | ot morph = t morph ]
	ifFound: [ :ot | 
		self orderedTasks replaceAll: ot with: t.
		deadTasks remove: ot.
		newTasks remove: t ] ] in TaskbarMorph>>updateTasks in Block: [ :t | ...
OrderedCollection>>do:
TaskbarMorph>>updateTasks
[ self updateBounds.
self updateTasks ] in TaskbarMorph>>ownerChanged in Block: [ self updateBounds....
BlockClosure>>on:do:
TaskbarMorph>>ownerChanged
[ :m | m ownerChanged ] in WorldMorph(Morph)>>doLayoutIn: in Block: [ :m | m ownerChanged ]
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
MouseOverHandler>>handleAsMouseOver:
[0m[31mUser Interrupt
[0mMorph class(Behavior)>>compiledMethodAt:ifAbsent:
[ :class | 
| method |
method := class compiledMethodAt: aSymbol ifAbsent: [ nil ].
method ifNotNil: [ ^ binaryBlock value: class value: method ] ] in PanelMorph class(Behavior)>>classAndMethodFor:do:ifAbsent: in Block: [ :class | ...
Morph class(Behavior)>>withAllSuperclassesDo:
BorderedMorph class(Behavior)>>withAllSuperclassesDo:
PanelMorph class(Behavior)>>withAllSuperclassesDo:
PanelMorph class(Behavior)>>classAndMethodFor:do:ifAbsent:
PanelMorph class(Behavior)>>canUnderstand:
PanelMorph(Object)>>respondsTo:
GTSpecPreDebugWindow(ComposablePresenter)>>ensureExtentFor:
GTSpecPreDebugWindow(ComposablePresenter)>>setExtentAndBindingTo:
GTSpecPreDebugWindow(ComposablePresenter)>>buildWithSpecLayout:
MorphicWindowAdapter>>addModelIn:withSpecLayout:
MorphicWindowAdapter(AbstractAdapter)>>update:with:
[ :aDependent | aDependent update: anAspect with: anObject ] in WindowPresenter(Model)>>changed:with: in Block: [ :aDependent | aDependent update: anAspect with: ...etc...
DependentsArray>>do:
WindowPresenter(Model)>>changed:with:
WindowPresenter>>addModelIn:withSpecLayout:
WindowPresenter>>buildWithSpecLayout:
WindowPresenter>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpecLayout:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec:
GTSpecPreDebugWindow(ComposablePresenter)>>openWithSpec
GTSpecPreDebugWindow(DynamicComposablePresenter)>>openWithSpec
GTGenericStackDebugger>>openWithNotification:
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ "schedule debugger in deferred UI message to add...etc...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>do:
Array>>generateSpec
SpecLayoutFrame>>generateSpec
SpecLayoutAddRow(SpecLayoutAdd)>>generateArguments
SpecColumnLayout(SpecLayout)>>computeNotSplitterWidget:
[ :e | self computeNotSplitterWidget: e ] in SpecColumnLayout(SpecLayout)>>computeNotSplitterWidgets in Block: [ :e | self computeNotSplitterWidget: e ]
OrderedCollection>>do:
SpecColumnLayout(SpecLayout)>>computeNotSplitterWidgets
SpecColumnLayout(SpecLayout)>>privateAsArray
SpecColumnLayout>>privateAsArray
SpecColumnLayout(SpecLayout)>>asArray
SpecLayoutAddColumn>>block:layoutFrame:
SpecLayoutAddColumn class>>block:layoutFrame:
SpecLayout>>newColumn:origin:corner:offsetOrigin:offsetCorner:
SpecLayout>>newColumn:origin:corner:
SpecLayout>>newColumn:
GTSpecPreDebugWindow>>dynamicLayoutForActions:
GTSpecPreDebugWindow>>rebuildWidget
[ :aDebugger | aDebugger ifNil: [ self clearWidget ] ifNotNil: [ self rebuildWidget ] ] in GTSpecPreDebugWindow>>initializePresenter in Block: [ :aDebugger | aDebugger ifNil: [ self clearWidget...etc...
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
BlockClosure>>cull:cull:cull:cull:
[ :announcement :ann | 
aBlock
	cull: announcement newValue
	cull: announcement oldValue
	cull: announcement
	cull: ann ] in NewValueHolder(Model)>>whenChangedDo: in Block: [ :announcement :ann | ...
BlockClosure>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>copyFrom:to:
WriteStream>>contents
AdditionalMethodState>>pragmas
CompiledMethod>>pragmas
[ :selector :method | method pragmas do: aBlock ] in Pragma class>>withPragmasIn:do: in Block: [ :selector :method | method pragmas do: aBlock ]
MethodDictionary>>keysAndValuesDo:
Object class(Behavior)>>selectorsAndMethodsDo:
Pragma class>>withPragmasIn:do:
[ :stream | Pragma withPragmasIn: aClass do: [ :pragma | stream nextPut: pragma ] ] in SpecPragmaCollector>>allPragmasIn: in Block: [ :stream | Pragma withPragmasIn: aClass do: [ :pr...etc...
Array class(SequenceableCollection class)>>new:streamContents:
Array class(SequenceableCollection class)>>streamContents:
SpecPragmaCollector>>allPragmasIn:
SpecPragmaCollector>>allPragmas
[ self collected copy do: [ :pragma | self removePragma: pragma ].
self allPragmas do: [ :pragma | self addPragma: pragma ] ] in SpecPragmaCollector>>reset in Block: [ self collected copy do: [ :pragma | self removeP...etc...
[ oldAnnouncing := announcing.
announcing := false.
aBlock value ] in SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile: in Block: [ oldAnnouncing := announcing....
BlockClosure>>ensure:
SpecPragmaCollector(PragmaCollector)>>noMoreAnnounceWhile:
SpecPragmaCollector>>reset
[ :class | 
(((SpecPragmaCollector behavior: class)
	filter: [ :pragma | pragma keyword = #spec ])
	reset;
	collected) collect: [ :pragmas | pragmas method selector ] ] in ContainerPresenter class(ComposablePresenter class)>>specSelectors in Block: [ :class | ...
[ :each | stream nextPutAll: (aBlock value: each) ] in OrderedCollection(SequenceableCollection)>>flatCollect: in Block: [ :each | stream nextPutAll: (aBlock value: each) ...etc...
OrderedCollection>>do:
OrderedCollection(SequenceableCollection)>>flatCollect:
ContainerPresenter class(ComposablePresenter class)>>specSelectors
ContainerPresenter(ComposablePresenter)>>specSelectors
ContainerPresenter(ComposablePresenter)>>defaultSpecSelector
ContainerPresenter>>buildAdapterWithSpec
SpecInterpreter>>computeSpecFrom:selector:
SpecInterpreter>>retrieveSpecFrom:selector:
SpecInterpreter>>interpretASpec:selector:
SpecInterpreter>>interpretASpec:model:selector:
[0m