OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:12:54.981303+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.d9saswfu4500xb4au3q9hd4zp', '14457' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(aCOOMatrix isMemberOf: self class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result\r\t\t\t\t\t\t\t\tfirst:\r\t\t\t\t\t\t\t\t\t(rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := leftMatrixMarker copy.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := rightMatrixMarker copy.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := leftMatrixMarker copy.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := rightMatrixMarker copy.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(self  isKindOf: aCOOMatrix class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result\r\t\t\t\t\t\t\t\tfirst:\r\t\t\t\t\t\t\t\t\t(rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := leftMatrixMarker copy.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := rightMatrixMarker copy.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := leftMatrixMarker copy.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := rightMatrixMarker copy.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/5/2019 16:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:04.199303+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:06.266303+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:18.641303+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:20.745303+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:22.882303+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:25.054303+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:27.222303+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:29.436303+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:31.617303+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:13:32.767303+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:24.036303+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'addAnimated:to:',			#protocol : #animations,			#sourceCode : 'addAnimated: left to: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix + rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setAdditionLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'addAnimated:to:',			#protocol : #animations,			#sourceCode : 'addAnimated: left to: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ [leftMatrix + rightMatrix] ensure: [ self unlink ] ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setAdditionLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:42.706303+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:44.782303+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:51.041303+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:53.190303+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:55.399303+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:57.546303+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:14:59.662303+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:15:01.815303+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:15:03.985303+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:15',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:15:05.120303+03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:15:05.205303+03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:17:01.351303+03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'COOSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleAddition,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleAddition\r|col col2 coo coo2 cooanimvis|\rcol := { { 1 . -1 . 0 . 0 } . \r\t  \t   { 0 . 3 . 0 . 0 } . \r\t  \t   { 1 . 0 . 2 . 1 } . \r\t\t   { 0 . 0 . 0 . 0 } }.\rcol2 := { { 1 . 0 . 0 . 3 } . \r\t  \t   { 0 . 0 . 0 . -1 } . \r\t  \t   { 0 . 0 . 0 . 0 } . \r\t\t   { 0 . 0 . 1 . 0 } }.\r\t\t\rcoo := COOSparseMatrix withAll: col.\rcoo2 := COOSparseMatrix withAll: col2.\r\rcooanimvis := COOSparseMatrixOperationVisualizer new.\rcooanimvis delay: 1.\r^ cooanimvis addAnimated: coo to: coo2\r',			#stamp : 'YaroslavKormushyn 5/5/2019 16:17',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:21:11.717303+03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:21',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:20.749303+03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'updateResultWith:',			#protocol : #'build ui',			#sourceCode : 'updateResultWith: result\rcomposer replaceElementsInGroup: #result with: result.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer redrawNamesFor: namedGroups.\r\tcomposer redrawBackgroundsFor: backgroundGroups',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'updateResultWith:',			#protocol : #'build ui',			#sourceCode : 'updateResultWith: result\r\tcomposer replaceElementsInGroup: #result with: result.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer redrawNamesFor: namedGroups.\r\tcomposer redrawBackgroundsFor: backgroundGroups.\r\tcomposer view canvas camera focusOnCenter ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:27.369303+03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:29.493303+03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:36.618303+03:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:38.789303+03:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:40.889303+03:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:43.015303+03:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:23:45.201303+03:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:34:51.799303+03:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'COOSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleMultiplication,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleMultiplication\r\t| col coo cooanimvis |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcoo := COOSparseMatrix withAll: col.\r\tcooanimvis := COOSparseMatrixOperationVisualizer new.\r\tcooanimvis delay: 1.\r\t^ cooanimvis multiplyAnimated: coo by: coo',			#stamp : 'YaroslavKormushyn 5/5/2019 16:34',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:35:02.817303+03:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:35',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:36:01.489303+03:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #animations,			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #animations,			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ [leftMatrix byMatrix: rightMatrix] ensure: [self unlink] ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormushyn 5/5/2019 16:36',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:36:08.256303+03:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:37:20.194303+03:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:37:33.046303+03:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/5/2019 16:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:43:33.700303+03:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #private,			#sourceCode : 'byMatrix: aLILSparseMatrix\r\t| result other index sum list arr cachedLeftRow cachedRightColumn |\r\t(columnNumber = aLILSparseMatrix rowNumber)\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [self isEmpty])\r\t\tifTrue: [ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\t\t\r\tother := aLILSparseMatrix transpose.\r\tresult := self class rows: rowNumber columns: aLILSparseMatrix columnNumber.\r\t\r\tarr := (1 to: result rowNumber) collect: [ :rowIndex |\r\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\tcachedLeftRow := rows at: rowIndex.\r\t\t(1 to: result columnNumber) do: [ :columnIndex | \r\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\tsum := (cachedLeftRow \r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\t\t\tifFalse: [ leftNode value * (cachedRightColumn at: index) value ]] \r\t\t\t\t\tthenReject: [:el | el isNil ])\r\t\t\tdetectSum: [ :each | each ].\r\t\t\tsum = 0\r\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\tcolumn: columnIndex \r\t\t\t\t\t\t\t\t\t\tvalue: sum).\r\t\t\t\t\t\tsum := 0 ]\r\t\t\t ].\r\t\t\t\tlist].\r\t\t\t\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li ].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #private,			#sourceCode : 'byMatrix: aLILSparseMatrix\r\t| result other index sum list arr cachedLeftRow cachedRightColumn |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber\r\t\t\t\tdo: [ :columnIndex | \r\t\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\t\tifFalse: [ leftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ list addLast:\r\t\t\t\t\t\t\t\t(LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\tlist ].\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/5/2019 16:43',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:46:49.924303+03:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRemoveClassRefactoring classNames: #(#TWSparseMatrixOperationVisualizer ))'	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ],		#time : DateAndTime [ '2019-05-05T16:46:49.999303+03:00' ],		#trigger : @3	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'MatrixOperationVisualizer subclass: #TWSparseMatrixOperationVisualizer\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'LNU-SparseMatrix-Visual\'',				#superclassName : 'MatrixOperationVisualizer'			},			#name : #TWSparseMatrixOperationVisualizer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TWSparseMatrixOperationVisualizer class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoleteTWSparseMatrixOperationVisualizer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoleteTWSparseMatrixOperationVisualizer,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LNU-SparseMatrix-Visual,			#package : #LNU-SparseMatrix,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:46:52.811303+03:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRemoveClassRefactoring classNames: #(#LILSparseMatrixOperationVisualizer ))'	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ],		#time : DateAndTime [ '2019-05-05T16:46:52.956303+03:00' ],		#trigger : @3	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'MatrixOperationVisualizer subclass: #LILSparseMatrixOperationVisualizer\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #\'LNU-SparseMatrix-Visual\'',				#superclassName : 'MatrixOperationVisualizer'			},			#name : #LILSparseMatrixOperationVisualizer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LILSparseMatrixOperationVisualizer class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoleteLILSparseMatrixOperationVisualizer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoleteLILSparseMatrixOperationVisualizer,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LNU-SparseMatrix-Visual,			#package : #LNU-SparseMatrix,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:47:04.056303+03:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'MatrixOperationVisualizer subclass: #LILSparseMatrixOperationVisualizer\r\tinstanceVariableNames: \'currentLeftRow currentRightColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker nowProcessingElementIndex leftMarkerElement rightMarkerElement\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LNU-SparseMatrix-Visual\'',				#superclassName : 'MatrixOperationVisualizer'			},			#name : #LILSparseMatrixOperationVisualizer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #currentLeftRow,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #currentRightColumn,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #leftMatrixMarker,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #leftSavedMatrixMarker,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #rightMatrixMarker,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #nowProcessingElementIndex,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #leftMarkerElement,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #LILSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #rightMarkerElement,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LILSparseMatrixOperationVisualizer class\r\tinstanceVariableNames: \'\''				},				#name : #'LILSparseMatrixOperationVisualizer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LILSparseMatrixOperationVisualizer,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LNU-SparseMatrix-Visual,			#package : #LNU-SparseMatrix,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:47:15.869303+03:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'MatrixOperationVisualizer subclass: #TWSparseMatrixOperationVisualizer\r\tinstanceVariableNames: \'currentLeftRow currentRightColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker nowProcessingElementIndex leftMarkerElement rightMarkerElement\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LNU-SparseMatrix-Visual\'',				#superclassName : 'MatrixOperationVisualizer'			},			#name : #TWSparseMatrixOperationVisualizer,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #currentLeftRow,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #currentRightColumn,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #leftMatrixMarker,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #leftSavedMatrixMarker,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #rightMatrixMarker,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #nowProcessingElementIndex,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #leftMarkerElement,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixOperationVisualizer,						#isMetaSide : false					},					#name : #rightMarkerElement,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TWSparseMatrixOperationVisualizer class\r\tinstanceVariableNames: \'\''				},				#name : #'TWSparseMatrixOperationVisualizer class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TWSparseMatrixOperationVisualizer,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LNU-SparseMatrix-Visual,			#package : #LNU-SparseMatrix,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:48:34.577303+03:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r\tsuper initialize.\r\tcurrentLeftRow := currentRightColumn := 0.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn:\r\t\t\t{currentLeftRow.\r\t\t\tcurrentRightColumn}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:48:34.583303+03:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r\tsuper initialize.\r\tcurrentLeftRow := currentRightColumn := 0.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn:\r\t\t\t{currentLeftRow.\r\t\t\tcurrentRightColumn}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tsuper initialize.\r\tcurrentLeftRow := currentRightColumn := 0.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn:\r\t\t\t{currentLeftRow.\r\t\t\tcurrentRightColumn}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:48:38.723303+03:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeAdditionView,			#protocol : #initialization,			#sourceCode : 'initializeAdditionView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\tself\r\t\tselectModels:\r\t\t\t{leftMarkerElement model.\r\t\t\trightMarkerElement model}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:48:44.167303+03:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeMultiplicationView,			#protocol : #initialization,			#sourceCode : 'initializeMultiplicationView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\tself\r\t\tselectModels:\r\t\t\t{leftMarkerElement model.\r\t\t\trightMarkerElement model}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:48:47.948303+03:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeAdditionView.\r\t\t\tself setPositionsForAddition.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\t"uninstall the initial block which suspends the process"\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\t"replace it with a new one without the suspend"\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tmetaLinks\r\t\t\t\taddAll:\r\t\t\t\t\t{resultMatrixUpdateLinkFirst.\r\t\t\t\t\tresultMatrixUpdateLinkLast} ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks add: resultMatrixLink',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:48:52.091303+03:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #left ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element inGroup: #left.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy ].\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #right ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t\t\t"elementCopy is the copied object which we use to set a link to value:"\r\t\t\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ "the link is set to right only according to the method code"\r\t\t\t\t\t\t\t\t\t"left is never the object which is copied in this situation"\r\t\t\t\t\t\t\t\t\tself highlightModel: leftMatrixMarker inGroup: #left.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\t\t\telementCopy\r\t\t\t\t\t\t\t\tlink: leftMatrixMarkerHightlightLink\r\t\t\t\t\t\t\t\ttoMethodNamed: #value:.\r\t\t\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\t\t\tself highlightModel: element inGroup: #right.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\t\t\t"metaLinks add: leftMatrixMarkerHightlightLink."\r\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\t\t\tmetaLinks add: rightMarkerHighlightLink ].\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:48:57.462303+03:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForCurrProcElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForCurrProcElementIndexOn: matrixInstance inMethod: methodName\r\t"Set links for the index in label \'Now processing\'"\r\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:01.745303+03:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\t"uninstall the initial block which suspends the process"\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\t"replace it with a new one without the suspend"\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tmetaLinks\r\t\t\t\taddAll:\r\t\t\t\t\t{resultMatrixUpdateLinkFirst.\r\t\t\t\t\tresultMatrixUpdateLinkLast} ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks add: resultMatrixLink',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:05.776303+03:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForRightMatrixOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForRightMatrixOn: matrixInstance inMethod: methodName\r\t| transposedRightMatrixLink |\r\t"reset the right matrix according to the algorithm in the method"\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks add: transposedRightMatrixLink',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:09.662303+03:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #byMatrix:.\r\tself\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method.\r\tself setMultiLinksForResultOn: matrixInstance inMethod: method.\r\tself setMultiLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tsumLink}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:13.764303+03:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForAddition,			#protocol : #initialization,			#sourceCode : 'setPositionsForAddition\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\tcomposer move: #nowProcessing above: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:17.484303+03:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForMultiplication,			#protocol : #initialization,			#sourceCode : 'setPositionsForMultiplication\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\tcomposer move: #nowProcessing above: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:33.364303+03:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForMultiplication,			#protocol : #'as yet unclassified',			#sourceCode : 'setPositionsForMultiplication\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\tcomposer move: #nowProcessing above: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:33.370303+03:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForMultiplication,			#protocol : #'as yet unclassified',			#sourceCode : 'setPositionsForMultiplication\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\tcomposer move: #nowProcessing above: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForMultiplication,			#protocol : #initialization,			#sourceCode : 'setPositionsForMultiplication\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\tcomposer move: #nowProcessing above: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:44.149303+03:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForAddition,			#protocol : #initialization,			#sourceCode : 'setPositionsForAddition\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\tcomposer move: #nowProcessing above: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:47.710303+03:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #byMatrix:.\r\tself\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method.\r\tself setMultiLinksForResultOn: matrixInstance inMethod: method.\r\tself setMultiLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tsumLink}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:51.964303+03:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForRightMatrixOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForRightMatrixOn: matrixInstance inMethod: methodName\r\t| transposedRightMatrixLink |\r\t"reset the right matrix according to the algorithm in the method"\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks add: transposedRightMatrixLink',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:49:56.297303+03:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\t"uninstall the initial block which suspends the process"\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\t"replace it with a new one without the suspend"\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tmetaLinks\r\t\t\t\taddAll:\r\t\t\t\t\t{resultMatrixUpdateLinkFirst.\r\t\t\t\t\tresultMatrixUpdateLinkLast} ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks add: resultMatrixLink',			#stamp : 'YaroslavKormushyn 5/5/2019 16:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:50:00.811303+03:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForCurrProcElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForCurrProcElementIndexOn: matrixInstance inMethod: methodName\r\t"Set links for the index in label \'Now processing\'"\r\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:50:05.571303+03:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #left ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element inGroup: #left.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy ].\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #right ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t\t\t"elementCopy is the copied object which we use to set a link to value:"\r\t\t\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ "the link is set to right only according to the method code"\r\t\t\t\t\t\t\t\t\t"left is never the object which is copied in this situation"\r\t\t\t\t\t\t\t\t\tself highlightModel: leftMatrixMarker inGroup: #left.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\t\t\telementCopy\r\t\t\t\t\t\t\t\tlink: leftMatrixMarkerHightlightLink\r\t\t\t\t\t\t\t\ttoMethodNamed: #value:.\r\t\t\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\t\t\tself highlightModel: element inGroup: #right.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\t\t\t"metaLinks add: leftMatrixMarkerHightlightLink."\r\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\t\t\tmetaLinks add: rightMarkerHighlightLink ].\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:50:09.021303+03:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeAdditionView.\r\t\t\tself setPositionsForAddition.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\t"uninstall the initial block which suspends the process"\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\t"replace it with a new one without the suspend"\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tmetaLinks\r\t\t\t\taddAll:\r\t\t\t\t\t{resultMatrixUpdateLinkFirst.\r\t\t\t\t\tresultMatrixUpdateLinkLast} ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.\r\tmetaLinks add: resultMatrixLink',			#stamp : 'YaroslavKormushyn 5/5/2019 16:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:50:12.145303+03:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeMultiplicationView,			#protocol : #initialization,			#sourceCode : 'initializeMultiplicationView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\tself\r\t\tselectModels:\r\t\t\t{leftMarkerElement model.\r\t\t\trightMarkerElement model}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:50:15.294303+03:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeAdditionView,			#protocol : #initialization,			#sourceCode : 'initializeAdditionView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\tself\r\t\tselectModels:\r\t\t\t{leftMarkerElement model.\r\t\t\trightMarkerElement model}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:50:19.243303+03:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tsuper initialize.\r\tcurrentLeftRow := currentRightColumn := 0.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn:\r\t\t\t{currentLeftRow.\r\t\t\tcurrentRightColumn}',			#stamp : 'YaroslavKormushyn 5/5/2019 16:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T16:52:15.754303+03:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #transpose,			#protocol : #transformation,			#sourceCode : 'transpose\r\t| result tempList marker |\r\tresult := self class rows: columnNumber columns: rowNumber.\r\tself isEmpty  \r\t\tifFalse: [ \r\t\t\tmarker := first.\r\t\t\ttempList := SortedCollection new sortBlock: [ \r\t\t\t\t:left :right | left row < right row or: [ left row = right row and: [ left column < right column ] ] ]. \r\t\t\t[ marker isNotNil ]\r\t\t\t\twhileTrue: [ tempList add:( COOSparseMatrixNode \r\t\t\t\t\t\t\t\t\t\t\trow: marker column \r\t\t\t\t\t\t\t\t\t\t\tcolumn: marker row \r\t\t\t\t\t\t\t\t\t\t\tvalue: marker value).\r\t\t\t\t\t\t\tmarker := marker rightNeighbour ].\r\t\t\ttempList reSort.\r\t\t\ttempList keysAndValuesDo: [ :index :element | \r\t\t\t\t(index - 1) > 0\r\t\t\t\tifTrue:\r\t\t\t\t\t[ element  \r\t\t\t\t\t\tleftNeighbour: (tempList at: index - 1)  ].\r\t\t\t\tindex < tempList size \r\t\t\t\tifTrue: \r\t\t\t\t\t[ element \r\t\t\t\t\trightNeighbour: (tempList at: index + 1) ].\r\t\t\t\t].\r\t\t\tresult first: tempList first.\r\t\t\tresult last: tempList last].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #transpose,			#protocol : #transformation,			#sourceCode : 'transpose\r\t| result tempList marker |\r\tresult := self class rows: columnNumber columns: rowNumber.\r\tself isEmpty\r\t\tifFalse: [ marker := first.\r\t\t\ttempList := SortedCollection new\r\t\t\t\tsortBlock: [ :left :right | \r\t\t\t\t\tleft row < right row\r\t\t\t\t\t\tor: [ left row = right row and: [ left column < right column ] ] ].\r\t\t\t[ marker isNotNil ]\r\t\t\t\twhileTrue: [ tempList\r\t\t\t\t\t\tadd:\r\t\t\t\t\t\t\tmarker copy.\r\t\t\t\t\tmarker := marker rightNeighbour ].\r\t\t\ttempList reSort.\r\t\t\ttempList\r\t\t\t\tkeysAndValuesDo: [ :index :element | \r\t\t\t\t\tindex - 1 > 0\r\t\t\t\t\t\tifTrue: [ element leftNeighbour: (tempList at: index - 1) ].\r\t\t\t\t\tindex < tempList size\r\t\t\t\t\t\tifTrue: [ element rightNeighbour: (tempList at: index + 1) ] ].\r\t\t\tresult first: tempList first.\r\t\t\tresult last: tempList last ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/5/2019 16:52',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:30:53.530303+03:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix\r\t| result arr list operationProcess vis composer|\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: 1.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [  \r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tlist := LinkedList new.\r\t\t\tarr do: [ :node | list addLast: node ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ].\r\t]newProcess.\rvis setUpMenuWithProcess: operationProcess.\r^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 17:30',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:38:10.054303+03:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #getHeaderShape,			#protocol : #'as yet unclassified',			#sourceCode : 'getHeaderShape\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:38',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:38:10.078303+03:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #getHeaderShape,			#protocol : #'as yet unclassified',			#sourceCode : 'getHeaderShape\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:38',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #getHeaderShape,			#protocol : #private,			#sourceCode : 'getHeaderShape\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:38',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:40:10.632303+03:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'getHeaderShapeScaled:',			#protocol : #private,			#sourceCode : 'getHeaderShapeScaled: scale\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:40',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:40:55.385303+03:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'getHeaderShapeScaled:',			#protocol : #private,			#sourceCode : 'getHeaderShapeScaled: scale\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:40',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'getHeaderShapeScaled:',			#protocol : #private,			#sourceCode : 'getHeaderShapeScaled: scale\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\theight: RTLabel defaultFontSize * scale;\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5 * scale;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:40',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:41:08.008303+03:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'getHeaderShapeScaled:',			#protocol : #private,			#sourceCode : 'getHeaderShapeScaled: scale\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\theight: RTLabel defaultFontSize * scale;\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5 * scale;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:40',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'getHeaderShapeScaled:',			#protocol : #private,			#sourceCode : 'getHeaderShapeScaled: scale\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\theight: RTLabel defaultFontSize * scale;\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5 * scale;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ (10 * scale).\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:41',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:41:17.756303+03:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'getHeaderShapeScaled:',			#protocol : #private,			#sourceCode : 'getHeaderShapeScaled: scale\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\theight: RTLabel defaultFontSize * scale;\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5 * scale;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ (10 * scale).\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:41',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'getHeaderShapeScaled:',			#protocol : #private,			#sourceCode : 'getHeaderShapeScaled: scale\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize * scale.\r\tvalueLabel := RTLabel new\r\t\theight: RTLabel defaultFontSize * scale;\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5 * scale;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ (10 * scale).\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 17:41',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:56:01.510303+03:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onRow:',			#protocol : #'instance creation',			#sourceCode : 'onRow: aLILSparseMatrixRow\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLILSparseMatrixRow\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t(el row = 0 or: [ el column = 0 ])\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: el ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: el ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 17:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T17:57:00.125303+03:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixVisualizer class',				#isMetaSide : true			},			#name : #'onRow:withView:',			#protocol : #'instance creation',			#sourceCode : 'onRow: aLILSparseMatrixRow withView: aView\r\t(aLILSparseMatrixRow isKindOf: LinkedList)\r\t\tifFalse: [ Error\r\t\t\t\tsignal: \'Matrix row should be of class \' , LinkedList className ].\r\t^ (self new withView: aView) on: aLILSparseMatrixRow',			#stamp : 'YaroslavKormushyn 5/5/2019 17:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T18:47:19.583303+03:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #delay,			#protocol : #'as yet unclassified',			#sourceCode : 'delay \r^ delay',			#stamp : 'YaroslavKormushyn 5/5/2019 18:47',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T18:47:19.588303+03:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #delay,			#protocol : #'as yet unclassified',			#sourceCode : 'delay \r^ delay',			#stamp : 'YaroslavKormushyn 5/5/2019 18:47',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #delay,			#protocol : #accessing,			#sourceCode : 'delay \r^ delay',			#stamp : 'YaroslavKormushyn 5/5/2019 18:47',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T18:50:11.661303+03:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #namedGroups,			#protocol : #accessing,			#sourceCode : 'namedGroups\r\t^ namedGroups',			#stamp : 'YaroslavKormushyn 5/5/2019 18:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T18:50:27.486303+03:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #backgroundGroups,			#protocol : #accessing,			#sourceCode : 'backgroundGroups\r\t^ backgroundGroups',			#stamp : 'YaroslavKormushyn 5/5/2019 18:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:08:58.751303+03:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'instance creation',			#sourceCode : 'withAll: aCollection\r\t(1 to: rows size)\r\t\tdo: [ :row | \r\t\t\t(((1 to: (aCollection at: row) size)\r\t\t\t\tcollect: [ :column | \r\t\t\t\t\t(((aCollection at: row) at: column) = 0 or: [ ((aCollection at: row) at: column) isNil ])\r\t\t\t\t\t\tifFalse:\r\t\t\t\t\t\t\t[ LILSparseMatrixNode column: column value: ((aCollection at: row) at: column) ] ])\r\t\t\t\treject: [ :el | el isNil ]) do: [ :node | (rows at: row) addLast: node ] ]',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'instance creation',			#sourceCode : 'withAll: aCollection\r\t1 to: rows size\r\t\tdo: [ :row | \r\t\t\t(((1 to: (aCollection at: row) size)\r\t\t\t\tcollect: [ :column | \r\t\t\t\t\t(((aCollection at: row) at: column) = 0\r\t\t\t\t\t\tor: [ ((aCollection at: row) at: column) isNil ])\r\t\t\t\t\t\tifFalse: [ LILSparseMatrixNode\r\t\t\t\t\t\t\t\tcolumn: column\r\t\t\t\t\t\t\t\tvalue: ((aCollection at: row) at: column) ] ])\r\t\t\t\treject: [ :el | el isNil ])\r\t\t\t\tdo: [ :node | (rows at: row) addLast: node ] ]',			#stamp : 'YaroslavKormushyn 5/5/2019 19:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:20:52.087303+03:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'rowAsCollectionAt:',			#protocol : #private,			#sourceCode : 'rowAsCollectionAt: rowIndex\r\t| result |\r\tself isEmpty\r\t\tifTrue: [ ^ OrderedCollection new ]\r\t\tifFalse: [ \r\t\t\t\t\tresult := OrderedCollection\r\t\t\t\t\t\twith: (MatrixElement row: rowIndex column: 0 value: nil).\r\t\t\t\t\tresult\r\t\t\t\t\t\taddAll:\r\t\t\t\t\t\t\t((rows at: rowIndex)\r\t\t\t\t\t\t\t\tcollectWithIndex:\r\t\t\t\t\t\t\t\t\t[ :el :ind | MatrixElement row: rowIndex column: el column value: el value ]).\r\t\t\t\t\tresult\r\t\t\t\t\t\twithIndexDo: [ :el :ind | \r\t\t\t\t\t\t\tind % result size = 0\r\t\t\t\t\t\t\t\tifFalse: [ el next: (result at: ind + 1) ] ].\r\t\t\t\t\t^ result ]',			#stamp : 'YaroslavKormushyn 5/5/2019 19:20',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:23:50.302303+03:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onRow:in:',			#protocol : #'instance creation',			#sourceCode : 'onRow: rowIndex in: aLILSparseMatrix\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t((aLILSparseMatrix rowAsCollectionAt: rowIndex)\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t[el row = 0 or: [ el column = 0 ]] ifTrue: [ \r\t\t\t\t\theaderShape elementOn: el]\r\t\t\t\tifFalse: [elementShape elementOn: el]]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 19:23',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:27:36.826303+03:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixVisualizer class',				#isMetaSide : true			},			#name : #'onRow:in:withView:',			#protocol : #'instance creation',			#sourceCode : 'onRow: rowIndex in: aLILSparseMatrix withView: aView\r\t(aLILSparseMatrix isKindOf: LILSparseMatrix)\r\t\tifFalse: [ Error\r\t\t\t\tsignal: \'Matrix should be of class \' , LILSparseMatrix className ].\r\t^ (self new withView: aView) onRow: rowIndex in:  aLILSparseMatrix',			#stamp : 'YaroslavKormushyn 5/5/2019 19:27',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:28:20.471303+03:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow|\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\t\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t|unionLabel|\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer onRow: row in:self withView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer onRow: row in: aLILSparseMatrix withView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r \tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis\r\t\tnamedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\toperationProcess suspend.\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tlist := LinkedList new.\r\t\t\tarr do: [ :node | list addLast: node ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 19:28',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:42:58.830303+03:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'deselectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'deselectUsing: aBlock\r"deselect all elements for which models aBlock answers true"\r\t[ view elements do:[:el | (aBlock value: el model) ifTrue: [el color: Color blue]] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:42',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:44:39.896303+03:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'highlightUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'highlightUsing: aBlock\r\t[ view elements\r\t\tdo: [ :el | \r\t\t\t(aBlock value: el model)\r\t\t\t\tifTrue: [ el color: Color yellow ] ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:44',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:45:17.933303+03:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock\r\t[ view elements\r\t\tdo: [ :el | \r\t\t\t(aBlock value: el model)\r\t\t\t\tifTrue: [ el color: Color red ] ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:45',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:48:06.153303+03:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock\r\t[ view elements\r\t\tdo: [ :el | \r\t\t\t(aBlock value: el model)\r\t\t\t\tifTrue: [ el color: Color red ] ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:45',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock\r\t[ view elements select:\r\t\t[ :el | \r\t\t\t[aBlock value: el model]\r\t\ton: Error do: False ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:48:11.761303+03:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock\r\t[ view elements select:\r\t\t[ :el | \r\t\t\t[aBlock value: el model]\r\t\ton: Error do: False ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock\r\t[ view elements\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:48:55.264303+03:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock\r\t[ view elements\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock\r\t[ view elements\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ]\r\t\t\tthenDo: [ :el | el color: Color red ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:49:15.880303+03:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'highlightUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'highlightUsing: aBlock\r\t[ view elements\r\t\tdo: [ :el | \r\t\t\t(aBlock value: el model)\r\t\t\t\tifTrue: [ el color: Color yellow ] ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:44',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'highlightUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'highlightUsing: aBlock\r\t[ view elements\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ]\r\t\tthenDo: [ :el | el color: Color yellow ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:49:24.573303+03:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'deselectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'deselectUsing: aBlock\r"deselect all elements for which models aBlock answers true"\r\t[ view elements do:[:el | (aBlock value: el model) ifTrue: [el color: Color blue]] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:42',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'deselectUsing:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'deselectUsing: aBlock\r\t"deselect all elements for which models aBlock answers true"\r\r\t[ view elements\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ]\r\t\tthenDo: [ :el | el color: Color blue ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 19:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T19:52:12.459303+03:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow|\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\t\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t|unionLabel|\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer onRow: row in:self withView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer onRow: row in: aLILSparseMatrix withView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r \tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis\r\t\tnamedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\toperationProcess suspend.\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tlist := LinkedList new.\r\t\t\tarr do: [ :node | list addLast: node ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 19:28',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| unionLabel |\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: self\r\t\t\t\twithView: vis view.\r\t\t\tvis add: leftMatrixRow.\r\t\t\tvis group: #leftRow.\r\t\t\trightMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis add: rightMatrixRow.\r\t\t\tvis group: #rightRow.\r\t\t\tvis move: leftMatrixRow below: #left.\r\t\t\tvis move: rightMatrixRow below: #right.\r\t\t\tvis composer move: unionLabel onTheRightOf: #left.\r\t\t\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis update.\r\t\t\toperationProcess suspend.\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tvis composer deselectUsing: [ :model | model column = columnIndex - 1 ].\r\t\t\t\t\tvis composer selectUsing: [ :model | model column = columnIndex ].\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tlist := LinkedList new.\r\t\t\tarr do: [ :node | list addLast: node ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 19:52',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T20:07:57.790303+03:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'deselectUsing:inGroup:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'deselectUsing: aBlock inGroup: groupName\r\t"deselect all elements for which models aBlock answers true"\r\r\t[ (self getGroup: groupName)\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ]\r\t\tthenDo: [ :el | el color: Color blue ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 20:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T20:08:17.601303+03:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'highlightUsing:inGroup:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'highlightUsing: aBlock inGroup: groupName\r\t[ (self getGroup: groupName)\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ]\r\t\tthenDo: [ :el | el color: Color yellow ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 20:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T20:08:33.069303+03:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectUsing:inGroup:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectUsing: aBlock inGroup: groupName\r\t[ (self getGroup: groupName)\r\t\tselect: [ :el | \r\t\t\t[ aBlock value: el model ]\r\t\t\t\ton: Error\r\t\t\t\tdo: false ]\r\t\tthenDo: [ :el | el color: Color red ] ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 20:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T20:10:03.976303+03:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| unionLabel |\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: self\r\t\t\t\twithView: vis view.\r\t\t\tvis add: leftMatrixRow.\r\t\t\tvis group: #leftRow.\r\t\t\trightMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis add: rightMatrixRow.\r\t\t\tvis group: #rightRow.\r\t\t\tvis move: leftMatrixRow below: #left.\r\t\t\tvis move: rightMatrixRow below: #right.\r\t\t\tvis composer move: unionLabel onTheRightOf: #left.\r\t\t\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis update.\r\t\t\toperationProcess suspend.\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tvis composer deselectUsing: [ :model | model column = columnIndex - 1 ].\r\t\t\t\t\tvis composer selectUsing: [ :model | model column = columnIndex ].\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tlist := LinkedList new.\r\t\t\tarr do: [ :node | list addLast: node ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 19:52',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| unionLabel |\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: self\r\t\t\t\twithView: vis view.\r\t\t\tvis add: leftMatrixRow.\r\t\t\tvis group: #leftRow.\r\t\t\trightMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis add: rightMatrixRow.\r\t\t\tvis group: #rightRow.\r\t\t\tvis move: leftMatrixRow below: #left.\r\t\t\tvis move: rightMatrixRow below: #right.\r\t\t\tvis composer move: unionLabel onTheRightOf: #left.\r\t\t\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis update.\r\t\t\toperationProcess suspend.\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ] inGroup: #leftRow.\rvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ] inGroup: #rightRow.\r\t\t\t\t\tvis composer selectUsing: [ :model | model column = columnIndex ] inGroup: #leftRow.\r\t\t\t\t\tvis composer selectUsing: [ :model | model column = columnIndex ] inGroup: #rightRow.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t\t"last column was not deselected"\r\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ] inGroup: #leftRow.\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ] inGroup: #rightRow.\r\t\t\tlist := LinkedList new.\r\t\t\tarr do: [ :node | list addLast: node ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 20:10',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:28:53.104303+03:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t(el row = 0 or: [ el column = 0 ])\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: el ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: el ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 21:28',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:31:31.791303+03:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedList,				#isMetaSide : false			},			#name : #'linksCollect:',			#protocol : #enumerating,			#sourceCode : 'linksCollect: aBlock\r\t| aLink newCollection|\r\taLink := firstLink.\r\tnewCollection := self class new.\r\t[ aLink == nil ]\r\t\twhileFalse: [ newCollection add: (aBlock value: aLink).\r\t\t\taLink := aLink nextLink ].\r\t^ newCollection',			#stamp : 'YaroslavKormushyn 5/5/2019 21:31',			#package : #Collections-Sequenceable		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:32:03.026303+03:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedList,				#isMetaSide : false			},			#name : #'linksCollect:',			#protocol : #enumerating,			#sourceCode : 'linksCollect: aBlock\r\t| aLink newCollection|\r\taLink := firstLink.\r\tnewCollection := self class new.\r\t[ aLink == nil ]\r\t\twhileFalse: [ newCollection add: (aBlock value: aLink).\r\t\t\taLink := aLink nextLink ].\r\t^ newCollection',			#stamp : 'YaroslavKormushyn 5/5/2019 21:31',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedList,				#isMetaSide : false			},			#name : #'linksCollect:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'linksCollect: aBlock\r\t| aLink newCollection|\r\taLink := firstLink.\r\tnewCollection := self class new.\r\t[ aLink == nil ]\r\t\twhileFalse: [ newCollection add: (aBlock value: aLink).\r\t\t\taLink := aLink nextLink ].\r\t^ newCollection',			#stamp : 'YaroslavKormushyn 5/5/2019 21:31',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:37:49.312303+03:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t(el row = 0 or: [ el column = 0 ])\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: el ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: el ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 21:28',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t(el column = 0 )\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: el ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: el ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 21:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:39:11.826303+03:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'drawEdgesWith:connectTo:',			#protocol : #private,			#sourceCode : 'drawEdgesWith: elements connectTo: aBlock\r\t| edgeBuilder arrowHead |\r\tedgeBuilder := RTEdgeBuilder new.\r\tedgeBuilder view: view.\r\tedgeBuilder elements: elements.\r\tarrowHead := RTSimpleArrow asHead\r\t\tsize: 1;\r\t\tbaseSize: 3.\r\tedgeBuilder shape styledLine\r\t\torthoHorizontalLine;\r\t\thorizontalAttachPoint;\r\t\thead: arrowHead;\r\t\tcolor: Color black.\r\tedgeBuilder\r\t\tconnectTo: aBlock',			#stamp : 'YaroslavKormushyn 5/5/2019 21:39',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:41:11.195303+03:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t(el column = 0 )\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: el ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: el ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 21:37',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements connectTo: [:elLink | elLink next isNotNil ifTrue: [elLink next]].\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 21:41',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:43:42.297303+03:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'setPositionsFor:using:',			#protocol : #initialization,			#sourceCode : 'setPositionsFor: elements using: aBlock\r\t| gap |\r\tgap := 10.\r\telements\r\t\tdo: aBlock',			#stamp : 'YaroslavKormushyn 5/5/2019 21:43',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:43:54.656303+03:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'setPositionsFor:using:',			#protocol : #initialization,			#sourceCode : 'setPositionsFor: elements using: aBlock\r\t| gap |\r\tgap := 10.\r\telements\r\t\tdo: aBlock',			#stamp : 'YaroslavKormushyn 5/5/2019 21:43',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #'setPositionsFor:using:',			#protocol : #initialization,			#sourceCode : 'setPositionsFor: elements using: aBlock\r\telements\r\t\tdo: aBlock',			#stamp : 'YaroslavKormushyn 5/5/2019 21:43',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:45:20.923303+03:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements connectTo: [:elLink | elLink next isNotNil ifTrue: [elLink next]].\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 21:41',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements using: [ :e | |gap|\r\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * (aNode column) ]\r\t\t\t\tvalueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 21:45',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:48:37.701303+03:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixVisualizer class',				#isMetaSide : true			},			#name : #'onLinkedList:withView:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList withView: aView\r\t(aLinkedList isKindOf:  LinkedList)\r\t\tifFalse: [ Error\r\t\t\t\tsignal: \'should be of class \' , LinkedList className ].\r\t^ (self new withView: aView) onLinkedList: aLinkedList ',			#stamp : 'YaroslavKormushyn 5/5/2019 21:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T21:48:54.635303+03:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements using: [ :e | |gap|\r\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * (aNode column) ]\r\t\t\t\tvalueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 21:45',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 21:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:33:22.089303+03:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'replaceGroup:with:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'replaceGroup: groupName with: elements\r\tself removeGroup: groupName.\r\tself view addAll: elements.\r\tself group: groupName.\r\tself view signalUpdate',			#stamp : 'YaroslavKormushyn 5/5/2019 22:33',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:33:31.849303+03:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'updateGroup:with:',			#protocol : #'build ui',			#sourceCode : 'updateGroup: groupName with: elements\r\tcomposer replaceGroup: groupName with: elements.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer redrawNamesFor: namedGroups.\r\tcomposer redrawBackgroundsFor: backgroundGroups.\r\tcomposer view canvas camera focusOnCenter',			#stamp : 'YaroslavKormushyn 5/5/2019 22:33',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:33:45.703303+03:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'updateGroup:with:',			#protocol : #'build ui',			#sourceCode : 'updateGroup: groupName with: elements\r\tcomposer replaceGroup: groupName with: elements.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer redrawNamesFor: namedGroups.\r\tcomposer redrawBackgroundsFor: backgroundGroups.\r\tcomposer view canvas camera focusOnCenter',			#stamp : 'YaroslavKormushyn 5/5/2019 22:33',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'updateGroup:with:',			#protocol : #'build ui',			#sourceCode : 'updateGroup: groupName with: elements\r\tcomposer replaceGroup: groupName with: elements.\r\tcomposer redrawNamesFor: namedGroups.\r\tcomposer redrawBackgroundsFor: backgroundGroups.\r\tcomposer view canvas camera focusOnCenter',			#stamp : 'YaroslavKormushyn 5/5/2019 22:33',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:42:03.692303+03:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| unionLabel |\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: self\r\t\t\t\twithView: vis view.\r\t\t\tvis add: leftMatrixRow.\r\t\t\tvis group: #leftRow.\r\t\t\trightMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis add: rightMatrixRow.\r\t\t\tvis group: #rightRow.\r\t\t\tvis move: leftMatrixRow below: #left.\r\t\t\tvis move: rightMatrixRow below: #right.\r\t\t\tvis composer move: unionLabel onTheRightOf: #left.\r\t\t\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis update.\r\t\t\toperationProcess suspend.\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ] inGroup: #leftRow.\rvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ] inGroup: #rightRow.\r\t\t\t\t\tvis composer selectUsing: [ :model | model column = columnIndex ] inGroup: #leftRow.\r\t\t\t\t\tvis composer selectUsing: [ :model | model column = columnIndex ] inGroup: #rightRow.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t\t"last column was not deselected"\r\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ] inGroup: #leftRow.\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ] inGroup: #rightRow.\r\t\t\tlist := LinkedList new.\r\t\t\tarr do: [ :node | list addLast: node ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 20:10',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ \r\t\t|unionLabel nowProcLabel|\r\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: 1\r\t\t\t\tin: self\r\t\t\t\twithView: vis view.\r\t\t\tvis add: leftMatrixRow.\r\t\t\tvis group: #leftRow.\r\t\t\trightMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: 1\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis add: rightMatrixRow.\r\t\t\tvis group: #rightRow.\r\t\t\tnowProcLabel := (RTLabel text: [:col | \'Processing column \', col]) elementOn: 0.\r\t\t\tvis add: nowProcLabel.\r\t\t\tvis group: #nowProc.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis move: leftMatrixRow below: #left.\r\t\t\tvis move: rightMatrixRow below: #right.\r\t\t\tvis composer move: unionLabel onTheRightOf: #left.\r\t\t\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis update.\r\t\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex .\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr do: [ :node | list addLast: node. vis composer removeGroup: #newRow. \r\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t vis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow. \r\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 22:42',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:43:46.875303+03:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ \r\t\t|unionLabel nowProcLabel|\r\t\tunionLabel := (RTLabel text: \'U\') element.\r\t\t\tvis add: unionLabel.\r\t\t\tvis group: #unionLabel.\r\t\t\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: 1\r\t\t\t\tin: self\r\t\t\t\twithView: vis view.\r\t\t\tvis add: leftMatrixRow.\r\t\t\tvis group: #leftRow.\r\t\t\trightMatrixRow := LILSparseMatrixVisualizer\r\t\t\t\tonRow: 1\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis add: rightMatrixRow.\r\t\t\tvis group: #rightRow.\r\t\t\tnowProcLabel := (RTLabel text: [:col | \'Processing column \', col]) elementOn: 0.\r\t\t\tvis add: nowProcLabel.\r\t\t\tvis group: #nowProc.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis move: leftMatrixRow below: #left.\r\t\t\tvis move: rightMatrixRow below: #right.\r\t\t\tvis composer move: unionLabel onTheRightOf: #left.\r\t\t\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis update.\r\t\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex .\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr do: [ :node | list addLast: node. vis composer removeGroup: #newRow. \r\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t vis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow. \r\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex) ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 22:42',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex). vis updateResultWith: result ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 22:43',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:44:13.006303+03:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex). vis updateResultWith: result ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer',			#stamp : 'YaroslavKormushyn 5/5/2019 22:43',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:44',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:47:10.758303+03:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:44',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait. ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait. ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:47',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:50:01.509303+03:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait. ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait. ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis composer view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:47',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:50:10.680303+03:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #composer,			#protocol : #'as yet unclassified',			#sourceCode : 'composer\r^ composer',			#stamp : 'YaroslavKormushyn 5/5/2019 22:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:50:10.685303+03:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #composer,			#protocol : #'as yet unclassified',			#sourceCode : 'composer\r^ composer',			#stamp : 'YaroslavKormushyn 5/5/2019 22:50',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #composer,			#protocol : #accessing,			#sourceCode : 'composer\r^ composer',			#stamp : 'YaroslavKormushyn 5/5/2019 22:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:51:53.910303+03:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onRow:in:',			#protocol : #'instance creation',			#sourceCode : 'onRow: rowIndex in: aLILSparseMatrix\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t((aLILSparseMatrix rowAsCollectionAt: rowIndex)\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t[el row = 0 or: [ el column = 0 ]] ifTrue: [ \r\t\t\t\t\theaderShape elementOn: el]\r\t\t\t\tifFalse: [elementShape elementOn: el]]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 19:23',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onRow:in:',			#protocol : #'instance creation',			#sourceCode : 'onRow: rowIndex in: aLILSparseMatrix\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t((aLILSparseMatrix rowAsCollectionAt: rowIndex)\r\t\t\t\tcollect: [ :el | \r\t\t\t\t\t( el row = 0 or: [ el column = 0 ] )\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: el ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: el ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself drawEdgesWith: elements.\r\tRTGridLayout on: elements.\r\tself setPositionsFor: elements',			#stamp : 'YaroslavKormushyn 5/5/2019 22:51',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:52:33.183303+03:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis add: leftMatrixRow.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis add: rightMatrixRow.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:50',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:52',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:52:55.175303+03:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:52',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col asString ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:52',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:53:15.865303+03:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel text: [ :col | \'Processing column \' , col asString ])\r\t\telementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis move: leftMatrixRow below: #left.\r\tvis move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:52',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: leftMatrixRow below: #left.\r\tvis composer move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:53',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:54:06.624303+03:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: leftMatrixRow below: #left.\r\tvis composer move: rightMatrixRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:53',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:54',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:54:47.453303+03:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:54',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:54',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T22:56:49.027303+03:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel onTheRightOf: #left.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel updateModelAndRedraw: columnIndex.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel updateModelAndRedraw: \'none\'.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:54',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel onTheRightOf: #leftRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:01:15.433303+03:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'move:between:and:',			#protocol : #public-layout,			#sourceCode : 'move: name1 between: name2 and: name3\r\t| g1 g2 g3 |\r\tg1 := self groupWithoutNest: (mapping at: name1).\r\tg2 := self groupWithoutNest: (mapping at: name2).\r\tg3 := self groupWithoutNest: (mapping at: name3).\r\tTRConstraint move: g1 between: g2 and: g3.\r\tg2 translateBy: 0 @ gap',			#stamp : 'YaroslavKormushyn 5/5/2019 23:01',			#package : #Roassal2		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:01:26.242303+03:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'move:between:and:',			#protocol : #public-layout,			#sourceCode : 'move: name1 between: name2 and: name3\r\t| g1 g2 g3 |\r\tg1 := self groupWithoutNest: (mapping at: name1).\r\tg2 := self groupWithoutNest: (mapping at: name2).\r\tg3 := self groupWithoutNest: (mapping at: name3).\r\tTRConstraint move: g1 between: g2 and: g3.\r\tg2 translateBy: 0 @ gap',			#stamp : 'YaroslavKormushyn 5/5/2019 23:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'move:between:and:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'move: name1 between: name2 and: name3\r\t| g1 g2 g3 |\r\tg1 := self groupWithoutNest: (mapping at: name1).\r\tg2 := self groupWithoutNest: (mapping at: name2).\r\tg3 := self groupWithoutNest: (mapping at: name3).\r\tTRConstraint move: g1 between: g2 and: g3.\r\tg2 translateBy: 0 @ gap',			#stamp : 'YaroslavKormushyn 5/5/2019 23:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:01:42.070303+03:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel onTheRightOf: #leftRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 22:56',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:02:03.382303+03:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'move:between:and:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'move: name1 between: name2 and: name3\r\t| g1 g2 g3 |\r\tg1 := self groupWithoutNest: (mapping at: name1).\r\tg2 := self groupWithoutNest: (mapping at: name2).\r\tg3 := self groupWithoutNest: (mapping at: name3).\r\tTRConstraint move: g1 between: g2 and: g3.\r\tg2 translateBy: 0 @ gap',			#stamp : 'YaroslavKormushyn 5/5/2019 23:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'move:between:and:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'move: name1 between: name2 and: name3\r\t| g1 g2 g3 |\r\tg1 := self groupWithoutNest: (mapping at: name1).\r\tg2 := self groupWithoutNest: (mapping at: name2).\r\tg3 := self groupWithoutNest: (mapping at: name3).\r\tTRConstraint move: g1 between: g2 and: g3',			#stamp : 'YaroslavKormushyn 5/5/2019 23:02',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:07:46.906303+03:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #getElementShape,			#protocol : #private,			#sourceCode : 'getElementShape\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | el value ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | el row @ el column ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #getElementShape,			#protocol : #private,			#sourceCode : 'getElementShape\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | el value ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | |row col| row := el row. col := el column.\r\t\t\trow isNil ifTrue: [ row := 0 ].\r\t\t\tcol isNil ifTrue: [ col := 0 ].\r\t\t\trow @ col ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 23:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:08:33.470303+03:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #getElementShape,			#protocol : #private,			#sourceCode : 'getElementShape\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | el value ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | |row col| row := el row. col := el column.\r\t\t\trow isNil ifTrue: [ row := 0 ].\r\t\t\tcol isNil ifTrue: [ col := 0 ].\r\t\t\trow @ col ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 23:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixVisualizer,				#isMetaSide : false			},			#name : #getElementShape,			#protocol : #private,			#sourceCode : 'getElementShape\r\t| comp box valueLabel indexLabel |\r\tcomp := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | el value isNil ifTrue:  0  ifFalse: [el value] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | \r\t\t\t| row col |\r\t\t\trow := el row.\r\t\t\tcol := el column.\r\t\t\trow isNil\r\t\t\t\tifTrue: [ row := 0 ].\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trow @ col ];\r\t\tcolor: Color white.\r\tcomp\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\t^ comp',			#stamp : 'YaroslavKormushyn 5/5/2019 23:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:14:21.102303+03:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements |\r\telementShape := self getElementShape.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 21:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements box valueLabel indexLabel|\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | \r\t\t\t| row col |\r\t\t\trow := el row.\r\t\t\tcol := el column.\r\t\t\trow isNil\r\t\t\t\tifTrue: [ row := 0 ].\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trow @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:17:32.150303+03:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements box valueLabel indexLabel|\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :el | \r\t\t\t| row col |\r\t\t\trow := el row.\r\t\t\tcol := el column.\r\t\t\trow isNil\r\t\t\t\tifTrue: [ row := 0 ].\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trow @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := self getHeaderShape.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:14',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel|\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| row col |\r\t\t\trow := elLink value row.\r\t\t\tcol := elLink value column.\r\t\t\trow isNil\r\t\t\t\tifTrue: [ row := 0 ].\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trow @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\t\theaderShape\r\t\tadd: headerBox ;\r\t\tadd: headerValueLabel ;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:17',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:18:54.054303+03:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t|  col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:18',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:19:52.078303+03:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixVisualizer class',				#isMetaSide : true			},			#name : #'onLinkedList:inRow:withView:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex withView: aView\r\t(aLinkedList isKindOf: LinkedList)\r\t\tifFalse: [ Error signal: \'should be of class \' , LinkedList className ].\r\t^ (self new withView: aView) onLinkedList: aLinkedList inRow: rowIndex',			#stamp : 'YaroslavKormushyn 5/5/2019 23:19',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:19:55.856303+03:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list inRow: row withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:19',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:22:44.730303+03:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'drawEdgesWith:',			#protocol : #private,			#sourceCode : 'drawEdgesWith: elements\r\t| edgeBuilder arrowHead |\r\tedgeBuilder := RTEdgeBuilder new.\r\tedgeBuilder view: view.\r\tedgeBuilder elements: elements.\r\tarrowHead := RTSimpleArrow asHead\r\t\tsize: 1;\r\t\tbaseSize: 3.\r\tedgeBuilder shape styledLine\r\t\torthoHorizontalLine;\r\t\thorizontalAttachPoint;\r\t\thead: arrowHead;\r\t\tcolor: Color black.\r\tedgeBuilder\r\t\tconnectTo: [ :el | \r\t\t\tel next isNotNil\r\t\t\t\tifTrue: [ el next ] ]',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'drawEdgesWith:',			#protocol : #private,			#sourceCode : 'drawEdgesWith: elements\r\t| edgeBuilder arrowHead |\r\tedgeBuilder := RTEdgeBuilder new.\r\tedgeBuilder view: view.\r\tedgeBuilder elements: elements.\r\tarrowHead := RTSimpleArrow asHead\r\t\tsize: 1;\r\t\tbaseSize: 3.\r\tedgeBuilder shape styledLine\r\t\torthoHorizontalLine;\r\t\thorizontalAttachPoint;\r\t\thead: arrowHead;\r\t\tcolor: Color black.\r\tedgeBuilder\r\t\tconnectTo: [ :el | \r\t\t\tel nextLink isNotNil\r\t\t\t\tifTrue: [ el next ] ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:22',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:23:19.455303+03:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t|  col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink next isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:18',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink nextLink isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:23',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:23:33.973303+03:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'drawEdgesWith:',			#protocol : #private,			#sourceCode : 'drawEdgesWith: elements\r\t| edgeBuilder arrowHead |\r\tedgeBuilder := RTEdgeBuilder new.\r\tedgeBuilder view: view.\r\tedgeBuilder elements: elements.\r\tarrowHead := RTSimpleArrow asHead\r\t\tsize: 1;\r\t\tbaseSize: 3.\r\tedgeBuilder shape styledLine\r\t\torthoHorizontalLine;\r\t\thorizontalAttachPoint;\r\t\thead: arrowHead;\r\t\tcolor: Color black.\r\tedgeBuilder\r\t\tconnectTo: [ :el | \r\t\t\tel nextLink isNotNil\r\t\t\t\tifTrue: [ el next ] ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:22',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'drawEdgesWith:',			#protocol : #private,			#sourceCode : 'drawEdgesWith: elements\r\t| edgeBuilder arrowHead |\r\tedgeBuilder := RTEdgeBuilder new.\r\tedgeBuilder view: view.\r\tedgeBuilder elements: elements.\r\tarrowHead := RTSimpleArrow asHead\r\t\tsize: 1;\r\t\tbaseSize: 3.\r\tedgeBuilder shape styledLine\r\t\torthoHorizontalLine;\r\t\thorizontalAttachPoint;\r\t\thead: arrowHead;\r\t\tcolor: Color black.\r\tedgeBuilder\r\t\tconnectTo: [ :el | \r\t\t\tel next isNotNil\r\t\t\t\tifTrue: [ el next ] ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:23',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:28:24.673303+03:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list inRow: row withView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:19',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:28',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:30:16.157303+03:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:28',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'. \r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:30',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-05T23:58:59.688303+03:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'. \r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:30',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tself halt.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T00:01:56.554303+03:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink nextLink isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/5/2019 23:23',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink nextLink isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/6/2019 00:01',			#package : #LNU-SparseMatrix		}	}}