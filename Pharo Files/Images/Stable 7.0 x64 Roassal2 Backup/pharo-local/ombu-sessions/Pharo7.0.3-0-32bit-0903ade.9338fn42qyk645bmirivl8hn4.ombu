OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:19:06.350856+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.eg6do84x97zefg1mthbnlppmz', '29' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue|\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel text: [:value | \'New element value: \', value asString]) elementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #newRowList.\r\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftNode.\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left. nil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw: (cachedRightColumn at: index).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\t\tnewElementValue model: newElementValue model + (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: #newRowList.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: #newRowList.\r\t\t\t\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tlist ].\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li.\r\t\t(vis composer hasGroup: #newRowList) ifTrue: [ vis composer removeGroup: #newRowList ].\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 00:06',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup|\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\t\r\t\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftNode.\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw: (cachedRightColumn at: index).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\t\t\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\t\tlist isEmpty ifFalse: [ rowIndex = 1 ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ] ifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\t\t\t\tvis add: captionLabel.\r\t\t\t\tvis group: newRowGroup, #Caption.\r\t\t\t\tvis composer move: newRowGroup, #Caption onTheRightOf: newRowGroup. ].\r\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:19',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:20:25.567856+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleMultiplication,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleMultiplication\r\t| col coo cooanimvis |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcoo := LILSparseMatrix withAll: col.\r\t^ coo byMatrixAnimated: coo delay: 1 ',			#stamp : 'YaroslavKormushyn 5/7/2019 16:20',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:20:29.030856+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleMultiplication,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleMultiplication\r\t| col coo cooanimvis |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcoo := LILSparseMatrix withAll: col.\r\t^ coo byMatrixAnimated: coo delay: 1 ',			#stamp : 'YaroslavKormushyn 5/7/2019 16:20',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleMultiplication,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleMultiplication\r\t| col coo |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcoo := LILSparseMatrix withAll: col.\r\t^ coo byMatrixAnimated: coo delay: 1',			#stamp : 'YaroslavKormushyn 5/7/2019 16:20',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:29:05.809856+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup|\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\t\r\t\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftNode.\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw: (cachedRightColumn at: index).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\t\t\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\t\tlist isEmpty ifFalse: [ rowIndex = 1 ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ] ifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\t\t\t\tvis add: captionLabel.\r\t\t\t\tvis group: newRowGroup, #Caption.\r\t\t\t\tvis composer move: newRowGroup, #Caption onTheRightOf: newRowGroup. ].\r\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:19',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: (MatrixElement row: rowIndex column: leftNode column value: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw: (MatrixElement row: rowIndex column: (cachedRightColumn at: index) column value: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:29',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:29:25.895856+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: (MatrixElement row: rowIndex column: leftNode column value: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw: (MatrixElement row: rowIndex column: (cachedRightColumn at: index) column value: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:29',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:29',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:55:38.204856+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:29',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:55',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:56:54.242856+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #private,			#sourceCode : 'byMatrix: aLILSparseMatrix\r\t| result other index sum list arr cachedLeftRow cachedRightColumn |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber\r\t\t\t\tdo: [ :columnIndex | \r\t\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\t\tifFalse: [ leftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ list addLast:\r\t\t\t\t\t\t\t\t(LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\tlist ].\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/5/2019 16:43',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #private,			#sourceCode : 'byMatrix: aLILSparseMatrix\r\t| result other index sum list arr cachedLeftRow cachedRightColumn |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifFalse: [ leftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0 ] ].\r\t\t\tlist ].\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li copyWithoutFirst].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/7/2019 16:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T16:58:28.787856+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:55',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:06:14.530856+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 16:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 17:06',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:11:20.027856+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #MatrixElement\r\tinstanceVariableNames: \'row column value next\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LNU-SparseMatrix-Visual\'',				#superclassName : 'Object'			},			#name : #MatrixElement,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #row,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #column,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #value,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #next,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MatrixElement class\r\tinstanceVariableNames: \'\''				},				#name : #'MatrixElement class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MatrixElement,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LNU-SparseMatrix-Visual,			#package : #LNU-SparseMatrix,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #MatrixElement\r\tinstanceVariableNames: \'row column value source next\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LNU-SparseMatrix-Visual\'',				#superclassName : 'Object'			},			#name : #MatrixElement,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #row,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #column,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #value,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #source,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #MatrixElement,						#isMetaSide : false					},					#name : #next,					#parent : @29				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MatrixElement class\r\tinstanceVariableNames: \'\''				},				#name : #'MatrixElement class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MatrixElement,					#isMetaSide : false				},				#parent : @29,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #LNU-SparseMatrix-Visual,			#package : #LNU-SparseMatrix,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:11:40.376856+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixElement,				#isMetaSide : false			},			#name : #'source:',			#protocol : #'as yet unclassified',			#sourceCode : 'source: sourceElement\rsource := sourceElement ',			#stamp : 'YaroslavKormushyn 5/7/2019 17:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:11:40.385856+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixElement,				#isMetaSide : false			},			#name : #'source:',			#protocol : #'as yet unclassified',			#sourceCode : 'source: sourceElement\rsource := sourceElement ',			#stamp : 'YaroslavKormushyn 5/7/2019 17:11',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixElement,				#isMetaSide : false			},			#name : #'source:',			#protocol : #accessing,			#sourceCode : 'source: sourceElement\rsource := sourceElement ',			#stamp : 'YaroslavKormushyn 5/7/2019 17:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:11:47.592856+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixElement,				#isMetaSide : false			},			#name : #source,			#protocol : #accessing,			#sourceCode : 'source\r\t^ source',			#stamp : 'YaroslavKormushyn 5/7/2019 17:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:12:05.546856+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixElement,				#isMetaSide : false			},			#name : #'row:column:value:source:',			#protocol : #'instance creation',			#sourceCode : 'row: rowInd column: colInd value: aValue source: sourceElement\r\trow := rowInd.\r\tcolumn := colInd.\r\tvalue := aValue.\r\tsource := sourceElement.\r\t^ self',			#stamp : 'YaroslavKormushyn 5/7/2019 17:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:12:36.468856+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #elementsAsCollection,			#protocol : #private,			#sourceCode : 'elementsAsCollection\r\t| result |\r\tself isEmpty\r\t\tifTrue: [ ^ rows\r\t\t\t\tcollectWithIndex: [ :head :rowIndex | MatrixElement row: rowIndex column: 0 value: nil ] ]\r\t\tifFalse: [ ^ (rows\r\t\t\t\tcollectWithIndex: [ :head :rowIndex | \r\t\t\t\t\tresult := OrderedCollection with: (MatrixElement row: rowIndex column: 0 value: nil).\r\t\t\t\t\tresult\r\t\t\t\t\t\taddAll:\r\t\t\t\t\t\t\t(head asOrderedCollection\r\t\t\t\t\t\t\t\tcollectWithIndex: [ :el :ind | MatrixElement row: rowIndex column: el column value: el value ]).\r\t\t\t\t\tresult\r\t\t\t\t\t\twithIndexDo: [ :el :ind | \r\t\t\t\t\t\t\tind % result size = 0\r\t\t\t\t\t\t\t\tifFalse: [ el next: (result at: ind + 1) ] ].\r\t\t\t\t\tresult ]) flattened ]',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #elementsAsCollection,			#protocol : #private,			#sourceCode : 'elementsAsCollection\r\t| result |\r\tself isEmpty\r\t\tifTrue: [ ^ rows\r\t\t\t\tcollectWithIndex: [ :head :rowIndex | MatrixElement row: rowIndex column: 0 value: nil ] ]\r\t\tifFalse: [ ^ (rows\r\t\t\t\tcollectWithIndex: [ :head :rowIndex | \r\t\t\t\t\tresult := OrderedCollection\r\t\t\t\t\t\twith: (MatrixElement row: rowIndex column: 0 value: nil).\r\t\t\t\t\tresult\r\t\t\t\t\t\taddAll:\r\t\t\t\t\t\t\t(head asOrderedCollection\r\t\t\t\t\t\t\t\tcollectWithIndex:\r\t\t\t\t\t\t\t\t\t[ :el :ind | MatrixElement row: rowIndex column: el column value: el value source: el ]).\r\t\t\t\t\tresult\r\t\t\t\t\t\twithIndexDo: [ :el :ind | \r\t\t\t\t\t\t\tind % result size = 0\r\t\t\t\t\t\t\t\tifFalse: [ el next: (result at: ind + 1) ] ].\r\t\t\t\t\tresult ]) flattened ]',			#stamp : 'YaroslavKormushyn 5/7/2019 17:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:16:30.529856+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 17:06',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer selectUsing: [:element | element source = leftNode] inGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer deselectUsing: [:element | element source = leftNode] inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis highlightUsing: [ :element | element source = leftNode ] inGroup: #left.\r\t\t\t\t\t\t\t\tvis highlightUsing: [ :element | element source = (cachedRightColumn at: index) ] inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectUsing: [ :element | element source = leftNode  ] inGroup: #left.\r\t\t\t\t\t\t\t\tvis deselectUsing: [ :element | element source = (cachedRightColumn at: index) ] inGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 17:16',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:18:30.050856+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'MatrixElement class',				#isMetaSide : true			},			#name : #'row:column:value:source:',			#protocol : #'instance creation',			#sourceCode : 'row: rowInd column: colInd value: aValue source: sourceElement\r\t^ self new row: rowInd column: colInd value: aValue source: sourceElement',			#stamp : 'YaroslavKormushyn 5/7/2019 17:18',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T17:19:09.998856+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer selectUsing: [:element | element source = leftNode] inGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer deselectUsing: [:element | element source = leftNode] inGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis highlightUsing: [ :element | element source = leftNode ] inGroup: #left.\r\t\t\t\t\t\t\t\tvis highlightUsing: [ :element | element source = (cachedRightColumn at: index) ] inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectUsing: [ :element | element source = leftNode  ] inGroup: #left.\r\t\t\t\t\t\t\t\tvis deselectUsing: [ :element | element source = (cachedRightColumn at: index) ] inGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 17:16',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\tselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 17:19',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T18:03:27.987856+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\tselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 17:19',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\tselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRow, i asString)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRow, i asString ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 18:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T18:28:18.147856+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\tselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRow, i asString)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRow, i asString ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 18:03',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\tselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRow , i asString)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRow , i asString.\r\t\t\t\t\tvis composer removeGroup: #newRow , i asString, #Caption. ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 18:28',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T18:31:06.111856+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\tselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRow , i asString)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRow , i asString.\r\t\t\t\t\tvis composer removeGroup: #newRow , i asString, #Caption. ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 18:28',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue captionLabel newRowGroup |\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (MatrixElement row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: (LILSparseMatrixNode new column: 0).\r\t\t\tnewRowGroup := #newRow , rowIndex asString.\r\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: newRowGroup.\r\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tvis delay wait.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement\r\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\tcolumn: leftNode column\r\t\t\t\t\t\t\t\t\tvalue: leftNode value).\r\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\tselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifTrue: [ vis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tnil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw:\r\t\t\t\t\t\t\t\t\t\t(MatrixElement\r\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\tcolumn: (cachedRightColumn at: index) column\r\t\t\t\t\t\t\t\t\t\t\tvalue: (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\thighlightUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = leftNode ]\r\t\t\t\t\t\t\t\t\tinGroup: #left.\r\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\tdeselectUsing: [ :element | element source = (cachedRightColumn at: index) ]\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\tnewElementValue\r\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\tnewElementValue model\r\t\t\t\t\t\t\t\t\t\t\t+ (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tvis delay wait.\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: newRowGroup.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\t\tvis composer move: newRowGroup above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tcaptionLabel := (RTLabel\r\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , rowIndex asString)\r\t\t\t\telement.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ rowIndex = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: rowIndex - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :row | vis composer hasGroup: #newRow , row asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: newRowGroup , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: newRowGroup , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t\tvis composer removeGroup: #leftMarker.\r\t\tvis composer removeGroup: #rightMarker.\r\t\t\tarr\r\t\tkeysAndValuesDo: [ :i :li | \r\t\t\tresult rows at: i put: li copyWithoutFirst.\r\t\t\t(vis composer hasGroup: #newRow , i asString)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRow , i asString.\r\t\t\t\t\tvis composer removeGroup: #newRow , i asString , #Caption ].\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 18:31',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T19:15:12.725856+03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess|\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [\r\t\t\r\t\t\t\t\r\t\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\t\t\t\t\r\t\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\rrowNumbers do: [ :rowIndex | \r\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\toutterGap := 5 @ 5.\r\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\tbackgroundBoxLeft strokeWidth: 0.\r\tbackgroundBoxLeft borderRadius: 5.\r\tbackgroundBoxRight := backgroundBoxLeft copy.\r\tbackgroundBoxLeft translateTo: (vis view elementFromModel: (rows at: rowIndex)) center x @ (vis composer getGroup: #left) center y.\r\tbackgroundBoxLeft extent: (vis composer getGroup: #left) extent x @ (vis view elementFromModel: (rows at: rowIndex)) extent y + outterGap.\r\tbackgroundBoxRight translateTo: (vis view elementFromModel: (aMatrix rows at: rowIndex)) center x @ (vis composer getGroup: #right) center y.\r\tbackgroundBoxRight extent: (vis composer getGroup: #right) extent x @ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y + outterGap.\r\tvis view canvas addShape: backgroundBoxLeft.\r\tvis view canvas addShape: backgroundBoxRight.\r\t(vis composer hasGroup: #shade)ifTrue:[vis composer groupToExisting: #shade] ifFalse: [vis group: #shade] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ rightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column) ].].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/7/2019 19:15',			#package : #LNU-SparseMatrix		}	}}