OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T12:49:13.428196+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.9338fn42qyk645bmirivl8hn4', '22' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess|\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [\r\t\t\r\t\t\t\t\r\t\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\t\t\t\t\r\t\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\rrowNumbers do: [ :rowIndex | \r\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\toutterGap := 5 @ 5.\r\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\tbackgroundBoxLeft strokeWidth: 0.\r\tbackgroundBoxLeft borderRadius: 5.\r\tbackgroundBoxRight := backgroundBoxLeft copy.\r\tbackgroundBoxLeft translateTo: (vis view elementFromModel: (rows at: rowIndex)) center x @ (vis composer getGroup: #left) center y.\r\tbackgroundBoxLeft extent: (vis composer getGroup: #left) extent x @ (vis view elementFromModel: (rows at: rowIndex)) extent y + outterGap.\r\tbackgroundBoxRight translateTo: (vis view elementFromModel: (aMatrix rows at: rowIndex)) center x @ (vis composer getGroup: #right) center y.\r\tbackgroundBoxRight extent: (vis composer getGroup: #right) extent x @ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y + outterGap.\r\tvis view canvas addShape: backgroundBoxLeft.\r\tvis view canvas addShape: backgroundBoxRight.\r\t(vis composer hasGroup: #shade)ifTrue:[vis composer groupToExisting: #shade] ifFalse: [vis group: #shade] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ rightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column) ].].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/7/2019 19:15',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t\t\t"gray out empty columns"\r\t\t\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ rightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column) ] ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/8/2019 12:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T12:55:53.806196+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t\t\t"gray out empty columns"\r\t\t\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ rightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column) ] ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/8/2019 12:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ rightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column) ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 12:55',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:11:29.604196+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ rightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column) ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 12:55',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex|\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer selectModels: { leftRowMarker . rightRowMarker  }.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ].\r\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker . \r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker . \r\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker .\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\rnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\r\t\t\t"shift last elements in columns up-to-down"\r"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:12:13.105196+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TWSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleAddition,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleAddition\r\t| col col2 coo coo2 |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcol2 := {{1 . 0 . 0 . 3}.\r\t{0 . 0 . 0 . -1}.\r\t{0 . 0 . 0 . 0}.\r\t{0 . 0 . 1 . 0}}.\r\tcoo := TWSparseMatrix withAll: col.\r\tcoo2 := TWSparseMatrix withAll: col2.\r\t^ coo addAnimated: coo2 delay: 1',			#stamp : 'YaroslavKormushyn 5/8/2019 14:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:12:32.352196+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TWSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleMultiplication,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleMultiplication\r\t| col coo |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcoo := TWSparseMatrix withAll: col.\r\t^ coo byMatrixAnimated: coo delay: 1',			#stamp : 'YaroslavKormushyn 5/8/2019 14:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:15:30.608196+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:15',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:15:33.237196+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex|\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer selectModels: { leftRowMarker . rightRowMarker  }.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ].\r\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker . \r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker . \r\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker .\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\rnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\r\t\t\t"shift last elements in columns up-to-down"\r"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:11',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #'as yet unclassified',			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex|\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer selectModels: { leftRowMarker . rightRowMarker  }.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ].\r\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker . \r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker . \r\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker .\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\rnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\r\t\t\t"shift last elements in columns up-to-down"\r"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:15:33.365196+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimatied:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimatied: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex|\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer selectModels: { leftRowMarker . rightRowMarker  }.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\t\t\ttail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ].\r\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker . \r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker .\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker . \r\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\tnowProcessingElementIndex model: { rowIndex . leftRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker .\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker .\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\rnowProcessingElementIndex model: { rowIndex . rightRowMarker column }.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker .\r\t\t\t\t\t\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\r\t\t\t"shift last elements in columns up-to-down"\r"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait. ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:17:12.957196+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TWMatrixNode class',				#isMetaSide : true			},			#name : #'row:column:value:',			#protocol : #'instance creation',			#sourceCode : 'row: rowNumber column: columnNumber value: aValue\r\trowNumber isInteger & columnNumber isInteger\r\t\tifFalse: [ Error signal: \'Row and column indices must be integer values\' ].\r\t(rowNumber > 0 & columnNumber > 0)\r\t\tifFalse: [ DomainError signal: \'Indices must be a positive value\' from: 1 ].\r\t^ self new value: aValue row: rowNumber column: columnNumber',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TWMatrixNode class',				#isMetaSide : true			},			#name : #'row:column:value:',			#protocol : #'instance creation',			#sourceCode : 'row: rowNumber column: columnNumber value: aValue\r\trowNumber isInteger & columnNumber isInteger\r\t\tifFalse: [ Error signal: \'Row and column indices must be integer values\' ].\r\t(rowNumber > 0 and: [ columnNumber > 0 ] )\r\t\tifFalse: [ DomainError signal: \'Indices must be a positive value\' from: 1 ].\r\t^ self new value: aValue row: rowNumber column: columnNumber',			#stamp : 'YaroslavKormushyn 5/8/2019 14:17',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:20:16.983196+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode row: 0 column: 0 value: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:15',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:20',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:21:32.543196+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ].\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:20',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess .\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:21',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:22:56.312196+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess .\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:21',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\tself halt.\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t\t\tself halt.\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t\t\tself halt.\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:22',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:36:55.144196+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ rowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\tself halt.\r\t"gray out rows which are empty"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t\t\tself halt.\r\t"gray out empty columns"\r\tcolNumbers\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t\t\tself halt.\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:22',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ \r\t\t"rowNumbers, colNumbers - indices which exist"\r\t\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\tself halt.\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\tself halt.\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:36',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:37:08.184196+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ \r\t\t"rowNumbers, colNumbers - indices which exist"\r\t\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\tself halt.\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\tself halt.\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:36',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:39:17.467196+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #elementsAsCollection,			#protocol : #private,			#sourceCode : 'elementsAsCollection\r\t| result marker |\r\tself isEmpty\r\t\tifTrue: [ result := rows asOrderedCollection.\r\t\t\tresult addAll: columns ]\r\t\tifFalse: [ result := rows asOrderedCollection.\r\t\t\tresult addAll: columns.\r\t\t\t1 to: rows size do: [ :rowInd | \r\t\t\t\tmarker := (rows at: rowInd) rightNeighbour.\r\t\t\t\t[ marker column ~= 0 ]\r\t\t\t\t\twhileTrue: [ result add: marker.\r\t\t\t\t\t\tmarker := marker rightNeighbour ] ] ].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #elementsAsCollection,			#protocol : #private,			#sourceCode : 'elementsAsCollection\r\t| result marker |\r\tself isEmpty\r\t\tifTrue: [ result := rows asOrderedCollection.\r\t\t\tresult addAll: columns ]\r\t\tifFalse: [ result := rows asOrderedCollection.\r\t\t\tresult addAll: columns.\r\t\t\t1 to: rows size do: [ :rowInd | \r\t\t\t\tmarker := (rows at: rowInd) rightNeighbour.\r\t\t\t\t[ marker isNotNil and: [marker column ~= 0] ]\r\t\t\t\t\twhileTrue: [ result add: marker.\r\t\t\t\t\t\tmarker := marker rightNeighbour ] ] ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/8/2019 14:39',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:55:02.926196+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:37',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:55',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:56:30.404196+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:55',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T14:58:49.396196+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:56',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t\t\tvis composer removeGroup: #leftMarker.\r\t\t\tvis composer removeGroup: #rightMarker.\r\t\t\tvis namedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\t\t\tvis redrawNamesAndBackgrounds. \r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:01:10.979196+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TWSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleAddition,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleAddition\r\t| col col2 coo coo2 |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcol2 := {{1 . 0 . 0 . 3}.\r\t{0 . 0 . 0 . -1}.\r\t{0 . 0 . 0 . 0}.\r\t{0 . 0 . 1 . 0}}.\r\tcoo := TWSparseMatrix withAll: col.\r\tcoo2 := TWSparseMatrix withAll: col2.\r\t^ coo addAnimated: coo2 delay: 1',			#stamp : 'YaroslavKormushyn 5/8/2019 14:12',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'TWSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleAddition,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleAddition\r\t| col col2 coo coo2 |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcol2 := {{1 . 0 . 0 . 3}.\r\t{0 . 0 . 0 . -1}.\r\t{0 . 0 . 0 . 0}.\r\t{0 . 0 . 0 . 0}}.\r\tcoo := TWSparseMatrix withAll: col.\r\tcoo2 := TWSparseMatrix withAll: col2.\r\t^ coo addAnimated: coo2 delay: 1',			#stamp : 'YaroslavKormushyn 5/8/2019 15:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:01:54.680196+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t\t\tvis composer removeGroup: #leftMarker.\r\t\t\tvis composer removeGroup: #rightMarker.\r\t\t\tvis namedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\t\t\tvis redrawNamesAndBackgrounds. \r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 14:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:07:43.981196+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour isNil ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:07:48.946196+03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns reject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows\r\t\t\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:08:24.314196+03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows\r\t\t\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows\r\t\t\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:11:43.443196+03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows\r\t\t\t\treject: [ :rowHead | rowHead rightNeighbour ~= rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour ~= colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t\t\t\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows\r\t\t\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:13:51.310196+03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows\r\t\t\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\t"check if the copy actually returns a new shape since it matters it the view"\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:11',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\t\t\t\t\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:13',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:14:11.138196+03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\t\t\t\t\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxRight := backgroundBoxLeft copy.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:13',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:14:56.414196+03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\tself halt.\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:14',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:16:43.263196+03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:14',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:16',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-08T15:47:48.632196+03:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\tvis composer\r\t\t\t\tselectModels:\r\t\t\t\t\t{leftRowMarker.\r\t\t\t\t\trightRowMarker}.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:16',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t(leftRowMarker column ~= 0) ifTrue: [ vis composer\r\t\t\t\tselectModel:\r\t\t\t\t\tleftRowMarker ].\r(rightRowMarker column ~= 0) ifTrue: [ vis composer\r\t\t\t\tselectModel:\r\t\t\t\t\trightRowMarker ].\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [vis composer selectModel: leftRowMarker] ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer selectModel: rightRowMarker] ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\t\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer selectModel: rightRowMarker].\r\t\t\t\t\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [vis composer selectModel: leftRowMarker].\r\t\t\t\t\t\t\t\t\t\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [leftRowMarker := leftRowMarker rightNeighbour].\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer deselectModel: rightRowMarker].\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:47',			#package : #LNU-SparseMatrix		}	}}