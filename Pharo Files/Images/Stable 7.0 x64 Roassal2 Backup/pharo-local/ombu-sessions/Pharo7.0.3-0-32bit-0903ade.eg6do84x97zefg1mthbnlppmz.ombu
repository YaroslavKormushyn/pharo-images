OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T20:48:12.723323+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.ewhcohvqr2w6wefga74smvyqm', '21' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:10',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty ifFalse: [ \r\t\t\t\t|captionLabel|\r\t\t\t\t(row = 1) ifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\tifFalse: [ (row - 1 to: 1) detect: [ :rowIndex | vis composer hasGroup: #newRow, rowIndex asString ] ifFound: [ :previousRow | vis composer move: newRowGroup below: #newRow, previousRow ] ].\r\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \', row asString) element.\r\t\t\t\tvis add: captionLabel.\r\t\t\t\tvis group: #newRow, row asString, #Caption.\r\t\t\t\tvis composer move: #newRow, row asString, #Caption onTheRightOf: newRowGroup ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow, rowIndex asString, #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 20:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T20:49:15.854323+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty ifFalse: [ \r\t\t\t\t|captionLabel|\r\t\t\t\t(row = 1) ifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\tifFalse: [ (row - 1 to: 1) detect: [ :rowIndex | vis composer hasGroup: #newRow, rowIndex asString ] ifFound: [ :previousRow | vis composer move: newRowGroup below: #newRow, previousRow ] ].\r\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \', row asString) element.\r\t\t\t\tvis add: captionLabel.\r\t\t\t\tvis group: #newRow, row asString, #Caption.\r\t\t\t\tvis composer move: #newRow, row asString, #Caption onTheRightOf: newRowGroup ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow, rowIndex asString, #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 20:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty ifFalse: [ \r\t\t\t\t|captionLabel|\r\t\t\t\t(row = 1) ifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\tifFalse: [ (row - 1 to: 1) detect: [ :rowIndex | vis composer hasGroup: #newRow, rowIndex asString ] ifFound: [ :previousRow | vis composer move: newRowGroup below: #newRow, previousRow asString] ].\r\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \', row asString) element.\r\t\t\t\tvis add: captionLabel.\r\t\t\t\tvis group: #newRow, row asString, #Caption.\r\t\t\t\tvis composer move: #newRow, row asString, #Caption onTheRightOf: newRowGroup ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow, rowIndex asString, #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 20:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T20:59:56.185323+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty ifFalse: [ \r\t\t\t\t|captionLabel|\r\t\t\t\t(row = 1) ifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\tifFalse: [ (row - 1 to: 1) detect: [ :rowIndex | vis composer hasGroup: #newRow, rowIndex asString ] ifFound: [ :previousRow | vis composer move: newRowGroup below: #newRow, previousRow asString] ].\r\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \', row asString) element.\r\t\t\t\tvis add: captionLabel.\r\t\t\t\tvis group: #newRow, row asString, #Caption.\r\t\t\t\tvis composer move: #newRow, row asString, #Caption onTheRightOf: newRowGroup ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow, rowIndex asString, #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 20:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas camera adjust.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\t\t\tvis composer view canvas camera adjust.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas camera adjust.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 20:59',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:04:26.948323+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas camera adjust.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\t\t\tvis composer view canvas camera adjust.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas camera adjust.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 20:59',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas camera focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas camera focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas camera focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:04',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:08:52.731323+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas camera focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas camera focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas camera focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:04',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:13:42.517323+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: Character arrowLeft, \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:13',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:14:06.255323+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel text: Character arrowLeft, \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:13',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString, \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:16:34.003323+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString, \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:14',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\tifTrue:[\r\t\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:16',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:29:21.696323+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\tifTrue:[\r\t\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:16',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t\tvis composer removeGroup: #leftRow.\r\t\tvis composer removeGroup: #rightRow.\r\t\tvis namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\rvis backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\t\t\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:29',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:31:18.863323+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #redrawNamesAndBackgrounds,			#protocol : #'as yet unclassified',			#sourceCode : 'redrawNamesAndBackgrounds\r(\tnamedGroups isNil or: [ backgroundGroups isNil ]) ifTrue: [ \r\t\tError signal: \'Empty group\' ].\r\tcomposer redrawBackgroundsFor: backgroundGroups.\r\tcomposer redrawNamesFor: namedGroups ',			#stamp : 'YaroslavKormushyn 5/6/2019 21:31',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:31:37.495323+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\t\tvis composer removeGroup: #leftRow.\r\t\tvis composer removeGroup: #rightRow.\r\t\tvis namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\rvis backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\t\t\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:29',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\t\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:31',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:32:17.128323+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\t\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:31',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:32',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:35:41.433323+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleAddition,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleAddition\r\t| col col2 coo coo2 cooanimvis |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcol2 := {{1 . 0 . 0 . 3}.\r\t{0 . 0 . 0 . -1}.\r\t{0 . 0 . 0 . 0}.\r\t{0 . 0 . 1 . 0}}.\r\tcoo := LILSparseMatrix withAll: col.\r\tcoo2 := LILSparseMatrix withAll: col2.\r\t^ coo addAnimated: coo2 delay: 1',			#stamp : 'YaroslavKormushyn 5/6/2019 21:35',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:35:44.999323+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleAddition,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleAddition\r\t| col col2 coo coo2 cooanimvis |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcol2 := {{1 . 0 . 0 . 3}.\r\t{0 . 0 . 0 . -1}.\r\t{0 . 0 . 0 . 0}.\r\t{0 . 0 . 1 . 0}}.\r\tcoo := LILSparseMatrix withAll: col.\r\tcoo2 := LILSparseMatrix withAll: col2.\r\t^ coo addAnimated: coo2 delay: 1',			#stamp : 'YaroslavKormushyn 5/6/2019 21:35',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'LILSparseMatrixOperationVisualizer class',				#isMetaSide : true			},			#name : #exampleAddition,			#protocol : #'as yet unclassified',			#sourceCode : 'exampleAddition\r\t| col col2 coo coo2 |\r\tcol := {{1 . -1 . 0 . 0}.\r\t{0 . 3 . 0 . 0}.\r\t{1 . 0 . 2 . 1}.\r\t{0 . 0 . 0 . 0}}.\r\tcol2 := {{1 . 0 . 0 . 3}.\r\t{0 . 0 . 0 . -1}.\r\t{0 . 0 . 0 . 0}.\r\t{0 . 0 . 1 . 0}}.\r\tcoo := LILSparseMatrix withAll: col.\r\tcoo2 := LILSparseMatrix withAll: col2.\r\t^ coo addAnimated: coo2 delay: 1',			#stamp : 'YaroslavKormushyn 5/6/2019 21:35',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:36:53.570323+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup below: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:32',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightOf: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:36',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:37:20.909323+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightOf: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:36',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:40:57.343323+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:37',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\t\tself halt.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:40',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:47:57.299323+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\t\tself halt.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ (row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:40',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\t\tself halt.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self withEscaper: [:break |\r\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString. break value ] ]].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:47',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:48:26.014323+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'withEscaper:',			#protocol : #'as yet unclassified',			#sourceCode : 'withEscaper: aBlock\r\taBlock value: [ ^ nil ]',			#stamp : 'YaroslavKormushyn 5/6/2019 21:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:48:26.039323+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'withEscaper:',			#protocol : #'as yet unclassified',			#sourceCode : 'withEscaper: aBlock\r\taBlock value: [ ^ nil ]',			#stamp : 'YaroslavKormushyn 5/6/2019 21:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'withEscaper:',			#protocol : #private,			#sourceCode : 'withEscaper: aBlock\r\taBlock value: [ ^ nil ]',			#stamp : 'YaroslavKormushyn 5/6/2019 21:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:48:34.600323+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\t\tself halt.\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self withEscaper: [:break |\r\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\tifFound:\r\t\t\t\t\t\t\t\t\t[ :previousRow | vis composer move: newRowGroup below: #newRow , previousRow asString. break value ] ]].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:47',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:51:47.070323+03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:51',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:53:43.099323+03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer move: newRowGroup below: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:51',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:53',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T21:57:24.654323+03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:53',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\tself halt.\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T22:01:32.573323+03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\tself halt.\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 21:57',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 22:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T22:06:51.393323+03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(row - 1 to: 1)\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 22:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: row - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 22:06',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T22:06:57.048323+03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: row - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 22:06',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer move: #nowProc below: #unionLabel.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer move: #nowProc below: #unionLabel.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup below: #nowProc.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist isEmpty\r\t\t\t\tifFalse: [ | captionLabel |\r\t\t\t\t\trow = 1\r\t\t\t\t\t\tifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]\r\t\t\t\t\t\tifFalse: [ self\r\t\t\t\t\t\t\t\twithEscaper: [ :break | \r\t\t\t\t\t\t\t\t\t(1 to: row - 1) reverse\r\t\t\t\t\t\t\t\t\t\tdetect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]\r\t\t\t\t\t\t\t\t\t\tifFound: [ :previousRow | \r\t\t\t\t\t\t\t\t\t\t\tvis composer\r\t\t\t\t\t\t\t\t\t\t\t\tmove: newRowGroup\r\t\t\t\t\t\t\t\t\t\t\t\tbelow: #newRow , previousRow asString.\r\t\t\t\t\t\t\t\t\t\t\tbreak value ] ] ].\r\t\t\t\t\tcaptionLabel := (RTLabel\r\t\t\t\t\t\ttext: Character arrowLeft asString , \'List for row \' , row asString)\r\t\t\t\t\t\telement.\r\t\t\t\t\tvis add: captionLabel.\r\t\t\t\t\tvis group: #newRow , row asString , #Caption.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tmove: #newRow , row asString , #Caption\r\t\t\t\t\t\tonTheRightOf: newRowGroup ].\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tlist ].\r\tvis composer removeGroup: #leftRow.\r\tvis composer removeGroup: #rightRow.\r\tvis composer removeGroup: #unionLabel.\r\tvis composer removeGroup: #nowProc.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis\r\t\tbackgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).\r\tvis redrawNamesAndBackgrounds.\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\t(vis composer hasGroup: #newRow , rowIndex asString)\r\t\t\tifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.\r\t\t\t\tvis composer removeGroup: #newRow , rowIndex asString , #Caption ].\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 22:06',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T23:38:47.985323+03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex|\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\t\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn:\r\t\t\t{0.\r\t\t\t0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ \r\t\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list inRow: rowIndex withView: vis view.\r\t\t\tvis group: #newRowList.\r\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\t\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex model: { rowIndex . columnIndex }.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftNode.\r\t\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t\t\trightMarkerElement updateModelAndRedraw: (cachedRightColumn at: index).\r\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\tvis deselectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: #newRowList.\r\t\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list inRow: rowIndex withView: vis view.\r\t\t\tvis group: #newRowList.\r\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t\t\tlist ].\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li ].] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 23:38',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-07T00:06:03.047323+03:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex|\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\t\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn:\r\t\t\t{0.\r\t\t\t0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ \r\t\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list inRow: rowIndex withView: vis view.\r\t\t\tvis group: #newRowList.\r\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\t\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex model: { rowIndex . columnIndex }.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftNode.\r\t\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\t\tifFalse: [ \r\t\t\t\t\t\t\t\trightMarkerElement updateModelAndRedraw: (cachedRightColumn at: index).\r\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\tvis deselectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: #newRowList.\r\t\t\t\t\t\tLILSparseMatrixVisualizer onLinkedList: list inRow: rowIndex withView: vis view.\r\t\t\tvis group: #newRowList.\r\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\t\t\tlist ].\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li ].] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 23:38',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aLILSparseMatrix delay: delay\r\t| result other index sum list arr cachedLeftRow cachedRightColumn vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue|\r\tcolumnNumber = aLILSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix sizes\' ].\r\t(aLILSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].\r\tother := aLILSparseMatrix transpose.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aLILSparseMatrix columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: other result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (LILSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5) elementOn: LILSparseMatrixNode new.\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel text: [:value | \'New element value: \', value asString]) elementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis groupToExisting: #labels.\r\tvis update.\r\toperationProcess := [ arr := (1 to: result rowNumber)\r\t\tcollect: [ :rowIndex | \r\t\t\tlist := LinkedList with: LILSparseMatrixNode new.\r\t\t\t(vis composer hasGroup: #newRowList)\r\t\t\t\tifTrue: [ vis composer removeGroup: #newRowList ].\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonLinkedList: list\r\t\t\t\tinRow: rowIndex\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #newRowList.\r\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\tcachedLeftRow := rows at: rowIndex.\r\t\t\t1 to: result columnNumber do: [ :columnIndex | \r\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\tmodel:\r\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\tcachedRightColumn := other rows at: columnIndex.\r\t\t\t\tsum := (cachedLeftRow\r\t\t\t\t\tcollect: [ :leftNode | \r\t\t\t\t\t\tindex := cachedRightColumn\r\t\t\t\t\t\t\tfindFirst: [ :rightNode | rightNode column = leftNode column ].\r\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftNode.\r\t\t\t\t\t\tvis selectModel: leftNode inGroup: #left.\r\t\t\t\t\t\tindex = 0\r\t\t\t\t\t\tifTrue: [ vis deselectModel: leftNode inGroup: #left. nil ]\r\t\t\t\t\t\t\tifFalse: [ rightMarkerElement\r\t\t\t\t\t\t\t\t\tupdateModelAndRedraw: (cachedRightColumn at: index).\r\t\t\t\t\t\t\t\tvis selectModel: (cachedRightColumn at: index) inGroup: #right.\r\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\tvis deselectModel: leftNode inGroup: #left.\r\t\t\t\t\t\t\t\tvis\r\t\t\t\t\t\t\t\t\tdeselectModel: (cachedRightColumn at: index)\r\t\t\t\t\t\t\t\t\tinGroup: #right.\r\t\t\t\t\t\t\t\t\tnewElementValue model: newElementValue model + (leftNode value * (cachedRightColumn at: index) value).\r\t\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\tleftNode value * (cachedRightColumn at: index) value ] ]\r\t\t\t\t\tthenReject: [ :el | el isNil ]) detectSum: [ :each | each ].\r\t\t\t\tsum = 0\r\t\t\t\t\tifFalse: [ list addLast: (LILSparseMatrixNode column: columnIndex value: sum).\r\t\t\t\t\t\tsum := 0.\r\t\t\t\t\t\tvis composer removeGroup: #newRowList.\r\t\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\t\tinRow: rowIndex\r\t\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\t\tvis group: #newRowList.\r\t\t\t\t\t\tvis move: #newRowList above: #nowProcessing.\r\t\t\t\t\t\tnewElementValue model: 0.\r\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\tvis redrawNamesAndBackgrounds.\r\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\tvis delay wait ] ].\r\t\t\tlist ].\r\tarr keysAndValuesDo: [ :i :li | result rows at: i put: li.\r\t\t(vis composer hasGroup: #newRowList) ifTrue: [ vis composer removeGroup: #newRowList ].\r\t\tvis updateResultWith: result.\r\t\tvis composer view canvas focusOnCenterScaled.\r\t\tvis delay wait ] ]\r\t\tnewProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/7/2019 00:06',			#package : #LNU-SparseMatrix		}	}}