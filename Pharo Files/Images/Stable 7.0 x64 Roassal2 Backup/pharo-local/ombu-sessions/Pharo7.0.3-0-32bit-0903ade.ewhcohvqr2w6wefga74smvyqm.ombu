OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T14:59:40.981918+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.1cm4pxvin2ck4z0p9pivkv6x3', '148' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tself halt.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/5/2019 23:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tself halt.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 14:59',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:00:49.720918+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tself halt.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 14:59',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tself halt.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tself halt.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:00',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:07:24.552918+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tself halt.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tself halt.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:00',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tself halt.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tself halt.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:07:33.083918+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tself halt.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tself halt.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:08:28.951918+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink nextLink isNotNil\r\t\t\t\tifTrue: [ elLink next ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/6/2019 00:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink nextLink isNotNil\r\t\t\t\tifTrue: [ elLink nextLink ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/6/2019 15:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:16:44.164918+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:16',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:36:05.313918+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tleftMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\trightMatrixRow := LILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:16',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\tonRow: row\r\t\tin: self\r\t\twithView: vis view.\r\t\t\t\t\tvis group: #leftRow.\r\t\t\t\t\t\r\t\t\t\t\tvis composer removeGroup: #rightRow.\r\t\tLILSparseMatrixVisualizer\r\t\tonRow: row\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\t\rvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:36',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:49:54.972918+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: self\r\t\twithView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\tonRow: row\r\t\tin: self\r\t\twithView: vis view.\r\t\t\t\t\tvis group: #leftRow.\r\t\t\t\t\t\r\t\t\t\t\tvis composer removeGroup: #rightRow.\r\t\tLILSparseMatrixVisualizer\r\t\tonRow: row\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\t\rvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:36',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view."\r\t\t\tvis group: #newRow.\r\t\t\t"vis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:53:11.780918+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view."\r\t\t\tvis group: #newRow.\r\t\t\t"vis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t\tTranscript show: arr asString;cr.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:53',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:53:50.164918+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t\tTranscript show: arr asString;cr.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:53',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tself halt.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:53',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:56:12.849918+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aLILSparseMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: aLILSparseMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: aLILSparseMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (aLILSparseMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tself halt.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:53',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: rightMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tself halt.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:56:50.295918+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer\r\t\tonRow: 1\r\t\tin: rightMatrix\r\t\twithView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tself halt.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\t"LILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow."\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:56',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tself halt.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T15:57:15.161918+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\tself halt.\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:56',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:01:04.118918+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink nextLink isNotNil\r\t\t\t\tifTrue: [ elLink nextLink ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * aNode column ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/6/2019 15:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrixVisualizer,				#isMetaSide : false			},			#name : #'onLinkedList:inRow:',			#protocol : #'instance creation',			#sourceCode : 'onLinkedList: aLinkedList inRow: rowIndex\r\t| elementShape headerShape elements box valueLabel indexLabel headerBox headerValueLabel |\r\telementShape := RTCompositeShape new.\r\tbox := RTBox new\r\t\tcolor: Color blue;\r\t\tsize: elementSize.\r\tvalueLabel := RTLabel new\r\t\ttext: [ :el | \r\t\t\tel value isNil\r\t\t\t\tifTrue: 0\r\t\t\t\tifFalse: [ el value value ] ];\r\t\tcolor: Color white.\r\tindexLabel := RTLabel new\r\t\theight: 5;\r\t\ttext: [ :elLink | \r\t\t\t| col |\r\t\t\tcol := elLink value column.\r\t\t\tcol isNil\r\t\t\t\tifTrue: [ col := 0 ].\r\t\t\trowIndex @ col ];\r\t\tcolor: Color white.\r\telementShape\r\t\tadd: box;\r\t\tadd: valueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\theaderShape := RTCompositeShape new.\r\theaderBox := RTBox new\r\t\tcolor: Color green;\r\t\tsize: elementSize.\r\theaderValueLabel := RTLabel new\r\t\ttext: \'H\';\r\t\tcolor: Color white.\r\theaderShape\r\t\tadd: headerBox;\r\t\tadd: headerValueLabel;\r\t\tadd: indexLabel translateBy: 0 @ 10.\r\telements := RTGroup new\r\t\taddAll:\r\t\t\t(aLinkedList\r\t\t\t\tlinksCollect: [ :elLink | \r\t\t\t\t\telLink value column = 0\r\t\t\t\t\t\tifTrue: [ headerShape elementOn: elLink ]\r\t\t\t\t\t\tifFalse: [ elementShape elementOn: elLink ] ]);\r\t\tyourself.\r\telements @ RTDraggable.\r\telements @ RTPopup.\r\tview addAll: elements.\r\tself\r\t\tdrawEdgesWith: elements\r\t\tconnectTo: [ :elLink | \r\t\t\telLink nextLink isNotNil\r\t\t\t\tifTrue: [ elLink nextLink ] ].\r\tRTGridLayout on: elements.\r\tself\r\t\tsetPositionsFor: elements\r\t\tusing: [ :e | \r\t\t\t| gap |\r\t\t\tgap := 10.\r\t\t\t[ :continue | \r\t\t\t| aNode |\r\t\t\te model value isNil\r\t\t\t\tifTrue: [ continue value ].\r\t\t\taNode := e model value.\r\t\t\te translateTo: (elementSize + gap) * (aNode column @ rowIndex) ] valueWithExit ]',			#stamp : 'YaroslavKormushyn 5/6/2019 16:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:04:19.966918+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'hasGroup:',			#protocol : #accessing,			#sourceCode : 'hasGroup: groupId\r\t"returns whether a group under groupId exists in the mapping"\r\r\t^ mapping includesKey: groupId',			#stamp : 'YaroslavKormushyn 5/6/2019 16:04',			#package : #Roassal2		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:04:30.091918+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'hasGroup:',			#protocol : #accessing,			#sourceCode : 'hasGroup: groupId\r\t"returns whether a group under groupId exists in the mapping"\r\r\t^ mapping includesKey: groupId',			#stamp : 'YaroslavKormushyn 5/6/2019 16:04',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'hasGroup:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'hasGroup: groupId\r\t"returns whether a group under groupId exists in the mapping"\r\r\t^ mapping includesKey: groupId',			#stamp : 'YaroslavKormushyn 5/6/2019 16:04',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:07:08.435918+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tLILSparseMatrixVisualizer onLinkedList: list withView: vis view.\r\t\t\tvis group: #newRow.\r\t\t\tvis composer move: #newRow below: #rightRow.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\tvis composer removeGroup: #newRow.\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow.\r\t\t\t\t\tvis view signalUpdate.\r\t\t\t\t\tvis composer move: #newRow onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 15:57',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: #newRow,row) ifTrue:[\r\t\t\t\t\tvis composer removeGroup: #newRow,row].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow,row.\r\t\t\t\t\tvis composer move: #newRow,row onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow, rowIndex.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:07:56.967918+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: #newRow,row) ifTrue:[\r\t\t\t\t\tvis composer removeGroup: #newRow,row].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow,row.\r\t\t\t\t\tvis composer move: #newRow,row onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow, rowIndex.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: #newRow , row  asSymbol)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRow , row  asSymbol].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow , row asSymbol.\r\t\t\t\t\tvis composer move: #newRow , row asSymbol onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex  asSymbol.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:09:17.624918+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: #newRow , row  asSymbol)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRow , row  asSymbol].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: #newRow , row asSymbol.\r\t\t\t\t\tvis composer move: #newRow , row asSymbol onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex  asSymbol.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t|newRowGroup|\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asSymbol.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRowGroup].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asSymbol.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:09',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:09:53.167918+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t|newRowGroup|\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asSymbol.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRowGroup].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asSymbol.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:09',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:09',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-06T16:10:25.646918+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: #newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:09',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LILSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aLILSparseMatrix delay: delay\r\t| result rightMatrix arr list operationProcess vis leftMatrixRow rightMatrixRow |\r\trowNumber = aLILSparseMatrix rowNumber\r\t\t& (columnNumber = aLILSparseMatrix columnNumber)\r\t\tifFalse: [ Error signal: \'Matrices must be of the same size.\' ].\r\trightMatrix := aLILSparseMatrix copy.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: rightMatrix result: result.\r\toperationProcess := [ | unionLabel nowProcLabel |\r\tunionLabel := (RTLabel text: \'U\') element.\r\tvis add: unionLabel.\r\tvis group: #unionLabel.\r\tLILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.\r\tvis group: #leftRow.\r\tLILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.\r\tvis group: #rightRow.\r\tnowProcLabel := (RTLabel\r\t\ttext: [ :col | \'Processing column \' , col asString ]) elementOn: 0.\r\tvis add: nowProcLabel.\r\tvis group: #nowProc.\r\tvis composer move: #leftRow below: #left.\r\tvis composer move: #rightRow below: #right.\r\tvis composer move: #nowProc below: #rightRow.\r\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\tvis composer nameGroup: #leftRow as: \'leftRow\'.\r\tvis composer nameGroup: #rightRow as: \'rightRow\'.\r\tvis composer groupToExisting: \'labels\'.\r\tvis namedGroups: #(#left #result #right #leftRow #rightRow).\r\tvis backgroundGroups: #(#left #result #right #leftRow #rightRow).\r\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\tvis group: #labels.\r\tvis update.\r\tvis delay wait.\r\tarr := (1 to: result rowNumber)\r\t\tcollect: [ :row | \r\t\t\t| newRowGroup |\r\t\t\tvis composer removeGroup: #leftRow.\r\t\t\tLILSparseMatrixVisualizer onRow: row in: self withView: vis view.\r\t\t\tvis group: #leftRow.\r\t\t\tvis composer removeGroup: #rightRow.\r\t\t\tLILSparseMatrixVisualizer\r\t\t\t\tonRow: row\r\t\t\t\tin: rightMatrix\r\t\t\t\twithView: vis view.\r\t\t\tvis group: #rightRow.\r\t\t\tvis composer move: #leftRow below: #left.\r\t\t\tvis composer move: #rightRow below: #right.\r\t\t\tvis composer move: #nowProc below: #rightRow.\r\t\t\tvis composer move: #unionLabel between: #leftRow and: #rightRow.\r\t\t\tvis composer redrawNamesAndBackgroundsFor: vis namedGroups.\r\t\t\tvis group: #labels.\r\t\t\tarr := (rows at: row) union: (rightMatrix rows at: row).\r\t\t\tarr := (1 to: columnNumber)\r\t\t\t\tcollect: [ :columnIndex | \r\t\t\t\t\tnowProcLabel model: columnIndex.\r\t\t\t\t\tnowProcLabel update.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tdeselectUsing: [ :model | model column = (columnIndex - 1) ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #leftRow.\r\t\t\t\t\tvis composer\r\t\t\t\t\t\tselectUsing: [ :model | model column = columnIndex ]\r\t\t\t\t\t\tinGroup: #rightRow.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tLILSparseMatrixNode\r\t\t\t\t\t\tcolumn: columnIndex\r\t\t\t\t\t\tvalue:\r\t\t\t\t\t\t\t((arr select: [ :node | node column = columnIndex ])\r\t\t\t\t\t\t\t\tinject: 0\r\t\t\t\t\t\t\t\tinto: [ :sum :element | sum + element value ]) ]\r\t\t\t\tthenReject: [ :node | node value = 0 ].\r\t\t\t"last column was not deselected"\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #leftRow.\r\t\t\tvis composer\r\t\t\t\tdeselectUsing: [ :model | model column = columnNumber ]\r\t\t\t\tinGroup: #rightRow.\r\t\t\tnowProcLabel model: \'none\'.\r\t\t\tnowProcLabel update.\r\t\t\tvis delay wait.\r\t\t\tlist := LinkedList new.\r\t\t\tnewRowGroup := #newRow , row asString.\r\t\t\tarr\r\t\t\t\tdo: [ :node | \r\t\t\t\t\tlist addLast: node.\r\t\t\t\t\t(vis composer hasGroup: newRowGroup)\r\t\t\t\t\t\tifTrue: [ vis composer removeGroup: newRowGroup ].\r\t\t\t\t\tLILSparseMatrixVisualizer\r\t\t\t\t\t\tonLinkedList: list\r\t\t\t\t\t\tinRow: row\r\t\t\t\t\t\twithView: vis view.\r\t\t\t\t\tvis group: newRowGroup.\r\t\t\t\t\tvis composer move: newRowGroup onTheRightOf: #rightRow.\r\t\t\t\t\tvis composer redrawNamesFor: vis namedGroups.\r\t\t\t\t\tvis composer redrawBackgroundsFor: vis backgroundGroups.\r\t\t\t\t\tvis delay wait ].\r\t\t\tlist ].\r\t1 to: result rowNumber do: [ :rowIndex | \r\t\tvis composer removeGroup: #newRow , rowIndex asString.\r\t\tresult rows at: rowIndex put: (arr at: rowIndex).\r\t\tvis updateResultWith: result.\r\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/6/2019 16:10',			#package : #LNU-SparseMatrix		}	}}