OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:05.161541+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.6od52x847e50cdsreld25yoa3', '4' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #byMatrix:.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"check what the stack top after copy is - maybe it has the new object which we\'ll use to bind to value: and highlight both elements"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 11:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"check what the stack top after copy is - maybe it has the new object which we\'ll use to bind to value: and highlight both elements"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:29',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.438541+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.490541+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.529541+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.573541+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.664541+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.720541+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 22:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.750541+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.787541+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 22:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.853541+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.891541+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 22:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.942541+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 22:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:11.973541+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 22:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.099541+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.154541+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 22:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.185541+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.224541+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 22:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.323541+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 23:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.371541+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 23:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.401541+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 23:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.446541+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 23:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.548541+03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 23:01',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.603541+03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 23:01',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:29:12.635541+03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 23:01',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:47:14.081541+03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"check what the stack top after copy is - maybe it has the new object which we\'ll use to bind to value: and highlight both elements"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:29',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t|leftMatrixMarkerHightlightLink|\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink metaObject: [ self highlightModel: leftMatrixMarker  . leftMatrixMarkerHightlightLink uninstall].\r\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\tvalue link: leftMatrixMarkerHightlightLink  toMethodNamed: #value:.\r\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:47',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:47:25.042541+03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #'value:',			#protocol : #'as yet unclassified',			#sourceCode : 'value: aValue\r\tvalue := aValue.',			#stamp : 'YaroslavKormusyn 5/5/2019 12:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:51:07.830541+03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t|leftMatrixMarkerHightlightLink|\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink metaObject: [ self highlightModel: leftMatrixMarker  . leftMatrixMarkerHightlightLink uninstall].\r\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\tvalue link: leftMatrixMarkerHightlightLink  toMethodNamed: #value:.\r\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:47',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:51',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:52:05.361541+03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/5/2019 12:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:57:37.860541+03:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:51',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript show: \'highlight left \', (leftMatrixMarker row @ leftMatrixMarker column) asString;cr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:58:53.647541+03:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript show: \'highlight left \', (leftMatrixMarker row @ leftMatrixMarker column) asString;cr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:57',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight left \', (element row @ element column) asString;cr.\r\t\t\t\t\t\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript show: \'select left \', (element row @ element column) asString;cr.\r\t\t\t\t\t\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight right \', (element row @ element column) asString;cr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript show: \'select right \', (element row @ element column) asString;cr.\r\t\t\t\t\t\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:59:03.450541+03:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/5/2019 12:58',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T13:04:38.503541+03:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight left \', (element row @ element column) asString;cr.\r\t\t\t\t\t\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript show: \'select left \', (element row @ element column) asString;cr.\r\t\t\t\t\t\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight right \', (element row @ element column) asString;cr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript show: \'select right \', (element row @ element column) asString;cr.\r\t\t\t\t\t\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 12:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:04',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T13:07:27.343541+03:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\tvalue link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:04',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\telementCopy link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T13:11:05.585541+03:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t"value is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\telementCopy link: leftMatrixMarkerHightlightLink toMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t"elementCopy is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\telementCopy\r\t\t\t\t\t\tlink: leftMatrixMarkerHightlightLink\r\t\t\t\t\t\ttoMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T13:15:08.206541+03:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t"elementCopy is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: leftMatrixMarker.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\telementCopy\r\t\t\t\t\t\tlink: leftMatrixMarkerHightlightLink\r\t\t\t\t\t\ttoMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:11',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #left] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #right ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t"elementCopy is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ \r\t\t\t\t\t\t\t"the link is set to right only according to the method code"\r\t\t\t\t\t\t\t"left is never the object which is copied in this situation"\r\t\t\t\t\t\t\tself highlightModel: leftMatrixMarker inGroup: #left.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\telementCopy\r\t\t\t\t\t\tlink: leftMatrixMarkerHightlightLink\r\t\t\t\t\t\ttoMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:15',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T13:15:13.380541+03:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #left] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #right ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t"elementCopy is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ \r\t\t\t\t\t\t\t"the link is set to right only according to the method code"\r\t\t\t\t\t\t\t"left is never the object which is copied in this situation"\r\t\t\t\t\t\t\tself highlightModel: leftMatrixMarker inGroup: #left.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\telementCopy\r\t\t\t\t\t\tlink: leftMatrixMarkerHightlightLink\r\t\t\t\t\t\ttoMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:15',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #+.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #left ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #left.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value inGroup: #right ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :elementCopy | \r\t\t\t\t\t"elementCopy is the copied object which we use to set a link to value:"\r\t\t\t\t\t"with that we know if it\'s selecting left and right markers or only one of them"\r\t\t\t\t\t| leftMatrixMarkerHightlightLink |\r\t\t\t\t\tleftMatrixMarkerHightlightLink := MetaLink new.\r\t\t\t\t\tleftMatrixMarkerHightlightLink\r\t\t\t\t\t\tmetaObject: [ "the link is set to right only according to the method code"\r\t\t\t\t\t\t\t"left is never the object which is copied in this situation"\r\t\t\t\t\t\t\tself highlightModel: leftMatrixMarker inGroup: #left.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\t\t\'highlight left \'\r\t\t\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait\r\t\t\t\t\t\t\t"leftMatrixMarkerHightlightLink uninstall" ].\r\t\t\t\t\tleftMatrixMarkerHightlightLink selector: #value.\r\t\t\t\t\tleftMatrixMarkerHightlightLink control: #after.\r\t\t\t\t\telementCopy\r\t\t\t\t\t\tlink: leftMatrixMarkerHightlightLink\r\t\t\t\t\t\ttoMethodNamed: #value:.\r\t\t\t\t\t"highlight the right marker and uninstall itself after first use"\r\t\t\t\t\tself highlightModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\t"add to metaLinks in case it won\'t run to uninstall after animation ends"\r\t\t\t\t\tmetaLinks add: leftMatrixMarkerHightlightLink.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element inGroup: #right.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 13:15',			#package : #LNU-SparseMatrix		}	}}