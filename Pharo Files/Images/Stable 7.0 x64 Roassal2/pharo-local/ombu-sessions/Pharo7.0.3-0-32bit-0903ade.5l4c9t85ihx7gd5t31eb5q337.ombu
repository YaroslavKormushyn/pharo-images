OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T22:53:18.230683+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.ay6k7px3rnwbwg6pmg7k4w6dh', '244' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\tleftMatrix := left.\r\trightMatrix := right.\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\tself setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait.\r\tself setLinksForMultiplicationOn: leftMatrix.\r\tself initializeMultiplicationView.\r\tself setMultiInitLinksOn2: leftMatrix.\r\tprocess resume.\r\tsemaphore wait.\r\t\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/1/2019 23:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r"remember matrices for reference in links"\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\tself setMultiInitLinksOn2: leftMatrix.\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/3/2019 22:53',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:02:00.169683+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawNamesFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawNamesFor: groupNames\r\tself removeAllNames.\r\tgroupNames do: [ :name | self nameGroup: name as: name asString ].\r\tself groupToExisting: #labels.',			#stamp : 'YaroslavKormusyn 4/30/2019 18:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawNamesFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawNamesFor: groupNames\r\tself removeAllNames.\r\tgroupNames do: [ :name | self nameGroup: name as: name asString ].\r\tself group: #labels',			#stamp : 'YaroslavKormusyn 5/3/2019 23:02',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:20:38.131683+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawNamesFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawNamesFor: groupNames\r\tself removeAllNames.\r\tgroupNames do: [ :name | self nameGroup: name as: name asString ].\r\tself group: #labels',			#stamp : 'YaroslavKormusyn 5/3/2019 23:02',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawNamesFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawNamesFor: groupNames\r\tself removeAllNames.\r\tgroupNames do: [ :name | self nameGroup: name as: name asString ].\r\tself groupToExisting: #labels',			#stamp : 'YaroslavKormusyn 5/3/2019 23:20',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:10.485683+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawBackgroundsFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawBackgroundsFor: groupNames\r\tself removeAllBackgrounds.\r\tgroupNames\r\t\tdo:\r\t\t\t[ :name | self setBackgroundColor: (Color gray alpha: 0.2) forGroup: name ].\r\t\tself groupToExisting: #labels.',			#stamp : 'YaroslavKormusyn 4/30/2019 19:09',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawBackgroundsFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawBackgroundsFor: groupNames\r\tself removeAllBackgrounds.\r\tgroupNames\r\t\tdo:\r\t\t\t[ :name | self setBackgroundColor: (Color gray alpha: 0.2) forGroup: name ].\r\t\t(mapping includesKey: #labels)\r\t\tifTrue: [ self groupToExisting: #labels ]\r\t\tifFalse: [ self group: #labels ]\r\t',			#stamp : 'YaroslavKormusyn 5/3/2019 23:28',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:16.230683+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawNamesFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawNamesFor: groupNames\r\tself removeAllNames.\r\tgroupNames do: [ :name | self nameGroup: name as: name asString ].\r\tself groupToExisting: #labels',			#stamp : 'YaroslavKormusyn 5/3/2019 23:20',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'redrawNamesFor:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'redrawNamesFor: groupNames\r\tself removeAllNames.\r\tgroupNames do: [ :name | self nameGroup: name as: name asString ].\r\t(mapping includesKey: #labels)\r\t\tifTrue: [ self groupToExisting: #labels ]\r\t\tifFalse: [ self group: #labels ]',			#stamp : 'YaroslavKormusyn 5/3/2019 23:28',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.104683+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.150683+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.193683+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.226683+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.259683+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.295683+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.331683+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.367683+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.404683+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.449683+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/1/2019 23:35',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.555683+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/1/2019 23:43',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.594683+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/1/2019 23:43',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.629683+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:43',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.720683+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.761683+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.793683+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.823683+03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.883683+03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/1/2019 23:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:26.976683+03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:31',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.022683+03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:31',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.065683+03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:31',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.096683+03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:31',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.168683+03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/3/2019 21:31',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.252683+03:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.300683+03:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.332683+03:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.363683+03:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 21:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.489683+03:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.523683+03:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:28:27.553683+03:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:44:09.361683+03:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkInit := MetaLink new.\r\tleftMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\tleftMatrixMarker := value.\r\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker.\r\t\t\tleftMarkerLinkInit uninstall ].\r\tleftMarkerLinkInit selector: #value:.\r\tleftMarkerLinkInit arguments: #(value).\r\tleftMarkerLinkInit control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkInit\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkInit := MetaLink new.\r\trightMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker.\r\t\t\trightMarkerLinkInit uninstall ].\r\trightMarkerLinkInit selector: #value:.\r\trightMarkerLinkInit arguments: #(value).\r\trightMarkerLinkInit control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkInit\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tself selectModel: value.\r\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tself selectModel: value.\r\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/1/2019 23:43',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkInit := MetaLink new.\r\tleftMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\t].\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\t\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tleftMatrixMarker := value.\r\t\t\tleftMarkerElement isNil \r\t\t\tifTrue: [leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker]\r\t\t\tifFalse: [self selectModel: value.\r\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\tdelay wait]\r\t\t\t\r\t\t\t ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\t\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkInit := MetaLink new.\r\trightMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker.\r\t\t\trightMarkerLinkInit uninstall ].\r\trightMarkerLinkInit selector: #value:.\r\trightMarkerLinkInit arguments: #(value).\r\trightMarkerLinkInit control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkInit\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t\r\t\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tself selectModel: value.\r\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:44',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:44:45.183683+03:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkInit := MetaLink new.\r\tleftMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\t].\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\t\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tleftMatrixMarker := value.\r\t\t\tleftMarkerElement isNil \r\t\t\tifTrue: [leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker]\r\t\t\tifFalse: [self selectModel: value.\r\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\tdelay wait]\r\t\t\t\r\t\t\t ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\t\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkInit := MetaLink new.\r\trightMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker.\r\t\t\trightMarkerLinkInit uninstall ].\r\trightMarkerLinkInit selector: #value:.\r\trightMarkerLinkInit arguments: #(value).\r\trightMarkerLinkInit control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkInit\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t\r\t\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tself selectModel: value.\r\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:44',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkInit := MetaLink new.\r\tleftMarkerLinkInit metaObject: [ :value |  ].\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tleftMatrixMarker := value.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkInit := MetaLink new.\r\trightMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker.\r\t\t\trightMarkerLinkInit uninstall ].\r\trightMarkerLinkInit selector: #value:.\r\trightMarkerLinkInit arguments: #(value).\r\trightMarkerLinkInit control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkInit\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tself selectModel: value.\r\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:44',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:46:43.085683+03:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkInit := MetaLink new.\r\tleftMarkerLinkInit metaObject: [ :value |  ].\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tleftMatrixMarker := value.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkInit := MetaLink new.\r\trightMarkerLinkInit\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker.\r\t\t\trightMarkerLinkInit uninstall ].\r\trightMarkerLinkInit selector: #value:.\r\trightMarkerLinkInit arguments: #(value).\r\trightMarkerLinkInit control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkInit\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tself selectModel: value.\r\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:44',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkInit := MetaLink new.\r\tleftMarkerLinkInit metaObject: [ :value |  ].\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tleftMatrixMarker := value.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement isNil\r\t\t\tifTrue: [rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker. ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait]\r\t\t\t ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:46',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:53:09.245683+03:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkInit := MetaLink new.\r\tleftMarkerLinkInit metaObject: [ :value |  ].\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\tleftMatrixMarker := value.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement isNil\r\t\t\tifTrue: [rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker. ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\tdelay wait]\r\t\t\t ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:46',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t|leftMarkerHighlightLink|\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\tleftMarkerHighlightLink\r\t\tmetaObject: [ :element | \r\t\t\tself highlightModel: element.\r\t\t\tdelay wait ].\r\tleftMarkerHighlightLink selector: #value:.\r\tleftMarkerHighlightLink arguments: #(value).\r\tleftMarkerHighlightLink control: #after.\r\tleftMatrixMarker\r\t\tlink: leftMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:53',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:54:50.673683+03:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t|leftMarkerHighlightLink|\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\tleftMarkerHighlightLink\r\t\tmetaObject: [ :element | \r\t\t\tself highlightModel: element.\r\t\t\tdelay wait ].\r\tleftMarkerHighlightLink selector: #value:.\r\tleftMarkerHighlightLink arguments: #(value).\r\tleftMarkerHighlightLink control: #after.\r\tleftMatrixMarker\r\t\tlink: leftMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\trightMatrixMarker := value.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:53',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t|rightMarkerHighlightLink|\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\trightMarkerHighlightLink\r\t\tmetaObject: [ :element | \r\t\t\tself highlightModel: element.\r\t\t\tdelay wait ].\r\trightMarkerHighlightLink selector: #value:.\r\trightMarkerHighlightLink arguments: #(value).\r\trightMarkerHighlightLink control: #after.\r\trightMatrixMarker\r\t\tlink: rightMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:54',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-03T23:59:46.207683+03:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\tresultMatrix := value.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t|rightMarkerHighlightLink|\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\trightMarkerHighlightLink\r\t\tmetaObject: [ :element | \r\t\t\tself highlightModel: element.\r\t\t\tdelay wait ].\r\trightMarkerHighlightLink selector: #value:.\r\trightMarkerHighlightLink arguments: #(value).\r\trightMarkerHighlightLink control: #after.\r\trightMatrixMarker\r\t\tlink: rightMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:54',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t|resultMatrixUpdateLinkLast|\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\tresultMatrixUpdateLinkLast\r\t\tmetaObject: [ :result | \r\t\t\tself updateResultWith: result.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\tcr.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixUpdateLinkLast selector: #value:.\r\tresultMatrixUpdateLinkLast arguments: #(value).\r\tresultMatrixUpdateLinkLast control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkLast\r\t\ttoSlotNamed: #last\r\t\toption: #write\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:59',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:00:00.337683+03:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t|resultMatrixUpdateLinkLast|\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\tresultMatrixUpdateLinkLast\r\t\tmetaObject: [ :result | \r\t\t\tself updateResultWith: result.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\tcr.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixUpdateLinkLast selector: #value:.\r\tresultMatrixUpdateLinkLast arguments: #(value).\r\tresultMatrixUpdateLinkLast control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkLast\r\t\ttoSlotNamed: #last\r\t\toption: #write\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/3/2019 23:59',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\t\t semaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:00',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:00:15.844683+03:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r"remember matrices for reference in links"\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\tself setMultiInitLinksOn2: leftMatrix.\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/3/2019 22:53',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 00:00',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:01:31.835683+03:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\t\t semaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:00',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\tresultMatrixUpdateLinkFirst\r\t\tmetaObject: [ :result | \r\t\t\tself updateResultWith: result.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated first in result\';\r\t\t\t\tcr ].\r\tresultMatrixUpdateLinkFirst selector: #value:.\r\tresultMatrixUpdateLinkFirst arguments: #(value).\r\tresultMatrixUpdateLinkFirst control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkFirst\r\t\ttoSlotNamed: #first\r\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:01:49.646683+03:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForMultiplicationOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForMultiplicationOn: matrixInstance\r\t| leftMarkerHighlightLink rightMarkerHighlightLink resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\tleftMarkerHighlightLink := MetaLink new.\r\tleftMarkerHighlightLink\r\t\tmetaObject: [ :value | \r\t\t\tself highlightModel: value.\r\t\t\tdelay wait ].\r\tleftMarkerHighlightLink selector: #value:.\r\tleftMarkerHighlightLink arguments: #(value).\r\tleftMarkerHighlightLink control: #after.\r\trightMarkerHighlightLink := MetaLink new.\r\trightMarkerHighlightLink\r\t\tmetaObject: [ :value | \r\t\t\tself highlightModel: value.\r\t\t\tdelay wait ].\r\trightMarkerHighlightLink selector: #value:.\r\trightMarkerHighlightLink arguments: #(value).\r\trightMarkerHighlightLink control: #after.\r\tleftMatrixMarker\r\t\tlink: leftMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\trightMatrixMarker\r\t\tlink: rightMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\tresultMatrixUpdateLinkFirst := MetaLink new.\r\tresultMatrixUpdateLinkFirst\r\t\tmetaObject: [ :value | self updateResultWith: value. Transcript show: \'updated first in result\';cr ].\r\tresultMatrixUpdateLinkFirst selector: #value:.\r\tresultMatrixUpdateLinkFirst arguments: #(value).\r\tresultMatrixUpdateLinkFirst control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkFirst\r\t\ttoSlotNamed: #first\r\t\toption: #write.\r\tresultMatrixUpdateLinkLast := MetaLink new.\r\tresultMatrixUpdateLinkLast\r\t\tmetaObject: [ :value | self updateResultWith: value. Transcript show: \'updated last in result\';cr ].\r\tresultMatrixUpdateLinkLast selector: #value:.\r\tresultMatrixUpdateLinkLast arguments: #(value).\r\tresultMatrixUpdateLinkLast control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkLast\r\t\ttoSlotNamed: #last\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/1/2019 23:28',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForMultiplicationOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForMultiplicationOn: matrixInstance\r\t| leftMarkerHighlightLink rightMarkerHighlightLink resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\tleftMarkerHighlightLink := MetaLink new.\r\tleftMarkerHighlightLink\r\t\tmetaObject: [ :value | \r\t\t\tself highlightModel: value.\r\t\t\tdelay wait ].\r\tleftMarkerHighlightLink selector: #value:.\r\tleftMarkerHighlightLink arguments: #(value).\r\tleftMarkerHighlightLink control: #after.\r\trightMarkerHighlightLink := MetaLink new.\r\trightMarkerHighlightLink\r\t\tmetaObject: [ :value | \r\t\t\tself highlightModel: value.\r\t\t\tdelay wait ].\r\trightMarkerHighlightLink selector: #value:.\r\trightMarkerHighlightLink arguments: #(value).\r\trightMarkerHighlightLink control: #after.\r\tleftMatrixMarker\r\t\tlink: leftMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\trightMatrixMarker\r\t\tlink: rightMarkerHighlightLink\r\t\ttoSlotNamed: #value\r\t\toption: #read.\r\tresultMatrixUpdateLinkFirst := MetaLink new.\r\tresultMatrixUpdateLinkFirst\r\t\tmetaObject: [ :value | \r\t\t\tself updateResultWith: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated first in result\';\r\t\t\t\tcr ].\r\tresultMatrixUpdateLinkFirst selector: #value:.\r\tresultMatrixUpdateLinkFirst arguments: #(value).\r\tresultMatrixUpdateLinkFirst control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkFirst\r\t\ttoSlotNamed: #first\r\t\toption: #write.\r\tresultMatrixUpdateLinkLast := MetaLink new.\r\tresultMatrixUpdateLinkLast\r\t\tmetaObject: [ :value | \r\t\t\tself updateResultWith: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated last in result\';\r\t\t\t\tcr ].\r\tresultMatrixUpdateLinkLast selector: #value:.\r\tresultMatrixUpdateLinkLast arguments: #(value).\r\tresultMatrixUpdateLinkLast control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkLast\r\t\ttoSlotNamed: #last\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 00:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:04.426683+03:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 00:00',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:20.749683+03:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/3/2019 23:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:20.788683+03:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:20.821683+03:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:20.865683+03:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:20.901683+03:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.019683+03:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:46',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.056683+03:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:46',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.088683+03:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:46',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.129683+03:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:46',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.234683+03:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:54',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.338683+03:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.374683+03:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.405683+03:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.436683+03:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.468683+03:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.503683+03:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:02:21.533683+03:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/3/2019 23:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:03:41.744683+03:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\tresultMatrixUpdateLinkFirst\r\t\tmetaObject: [ :result | \r\t\t\tself updateResultWith: result.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated first in result\';\r\t\t\t\tcr ].\r\tresultMatrixUpdateLinkFirst selector: #value:.\r\tresultMatrixUpdateLinkFirst arguments: #(value).\r\tresultMatrixUpdateLinkFirst control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkFirst\r\t\ttoSlotNamed: #first\r\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | leftMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:08:50.094683+03:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink metaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:03',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself halt.\r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:11:05.097683+03:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself halt.\r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:11:45.098683+03:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeView,			#protocol : #initialization,			#sourceCode : 'initializeView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\t',			#stamp : 'YaroslavKormusyn 5/1/2019 23:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeView,			#protocol : #'as yet unclassified',			#sourceCode : 'initializeView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\t',			#stamp : 'YaroslavKormusyn 5/1/2019 23:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:11:45.154683+03:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeView,			#protocol : #initialization,			#sourceCode : 'initializeView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\t',			#stamp : 'YaroslavKormusyn 5/1/2019 23:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:11:54.929683+03:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeView,			#protocol : #initialization,			#sourceCode : 'initializeView\r\tself subclassResponsibility ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeView,			#protocol : #'as yet unclassified',			#sourceCode : 'initializeView\r\tself subclassResponsibility ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:11:54.946683+03:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeView,			#protocol : #initialization,			#sourceCode : 'initializeView\r\tself subclassResponsibility ',			#stamp : 'YaroslavKormusyn 5/1/2019 23:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:15:51.757683+03:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn2:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn2: matrixInstance\r|resultMatrixUpdateLinkLast|\r"set a one-time metalink to update the result view and uninstall itself"\r\tresultMatrixUpdateLinkLast := MetaLink new.\r\tresultMatrixUpdateLinkLast\r\t\tmetaObject: [ :value | \r\t\t\tself updateResultWith: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated last in result\';\r\t\t\t\tcr.\r\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixUpdateLinkLast selector: #value:.\r\tresultMatrixUpdateLinkLast arguments: #(value).\r\tresultMatrixUpdateLinkLast control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkLast\r\t\ttoSlotNamed: #last\r\t\toption: #write.\r\t',			#stamp : 'YaroslavKormusyn 5/1/2019 23:43',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn2:',			#protocol : #'as yet unclassified',			#sourceCode : 'setMultiInitLinksOn2: matrixInstance\r|resultMatrixUpdateLinkLast|\r"set a one-time metalink to update the result view and uninstall itself"\r\tresultMatrixUpdateLinkLast := MetaLink new.\r\tresultMatrixUpdateLinkLast\r\t\tmetaObject: [ :value | \r\t\t\tself updateResultWith: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated last in result\';\r\t\t\t\tcr.\r\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixUpdateLinkLast selector: #value:.\r\tresultMatrixUpdateLinkLast arguments: #(value).\r\tresultMatrixUpdateLinkLast control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkLast\r\t\ttoSlotNamed: #last\r\t\toption: #write.\r\t',			#stamp : 'YaroslavKormusyn 5/1/2019 23:43',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:15:51.764683+03:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn2:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn2: matrixInstance\r|resultMatrixUpdateLinkLast|\r"set a one-time metalink to update the result view and uninstall itself"\r\tresultMatrixUpdateLinkLast := MetaLink new.\r\tresultMatrixUpdateLinkLast\r\t\tmetaObject: [ :value | \r\t\t\tself updateResultWith: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'updated last in result\';\r\t\t\t\tcr.\r\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixUpdateLinkLast selector: #value:.\r\tresultMatrixUpdateLinkLast arguments: #(value).\r\tresultMatrixUpdateLinkLast control: #after.\r\tresultMatrix\r\t\tlink: resultMatrixUpdateLinkLast\r\t\ttoSlotNamed: #last\r\t\toption: #write.\r\t',			#stamp : 'YaroslavKormusyn 5/1/2019 23:43',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T00:21:02.159683+03:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tresultMatrix\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tleftMatrixMarker\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\trightMatrixMarker\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:11',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:21',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:13:25.320683+03:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 00:21',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:13',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:15:11.719683+03:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:13',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:15',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:20:45.037683+03:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRenameTemporaryRefactoring renameTemporaryFrom: (1676 to: 1699) to: \'transposedRightMatrixLink\' in: COOSparseMatrixOperationVisualizer selector: #setMultiInitLinksOn:)'	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ],		#time : DateAndTime [ '2019-05-04T10:20:45.086683+03:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedLeftMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedLeftMatrixLink := MetaLink new.\r\ttransposedLeftMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedLeftMatrixLink selector: #value:.\r\ttransposedLeftMatrixLink arguments: #(value).\r\ttransposedLeftMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedLeftMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedLeftMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:15',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:20',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:38:34.638683+03:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual link to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:20',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\t\t"select the element and update the view otherwise"\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:38',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:38:41.841683+03:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\t\t"select the element and update the view otherwise"\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:38',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: ["select the element and update the view otherwise" self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:38',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:43:27.671683+03:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: ["select the element and update the view otherwise" self selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:38',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight left \', (element row @ element column); cr. \r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight right \', (element row @ element column); cr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:43',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:45:58.462683+03:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight left \', (element row @ element column); cr. \r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :element | \r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\tTranscript show: \'highlight right \', (element row @ element column); cr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:43',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:45',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:48:20.674683+03:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value:.\r\t\t\tleftMarkerHighlightLink arguments: #(value).\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:45',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:48',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:02.287683+03:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column);\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.339683+03:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.382683+03:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.415683+03:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.455683+03:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.494683+03:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.527683+03:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.556683+03:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.643683+03:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.698683+03:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.731683+03:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.779683+03:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.813683+03:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 00:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.889683+03:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.921683+03:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.953683+03:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:13.985683+03:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.020683+03:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.057683+03:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.093683+03:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.130683+03:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.193683+03:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.222683+03:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.259683+03:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.296683+03:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.330683+03:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.361683+03:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 00:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.447683+03:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.497683+03:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.528683+03:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.559683+03:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.609683+03:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 00:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.640683+03:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 00:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.679683+03:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.710683+03:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.759683+03:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.807683+03:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.855683+03:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.893683+03:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.924683+03:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:14.999683+03:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:21',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.030683+03:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:21',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.075683+03:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:21',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.109683+03:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 00:21',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.140683+03:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 00:21',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.178683+03:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.231683+03:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.267683+03:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.305683+03:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.336683+03:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.366683+03:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.397683+03:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.426683+03:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 00:25',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.504683+03:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:43',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.556683+03:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:43',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.636683+03:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.670683+03:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.754683+03:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:48',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:49:15.807683+03:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:48',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:54:01.443683+03:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value.Transcript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr. ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value.Transcript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr. ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:54',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:55:49.822683+03:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 00:02',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\t[self setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.] on: Error do: [ semaphore signal. ]\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:55',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:56:22.265683+03:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\t[self setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\tprocess resume.\r\tsemaphore wait.] on: Error do: [ semaphore signal. ]\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:55',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\t self setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[process resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" "self setLinksForMultiplicationOn: leftMatrix." "initialize the view" semaphore signal ]\r\t\t\t\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:57:05.292683+03:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\t self setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[process resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" "self setLinksForMultiplicationOn: leftMatrix." "initialize the view" semaphore signal ]\r\t\t\t\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:56',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ process resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" "self setLinksForMultiplicationOn: leftMatrix." "initialize the view" semaphore signal ].\r\t\t\t\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:57:12.439683+03:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\tself setMultiInitLinksOn: leftMatrix.\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ process resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" "self setLinksForMultiplicationOn: leftMatrix." "initialize the view" semaphore signal ].\r\t\t\t\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:57',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\t\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.process resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" "self setLinksForMultiplicationOn: leftMatrix." "initialize the view" semaphore signal ].\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:58:26.400683+03:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\t\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.process resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" "self setLinksForMultiplicationOn: leftMatrix." "initialize the view" semaphore signal ].\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:57',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" semaphore signal ].\r\t\t self setLinksForMultiplicationOn: leftMatrix. "initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:58:30.088683+03:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo:\r\t\t\t[ "set the rest of links" semaphore signal ].\r\t\t self setLinksForMultiplicationOn: leftMatrix. "initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo: [ "set the rest of links" semaphore signal ].\r\tself setLinksForMultiplicationOn: leftMatrix.\t\r\t\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:58:37.209683+03:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo: [ "set the rest of links" semaphore signal ].\r\tself setLinksForMultiplicationOn: leftMatrix.\t\r\t\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo: [ semaphore signal ].\r\t "set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T10:59:24.570683+03:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ]\r\t\ton: Error\r\t\tdo: [ semaphore signal ].\r\t "set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume. ]\r\t\ton: Error\r\t\tdo: [ semaphore signal. ].\r\t\t\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:59',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:01:28.538683+03:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume. ]\r\t\ton: Error\r\t\tdo: [ semaphore signal. ].\r\t\t\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 10:59',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\r\t\ton: Error\r\t\tdo: [:exception | semaphore signal. ^ exception ].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:01:41.189683+03:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\r\t\ton: Error\r\t\tdo: [:exception | semaphore signal. ^ exception ].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\r\t\ton: Error\r\t\tdo: [ :exception | \r\t\t\tsemaphore signal.\r\t\t\t^ Error signal: exception ].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:07:22.096683+03:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\r\t\ton: Error\r\t\tdo: [ :exception | \r\t\t\tsemaphore signal.\r\t\t\t^ Error signal: exception ].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\r\t\tensure: [semaphore signal].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:08:34.875683+03:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value.Transcript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr. ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | self deselectModel: value.Transcript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr. ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 10:54',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil ifTrue: [self deselectModel: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\tcr] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil ifTrue: [self deselectModel: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\tcr] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:11:33.383683+03:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\r\t\tensure: [semaphore signal].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\ron: Error\r\t\tfork: [ semaphore signal ].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:11',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:13:42.630683+03:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value:.\r\t\t\tresultMatrixUpdateLinkFirst arguments: #(value).\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ :result | \r\t\t\t\t\tself updateResultWith: result.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value:.\r\t\t\tresultMatrixUpdateLinkLast arguments: #(value).\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil ifTrue: [self deselectModel: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\tcr] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil ifTrue: [self deselectModel: value.\r\t\t\tTranscript\r\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\tcr] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\t"resultMatrixUpdateLinkFirst arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:13',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:36:12.040683+03:00' ],		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ]\ron: Error\r\t\tfork: [ semaphore signal ].\r\tsemaphore wait.\r\t"set the rest of links"\r\tself setLinksForMultiplicationOn: leftMatrix.\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:11',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ semaphore signal ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:50:59.900683+03:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ semaphore signal ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\tprocess resume.\r\tsemaphore wait.\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ semaphore signal ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:52:39.758683+03:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\t"resultMatrixUpdateLinkFirst arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:13',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\t"resultMatrixUpdateLinkFirst arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr. ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T11:56:56.328683+03:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\t"resultMatrixUpdateLinkFirst arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr. ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\t"resultMatrixUpdateLinkFirst arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ \r\t\t\t\t\t|newResultUpdateLastLink|\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend.\r\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\tnewResultUpdateLastLink\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr].\r\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\t ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write. ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:22:00.111683+03:00' ],		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\t"resultMatrixUpdateLinkFirst arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ \r\t\t\t\t\t|newResultUpdateLastLink|\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\r\t\t\tsemaphore signal.\r\t\t\tprocess suspend.\r\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\tnewResultUpdateLastLink\r\t\t\t\tmetaObject: [ \r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr].\r\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write.\r\t\t\t ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write. ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := value.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: value ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :value | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := value.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\tvalue\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: value ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 11:56',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:23:30.974683+03:00' ],		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ semaphore signal ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 11:50',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ :ex | Error signal ex ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:23:33.915683+03:00' ],		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ :ex | Error signal ex ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ :ex | Error signal: ex ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:24:00.691683+03:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume ] on: Error fork: [ :ex | Error signal: ex ].\r\tsemaphore wait.\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.semaphore wait. ] on: Error fork: [ :ex | Error signal: ex ].\r\t\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:27:56.796683+03:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\t\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend. ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:27',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:30:03.503683+03:00' ],		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\t\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend. ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:30:26.307683+03:00' ],		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.semaphore wait. ] on: Error fork: [ :ex | Error signal: ex ].\r\t\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\tself initializeMultiplicationView.\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\t"self initializeMultiplicationView."\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:30:36.775683+03:00' ],		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:41:34.329683+03:00' ],		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:41:46.833683+03:00' ],		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\t"self initializeMultiplicationView."\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\tself setPositionsForMultiplication.\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\t"self initializeMultiplicationView."\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\t"self setPositionsForMultiplication."\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:41:57.477683+03:00' ],		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:47:07.875683+03:00' ],		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\telement isNotNil ifTrue: [leftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.].\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\telement isNotNil ifTrue: [rightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.].\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:47',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T12:59:16.513683+03:00' ],		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"bind the actual element to the highlight"\r\t\t\telement isNotNil ifTrue: [leftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.].\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: leftMatrixMarker ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\telement isNotNil ifTrue: [rightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t"rightMarkerHighlightLink arguments: #(value)."\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read.].\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: rightMatrixMarker ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:47',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ].\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ].\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:59',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:00:20.685683+03:00' ],		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:02:22.477683+03:00' ],		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.337683+03:00' ],		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.388683+03:00' ],		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.423683+03:00' ],		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.461683+03:00' ],		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.493683+03:00' ],		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.529683+03:00' ],		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 10:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.571683+03:00' ],		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.604683+03:00' ],		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.641683+03:00' ],		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.679683+03:00' ],		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.714683+03:00' ],		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.752683+03:00' ],		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.784683+03:00' ],		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:20.815683+03:00' ],		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 10:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.131683+03:00' ],		#prior : OmReference [ '189' ],		#self : OmReference [ '190' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 11:07',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.213683+03:00' ],		#prior : OmReference [ '190' ],		#self : OmReference [ '191' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.247683+03:00' ],		#prior : OmReference [ '191' ],		#self : OmReference [ '192' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.278683+03:00' ],		#prior : OmReference [ '192' ],		#self : OmReference [ '193' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.309683+03:00' ],		#prior : OmReference [ '193' ],		#self : OmReference [ '194' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.340683+03:00' ],		#prior : OmReference [ '194' ],		#self : OmReference [ '195' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.385683+03:00' ],		#prior : OmReference [ '195' ],		#self : OmReference [ '196' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.496683+03:00' ],		#prior : OmReference [ '196' ],		#self : OmReference [ '197' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:11',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.557683+03:00' ],		#prior : OmReference [ '197' ],		#self : OmReference [ '198' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:11',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.684683+03:00' ],		#prior : OmReference [ '198' ],		#self : OmReference [ '199' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:12',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.844683+03:00' ],		#prior : OmReference [ '199' ],		#self : OmReference [ '200' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 11:32',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.889683+03:00' ],		#prior : OmReference [ '200' ],		#self : OmReference [ '201' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.919683+03:00' ],		#prior : OmReference [ '201' ],		#self : OmReference [ '202' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.953683+03:00' ],		#prior : OmReference [ '202' ],		#self : OmReference [ '203' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:21.984683+03:00' ],		#prior : OmReference [ '203' ],		#self : OmReference [ '204' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.016683+03:00' ],		#prior : OmReference [ '204' ],		#self : OmReference [ '205' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.046683+03:00' ],		#prior : OmReference [ '205' ],		#self : OmReference [ '206' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.076683+03:00' ],		#prior : OmReference [ '206' ],		#self : OmReference [ '207' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.108683+03:00' ],		#prior : OmReference [ '207' ],		#self : OmReference [ '208' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.245683+03:00' ],		#prior : OmReference [ '208' ],		#self : OmReference [ '209' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 11:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.338683+03:00' ],		#prior : OmReference [ '209' ],		#self : OmReference [ '210' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.398683+03:00' ],		#prior : OmReference [ '210' ],		#self : OmReference [ '211' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.430683+03:00' ],		#prior : OmReference [ '211' ],		#self : OmReference [ '212' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.460683+03:00' ],		#prior : OmReference [ '212' ],		#self : OmReference [ '213' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.496683+03:00' ],		#prior : OmReference [ '213' ],		#self : OmReference [ '214' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.537683+03:00' ],		#prior : OmReference [ '214' ],		#self : OmReference [ '215' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.571683+03:00' ],		#prior : OmReference [ '215' ],		#self : OmReference [ '216' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 11:36',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.655683+03:00' ],		#prior : OmReference [ '216' ],		#self : OmReference [ '217' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.704683+03:00' ],		#prior : OmReference [ '217' ],		#self : OmReference [ '218' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.734683+03:00' ],		#prior : OmReference [ '218' ],		#self : OmReference [ '219' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.765683+03:00' ],		#prior : OmReference [ '219' ],		#self : OmReference [ '220' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.813683+03:00' ],		#prior : OmReference [ '220' ],		#self : OmReference [ '221' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.846683+03:00' ],		#prior : OmReference [ '221' ],		#self : OmReference [ '222' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.880683+03:00' ],		#prior : OmReference [ '222' ],		#self : OmReference [ '223' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.913683+03:00' ],		#prior : OmReference [ '223' ],		#self : OmReference [ '224' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 11:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:22.990683+03:00' ],		#prior : OmReference [ '224' ],		#self : OmReference [ '225' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.063683+03:00' ],		#prior : OmReference [ '225' ],		#self : OmReference [ '226' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.092683+03:00' ],		#prior : OmReference [ '226' ],		#self : OmReference [ '227' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.123683+03:00' ],		#prior : OmReference [ '227' ],		#self : OmReference [ '228' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.171683+03:00' ],		#prior : OmReference [ '228' ],		#self : OmReference [ '229' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.202683+03:00' ],		#prior : OmReference [ '229' ],		#self : OmReference [ '230' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.235683+03:00' ],		#prior : OmReference [ '230' ],		#self : OmReference [ '231' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 11:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.314683+03:00' ],		#prior : OmReference [ '231' ],		#self : OmReference [ '232' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:56',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.373683+03:00' ],		#prior : OmReference [ '232' ],		#self : OmReference [ '233' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:56',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.412683+03:00' ],		#prior : OmReference [ '233' ],		#self : OmReference [ '234' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.446683+03:00' ],		#prior : OmReference [ '234' ],		#self : OmReference [ '235' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.477683+03:00' ],		#prior : OmReference [ '235' ],		#self : OmReference [ '236' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 11:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.512683+03:00' ],		#prior : OmReference [ '236' ],		#self : OmReference [ '237' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 11:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.546683+03:00' ],		#prior : OmReference [ '237' ],		#self : OmReference [ '238' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.577683+03:00' ],		#prior : OmReference [ '238' ],		#self : OmReference [ '239' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 11:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.655683+03:00' ],		#prior : OmReference [ '239' ],		#self : OmReference [ '240' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.689683+03:00' ],		#prior : OmReference [ '240' ],		#self : OmReference [ '241' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.725683+03:00' ],		#prior : OmReference [ '241' ],		#self : OmReference [ '242' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.770683+03:00' ],		#prior : OmReference [ '242' ],		#self : OmReference [ '243' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.813683+03:00' ],		#prior : OmReference [ '243' ],		#self : OmReference [ '244' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.852683+03:00' ],		#prior : OmReference [ '244' ],		#self : OmReference [ '245' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.883683+03:00' ],		#prior : OmReference [ '245' ],		#self : OmReference [ '246' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.915683+03:00' ],		#prior : OmReference [ '246' ],		#self : OmReference [ '247' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 12:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:23.996683+03:00' ],		#prior : OmReference [ '247' ],		#self : OmReference [ '248' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.025683+03:00' ],		#prior : OmReference [ '248' ],		#self : OmReference [ '249' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.055683+03:00' ],		#prior : OmReference [ '249' ],		#self : OmReference [ '250' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.084683+03:00' ],		#prior : OmReference [ '250' ],		#self : OmReference [ '251' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.129683+03:00' ],		#prior : OmReference [ '251' ],		#self : OmReference [ '252' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.176683+03:00' ],		#prior : OmReference [ '252' ],		#self : OmReference [ '253' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.226683+03:00' ],		#prior : OmReference [ '253' ],		#self : OmReference [ '254' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 12:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.287683+03:00' ],		#prior : OmReference [ '254' ],		#self : OmReference [ '255' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.332683+03:00' ],		#prior : OmReference [ '255' ],		#self : OmReference [ '256' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.362683+03:00' ],		#prior : OmReference [ '256' ],		#self : OmReference [ '257' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.391683+03:00' ],		#prior : OmReference [ '257' ],		#self : OmReference [ '258' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.424683+03:00' ],		#prior : OmReference [ '258' ],		#self : OmReference [ '259' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.464683+03:00' ],		#prior : OmReference [ '259' ],		#self : OmReference [ '260' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.495683+03:00' ],		#prior : OmReference [ '260' ],		#self : OmReference [ '261' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.600683+03:00' ],		#prior : OmReference [ '261' ],		#self : OmReference [ '262' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.642683+03:00' ],		#prior : OmReference [ '262' ],		#self : OmReference [ '263' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.677683+03:00' ],		#prior : OmReference [ '263' ],		#self : OmReference [ '264' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.712683+03:00' ],		#prior : OmReference [ '264' ],		#self : OmReference [ '265' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.745683+03:00' ],		#prior : OmReference [ '265' ],		#self : OmReference [ '266' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.783683+03:00' ],		#prior : OmReference [ '266' ],		#self : OmReference [ '267' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 12:30',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.870683+03:00' ],		#prior : OmReference [ '267' ],		#self : OmReference [ '268' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.920683+03:00' ],		#prior : OmReference [ '268' ],		#self : OmReference [ '269' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.967683+03:00' ],		#prior : OmReference [ '269' ],		#self : OmReference [ '270' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:24.997683+03:00' ],		#prior : OmReference [ '270' ],		#self : OmReference [ '271' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.030683+03:00' ],		#prior : OmReference [ '271' ],		#self : OmReference [ '272' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.078683+03:00' ],		#prior : OmReference [ '272' ],		#self : OmReference [ '273' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.109683+03:00' ],		#prior : OmReference [ '273' ],		#self : OmReference [ '274' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.149683+03:00' ],		#prior : OmReference [ '274' ],		#self : OmReference [ '275' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.185683+03:00' ],		#prior : OmReference [ '275' ],		#self : OmReference [ '276' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.227683+03:00' ],		#prior : OmReference [ '276' ],		#self : OmReference [ '277' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.262683+03:00' ],		#prior : OmReference [ '277' ],		#self : OmReference [ '278' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.293683+03:00' ],		#prior : OmReference [ '278' ],		#self : OmReference [ '279' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.322683+03:00' ],		#prior : OmReference [ '279' ],		#self : OmReference [ '280' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.357683+03:00' ],		#prior : OmReference [ '280' ],		#self : OmReference [ '281' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.387683+03:00' ],		#prior : OmReference [ '281' ],		#self : OmReference [ '282' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 12:42',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.472683+03:00' ],		#prior : OmReference [ '282' ],		#self : OmReference [ '283' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.525683+03:00' ],		#prior : OmReference [ '283' ],		#self : OmReference [ '284' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.574683+03:00' ],		#prior : OmReference [ '284' ],		#self : OmReference [ '285' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.606683+03:00' ],		#prior : OmReference [ '285' ],		#self : OmReference [ '286' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.646683+03:00' ],		#prior : OmReference [ '286' ],		#self : OmReference [ '287' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.679683+03:00' ],		#prior : OmReference [ '287' ],		#self : OmReference [ '288' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.718683+03:00' ],		#prior : OmReference [ '288' ],		#self : OmReference [ '289' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.752683+03:00' ],		#prior : OmReference [ '289' ],		#self : OmReference [ '290' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.803683+03:00' ],		#prior : OmReference [ '290' ],		#self : OmReference [ '291' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.845683+03:00' ],		#prior : OmReference [ '291' ],		#self : OmReference [ '292' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.881683+03:00' ],		#prior : OmReference [ '292' ],		#self : OmReference [ '293' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.912683+03:00' ],		#prior : OmReference [ '293' ],		#self : OmReference [ '294' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:25.996683+03:00' ],		#prior : OmReference [ '294' ],		#self : OmReference [ '295' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.056683+03:00' ],		#prior : OmReference [ '295' ],		#self : OmReference [ '296' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.088683+03:00' ],		#prior : OmReference [ '296' ],		#self : OmReference [ '297' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.131683+03:00' ],		#prior : OmReference [ '297' ],		#self : OmReference [ '298' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.165683+03:00' ],		#prior : OmReference [ '298' ],		#self : OmReference [ '299' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 13:02',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.211683+03:00' ],		#prior : OmReference [ '299' ],		#self : OmReference [ '300' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.243683+03:00' ],		#prior : OmReference [ '300' ],		#self : OmReference [ '301' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.274683+03:00' ],		#prior : OmReference [ '301' ],		#self : OmReference [ '302' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.303683+03:00' ],		#prior : OmReference [ '302' ],		#self : OmReference [ '303' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.336683+03:00' ],		#prior : OmReference [ '303' ],		#self : OmReference [ '304' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.377683+03:00' ],		#prior : OmReference [ '304' ],		#self : OmReference [ '305' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:06:26.410683+03:00' ],		#prior : OmReference [ '305' ],		#self : OmReference [ '306' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:03',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:13:43.519683+03:00' ],		#prior : OmReference [ '306' ],		#self : OmReference [ '307' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ].\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ].\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 12:59',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method|\r\tmethod := #byMatrix:.\r\tmatrixInstance elementsAsCollection do: [ :element|\r\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ].\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value.\r\t\t\tvalue elementsAsCollection do: [ :element | \r\t\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ] ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:14:35.191683+03:00' ],		#prior : OmReference [ '307' ],		#self : OmReference [ '308' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:15:15.584683+03:00' ],		#prior : OmReference [ '308' ],		#self : OmReference [ '309' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:15',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:40:50.729683+03:00' ],		#prior : OmReference [ '309' ],		#self : OmReference [ '310' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkInit rightMarkerLinkInit leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method|\r\tmethod := #byMatrix:.\r\tmatrixInstance elementsAsCollection do: [ :element|\r\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ].\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value.\r\t\t\tvalue elementsAsCollection do: [ :element | \r\t\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ] ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tmatrixInstance elementsAsCollection\r\t\tdo: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read ].\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\trightMatrix := value.\r\t\t\tvalue elementsAsCollection\r\t\t\t\tdo: [ :element | \r\t\t\t\t\t| rightMarkerHighlightLink |\r\t\t\t\t\t"bind the highlight to actual marker element"\r\t\t\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ] ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 13:40',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:41:29.534683+03:00' ],		#prior : OmReference [ '310' ],		#self : OmReference [ '311' ]	},	#content : EpCategoryAddition {		#classCategoryName : #refl-test,		#affectedPackageName : #refl-test	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:41:29.539683+03:00' ],		#prior : OmReference [ '311' ],		#self : OmReference [ '312' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #TestReflCl\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'refl-test\'',				#superclassName : 'Object'			},			#name : #TestReflCl,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestReflCl class\r\tinstanceVariableNames: \'\''				},				#name : #'TestReflCl class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestReflCl,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #refl-test,			#package : #refl-test,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:42:15.348683+03:00' ],		#prior : OmReference [ '312' ],		#self : OmReference [ '313' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r|temp|\r\rtemp:= COOSparseMatrixNode new.\rtemp value.',			#stamp : 'YaroslavKormusyn 5/4/2019 13:42',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:43:14.615683+03:00' ],		#prior : OmReference [ '313' ],		#self : OmReference [ '314' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #TestReflClLink\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'refl-test\'',				#superclassName : 'Object'			},			#name : #TestReflClLink,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestReflClLink class\r\tinstanceVariableNames: \'\''				},				#name : #'TestReflClLink class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestReflClLink,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #refl-test,			#package : #refl-test,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:48:23.715683+03:00' ],		#prior : OmReference [ '314' ],		#self : OmReference [ '315' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflClLink,				#isMetaSide : false			},			#name : #'setLinksWith:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksWith: instance\r\t|writeTempLink readSlotInTempLink|\r\twriteTempLink := MetaLink new.\r\twriteTempLink metaObject: [ :element| Transcript show: \'written to \', (element row @ element column) asString.\r\t\treadSlotInTempLink := MetaLink new.\rreadSlotInTempLink metaObject: [ Transcript show: \'read from \', (element row @ element column) asString ].\rreadSlotInTempLink selector: #value.\rreadSlotInTempLink control: #after.\relement link: readSlotInTempLink toSlotNamed: #value option: #read ].\r\twriteTempLink selector: #value:.\r\twriteTempLink arguments: #(value).\r\twriteTempLink control: #after.\r\tinstance link: writeTempLink toTemporaryNamed: #temp inMethod: #methodWithTemp option: #write.\r\t\r',			#stamp : 'YaroslavKormusyn 5/4/2019 13:48',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:48:23.722683+03:00' ],		#prior : OmReference [ '315' ],		#self : OmReference [ '316' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflClLink,				#isMetaSide : false			},			#name : #'setLinksWith:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksWith: instance\r\t|writeTempLink readSlotInTempLink|\r\twriteTempLink := MetaLink new.\r\twriteTempLink metaObject: [ :element| Transcript show: \'written to \', (element row @ element column) asString.\r\t\treadSlotInTempLink := MetaLink new.\rreadSlotInTempLink metaObject: [ Transcript show: \'read from \', (element row @ element column) asString ].\rreadSlotInTempLink selector: #value.\rreadSlotInTempLink control: #after.\relement link: readSlotInTempLink toSlotNamed: #value option: #read ].\r\twriteTempLink selector: #value:.\r\twriteTempLink arguments: #(value).\r\twriteTempLink control: #after.\r\tinstance link: writeTempLink toTemporaryNamed: #temp inMethod: #methodWithTemp option: #write.\r\t\r',			#stamp : 'YaroslavKormusyn 5/4/2019 13:48',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflClLink,				#isMetaSide : false			},			#name : #'setLinksWith:',			#protocol : #initialization,			#sourceCode : 'setLinksWith: instance\r\t|writeTempLink readSlotInTempLink|\r\twriteTempLink := MetaLink new.\r\twriteTempLink metaObject: [ :element| Transcript show: \'written to \', (element row @ element column) asString.\r\t\treadSlotInTempLink := MetaLink new.\rreadSlotInTempLink metaObject: [ Transcript show: \'read from \', (element row @ element column) asString ].\rreadSlotInTempLink selector: #value.\rreadSlotInTempLink control: #after.\relement link: readSlotInTempLink toSlotNamed: #value option: #read ].\r\twriteTempLink selector: #value:.\r\twriteTempLink arguments: #(value).\r\twriteTempLink control: #after.\r\tinstance link: writeTempLink toTemporaryNamed: #temp inMethod: #methodWithTemp option: #write.\r\t\r',			#stamp : 'YaroslavKormusyn 5/4/2019 13:48',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:49:14.336683+03:00' ],		#prior : OmReference [ '316' ],		#self : OmReference [ '317' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r|temp|\r\rtemp:= COOSparseMatrixNode new.\rtemp value.',			#stamp : 'YaroslavKormusyn 5/4/2019 13:42',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp |\r\ttemp := COOSparseMatrixNode new.\r\ttemp value.\r\ttemp := COOSparseMatrixNode new.',			#stamp : 'YaroslavKormusyn 5/4/2019 13:49',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:30.927683+03:00' ],		#prior : OmReference [ '317' ],		#self : OmReference [ '318' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflClLink,				#isMetaSide : false			},			#name : #'setLinksWith:',			#protocol : #initialization,			#sourceCode : 'setLinksWith: instance\r\t|writeTempLink readSlotInTempLink|\r\twriteTempLink := MetaLink new.\r\twriteTempLink metaObject: [ :element| Transcript show: \'written to \', (element row @ element column) asString.\r\t\treadSlotInTempLink := MetaLink new.\rreadSlotInTempLink metaObject: [ Transcript show: \'read from \', (element row @ element column) asString ].\rreadSlotInTempLink selector: #value.\rreadSlotInTempLink control: #after.\relement link: readSlotInTempLink toSlotNamed: #value option: #read ].\r\twriteTempLink selector: #value:.\r\twriteTempLink arguments: #(value).\r\twriteTempLink control: #after.\r\tinstance link: writeTempLink toTemporaryNamed: #temp inMethod: #methodWithTemp option: #write.\r\t\r',			#stamp : 'YaroslavKormusyn 5/4/2019 13:48',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflClLink,				#isMetaSide : false			},			#name : #'setLinksWith:',			#protocol : #initialization,			#sourceCode : 'setLinksWith: instance\r\t|writeTempLink readSlotInTempLink|\r\twriteTempLink := MetaLink new.\r\twriteTempLink metaObject: [ :element| Transcript show: \'written to \', (element row @ element column) asString.\r\t\treadSlotInTempLink := MetaLink new.\rreadSlotInTempLink metaObject: [ Transcript show: \'read from \', (element row @ element column) asString ].\rreadSlotInTempLink selector: #value.\rreadSlotInTempLink control: #after.\relement link: readSlotInTempLink toSlotNamed: #value option: #read ].\r\twriteTempLink selector: #value:.\r\twriteTempLink arguments: #(value).\r\twriteTempLink control: #after.\r\tinstance link: writeTempLink toTemporaryNamed: #temp inMethod: #methodWithTemp: option: #write.\r\t\r',			#stamp : 'YaroslavKormusyn 5/4/2019 13:55',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.695683+03:00' ],		#prior : OmReference [ '318' ],		#self : OmReference [ '319' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.741683+03:00' ],		#prior : OmReference [ '319' ],		#self : OmReference [ '320' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.779683+03:00' ],		#prior : OmReference [ '320' ],		#self : OmReference [ '321' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.814683+03:00' ],		#prior : OmReference [ '321' ],		#self : OmReference [ '322' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.848683+03:00' ],		#prior : OmReference [ '322' ],		#self : OmReference [ '323' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.882683+03:00' ],		#prior : OmReference [ '323' ],		#self : OmReference [ '324' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.916683+03:00' ],		#prior : OmReference [ '324' ],		#self : OmReference [ '325' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.950683+03:00' ],		#prior : OmReference [ '325' ],		#self : OmReference [ '326' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:47.984683+03:00' ],		#prior : OmReference [ '326' ],		#self : OmReference [ '327' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.036683+03:00' ],		#prior : OmReference [ '327' ],		#self : OmReference [ '328' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.075683+03:00' ],		#prior : OmReference [ '328' ],		#self : OmReference [ '329' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.116683+03:00' ],		#prior : OmReference [ '329' ],		#self : OmReference [ '330' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.155683+03:00' ],		#prior : OmReference [ '330' ],		#self : OmReference [ '331' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.190683+03:00' ],		#prior : OmReference [ '331' ],		#self : OmReference [ '332' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.225683+03:00' ],		#prior : OmReference [ '332' ],		#self : OmReference [ '333' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.259683+03:00' ],		#prior : OmReference [ '333' ],		#self : OmReference [ '334' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.293683+03:00' ],		#prior : OmReference [ '334' ],		#self : OmReference [ '335' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.327683+03:00' ],		#prior : OmReference [ '335' ],		#self : OmReference [ '336' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.361683+03:00' ],		#prior : OmReference [ '336' ],		#self : OmReference [ '337' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.396683+03:00' ],		#prior : OmReference [ '337' ],		#self : OmReference [ '338' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.431683+03:00' ],		#prior : OmReference [ '338' ],		#self : OmReference [ '339' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:13',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.471683+03:00' ],		#prior : OmReference [ '339' ],		#self : OmReference [ '340' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.523683+03:00' ],		#prior : OmReference [ '340' ],		#self : OmReference [ '341' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.573683+03:00' ],		#prior : OmReference [ '341' ],		#self : OmReference [ '342' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.614683+03:00' ],		#prior : OmReference [ '342' ],		#self : OmReference [ '343' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.653683+03:00' ],		#prior : OmReference [ '343' ],		#self : OmReference [ '344' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.692683+03:00' ],		#prior : OmReference [ '344' ],		#self : OmReference [ '345' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.726683+03:00' ],		#prior : OmReference [ '345' ],		#self : OmReference [ '346' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.818683+03:00' ],		#prior : OmReference [ '346' ],		#self : OmReference [ '347' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.868683+03:00' ],		#prior : OmReference [ '347' ],		#self : OmReference [ '348' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.902683+03:00' ],		#prior : OmReference [ '348' ],		#self : OmReference [ '349' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.938683+03:00' ],		#prior : OmReference [ '349' ],		#self : OmReference [ '350' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:48.971683+03:00' ],		#prior : OmReference [ '350' ],		#self : OmReference [ '351' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.005683+03:00' ],		#prior : OmReference [ '351' ],		#self : OmReference [ '352' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.041683+03:00' ],		#prior : OmReference [ '352' ],		#self : OmReference [ '353' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.074683+03:00' ],		#prior : OmReference [ '353' ],		#self : OmReference [ '354' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.108683+03:00' ],		#prior : OmReference [ '354' ],		#self : OmReference [ '355' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.156683+03:00' ],		#prior : OmReference [ '355' ],		#self : OmReference [ '356' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.195683+03:00' ],		#prior : OmReference [ '356' ],		#self : OmReference [ '357' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.246683+03:00' ],		#prior : OmReference [ '357' ],		#self : OmReference [ '358' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:15',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.296683+03:00' ],		#prior : OmReference [ '358' ],		#self : OmReference [ '359' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 13:15',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.336683+03:00' ],		#prior : OmReference [ '359' ],		#self : OmReference [ '360' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 13:15',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.373683+03:00' ],		#prior : OmReference [ '360' ],		#self : OmReference [ '361' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 13:15',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.410683+03:00' ],		#prior : OmReference [ '361' ],		#self : OmReference [ '362' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:15',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.443683+03:00' ],		#prior : OmReference [ '362' ],		#self : OmReference [ '363' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.480683+03:00' ],		#prior : OmReference [ '363' ],		#self : OmReference [ '364' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.514683+03:00' ],		#prior : OmReference [ '364' ],		#self : OmReference [ '365' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.549683+03:00' ],		#prior : OmReference [ '365' ],		#self : OmReference [ '366' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.583683+03:00' ],		#prior : OmReference [ '366' ],		#self : OmReference [ '367' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.624683+03:00' ],		#prior : OmReference [ '367' ],		#self : OmReference [ '368' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.664683+03:00' ],		#prior : OmReference [ '368' ],		#self : OmReference [ '369' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:55:49.704683+03:00' ],		#prior : OmReference [ '369' ],		#self : OmReference [ '370' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:14',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:56:45.033683+03:00' ],		#prior : OmReference [ '370' ],		#self : OmReference [ '371' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp |\r\ttemp := COOSparseMatrixNode new.\r\ttemp value.\r\ttemp := COOSparseMatrixNode new.',			#stamp : 'YaroslavKormusyn 5/4/2019 13:49',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp |\r\ttemp := ((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\ttemp value.\r\ttemp := ((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil)',			#stamp : 'YaroslavKormusyn 5/4/2019 13:56',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:56:45.053683+03:00' ],		#prior : OmReference [ '371' ],		#self : OmReference [ '372' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of TestReflCl',				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp |\r\ttemp := COOSparseMatrixNode new.\r\ttemp value.\r\ttemp := COOSparseMatrixNode new.',			#stamp : 'YaroslavKormusyn 5/4/2019 13:55',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:57:57.313683+03:00' ],		#prior : OmReference [ '372' ],		#self : OmReference [ '373' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp |\r\ttemp := ((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\ttemp value.\r\ttemp := ((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil)',			#stamp : 'YaroslavKormusyn 5/4/2019 13:56',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := (COOSparseMatrixNode new row: 0 column: 0 value: 0).\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0) rightNeighbour: first.\r\ttemp := first\r\ttemp value.\r\ttemp := second',			#stamp : 'YaroslavKormusyn 5/4/2019 13:57',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:57:57.332683+03:00' ],		#prior : OmReference [ '373' ],		#self : OmReference [ '374' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of TestReflCl',				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp |\r\ttemp := ((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\ttemp value.\r\ttemp := ((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil)',			#stamp : 'YaroslavKormusyn 5/4/2019 13:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:01.039683+03:00' ],		#prior : OmReference [ '374' ],		#self : OmReference [ '375' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := (COOSparseMatrixNode new row: 0 column: 0 value: 0).\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0) rightNeighbour: first.\r\ttemp := first\r\ttemp value.\r\ttemp := second',			#stamp : 'YaroslavKormusyn 5/4/2019 13:57',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\trightNeighbour: first.\r\ttemp := first. temp value.\r\ttemp := second',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:09.425683+03:00' ],		#prior : OmReference [ '375' ],		#self : OmReference [ '376' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\trightNeighbour: first.\r\ttemp := first. temp value.\r\ttemp := second',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\trightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp := first rightNeighbour ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:13.520683+03:00' ],		#prior : OmReference [ '376' ],		#self : OmReference [ '377' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:13.562683+03:00' ],		#prior : OmReference [ '377' ],		#self : OmReference [ '378' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:13.599683+03:00' ],		#prior : OmReference [ '378' ],		#self : OmReference [ '379' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:36.454683+03:00' ],		#prior : OmReference [ '379' ],		#self : OmReference [ '380' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\trightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp := first rightNeighbour ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0).\r\t\tfirst rightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp := first rightNeighbour',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:36.473683+03:00' ],		#prior : OmReference [ '380' ],		#self : OmReference [ '381' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of TestReflCl',				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\trightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp := first rightNeighbour ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:39.170683+03:00' ],		#prior : OmReference [ '381' ],		#self : OmReference [ '382' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T13:58:39.217683+03:00' ],		#prior : OmReference [ '382' ],		#self : OmReference [ '383' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T14:00:08.219683+03:00' ],		#prior : OmReference [ '383' ],		#self : OmReference [ '384' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 14:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T14:05:05.001683+03:00' ],		#prior : OmReference [ '384' ],		#self : OmReference [ '385' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0).\r\t\tfirst rightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp := first rightNeighbour',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #refl-test		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestReflCl,				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tfirst rightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp row.\r\ttemp := first rightNeighbour',			#stamp : 'YaroslavKormusyn 5/4/2019 14:05',			#package : #refl-test		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T14:05:05.042683+03:00' ],		#prior : OmReference [ '385' ],		#self : OmReference [ '386' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of TestReflCl',				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := (COOSparseMatrixNode new row: 0 column: 0 value: 0).\r\t\tfirst rightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp := first rightNeighbour',			#stamp : 'YaroslavKormusyn 5/4/2019 13:58',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T14:21:57.389683+03:00' ],		#prior : OmReference [ '386' ],		#self : OmReference [ '387' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\t"set the rest of links"\r\t"self setLinksForMultiplicationOn: leftMatrix."\r\t"initialize the view"\r\t"self initializeMultiplicationView."\r\t"set initialization links for the rest of the view - result for COO"\r\t"self setMultiInitLinksOn2: leftMatrix."\r\t"process resume.\r\tsemaphore wait."\r\t"self setPositionsForMultiplication."\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 12:41',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 14:21',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T14:50:32.616683+03:00' ],		#prior : OmReference [ '387' ],		#self : OmReference [ '388' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tmatrixInstance elementsAsCollection\r\t\tdo: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t"leftMarkerHighlightLink arguments: #(value)."\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement\r\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\ttoSlotNamed: #value\r\t\t\t\toption: #read ].\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\t"resultMatrixUpdateLinkLast arguments: #(value)."\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\trightMatrix := value.\r\t\t\tvalue elementsAsCollection\r\t\t\t\tdo: [ :element | \r\t\t\t\t\t| rightMarkerHighlightLink |\r\t\t\t\t\t"bind the highlight to actual marker element"\r\t\t\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ] ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 13:40',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\trightMatrix := value.\r\t\t\t].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\t\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 14:50',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:26:12.800683+03:00' ],		#prior : OmReference [ '388' ],		#self : OmReference [ '389' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\trightMatrix := value.\r\t\t\t].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"bind the actual element to the highlight"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ leftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\t\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 14:50',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tself halt.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]. ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:26',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:26:16.420683+03:00' ],		#prior : OmReference [ '389' ],		#self : OmReference [ '390' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:26:16.469683+03:00' ],		#prior : OmReference [ '390' ],		#self : OmReference [ '391' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 15:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:26:16.519683+03:00' ],		#prior : OmReference [ '391' ],		#self : OmReference [ '392' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 15:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:29:18.251683+03:00' ],		#prior : OmReference [ '392' ],		#self : OmReference [ '393' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tself halt.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]. ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:26',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tself halt.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\t\r\t\t\t\t\tself halt.\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ] ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:29:21.471683+03:00' ],		#prior : OmReference [ '393' ],		#self : OmReference [ '394' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:29:21.523683+03:00' ],		#prior : OmReference [ '394' ],		#self : OmReference [ '395' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:29:21.570683+03:00' ],		#prior : OmReference [ '395' ],		#self : OmReference [ '396' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:06.906683+03:00' ],		#prior : OmReference [ '396' ],		#self : OmReference [ '397' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tself halt.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\t\r\t\t\t\t\tself halt.\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ] ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ] ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.065683+03:00' ],		#prior : OmReference [ '397' ],		#self : OmReference [ '398' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.100683+03:00' ],		#prior : OmReference [ '398' ],		#self : OmReference [ '399' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.133683+03:00' ],		#prior : OmReference [ '399' ],		#self : OmReference [ '400' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.163683+03:00' ],		#prior : OmReference [ '400' ],		#self : OmReference [ '401' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.194683+03:00' ],		#prior : OmReference [ '401' ],		#self : OmReference [ '402' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.225683+03:00' ],		#prior : OmReference [ '402' ],		#self : OmReference [ '403' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.261683+03:00' ],		#prior : OmReference [ '403' ],		#self : OmReference [ '404' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.298683+03:00' ],		#prior : OmReference [ '404' ],		#self : OmReference [ '405' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.335683+03:00' ],		#prior : OmReference [ '405' ],		#self : OmReference [ '406' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.371683+03:00' ],		#prior : OmReference [ '406' ],		#self : OmReference [ '407' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.403683+03:00' ],		#prior : OmReference [ '407' ],		#self : OmReference [ '408' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.432683+03:00' ],		#prior : OmReference [ '408' ],		#self : OmReference [ '409' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.464683+03:00' ],		#prior : OmReference [ '409' ],		#self : OmReference [ '410' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.495683+03:00' ],		#prior : OmReference [ '410' ],		#self : OmReference [ '411' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.529683+03:00' ],		#prior : OmReference [ '411' ],		#self : OmReference [ '412' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.562683+03:00' ],		#prior : OmReference [ '412' ],		#self : OmReference [ '413' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.593683+03:00' ],		#prior : OmReference [ '413' ],		#self : OmReference [ '414' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.625683+03:00' ],		#prior : OmReference [ '414' ],		#self : OmReference [ '415' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.662683+03:00' ],		#prior : OmReference [ '415' ],		#self : OmReference [ '416' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.698683+03:00' ],		#prior : OmReference [ '416' ],		#self : OmReference [ '417' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.743683+03:00' ],		#prior : OmReference [ '417' ],		#self : OmReference [ '418' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.788683+03:00' ],		#prior : OmReference [ '418' ],		#self : OmReference [ '419' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.819683+03:00' ],		#prior : OmReference [ '419' ],		#self : OmReference [ '420' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.905683+03:00' ],		#prior : OmReference [ '420' ],		#self : OmReference [ '421' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 13:59',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.959683+03:00' ],		#prior : OmReference [ '421' ],		#self : OmReference [ '422' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 14:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:18.996683+03:00' ],		#prior : OmReference [ '422' ],		#self : OmReference [ '423' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 14:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.032683+03:00' ],		#prior : OmReference [ '423' ],		#self : OmReference [ '424' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 14:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.068683+03:00' ],		#prior : OmReference [ '424' ],		#self : OmReference [ '425' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 14:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.107683+03:00' ],		#prior : OmReference [ '425' ],		#self : OmReference [ '426' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of TestReflCl',				#isMetaSide : false			},			#name : #'methodWithTemp:',			#protocol : #'as yet unclassified',			#sourceCode : 'methodWithTemp: arg\r\t| temp first second |\r\tfirst := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tsecond := COOSparseMatrixNode new row: 0 column: 0 value: 0.\r\tfirst rightNeighbour: first.\r\ttemp := first.\r\ttemp value.\r\ttemp row.\r\ttemp := first rightNeighbour',			#stamp : 'YaroslavKormusyn 5/4/2019 14:05',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.180683+03:00' ],		#prior : OmReference [ '426' ],		#self : OmReference [ '427' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.218683+03:00' ],		#prior : OmReference [ '427' ],		#self : OmReference [ '428' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 15:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.297683+03:00' ],		#prior : OmReference [ '428' ],		#self : OmReference [ '429' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.359683+03:00' ],		#prior : OmReference [ '429' ],		#self : OmReference [ '430' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:19.392683+03:00' ],		#prior : OmReference [ '430' ],		#self : OmReference [ '431' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 15:29',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:22.354683+03:00' ],		#prior : OmReference [ '431' ],		#self : OmReference [ '432' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:22.393683+03:00' ],		#prior : OmReference [ '432' ],		#self : OmReference [ '433' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:22.430683+03:00' ],		#prior : OmReference [ '433' ],		#self : OmReference [ '434' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:28.560683+03:00' ],		#prior : OmReference [ '434' ],		#self : OmReference [ '435' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:28.596683+03:00' ],		#prior : OmReference [ '435' ],		#self : OmReference [ '436' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:29.860683+03:00' ],		#prior : OmReference [ '436' ],		#self : OmReference [ '437' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:30.951683+03:00' ],		#prior : OmReference [ '437' ],		#self : OmReference [ '438' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:30.985683+03:00' ],		#prior : OmReference [ '438' ],		#self : OmReference [ '439' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:32.090683+03:00' ],		#prior : OmReference [ '439' ],		#self : OmReference [ '440' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:33.185683+03:00' ],		#prior : OmReference [ '440' ],		#self : OmReference [ '441' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:33.248683+03:00' ],		#prior : OmReference [ '441' ],		#self : OmReference [ '442' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:34.453683+03:00' ],		#prior : OmReference [ '442' ],		#self : OmReference [ '443' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:34.488683+03:00' ],		#prior : OmReference [ '443' ],		#self : OmReference [ '444' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:35.560683+03:00' ],		#prior : OmReference [ '444' ],		#self : OmReference [ '445' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:35.596683+03:00' ],		#prior : OmReference [ '445' ],		#self : OmReference [ '446' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:36.687683+03:00' ],		#prior : OmReference [ '446' ],		#self : OmReference [ '447' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:37.776683+03:00' ],		#prior : OmReference [ '447' ],		#self : OmReference [ '448' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:37:37.836683+03:00' ],		#prior : OmReference [ '448' ],		#self : OmReference [ '449' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:38:56.403683+03:00' ],		#prior : OmReference [ '449' ],		#self : OmReference [ '450' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ] ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t"element isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]."\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ] ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]. ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:38',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:15.058683+03:00' ],		#prior : OmReference [ '450' ],		#self : OmReference [ '451' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:25.620683+03:00' ],		#prior : OmReference [ '451' ],		#self : OmReference [ '452' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:25.657683+03:00' ],		#prior : OmReference [ '452' ],		#self : OmReference [ '453' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:26.907683+03:00' ],		#prior : OmReference [ '453' ],		#self : OmReference [ '454' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:26.954683+03:00' ],		#prior : OmReference [ '454' ],		#self : OmReference [ '455' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:29.074683+03:00' ],		#prior : OmReference [ '455' ],		#self : OmReference [ '456' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:29.111683+03:00' ],		#prior : OmReference [ '456' ],		#self : OmReference [ '457' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:30.240683+03:00' ],		#prior : OmReference [ '457' ],		#self : OmReference [ '458' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:30.275683+03:00' ],		#prior : OmReference [ '458' ],		#self : OmReference [ '459' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:32.380683+03:00' ],		#prior : OmReference [ '459' ],		#self : OmReference [ '460' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:32.418683+03:00' ],		#prior : OmReference [ '460' ],		#self : OmReference [ '461' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:33.665683+03:00' ],		#prior : OmReference [ '461' ],		#self : OmReference [ '462' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:39:33.701683+03:00' ],		#prior : OmReference [ '462' ],		#self : OmReference [ '463' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:29.126683+03:00' ],		#prior : OmReference [ '463' ],		#self : OmReference [ '464' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ] ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\t\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\telement\r\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\toption: #read ]. ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:38',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:31.816683+03:00' ],		#prior : OmReference [ '464' ],		#self : OmReference [ '465' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:31.857683+03:00' ],		#prior : OmReference [ '465' ],		#self : OmReference [ '466' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:39.245683+03:00' ],		#prior : OmReference [ '466' ],		#self : OmReference [ '467' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:39.282683+03:00' ],		#prior : OmReference [ '467' ],		#self : OmReference [ '468' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:45.718683+03:00' ],		#prior : OmReference [ '468' ],		#self : OmReference [ '469' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:45.753683+03:00' ],		#prior : OmReference [ '469' ],		#self : OmReference [ '470' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:47.903683+03:00' ],		#prior : OmReference [ '470' ],		#self : OmReference [ '471' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:47.943683+03:00' ],		#prior : OmReference [ '471' ],		#self : OmReference [ '472' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:51.145683+03:00' ],		#prior : OmReference [ '472' ],		#self : OmReference [ '473' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:51.181683+03:00' ],		#prior : OmReference [ '473' ],		#self : OmReference [ '474' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:53.333683+03:00' ],		#prior : OmReference [ '474' ],		#self : OmReference [ '475' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:53.404683+03:00' ],		#prior : OmReference [ '475' ],		#self : OmReference [ '476' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:58.748683+03:00' ],		#prior : OmReference [ '476' ],		#self : OmReference [ '477' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:40:58.784683+03:00' ],		#prior : OmReference [ '477' ],		#self : OmReference [ '478' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:02.050683+03:00' ],		#prior : OmReference [ '478' ],		#self : OmReference [ '479' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:02.086683+03:00' ],		#prior : OmReference [ '479' ],		#self : OmReference [ '480' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:04.227683+03:00' ],		#prior : OmReference [ '480' ],		#self : OmReference [ '481' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:04.265683+03:00' ],		#prior : OmReference [ '481' ],		#self : OmReference [ '482' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:06.430683+03:00' ],		#prior : OmReference [ '482' ],		#self : OmReference [ '483' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:06.474683+03:00' ],		#prior : OmReference [ '483' ],		#self : OmReference [ '484' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:36.600683+03:00' ],		#prior : OmReference [ '484' ],		#self : OmReference [ '485' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:36.641683+03:00' ],		#prior : OmReference [ '485' ],		#self : OmReference [ '486' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:36.681683+03:00' ],		#prior : OmReference [ '486' ],		#self : OmReference [ '487' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:45.300683+03:00' ],		#prior : OmReference [ '487' ],		#self : OmReference [ '488' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:41:45.335683+03:00' ],		#prior : OmReference [ '488' ],		#self : OmReference [ '489' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:50:07.084683+03:00' ],		#prior : OmReference [ '489' ],		#self : OmReference [ '490' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:50:07.127683+03:00' ],		#prior : OmReference [ '490' ],		#self : OmReference [ '491' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:50:07.175683+03:00' ],		#prior : OmReference [ '491' ],		#self : OmReference [ '492' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:50:20.663683+03:00' ],		#prior : OmReference [ '492' ],		#self : OmReference [ '493' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T15:50:20.702683+03:00' ],		#prior : OmReference [ '493' ],		#self : OmReference [ '494' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:05:21.535683+03:00' ],		#prior : OmReference [ '494' ],		#self : OmReference [ '495' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write. ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\t\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:06:45.849683+03:00' ],		#prior : OmReference [ '495' ],		#self : OmReference [ '496' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write. ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ rightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\t\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:05',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:06',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:28.976683+03:00' ],		#prior : OmReference [ '496' ],		#self : OmReference [ '497' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\trightMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait ].\r\t\t\t\t\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ \r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:06',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\t\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\t\t leftMarkerHighlightLink uninstall] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write. ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\t\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ element\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:43.756683+03:00' ],		#prior : OmReference [ '497' ],		#self : OmReference [ '498' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:43.820683+03:00' ],		#prior : OmReference [ '498' ],		#self : OmReference [ '499' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:43.875683+03:00' ],		#prior : OmReference [ '499' ],		#self : OmReference [ '500' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:43.919683+03:00' ],		#prior : OmReference [ '500' ],		#self : OmReference [ '501' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:43.958683+03:00' ],		#prior : OmReference [ '501' ],		#self : OmReference [ '502' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:43.999683+03:00' ],		#prior : OmReference [ '502' ],		#self : OmReference [ '503' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.040683+03:00' ],		#prior : OmReference [ '503' ],		#self : OmReference [ '504' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.081683+03:00' ],		#prior : OmReference [ '504' ],		#self : OmReference [ '505' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:37',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.194683+03:00' ],		#prior : OmReference [ '505' ],		#self : OmReference [ '506' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.256683+03:00' ],		#prior : OmReference [ '506' ],		#self : OmReference [ '507' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.295683+03:00' ],		#prior : OmReference [ '507' ],		#self : OmReference [ '508' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.336683+03:00' ],		#prior : OmReference [ '508' ],		#self : OmReference [ '509' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.375683+03:00' ],		#prior : OmReference [ '509' ],		#self : OmReference [ '510' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.415683+03:00' ],		#prior : OmReference [ '510' ],		#self : OmReference [ '511' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.458683+03:00' ],		#prior : OmReference [ '511' ],		#self : OmReference [ '512' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.512683+03:00' ],		#prior : OmReference [ '512' ],		#self : OmReference [ '513' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.573683+03:00' ],		#prior : OmReference [ '513' ],		#self : OmReference [ '514' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.633683+03:00' ],		#prior : OmReference [ '514' ],		#self : OmReference [ '515' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.694683+03:00' ],		#prior : OmReference [ '515' ],		#self : OmReference [ '516' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.733683+03:00' ],		#prior : OmReference [ '516' ],		#self : OmReference [ '517' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.771683+03:00' ],		#prior : OmReference [ '517' ],		#self : OmReference [ '518' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.811683+03:00' ],		#prior : OmReference [ '518' ],		#self : OmReference [ '519' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:39',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.917683+03:00' ],		#prior : OmReference [ '519' ],		#self : OmReference [ '520' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:44.971683+03:00' ],		#prior : OmReference [ '520' ],		#self : OmReference [ '521' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.018683+03:00' ],		#prior : OmReference [ '521' ],		#self : OmReference [ '522' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.059683+03:00' ],		#prior : OmReference [ '522' ],		#self : OmReference [ '523' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.098683+03:00' ],		#prior : OmReference [ '523' ],		#self : OmReference [ '524' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.140683+03:00' ],		#prior : OmReference [ '524' ],		#self : OmReference [ '525' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.179683+03:00' ],		#prior : OmReference [ '525' ],		#self : OmReference [ '526' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.219683+03:00' ],		#prior : OmReference [ '526' ],		#self : OmReference [ '527' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.260683+03:00' ],		#prior : OmReference [ '527' ],		#self : OmReference [ '528' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.304683+03:00' ],		#prior : OmReference [ '528' ],		#self : OmReference [ '529' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.350683+03:00' ],		#prior : OmReference [ '529' ],		#self : OmReference [ '530' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:40',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.411683+03:00' ],		#prior : OmReference [ '530' ],		#self : OmReference [ '531' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.457683+03:00' ],		#prior : OmReference [ '531' ],		#self : OmReference [ '532' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.495683+03:00' ],		#prior : OmReference [ '532' ],		#self : OmReference [ '533' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.538683+03:00' ],		#prior : OmReference [ '533' ],		#self : OmReference [ '534' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.582683+03:00' ],		#prior : OmReference [ '534' ],		#self : OmReference [ '535' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.680683+03:00' ],		#prior : OmReference [ '535' ],		#self : OmReference [ '536' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.749683+03:00' ],		#prior : OmReference [ '536' ],		#self : OmReference [ '537' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.801683+03:00' ],		#prior : OmReference [ '537' ],		#self : OmReference [ '538' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.853683+03:00' ],		#prior : OmReference [ '538' ],		#self : OmReference [ '539' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.893683+03:00' ],		#prior : OmReference [ '539' ],		#self : OmReference [ '540' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.934683+03:00' ],		#prior : OmReference [ '540' ],		#self : OmReference [ '541' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:45.973683+03:00' ],		#prior : OmReference [ '541' ],		#self : OmReference [ '542' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.012683+03:00' ],		#prior : OmReference [ '542' ],		#self : OmReference [ '543' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.064683+03:00' ],		#prior : OmReference [ '543' ],		#self : OmReference [ '544' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:41',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.165683+03:00' ],		#prior : OmReference [ '544' ],		#self : OmReference [ '545' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.229683+03:00' ],		#prior : OmReference [ '545' ],		#self : OmReference [ '546' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.284683+03:00' ],		#prior : OmReference [ '546' ],		#self : OmReference [ '547' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.329683+03:00' ],		#prior : OmReference [ '547' ],		#self : OmReference [ '548' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.368683+03:00' ],		#prior : OmReference [ '548' ],		#self : OmReference [ '549' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:50',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.406683+03:00' ],		#prior : OmReference [ '549' ],		#self : OmReference [ '550' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.446683+03:00' ],		#prior : OmReference [ '550' ],		#self : OmReference [ '551' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.485683+03:00' ],		#prior : OmReference [ '551' ],		#self : OmReference [ '552' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.523683+03:00' ],		#prior : OmReference [ '552' ],		#self : OmReference [ '553' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.567683+03:00' ],		#prior : OmReference [ '553' ],		#self : OmReference [ '554' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.626683+03:00' ],		#prior : OmReference [ '554' ],		#self : OmReference [ '555' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.669683+03:00' ],		#prior : OmReference [ '555' ],		#self : OmReference [ '556' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:46.727683+03:00' ],		#prior : OmReference [ '556' ],		#self : OmReference [ '557' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 15:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:49.193683+03:00' ],		#prior : OmReference [ '557' ],		#self : OmReference [ '558' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:49.248683+03:00' ],		#prior : OmReference [ '558' ],		#self : OmReference [ '559' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:08:49.304683+03:00' ],		#prior : OmReference [ '559' ],		#self : OmReference [ '560' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:09:03.123683+03:00' ],		#prior : OmReference [ '560' ],		#self : OmReference [ '561' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:10:33.976683+03:00' ],		#prior : OmReference [ '561' ],		#self : OmReference [ '562' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\t\t\t\t\tleftMarkerHighlightLink\r\t\t\t\t\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tdelay wait.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\t\t\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\t\t\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\t\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\t\t leftMarkerHighlightLink uninstall] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write. ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\t\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ element\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\tleftMarkerLinkBefore := MetaLink new.\r\t\t\t\t\tleftMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ] ].\r\t\t\t\t\tleftMarkerLinkBefore selector: #value:.\r\t\t\t\t\tleftMarkerLinkBefore arguments: #(value).\r\t\t\t\t\tleftMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: leftMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element. ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ element\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:10:52.823683+03:00' ],		#prior : OmReference [ '562' ],		#self : OmReference [ '563' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\tleftMarkerLinkBefore := MetaLink new.\r\t\t\t\t\tleftMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ] ].\r\t\t\t\t\tleftMarkerLinkBefore selector: #value:.\r\t\t\t\t\tleftMarkerLinkBefore arguments: #(value).\r\t\t\t\t\tleftMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: leftMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element. ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element.\r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ element\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerLinkBefore := MetaLink new.\r\t\t\t\t\tleftMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ] ].\r\t\t\t\t\tleftMarkerLinkBefore selector: #value:.\r\t\t\t\t\tleftMarkerLinkBefore arguments: #(value).\r\t\t\t\t\tleftMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: leftMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element. ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ element\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:10:59.578683+03:00' ],		#prior : OmReference [ '563' ],		#self : OmReference [ '564' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:10:59.618683+03:00' ],		#prior : OmReference [ '564' ],		#self : OmReference [ '565' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:10:59.659683+03:00' ],		#prior : OmReference [ '565' ],		#self : OmReference [ '566' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:11:15.125683+03:00' ],		#prior : OmReference [ '566' ],		#self : OmReference [ '567' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:11',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:52.487683+03:00' ],		#prior : OmReference [ '567' ],		#self : OmReference [ '568' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerLinkBefore := MetaLink new.\r\t\t\t\t\tleftMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\tleftMarkerHighlightLink uninstall ] ].\r\t\t\t\t\tleftMarkerLinkBefore selector: #value:.\r\t\t\t\t\tleftMarkerLinkBefore arguments: #(value).\r\t\t\t\t\tleftMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: leftMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ "bind the actual element to the highlight"\r\t\t\t\t\t\t\telement\r\t\t\t\t\t\t\t\tlink: leftMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"rightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\trightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\trightMarkerHighlightLink uninstall ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element. ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\telement isNotNil\r\t\t\t\t\t\tifTrue: [ element\r\t\t\t\t\t\t\t\tlink: rightMarkerHighlightLink\r\t\t\t\t\t\t\t\ttoSlotNamed: #value\r\t\t\t\t\t\t\t\toption: #read ].\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\t\tsumLink := MetaLink new.\r\t\tsumLink metaObject: [ :sumValue | sumValue ~= 0 ifTrue: [ self highlightModels: { leftMatrixMarker . rightMatrixMarker } ] ].\r\t\tsumLink selector: #value:.\r\t\tsumLink arguments: #(value).\r\t\tsumLink control: #after.\r\t\tmatrixInstance link: sumLink toTemporaryNamed: #sum inMethod: method option: #write.\r\t\tleftMarkerLinkBefore := MetaLink new.\r\t\t\t\t\tleftMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "] ].\r\t\t\t\t\tleftMarkerLinkBefore selector: #value:.\r\t\t\t\t\tleftMarkerLinkBefore arguments: #(value).\r\t\t\t\t\tleftMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: leftMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\t\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\t\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:21',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:58.837683+03:00' ],		#prior : OmReference [ '568' ],		#self : OmReference [ '569' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:58.880683+03:00' ],		#prior : OmReference [ '569' ],		#self : OmReference [ '570' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:58.913683+03:00' ],		#prior : OmReference [ '570' ],		#self : OmReference [ '571' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:08',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:58.948683+03:00' ],		#prior : OmReference [ '571' ],		#self : OmReference [ '572' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:58.981683+03:00' ],		#prior : OmReference [ '572' ],		#self : OmReference [ '573' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.021683+03:00' ],		#prior : OmReference [ '573' ],		#self : OmReference [ '574' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.052683+03:00' ],		#prior : OmReference [ '574' ],		#self : OmReference [ '575' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.082683+03:00' ],		#prior : OmReference [ '575' ],		#self : OmReference [ '576' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:09',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.171683+03:00' ],		#prior : OmReference [ '576' ],		#self : OmReference [ '577' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.233683+03:00' ],		#prior : OmReference [ '577' ],		#self : OmReference [ '578' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:10',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.271683+03:00' ],		#prior : OmReference [ '578' ],		#self : OmReference [ '579' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:11',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.303683+03:00' ],		#prior : OmReference [ '579' ],		#self : OmReference [ '580' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:11',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.337683+03:00' ],		#prior : OmReference [ '580' ],		#self : OmReference [ '581' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #value,			#protocol : #'as yet unclassified',			#sourceCode : 'value\r\t^ value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:11',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:21:59.368683+03:00' ],		#prior : OmReference [ '581' ],		#self : OmReference [ '582' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:11',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:22:04.625683+03:00' ],		#prior : OmReference [ '582' ],		#self : OmReference [ '583' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:22:04.671683+03:00' ],		#prior : OmReference [ '583' ],		#self : OmReference [ '584' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:22:04.720683+03:00' ],		#prior : OmReference [ '584' ],		#self : OmReference [ '585' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:22:04.761683+03:00' ],		#prior : OmReference [ '585' ],		#self : OmReference [ '586' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:23:49.449683+03:00' ],		#prior : OmReference [ '586' ],		#self : OmReference [ '587' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\t\tsumLink := MetaLink new.\r\t\tsumLink metaObject: [ :sumValue | sumValue ~= 0 ifTrue: [ self highlightModels: { leftMatrixMarker . rightMatrixMarker } ] ].\r\t\tsumLink selector: #value:.\r\t\tsumLink arguments: #(value).\r\t\tsumLink control: #after.\r\t\tmatrixInstance link: sumLink toTemporaryNamed: #sum inMethod: method option: #write.\r\t\tleftMarkerLinkBefore := MetaLink new.\r\t\t\t\t\tleftMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr.\r\t\t\t\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "] ].\r\t\t\t\t\tleftMarkerLinkBefore selector: #value:.\r\t\t\t\t\tleftMarkerLinkBefore arguments: #(value).\r\t\t\t\t\tleftMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: leftMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\t\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\tleftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\t\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:21',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker} ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr\r\t\t\t\t\t"leftMarkerHighlightLink uninstall " ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:23:53.347683+03:00' ],		#prior : OmReference [ '587' ],		#self : OmReference [ '588' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:23:53.404683+03:00' ],		#prior : OmReference [ '588' ],		#self : OmReference [ '589' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:23:53.453683+03:00' ],		#prior : OmReference [ '589' ],		#self : OmReference [ '590' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:22',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:23:56.880683+03:00' ],		#prior : OmReference [ '590' ],		#self : OmReference [ '591' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:23:56.932683+03:00' ],		#prior : OmReference [ '591' ],		#self : OmReference [ '592' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:23:56.994683+03:00' ],		#prior : OmReference [ '592' ],		#self : OmReference [ '593' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:24:48.201683+03:00' ],		#prior : OmReference [ '593' ],		#self : OmReference [ '594' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker} ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr\r\t\t\t\t\t"leftMarkerHighlightLink uninstall " ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ \r\t\t\t\t\tself halt.\r\t\t\t\t\tself\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker} ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:24:51.313683+03:00' ],		#prior : OmReference [ '594' ],		#self : OmReference [ '595' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:24:51.368683+03:00' ],		#prior : OmReference [ '595' ],		#self : OmReference [ '596' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:26:04.805683+03:00' ],		#prior : OmReference [ '596' ],		#self : OmReference [ '597' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ \r\t\t\t\t\tself halt.\r\t\t\t\t\tself\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker} ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ \r\t\t\t\t\tself\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\t\t\tdelay wait. ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:26:07.864683+03:00' ],		#prior : OmReference [ '597' ],		#self : OmReference [ '598' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:26:07.929683+03:00' ],		#prior : OmReference [ '598' ],		#self : OmReference [ '599' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:26:07.995683+03:00' ],		#prior : OmReference [ '599' ],		#self : OmReference [ '600' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:19.632683+03:00' ],		#prior : OmReference [ '600' ],		#self : OmReference [ '601' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ \r\t\t\t\t\tself\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\t\t\tdelay wait. ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\t\t\tTranscript show: \'highlight \', (leftMatrixMarker row @ leftMatrixMarker column), \'&\', (rightMatrixMarker row @ rightMatrixMarker column);cr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:23.316683+03:00' ],		#prior : OmReference [ '601' ],		#self : OmReference [ '602' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:23.355683+03:00' ],		#prior : OmReference [ '602' ],		#self : OmReference [ '603' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:23.409683+03:00' ],		#prior : OmReference [ '603' ],		#self : OmReference [ '604' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:23.449683+03:00' ],		#prior : OmReference [ '604' ],		#self : OmReference [ '605' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:43.055683+03:00' ],		#prior : OmReference [ '605' ],		#self : OmReference [ '606' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\t\t\tTranscript show: \'highlight \', (leftMatrixMarker row @ leftMatrixMarker column), \'&\', (rightMatrixMarker row @ rightMatrixMarker column);cr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \' , (leftMatrixMarker row @ leftMatrixMarker column) asString , \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:46.308683+03:00' ],		#prior : OmReference [ '606' ],		#self : OmReference [ '607' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:46.357683+03:00' ],		#prior : OmReference [ '607' ],		#self : OmReference [ '608' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:27:46.395683+03:00' ],		#prior : OmReference [ '608' ],		#self : OmReference [ '609' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:28:19.748683+03:00' ],		#prior : OmReference [ '609' ],		#self : OmReference [ '610' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'highlightModels:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'highlightModels: modelCollection\r\tmodelCollection\r\t\tdo: [ :model | \r\t\t\t[ (view elementFromModel: model) color: Color red ]\r\t\t\t\ton: Error\r\t\t\t\tdo: [ :exception | nil ] ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormusyn 5/1/2019 18:09',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'highlightModels:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'highlightModels: modelCollection\r\tmodelCollection\r\t\tdo: [ :model | \r\t\t\t[ (view elementFromModel: model) color: Color yellow ]\r\t\t\t\ton: Error\r\t\t\t\tdo: [ :exception | nil ] ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormusyn 5/4/2019 16:28',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:28:45.617683+03:00' ],		#prior : OmReference [ '610' ],		#self : OmReference [ '611' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:28:45.671683+03:00' ],		#prior : OmReference [ '611' ],		#self : OmReference [ '612' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:28:45.713683+03:00' ],		#prior : OmReference [ '612' ],		#self : OmReference [ '613' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:34:56.074683+03:00' ],		#prior : OmReference [ '613' ],		#self : OmReference [ '614' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:34',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T16:34:56.117683+03:00' ],		#prior : OmReference [ '614' ],		#self : OmReference [ '615' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:34',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:11.084683+03:00' ],		#prior : OmReference [ '615' ],		#self : OmReference [ '616' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:11.128683+03:00' ],		#prior : OmReference [ '616' ],		#self : OmReference [ '617' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:11.167683+03:00' ],		#prior : OmReference [ '617' ],		#self : OmReference [ '618' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.073683+03:00' ],		#prior : OmReference [ '618' ],		#self : OmReference [ '619' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #'as yet unclassified',			#sourceCode : 'byMatrix: aCOOSparseMatrix\r\t| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode sum |\r\tcolumnNumber = aCOOSparseMatrix rowNumber\r\t\tifFalse: [ Error signal: \'Invalid matrix size\' ].\r\t(aCOOSparseMatrix isEmpty or: [ self isEmpty ])\r\t\tifTrue:\r\t\t\t[ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].\r\t\r\ttransposed := aCOOSparseMatrix transpose.\r\tleftSavedMatrixMarker := leftMatrixMarker := first.\r\trightMatrixMarker := transposed first.\r\tcurrentLeftRow := leftMatrixMarker row.\r\tcurrentRightColumn := rightMatrixMarker row.\r\tresult := self class\r\t\trows: rowNumber\r\t\tcolumns: aCOOSparseMatrix columnNumber.\r\tresult\r\t\tfirst:\r\t\t\t((COOSparseMatrixNode new row: 0 column: 0 value: 0)\r\t\t\t\trightNeighbour: nil).\r\tresult last: result first.\r\tsum := 0.\r\tself\r\t\twithEscaper: [ :end | \r\t\t\t[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]\r\t\t\t\twhileTrue: [ self\r\t\t\t\t\t\twithEscaper: [ :outer | \r\t\t\t\t\t\t\t"Switch to next row in left and reset right marker if right ended"\r\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\tifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.\r\t\t\t\t\t\t\t\t\trightMatrixMarker := transposed first ].\r\t\t\t\t\t\t\t"reset left marker to row beginning"\r\t\t\t\t\t\t\tleftMatrixMarker := leftSavedMatrixMarker.\r\t\t\t\t\t\t\tcurrentLeftRow := leftMatrixMarker row.\r\t\t\t\t\t\t\tcurrentRightColumn := rightMatrixMarker row.\r\t\t\t\t\t\t\tself\r\t\t\t\t\t\t\t\twithEscaper: [ :next | \r\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ] ] ]\r\t\t\t\t\t\t\t\t\t\twhileTrue: [ priorityColumn := {leftMatrixMarker column.\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker column} max.\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in left"\r\t\t\t\t\t\t\t\t\t\t\t[ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersection - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker row ~= currentLeftRow\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\tpriorityColumn := leftMatrixMarker column.\r\r\t\t\t\t\t\t\t\t\t\t\t"Find same column as prioritized or higher in right"\r\t\t\t\t\t\t\t\t\t\t\t[ rightMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker row = currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ rightMatrixMarker column < priorityColumn ] ] ]\r\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ [ leftMatrixMarker isNotNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tand: [ leftMatrixMarker row = currentLeftRow ] ]\r\t\t\t\t\t\t\t\t\t\t\t\t\t\twhileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].\r\r\t\t\t\t\t\t\t\t\t\t\t\t\t"If no intersections - end"\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker isNil\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ end value ].\r\t\t\t\t\t\t\t\t\t\t\t\t\t"Else - continue loop"\r\t\t\t\t\t\t\t\t\t\t\t\t\tnext value ].\r\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker row ~= currentRightColumn\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ next value ].\r\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker column = rightMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\t\t\t\t\t\t\tifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].\r\t\t\t\t\t\t\tsum = 0\r\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\t\t\tsum := 0 ] ].\r\t\t\t\t\tsum = 0\r\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: currentLeftRow\r\t\t\t\t\t\t\t\tcolumn: currentRightColumn\r\t\t\t\t\t\t\t\tvalue: sum.\r\t\t\t\t\t\t\tresult last rightNeighbour: newNode.\r\t\t\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\t\t\tresult last: newNode.\r\t\t\t\t\t\t\tsum := 0 ] ] ].\r\t"nil the reference to dummy head"\r\tresult first rightNeighbour leftNeighbour: nil.\r\tresult first: result first rightNeighbour.\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.119683+03:00' ],		#prior : OmReference [ '619' ],		#self : OmReference [ '620' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.159683+03:00' ],		#prior : OmReference [ '620' ],		#self : OmReference [ '621' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.197683+03:00' ],		#prior : OmReference [ '621' ],		#self : OmReference [ '622' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:23',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.296683+03:00' ],		#prior : OmReference [ '622' ],		#self : OmReference [ '623' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.342683+03:00' ],		#prior : OmReference [ '623' ],		#self : OmReference [ '624' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.378683+03:00' ],		#prior : OmReference [ '624' ],		#self : OmReference [ '625' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.417683+03:00' ],		#prior : OmReference [ '625' ],		#self : OmReference [ '626' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:24',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.509683+03:00' ],		#prior : OmReference [ '626' ],		#self : OmReference [ '627' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.561683+03:00' ],		#prior : OmReference [ '627' ],		#self : OmReference [ '628' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.599683+03:00' ],		#prior : OmReference [ '628' ],		#self : OmReference [ '629' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.640683+03:00' ],		#prior : OmReference [ '629' ],		#self : OmReference [ '630' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.733683+03:00' ],		#prior : OmReference [ '630' ],		#self : OmReference [ '631' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.795683+03:00' ],		#prior : OmReference [ '631' ],		#self : OmReference [ '632' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.834683+03:00' ],		#prior : OmReference [ '632' ],		#self : OmReference [ '633' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.939683+03:00' ],		#prior : OmReference [ '633' ],		#self : OmReference [ '634' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:50.978683+03:00' ],		#prior : OmReference [ '634' ],		#self : OmReference [ '635' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.015683+03:00' ],		#prior : OmReference [ '635' ],		#self : OmReference [ '636' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.054683+03:00' ],		#prior : OmReference [ '636' ],		#self : OmReference [ '637' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.143683+03:00' ],		#prior : OmReference [ '637' ],		#self : OmReference [ '638' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 16:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.202683+03:00' ],		#prior : OmReference [ '638' ],		#self : OmReference [ '639' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.243683+03:00' ],		#prior : OmReference [ '639' ],		#self : OmReference [ '640' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:28',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.342683+03:00' ],		#prior : OmReference [ '640' ],		#self : OmReference [ '641' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 16:34',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.387683+03:00' ],		#prior : OmReference [ '641' ],		#self : OmReference [ '642' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 16:34',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.429683+03:00' ],		#prior : OmReference [ '642' ],		#self : OmReference [ '643' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 16:34',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.527683+03:00' ],		#prior : OmReference [ '643' ],		#self : OmReference [ '644' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:51.582683+03:00' ],		#prior : OmReference [ '644' ],		#self : OmReference [ '645' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:54.078683+03:00' ],		#prior : OmReference [ '645' ],		#self : OmReference [ '646' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:54.121683+03:00' ],		#prior : OmReference [ '646' ],		#self : OmReference [ '647' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T17:26:54.166683+03:00' ],		#prior : OmReference [ '647' ],		#self : OmReference [ '648' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T21:52:37.834683+03:00' ],		#prior : OmReference [ '648' ],		#self : OmReference [ '649' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 21:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T21:52:37.888683+03:00' ],		#prior : OmReference [ '649' ],		#self : OmReference [ '650' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 21:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T21:52:37.938683+03:00' ],		#prior : OmReference [ '650' ],		#self : OmReference [ '651' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 21:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T21:53:08.917683+03:00' ],		#prior : OmReference [ '651' ],		#self : OmReference [ '652' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\t"resultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write."\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \' , (leftMatrixMarker row @ leftMatrixMarker column) asString , \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 16:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 21:53',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T21:56:28.359683+03:00' ],		#prior : OmReference [ '652' ],		#self : OmReference [ '653' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\t"leftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write."\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t"leftMarkerHighlightLink uninstall "\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"| leftMarkerHighlightLink |\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after."\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\t"| rightMarkerHighlightLink |\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'highlight right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ].\r\t\t\trightMarkerHighlightLink selector: #value.\r\t\t\trightMarkerHighlightLink control: #after."\r\t\t\t"bind the highlight to actual marker element"\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ "rightMarkerLinkBefore := MetaLink new.\r\t\t\t\t\trightMarkerLinkBefore\r\t\t\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t\t\tvalue isNotNil\r\t\t\t\t\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\t\t\t\t\tcr. ] ].\r\t\t\t\t\trightMarkerLinkBefore selector: #value:.\r\t\t\t\t\trightMarkerLinkBefore arguments: #(value).\r\t\t\t\t\trightMarkerLinkBefore control: #before.\r\t\t\t\t\tmatrixInstance\r\t\t\t\t\t\tlink: rightMarkerLinkBefore\r\t\t\t\t\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\t\t\t\t\tinMethod: method\r\t\t\t\t\t\toption: #write."\r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 21:53',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 21:56',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:03:26.698683+03:00' ],		#prior : OmReference [ '653' ],		#self : OmReference [ '654' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ \r\t\t\t\t\trightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 21:56',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t\t\t "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait  ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:03:39.523683+03:00' ],		#prior : OmReference [ '654' ],		#self : OmReference [ '655' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t\t\t "select the element and update the view otherwise"\r\t\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait  ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:03',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:03:56.602683+03:00' ],		#prior : OmReference [ '655' ],		#self : OmReference [ '656' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:03',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:04:02.089683+03:00' ],		#prior : OmReference [ '656' ],		#self : OmReference [ '657' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:05:02.711683+03:00' ],		#prior : OmReference [ '657' ],		#self : OmReference [ '658' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t\tself selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:03',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t\t\tself halt.\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:06:43.474683+03:00' ],		#prior : OmReference [ '658' ],		#self : OmReference [ '659' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:06',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:07:14.010683+03:00' ],		#prior : OmReference [ '659' ],		#self : OmReference [ '660' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t\t\tself halt.\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:05',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\tifFalse: [self halt].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:12:19.418683+03:00' ],		#prior : OmReference [ '660' ],		#self : OmReference [ '661' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForResultOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:12:19.424683+03:00' ],		#prior : OmReference [ '661' ],		#self : OmReference [ '662' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForResultOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:12',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:14:20.446683+03:00' ],		#prior : OmReference [ '662' ],		#self : OmReference [ '663' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForRightMatrixOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForRightMatrixOn: matrixInstance inMethod: methodName\r|transposedRightMatrixLink|\rtransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:14:20.450683+03:00' ],		#prior : OmReference [ '663' ],		#self : OmReference [ '664' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForRightMatrixOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForRightMatrixOn: matrixInstance inMethod: methodName\r|transposedRightMatrixLink|\rtransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:14',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForRightMatrixOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForRightMatrixOn: matrixInstance inMethod: methodName\r|transposedRightMatrixLink|\rtransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:16:26.474683+03:00' ],		#prior : OmReference [ '664' ],		#self : OmReference [ '665' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r|leftRowIndexLink rightColumnIndexLink|\rleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\t\t\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:16',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:16:26.479683+03:00' ],		#prior : OmReference [ '665' ],		#self : OmReference [ '666' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r|leftRowIndexLink rightColumnIndexLink|\rleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\t\t\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:16',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r|leftRowIndexLink rightColumnIndexLink|\rleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\t\t\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:16',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:39:12.179683+03:00' ],		#prior : OmReference [ '666' ],		#self : OmReference [ '667' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: method\r\t\toption: #write.\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: method\r\t\toption: #write.\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: method\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: method\r\t\toption: #write.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\tifFalse: [self halt].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self halt ].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:39',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:39:24.097683+03:00' ],		#prior : OmReference [ '667' ],		#self : OmReference [ '668' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ]\r\t\t\t\tifFalse: [ self halt ].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:39',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:39',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:42:13.626683+03:00' ],		#prior : OmReference [ '668' ],		#self : OmReference [ '669' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:39',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil ifTrue: [self selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:42',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:42:52.434683+03:00' ],		#prior : OmReference [ '669' ],		#self : OmReference [ '670' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil ifTrue: [self selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\tself selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:42',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil ifTrue: [self selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:42',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:44:31.343683+03:00' ],		#prior : OmReference [ '670' ],		#self : OmReference [ '671' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil ifTrue: [self selectModel: element.\r\t\t\tTranscript\r\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\tcr.\r\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\tdelay wait] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:42',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:44:52.991683+03:00' ],		#prior : OmReference [ '671' ],		#self : OmReference [ '672' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:14.545683+03:00' ],		#prior : OmReference [ '672' ],		#self : OmReference [ '673' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 21:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:14.608683+03:00' ],		#prior : OmReference [ '673' ],		#self : OmReference [ '674' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 21:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:14.664683+03:00' ],		#prior : OmReference [ '674' ],		#self : OmReference [ '675' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 21:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:14.773683+03:00' ],		#prior : OmReference [ '675' ],		#self : OmReference [ '676' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:14.824683+03:00' ],		#prior : OmReference [ '676' ],		#self : OmReference [ '677' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:14.868683+03:00' ],		#prior : OmReference [ '677' ],		#self : OmReference [ '678' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 17:26',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:14.946683+03:00' ],		#prior : OmReference [ '678' ],		#self : OmReference [ '679' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.015683+03:00' ],		#prior : OmReference [ '679' ],		#self : OmReference [ '680' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.067683+03:00' ],		#prior : OmReference [ '680' ],		#self : OmReference [ '681' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 22:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.115683+03:00' ],		#prior : OmReference [ '681' ],		#self : OmReference [ '682' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 22:04',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.214683+03:00' ],		#prior : OmReference [ '682' ],		#self : OmReference [ '683' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:06',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.279683+03:00' ],		#prior : OmReference [ '683' ],		#self : OmReference [ '684' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 22:06',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.329683+03:00' ],		#prior : OmReference [ '684' ],		#self : OmReference [ '685' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 22:06',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.375683+03:00' ],		#prior : OmReference [ '685' ],		#self : OmReference [ '686' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:06',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.480683+03:00' ],		#prior : OmReference [ '686' ],		#self : OmReference [ '687' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:07',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.548683+03:00' ],		#prior : OmReference [ '687' ],		#self : OmReference [ '688' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 22:07',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.598683+03:00' ],		#prior : OmReference [ '688' ],		#self : OmReference [ '689' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 22:07',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.711683+03:00' ],		#prior : OmReference [ '689' ],		#self : OmReference [ '690' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.760683+03:00' ],		#prior : OmReference [ '690' ],		#self : OmReference [ '691' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.811683+03:00' ],		#prior : OmReference [ '691' ],		#self : OmReference [ '692' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.860683+03:00' ],		#prior : OmReference [ '692' ],		#self : OmReference [ '693' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:15.958683+03:00' ],		#prior : OmReference [ '693' ],		#self : OmReference [ '694' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'first:',			#protocol : #'as yet unclassified',			#sourceCode : 'first: aCOOMatrixNode\r\tfirst := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:16.020683+03:00' ],		#prior : OmReference [ '694' ],		#self : OmReference [ '695' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: rowIndex at: columnIndex put: aValue\r\t| leftNeighbour rightNeighbour newNode |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [ SubscriptOutOfBounds signal: \'Invalid index.\' ].\r\taValue = 0\r\t\tifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].\r\tnewNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.\r\tself isEmpty\r\t\tifTrue: [ first := newNode.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\t(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])\r\t\tifTrue: [ first leftNeighbour: newNode.\r\t\t\tnewNode rightNeighbour: first.\r\t\t\tfirst := newNode.\r\t\t\t^ self ].\r\t(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])\r\t\tifTrue: [ last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: last.\r\t\t\tlast := newNode.\r\t\t\t^ self ].\r\tleftNeighbour := first.\r\tleftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)\r\t\tifTrue: [ leftNeighbour value: aValue.\r\t\t\t^ self ].\r\t[ leftNeighbour rightNeighbour isNotNil\r\t\tand: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]\r\t\twhileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].\r\t(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])\r\t\tifTrue: [ leftNeighbour rightNeighbour value: aValue.\r\t\t\t^ self ].\r\trightNeighbour := leftNeighbour rightNeighbour.\r\tnewNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.\r\trightNeighbour leftNeighbour: newNode.\r\tleftNeighbour rightNeighbour: newNode',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:16.069683+03:00' ],		#prior : OmReference [ '695' ],		#self : OmReference [ '696' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'as yet unclassified',			#sourceCode : 'withAll: aCollection\r\t| list |\r\tlist := ((1 to: aCollection size)\r\t\tcollect: [ :rowIndex | \r\t\t\t(1 to: (aCollection at: rowIndex) size)\r\t\t\t\tcollect: [ :colIndex | \r\t\t\t\t\tCOOSparseMatrixNode\r\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\tcolumn: colIndex\r\t\t\t\t\t\tvalue: ((aCollection at: rowIndex) at: colIndex) ]\r\t\t\t\tthenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.\r\tlist := list inject: OrderedCollection new into: [ :array :each | array , each ].\r\t(list at: 1) rightNeighbour: (list at: 2).\r\tlist at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).\r\t(2 to: list size - 1)\r\t\tdo:\r\t\t\t[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].\r\tfirst := list at: 1.\r\tlast := list at: list size',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:16.121683+03:00' ],		#prior : OmReference [ '696' ],		#self : OmReference [ '697' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'removeAt:at:',			#protocol : #'as yet unclassified',			#sourceCode : 'removeAt: rowIndex at: columnIndex\r\t| marker |\r\t(self validAt: rowIndex at: columnIndex)\r\t\tifFalse: [SubscriptOutOfBounds signal: \'Invalid index\'].\r\tself isEmpty\r\t\tifTrue: [ ^ self ].\r\t\r\t( first row = rowIndex ) & ( first column = columnIndex )\r\t\tifTrue: [ first rightNeighbour isNotNil\r\t\t\t\t\tifTrue: [ first rightNeighbour leftNeighbour: nil. \r\t\t\t\t\t\t\tfirst := first rightNeighbour]\r\t\t\t\t\tifFalse: [ first := nil.\r\t\t\t\t\t\t\tlast := nil ] ].\r\t\r\t( last row = rowIndex ) & ( last column = columnIndex )\r\t\tifTrue: [ last leftNeighbour isNotNil\r\t\t\t\t\tifTrue: [ last leftNeighbour rightNeighbour: nil. \r\t\t\t\t\t\t\tlast := last leftNeighbour ]\r\t\t\t\t\tifFalse: [ last := nil.\r\t\t\t\t\t\t\tfirst := nil ] ].\r\t\r\tmarker := first .\r\t[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ].\r\t\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])\r\t\tifTrue: [\r\t\t\t[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]\r\t\t\t\t\t\twhileTrue: [ marker := marker rightNeighbour ]]\r\t\tifFalse: [ ^ self ].\r\t(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])\r\tifTrue: [\r\t\tmarker leftNeighbour rightNeighbour: marker rightNeighbour.\r\t\tmarker rightNeighbour leftNeighbour: marker leftNeighbour].\r\t^ self',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:45:22.978683+03:00' ],		#prior : OmReference [ '697' ],		#self : OmReference [ '698' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:45',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:49:29.027683+03:00' ],		#prior : OmReference [ '698' ],		#self : OmReference [ '699' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectModel:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectModel: model\r\t[ (view elementFromModel: model) color: Color red ]\r\t\ton: Error\r\t\tdo: [ :exception | nil ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormusyn 5/1/2019 18:09',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectModel:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectModel: model\r\t[ (view elementFromModel: model) color: Color red ]\r\t\ton: Error\r\t\tdo: [ :exception | nil. Transcript show: \'fucked up\' ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormusyn 5/4/2019 22:49',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:49:38.616683+03:00' ],		#prior : OmReference [ '699' ],		#self : OmReference [ '700' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:49',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:51:18.376683+03:00' ],		#prior : OmReference [ '700' ],		#self : OmReference [ '701' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeMultiplicationView,			#protocol : #initialization,			#sourceCode : 'initializeMultiplicationView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker',			#stamp : 'YaroslavKormusyn 5/1/2019 23:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeMultiplicationView,			#protocol : #initialization,			#sourceCode : 'initializeMultiplicationView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\tself selectModels: {leftMarkerElement model.rightMarkerElement model}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:51',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:51:30.415683+03:00' ],		#prior : OmReference [ '701' ],		#self : OmReference [ '702' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:51',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:51:47.338683+03:00' ],		#prior : OmReference [ '702' ],		#self : OmReference [ '703' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectModel:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectModel: model\r\t[ (view elementFromModel: model) color: Color red ]\r\t\ton: Error\r\t\tdo: [ :exception | nil. Transcript show: \'fucked up\' ].\r\tself view signalUpdate',			#stamp : 'YaroslavKormusyn 5/4/2019 22:49',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #RTComposer,				#isMetaSide : false			},			#name : #'selectModel:',			#protocol : #'*LNU-SparseMatrix',			#sourceCode : 'selectModel: model\r\t[ (view elementFromModel: model) color: Color red ]\r\t\ton: Error\r\t\tdo: [ :exception | \r\t\t\tnil.].\r\tself view signalUpdate',			#stamp : 'YaroslavKormusyn 5/4/2019 22:51',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:52:16.833683+03:00' ],		#prior : OmReference [ '703' ],		#self : OmReference [ '704' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 22:52',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:57:51.344683+03:00' ],		#prior : OmReference [ '704' ],		#self : OmReference [ '705' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r|leftRowIndexLink rightColumnIndexLink|\rleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\t\t\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:16',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ]; selector: #value:;arguments: #(value);control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 22:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T22:58:10.764683+03:00' ],		#prior : OmReference [ '705' ],		#self : OmReference [ '706' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ]; selector: #value:;arguments: #(value);control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 22:57',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ];\r\t\tselector: #value:;\r\t\targuments: #(value);\r\t\tcontrol: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ];selector: #value:;arguments: #(value);control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 22:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:00:18.635683+03:00' ],		#prior : OmReference [ '706' ],		#self : OmReference [ '707' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormusyn 5/4/2019 23:00',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:01:18.177683+03:00' ],		#prior : OmReference [ '707' ],		#self : OmReference [ '708' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ];\r\t\tselector: #value:;\r\t\targuments: #(value);\r\t\tcontrol: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ];selector: #value:;arguments: #(value);control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 22:58',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\t\tleftRowIndexLink selector: #value:.\r\t\tleftRowIndexLink arguments: #(value).\r\t\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\t\trightColumnIndexLink selector: #value:.\r\t\trightColumnIndexLink arguments: #(value).\r\t\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:03:27.953683+03:00' ],		#prior : OmReference [ '708' ],		#self : OmReference [ '709' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'setMultiInitLinksOn:',		#newSelector : #'setMultiLinksOn:',		#affectedClassName : #COOSparseMatrixOperationVisualizer	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '709' ],		#self : OmReference [ '710' ],		#time : DateAndTime [ '2019-05-04T23:03:27.990683+03:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\rself subclassResponsibility ',			#stamp : 'YaroslavKormusyn 5/4/2019 23:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '710' ],		#self : OmReference [ '711' ],		#time : DateAndTime [ '2019-05-04T23:03:28.006683+03:00' ],		#trigger : OmReference [ '709' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 23:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '711' ],		#self : OmReference [ '712' ],		#time : DateAndTime [ '2019-05-04T23:03:28.016683+03:00' ],		#trigger : OmReference [ '709' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiInitLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 14:21',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'multiplyAnimated:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'multiplyAnimated: left by: right\r\t"remember matrices for reference in links"\r\r\tleftMatrix := left.\r\trightMatrix := right.\r\t"process of multiplication"\r\tprocess := [ leftMatrix byMatrix: rightMatrix ] newProcess.\r\t"set initial links to initialize the view"\r\r\t"the process runs until all the initialization is done and the view is in its initial state"\r\t[ self setMultiLinksOn: leftMatrix.\r\tprocess resume.\r\tsemaphore wait ] on: Error fork: [ :ex | Error signal: ex ].\r\r\tself setUpMenuWithProcess: process.\r\t^ composer view',			#stamp : 'YaroslavKormusyn 5/4/2019 23:03',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '712' ],		#self : OmReference [ '713' ],		#time : DateAndTime [ '2019-05-04T23:03:28.020683+03:00' ],		#trigger : OmReference [ '709' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\rself subclassResponsibility ',			#stamp : 'YaroslavKormusyn 5/1/2019 20:52',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'setMultiInitLinksOn: matrixInstance\rself subclassResponsibility ',			#stamp : 'YaroslavKormusyn 5/1/2019 20:52',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '713' ],		#self : OmReference [ '714' ],		#time : DateAndTime [ '2019-05-04T23:03:28.023683+03:00' ],		#trigger : OmReference [ '709' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\rself subclassResponsibility ',			#stamp : 'YaroslavKormusyn 5/1/2019 20:52',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '714' ],		#self : OmReference [ '715' ],		#time : DateAndTime [ '2019-05-04T23:03:28.058683+03:00' ],		#trigger : OmReference [ '709' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '715' ],		#self : OmReference [ '716' ],		#time : DateAndTime [ '2019-05-04T23:03:28.152683+03:00' ],		#trigger : OmReference [ '709' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiInitLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiInitLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 22:44',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:04:59.981683+03:00' ],		#prior : OmReference [ '716' ],		#self : OmReference [ '717' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'setLinksForRightMatrixOn:inMethod:',		#newSelector : #'setMultiLinksForRightMatrixOn:inMethod:',		#affectedClassName : 'setLinksForRightMatrixOn: matrixInstance inMethod: methodName\r\t| transposedRightMatrixLink |\r\ttransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write'	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '717' ],		#self : OmReference [ '718' ],		#time : DateAndTime [ '2019-05-04T23:05:00.007683+03:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForRightMatrixOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForRightMatrixOn: matrixInstance inMethod: methodName\r|transposedRightMatrixLink|\rtransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 23:04',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '718' ],		#self : OmReference [ '719' ],		#time : DateAndTime [ '2019-05-04T23:05:00.027683+03:00' ],		#trigger : OmReference [ '717' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 23:03',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setMultiLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '719' ],		#self : OmReference [ '720' ],		#time : DateAndTime [ '2019-05-04T23:05:00.137683+03:00' ],		#trigger : OmReference [ '717' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForRightMatrixOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForRightMatrixOn: matrixInstance inMethod: methodName\r|transposedRightMatrixLink|\rtransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:14',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForRightMatrixOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForRightMatrixOn: matrixInstance inMethod: methodName\r|transposedRightMatrixLink|\rtransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '720' ],		#self : OmReference [ '721' ],		#time : DateAndTime [ '2019-05-04T23:05:00.143683+03:00' ],		#trigger : OmReference [ '717' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForRightMatrixOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForRightMatrixOn: matrixInstance inMethod: methodName\r|transposedRightMatrixLink|\rtransposedRightMatrixLink := MetaLink new.\r\ttransposedRightMatrixLink\r\t\tmetaObject: [ :value | rightMatrix := value ].\r\ttransposedRightMatrixLink selector: #value:.\r\ttransposedRightMatrixLink arguments: #(value).\r\ttransposedRightMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: transposedRightMatrixLink\r\t\ttoTemporaryNamed: #transposed\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:14',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:05:18.746683+03:00' ],		#prior : OmReference [ '721' ],		#self : OmReference [ '722' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'setLinksForResultOn:inMethod:',		#newSelector : #'setMultiLinksForResultOn:inMethod:',		#affectedClassName : 'setLinksForResultOn: matrixInstance inMethod: methodName\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write'	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '722' ],		#self : OmReference [ '723' ],		#time : DateAndTime [ '2019-05-04T23:05:18.776683+03:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '723' ],		#self : OmReference [ '724' ],		#time : DateAndTime [ '2019-05-04T23:05:18.790683+03:00' ],		#trigger : OmReference [ '722' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setMultiLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setMultiLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setMultiLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '724' ],		#self : OmReference [ '725' ],		#time : DateAndTime [ '2019-05-04T23:05:18.798683+03:00' ],		#trigger : OmReference [ '722' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:12',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForResultOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '725' ],		#self : OmReference [ '726' ],		#time : DateAndTime [ '2019-05-04T23:05:18.868683+03:00' ],		#trigger : OmReference [ '722' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 22:12',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:05:52.555683+03:00' ],		#prior : OmReference [ '726' ],		#self : OmReference [ '727' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'setLinksForProcessedElementIndexOn:inMethod:',		#newSelector : #'setMultiLinksForCurrProcElementIndexOn:inMethod:',		#affectedClassName : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write'	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '727' ],		#self : OmReference [ '728' ],		#time : DateAndTime [ '2019-05-04T23:05:52.583683+03:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForCurrProcElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForCurrProcElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\t\tleftRowIndexLink selector: #value:.\r\t\tleftRowIndexLink arguments: #(value).\r\t\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\t\trightColumnIndexLink selector: #value:.\r\t\trightColumnIndexLink arguments: #(value).\r\t\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '728' ],		#self : OmReference [ '729' ],		#time : DateAndTime [ '2019-05-04T23:05:52.597683+03:00' ],		#trigger : OmReference [ '727' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setLinksForProcessedElementIndexOn: matrixInstance inMethod: method.\r\tself setMultiLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setMultiLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksOn:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksOn: matrixInstance\r\t| leftRowIndexLink rightColumnIndexLink leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter resultMatrixLink transposedRightMatrixLink method sumLink |\r\tmethod := #byMatrix:.\r\tself setMultiLinksForCurrProcElementIndexOn: matrixInstance inMethod: method.\r\tself setMultiLinksForResultOn: matrixInstance inMethod: method.\r\t\tself setMultiLinksForRightMatrixOn: matrixInstance inMethod: method.\r\t\t\tsumLink := MetaLink new.\r\tsumLink\r\t\tmetaObject: [ :sumValue | \r\t\t\tsumValue ~= 0\r\t\t\t\tifTrue: [ self\r\t\t\t\t\t\thighlightModels:\r\t\t\t\t\t\t\t{leftMatrixMarker.\r\t\t\t\t\t\t\trightMatrixMarker}.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow:\r\t\t\t\t\t\t\t\'highlight \'\r\t\t\t\t\t\t\t\t, (leftMatrixMarker row @ leftMatrixMarker column) asString\r\t\t\t\t\t\t\t\t, \'&\'\r\t\t\t\t\t\t\t\t, (rightMatrixMarker row @ rightMatrixMarker column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tdelay wait ] ].\r\tsumLink selector: #value:.\r\tsumLink arguments: #(value).\r\tsumLink control: #after.\r\tmatrixInstance\r\t\tlink: sumLink\r\t\ttoTemporaryNamed: #sum\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect left \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\tleftMatrixMarker := element.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select left \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'deselect right \' , (value row @ value column) asString;\r\t\t\t\t\t\tcr ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\trightMatrixMarker := element.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'select right \' , (element row @ element column) asString;\r\t\t\t\t\t\tcr.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftRowIndexLink.\r\t\t\trightColumnIndexLink.\r\t\t\tleftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tresultMatrixLink.\r\t\t\ttransposedRightMatrixLink}',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '729' ],		#self : OmReference [ '730' ],		#time : DateAndTime [ '2019-05-04T23:05:52.607683+03:00' ],		#trigger : OmReference [ '727' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\t\tleftRowIndexLink selector: #value:.\r\t\tleftRowIndexLink arguments: #(value).\r\t\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\t\trightColumnIndexLink selector: #value:.\r\t\trightColumnIndexLink arguments: #(value).\r\t\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:01',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #'as yet unclassified',			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\t\tleftRowIndexLink selector: #value:.\r\t\tleftRowIndexLink arguments: #(value).\r\t\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\t\trightColumnIndexLink selector: #value:.\r\t\trightColumnIndexLink arguments: #(value).\r\t\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#prior : OmReference [ '730' ],		#self : OmReference [ '731' ],		#time : DateAndTime [ '2019-05-04T23:05:52.687683+03:00' ],		#trigger : OmReference [ '727' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setLinksForProcessedElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setLinksForProcessedElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\t\tleftRowIndexLink selector: #value:.\r\t\tleftRowIndexLink arguments: #(value).\r\t\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\t\trightColumnIndexLink selector: #value:.\r\t\trightColumnIndexLink arguments: #(value).\r\t\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:06:24.469683+03:00' ],		#prior : OmReference [ '731' ],		#self : OmReference [ '732' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForCurrProcElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForCurrProcElementIndexOn: matrixInstance inMethod: methodName\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\t\tleftRowIndexLink selector: #value:.\r\t\tleftRowIndexLink arguments: #(value).\r\t\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\t\trightColumnIndexLink selector: #value:.\r\t\trightColumnIndexLink arguments: #(value).\r\t\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForCurrProcElementIndexOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForCurrProcElementIndexOn: matrixInstance inMethod: methodName\r"Set links for the index in label \'Now processing\'"\r\t| leftRowIndexLink rightColumnIndexLink |\r\tleftRowIndexLink := MetaLink new.\r\tleftRowIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentLeftRow := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{value.\r\t\t\t\t\tcurrentRightColumn}.\r\t\t\tnowProcessingElementIndex update ].\r\tleftRowIndexLink selector: #value:.\r\tleftRowIndexLink arguments: #(value).\r\tleftRowIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: leftRowIndexLink\r\t\ttoTemporaryNamed: #currentLeftRow\r\t\tinMethod: methodName\r\t\toption: #write.\r\trightColumnIndexLink := MetaLink new.\r\trightColumnIndexLink\r\t\tmetaObject: [ :value | \r\t\t\tcurrentRightColumn := value.\r\t\t\tnowProcessingElementIndex\r\t\t\t\tmodel:\r\t\t\t\t\t{currentLeftRow.\r\t\t\t\t\tvalue}.\r\t\t\tnowProcessingElementIndex update ].\r\trightColumnIndexLink selector: #value:.\r\trightColumnIndexLink arguments: #(value).\r\trightColumnIndexLink control: #after.\r\tmatrixInstance\r\t\tlink: rightColumnIndexLink\r\t\ttoTemporaryNamed: #currentRightColumn\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:06',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:07:33.957683+03:00' ],		#prior : OmReference [ '732' ],		#self : OmReference [ '733' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r|resultMatrixLink|\rresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write.',			#stamp : 'YaroslavKormusyn 5/4/2019 23:05',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r"Set links for result matrix update on viewer"\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:07',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:08:34.884683+03:00' ],		#prior : OmReference [ '733' ],		#self : OmReference [ '734' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r"Set links for result matrix update on viewer"\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:07',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:08:49.324683+03:00' ],		#prior : OmReference [ '734' ],		#self : OmReference [ '735' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'updated last in result -> new 2nd rec link\';\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:08:55.158683+03:00' ],		#prior : OmReference [ '735' ],		#self : OmReference [ '736' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated last in result -> 2nd rec link\';\r\t\t\t\t\t\tcr.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value.].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:08',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-04T23:09:56.694683+03:00' ],		#prior : OmReference [ '736' ],		#self : OmReference [ '737' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:08',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setMultiLinksForResultOn:inMethod:',			#protocol : #initialization,			#sourceCode : 'setMultiLinksForResultOn: matrixInstance inMethod: methodName\r\t"Set links for result matrix update on viewer"\r\r\t| resultMatrixLink |\r\tresultMatrixLink := MetaLink new.\r\tresultMatrixLink\r\t\tmetaObject: [ :value | \r\t\t\t| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |\r\t\t\tresultMatrix := value.\r\t\t\t"initialize the view for the updates not to fail"\r\t\t\tself initializeMultiplicationView.\r\t\t\tself setPositionsForMultiplication.\r\t\t\tresultMatrixUpdateLinkFirst := MetaLink new.\r\t\t\tresultMatrixUpdateLinkFirst\r\t\t\t\tmetaObject: [ self updateResultWith: value.\r\t\t\t\t\tTranscript\r\t\t\t\t\t\tshow: \'updated first in result -> 2nd rec link\';\r\t\t\t\t\t\tcr ].\r\t\t\tresultMatrixUpdateLinkFirst selector: #value.\r\t\t\tresultMatrixUpdateLinkFirst control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkFirst\r\t\t\t\ttoSlotNamed: #first\r\t\t\t\toption: #write.\r\t\t\tresultMatrixUpdateLinkLast := MetaLink new.\r\t\t\tresultMatrixUpdateLinkLast\r\t\t\t\tmetaObject: [ | newResultUpdateLastLink |\r\t\t\t\t\tself updateResultWith: value.\r\t\t\t\t\t"uninstall the initial block which suspends the process"\r\t\t\t\t\t\r\t\t\t\t\tresultMatrixUpdateLinkLast uninstall.\r\t\t\t\t\t"replace it with a new one without the suspend"\r\t\t\t\t\tnewResultUpdateLastLink := MetaLink new.\r\t\t\t\t\tnewResultUpdateLastLink\r\t\t\t\t\t\tmetaObject: [ self updateResultWith: value ].\r\t\t\t\t\tnewResultUpdateLastLink selector: #value.\r\t\t\t\t\tnewResultUpdateLastLink control: #after.\r\t\t\t\t\tvalue\r\t\t\t\t\t\tlink: newResultUpdateLastLink\r\t\t\t\t\t\ttoSlotNamed: #last\r\t\t\t\t\t\toption: #write.\r\t\t\t\t\t"signal to root multiplication method that we finished initializing"\r\t\t\t\t\tsemaphore signal.\r\t\t\t\t\t"wait for input before starting the operation"\r\t\t\t\t\tprocess suspend ].\r\t\t\tresultMatrixUpdateLinkLast selector: #value.\r\t\t\tresultMatrixUpdateLinkLast control: #after.\r\t\t\tvalue\r\t\t\t\tlink: resultMatrixUpdateLinkLast\r\t\t\t\ttoSlotNamed: #last\r\t\t\t\toption: #write ].\r\tresultMatrixLink selector: #value:.\r\tresultMatrixLink arguments: #(value).\r\tresultMatrixLink control: #after.\r\tmatrixInstance\r\t\tlink: resultMatrixLink\r\t\ttoTemporaryNamed: #result\r\t\tinMethod: methodName\r\t\toption: #write',			#stamp : 'YaroslavKormusyn 5/4/2019 23:09',			#package : #LNU-SparseMatrix		}	}}