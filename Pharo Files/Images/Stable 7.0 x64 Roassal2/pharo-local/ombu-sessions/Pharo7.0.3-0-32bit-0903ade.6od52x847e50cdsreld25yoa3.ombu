OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T11:58:56.725083+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.dgwhi1647nwg473fxnnmt5kin', '47' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #byMatrix:.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"check what the stack top after copy is - maybe it has the new object which we\'ll use to bind to value: and highlight both elements"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter.\r\t\t\tsumLink}',			#stamp : 'YaroslavKormusyn 5/5/2019 00:20',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #'setAdditionLinksOn:',			#protocol : #initialization,			#sourceCode : 'setAdditionLinksOn: matrixInstance\r\t| leftMarkerLinkBefore leftMarkerLinkAfter rightMarkerLinkBefore rightMarkerLinkAfter method sumLink |\r\tmethod := #byMatrix:.\r\t"self\r\t\tsetMultiLinksForCurrProcElementIndexOn: matrixInstance\r\t\tinMethod: method."\r\tself setAdditionLinksForResultOn: matrixInstance inMethod: method.\r\t"self setAdditionLinksForRightMatrixOn: matrixInstance inMethod: method."\r\t"set highlights on elements which were added to sum according to algorithm in the method"\r\r\r\t"remove selection from previous marker element"\r\tleftMarkerLinkBefore := MetaLink new.\r\tleftMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\tleftMarkerLinkBefore selector: #value:.\r\tleftMarkerLinkBefore arguments: #(value).\r\tleftMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkBefore\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current marker element"\r\tleftMarkerLinkAfter := MetaLink new.\r\tleftMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| leftMarkerHighlightLink |\r\t\t\tleftMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\tleftMarkerHighlightLink := MetaLink new.\r\t\t\tleftMarkerHighlightLink\r\t\t\t\tmetaObject: [ self highlightModel: element.\r\t\t\t\t\tleftMarkerHighlightLink uninstall ].\r\t\t\tleftMarkerHighlightLink selector: #value.\r\t\t\tleftMarkerHighlightLink control: #after.\r\t\t\telement link: leftMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: leftMarkerHighlightLink.\r\t\t\t"draw the marker element on the view if its the initialization"\r\t\t\tleftMarkerElement isNil\r\t\t\t\tifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\t"select the element and update the view"\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\tleftMarkerLinkAfter selector: #value:.\r\tleftMarkerLinkAfter arguments: #(value).\r\tleftMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: leftMarkerLinkAfter\r\t\ttoTemporaryNamed: #leftMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"remove selection from previous marker element"\r\trightMarkerLinkBefore := MetaLink new.\r\trightMarkerLinkBefore\r\t\tmetaObject: [ :value | \r\t\t\tvalue isNotNil\r\t\t\t\tifTrue: [ self deselectModel: value ] ].\r\trightMarkerLinkBefore selector: #value:.\r\trightMarkerLinkBefore arguments: #(value).\r\trightMarkerLinkBefore control: #before.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkBefore\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\t"select current right matrix marker element"\r\trightMarkerLinkAfter := MetaLink new.\r\trightMarkerLinkAfter\r\t\tmetaObject: [ :element | \r\t\t\t| rightMarkerHighlightLink |\r\t\t\trightMatrixMarker := element.\r\t\t\t"highlights marker if it was copied - most common path in the method"\r\t\t\t"uninstalls itself after one use since the algorithm does not revert"\r\t\t\trightMarkerHighlightLink := MetaLink new.\r\t\t\trightMarkerHighlightLink\r\t\t\t\tmetaObject: [ :value | \r\t\t\t\t\t"check what the stack top after copy is - maybe it has the new object which we\'ll use to bind to value: and highlight both elements"\r\t\t\t\t\tself halt.\r\t\t\t\t\tself highlightModel: element.\r\t\t\t\t\trightMarkerHighlightLink uninstall ].\r\t\t\trightMarkerHighlightLink selector: #value:.\r\t\t\trightMarkerHighlightLink arguments: #(value).\r\t\t\trightMarkerHighlightLink control: #after.\r\t\t\telement link: rightMarkerHighlightLink toMethodNamed: #copy.\r\t\t\tmetaLinks add: rightMarkerHighlightLink.\r\t\t\trightMarkerElement isNil\r\t\t\t\tifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new\r\t\t\t\t\t\tgetElementShapeScaled: 5) elementOn: element ].\r\t\t\telement isNotNil\r\t\t\t\tifTrue: [ self selectModel: element.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: element.\r\t\t\t\t\tdelay wait ] ].\r\trightMarkerLinkAfter selector: #value:.\r\trightMarkerLinkAfter arguments: #(value).\r\trightMarkerLinkAfter control: #after.\r\tmatrixInstance\r\t\tlink: rightMarkerLinkAfter\r\t\ttoTemporaryNamed: #rightMatrixMarker\r\t\tinMethod: method\r\t\toption: #write.\r\tmetaLinks\r\t\taddAll:\r\t\t\t{leftMarkerLinkBefore.\r\t\t\tleftMarkerLinkAfter.\r\t\t\trightMarkerLinkBefore.\r\t\t\trightMarkerLinkAfter}',			#stamp : 'YaroslavKormusyn 5/5/2019 11:58',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:04:46.330083+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(aCOOMatrix isMemberOf: self class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result first: (rightMatrixMarker copy\r\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\trow: leftMatrixMarker row\r\t\t\t\t\t\tcolumn: leftMatrixMarker column\r\t\t\t\t\t\tvalue: leftMatrixMarker value.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\trow: rightMatrixMarker row\r\t\t\t\t\t\t\t\tcolumn: rightMatrixMarker column\r\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := COOSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: leftMatrixMarker row\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: leftMatrixMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: leftMatrixMarker value + rightMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: leftMatrixMarker row\r\t\t\t\tcolumn: leftMatrixMarker column\r\t\t\t\tvalue: leftMatrixMarker value.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: rightMatrixMarker row\r\t\t\t\tcolumn: rightMatrixMarker column\r\t\t\t\tvalue: rightMatrixMarker value.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'YaroslavKormusyn 5/4/2019 23:48',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(aCOOMatrix isMemberOf: self class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result\r\t\t\t\t\t\t\t\tfirst:\r\t\t\t\t\t\t\t\t\t(rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := leftMatrixMarker copy.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := rightMatrixMarker copy.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := rightMatrixMarker copy value: rightMatrixMarker value + leftMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: leftMatrixMarker row\r\t\t\t\tcolumn: leftMatrixMarker column\r\t\t\t\tvalue: leftMatrixMarker value.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: rightMatrixMarker row\r\t\t\t\tcolumn: rightMatrixMarker column\r\t\t\t\tvalue: rightMatrixMarker value.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'YaroslavKormusyn 5/5/2019 12:04',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:05:16.354083+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(aCOOMatrix isMemberOf: self class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result\r\t\t\t\t\t\t\t\tfirst:\r\t\t\t\t\t\t\t\t\t(rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := leftMatrixMarker copy.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := rightMatrixMarker copy.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := rightMatrixMarker copy value: rightMatrixMarker value + leftMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: leftMatrixMarker row\r\t\t\t\tcolumn: leftMatrixMarker column\r\t\t\t\tvalue: leftMatrixMarker value.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: rightMatrixMarker row\r\t\t\t\tcolumn: rightMatrixMarker column\r\t\t\t\tvalue: rightMatrixMarker value.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'YaroslavKormusyn 5/5/2019 12:04',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(aCOOMatrix isMemberOf: self class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result\r\t\t\t\t\t\t\t\tfirst:\r\t\t\t\t\t\t\t\t\t(rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := leftMatrixMarker copy.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := rightMatrixMarker copy.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := leftMatrixMarker copy.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: rightMatrixMarker row\r\t\t\t\tcolumn: rightMatrixMarker column\r\t\t\t\tvalue: rightMatrixMarker value.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'YaroslavKormusyn 5/5/2019 12:05',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormusyn',		#time : DateAndTime [ '2019-05-05T12:05:25.149083+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(aCOOMatrix isMemberOf: self class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result\r\t\t\t\t\t\t\t\tfirst:\r\t\t\t\t\t\t\t\t\t(rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := leftMatrixMarker copy.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := rightMatrixMarker copy.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := leftMatrixMarker copy.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := COOSparseMatrixNode\r\t\t\t\trow: rightMatrixMarker row\r\t\t\t\tcolumn: rightMatrixMarker column\r\t\t\t\tvalue: rightMatrixMarker value.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'YaroslavKormusyn 5/5/2019 12:05',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aCOOMatrix\r\t| leftMatrixMarker rightMatrixMarker result newNode continue |\r\t(aCOOMatrix isMemberOf: self class)\r\t\tifFalse: [ Error signal: \'Convert matrix\' ].\r\t(rowNumber = aCOOMatrix rowNumber\r\t\tand: [ columnNumber = aCOOMatrix columnNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size\' ].\r\tleftMatrixMarker := first.\r\trightMatrixMarker := aCOOMatrix first.\r\tresult := self class rows: rowNumber columns: columnNumber.\r\t(leftMatrixMarker preceeds: rightMatrixMarker)\r\t\tifTrue: [ result first: leftMatrixMarker copy.\r\t\t\tresult last: result first.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\tifTrue: [ result first: rightMatrixMarker copy.\r\t\t\t\t\tresult last: result first.\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0\r\t\t\t\t\t\tifTrue: [ result first: (COOSparseMatrixNode row: 0 column: 0 value: 0).\r\t\t\t\t\t\t\tresult last: result first ]\r\t\t\t\t\t\tifFalse: [ result\r\t\t\t\t\t\t\t\tfirst:\r\t\t\t\t\t\t\t\t\t(rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value).\r\t\t\t\t\t\t\tresult last: result first ].\r\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ].\r\t[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]\r\t\twhileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)\r\t\t\t\tifTrue: [ newNode := leftMatrixMarker copy.\r\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ]\r\t\t\t\tifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)\r\t\t\t\t\t\tifTrue: [ newNode := rightMatrixMarker copy.\r\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ (leftMatrixMarker row = rightMatrixMarker row\r\t\t\t\t\t\t\t\tand: [ leftMatrixMarker column = rightMatrixMarker column ])\r\t\t\t\t\t\t\t\tifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ continue := true ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ newNode := rightMatrixMarker copy\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightMatrixMarker value + leftMatrixMarker value ].\r\t\t\t\t\t\t\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].\r\t\t\tnewNode isNil\r\t\t\t\tifFalse: [ result last rightNeighbour: newNode.\r\t\t\t\t\tnewNode leftNeighbour: result last.\r\t\t\t\t\tresult last: newNode.\r\t\t\t\t\tnewNode := nil ] ].\r\t[ leftMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := leftMatrixMarker copy.\r\t\t\tleftMatrixMarker := leftMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\t[ rightMatrixMarker isNotNil ]\r\t\twhileTrue: [ newNode := rightMatrixMarker copy.\r\t\t\trightMatrixMarker := rightMatrixMarker rightNeighbour.\r\t\t\tresult last rightNeighbour: newNode.\r\t\t\tnewNode leftNeighbour: result last.\r\t\t\tresult last: newNode ].\r\r\t"remove the dummy result first if zero"\r\tresult first value = 0\r\t\tifTrue: [ result first: result first rightNeighbour.\r\t\t\tresult first leftNeighbour: nil ].\r\t^ result',			#stamp : 'YaroslavKormusyn 5/5/2019 12:05',			#package : #LNU-SparseMatrix		}	}}