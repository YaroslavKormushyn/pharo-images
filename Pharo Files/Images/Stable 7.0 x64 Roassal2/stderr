[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
GLMTransmission>>postCopy
GLMTransmission(Object)>>copy
GLMPager(GLMFinder)>>newFirstTransmission
GLMPager(GLMFinder)>>addPaneFromOuter:
GLMPager(GLMFinder)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTInspector(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTInspector(GLMCompositePresentation)>>do:
GTInspector(GLMCompositePresentation)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTPlayground(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTPlayground(GLMCompositePresentation)>>do:
GTPlayground(GLMCompositePresentation)>>outerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
GLMPanePort(GLMPort)>>value:
GTPlayground(GLMPresentation)>>entity:
GTPlayground(GLMCompositePresentation)>>startOn:
GTPlayground(GLMCompositePresentation)>>openOn:with:
GTPlayground(GLMCompositePresentation)>>openOn:
GTPlayground>>openOn:
[0mhtEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
GLMTransmission>>postCopy
GLMTransmission(Object)>>copy
GLMPager(GLMFinder)>>newFirstTransmission
GLMPager(GLMFinder)>>addPaneFromOuter:
GLMPager(GLMFinder)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTDebuggerInspector(GLMCompositePresentation)>>do:
GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
GLMPanePort(GLMPort)>>value:
GTDebuggerInspector(GLMPresentation)>>entity:
GTDebuggerInspector(GLMCompositePresentation)>>startOn:
Context>>gtConstructDebuggerInspectorIn:for:
GTGenericStackDebugger>>inspectorIn:on:
[ :anObject | self inspectorIn: GLMCompositePresentation new on: anObject ] in GTGenericStackDebugger>>inspectorIn: in Block: [ :anObject | self inspectorIn: GLMCompositePresen...etc...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
GLMTransmission>>postCopy
GLMTransmission(Object)>>copy
GLMPager(GLMImplicitBrowser)>>newTransmission
GLMPager(GLMFinder)>>newFirstTransmission
GLMPager(GLMFinder)>>addPaneFromOuter:
GLMPager(GLMFinder)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTInspector(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTInspector(GLMCompositePresentation)>>do:
GTInspector(GLMCompositePresentation)>>outerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
GLMPanePort(GLMPort)>>value:
GTInspector(GLMPresentation)>>entity:
GTInspector(GLMCompositePresentation)>>startOn:
GTInspector(GLMCompositePresentation)>>openOn:with:
GTInspector(GLMCompositePresentation)>>openOn:
GTInspector>>openOn:
GTInspector class>>openOn:
GTInspector class>>inspect:
FileReference(Object)>>inspect
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
GLMTransmission>>postCopy
GLMTransmission(Object)>>copy
GLMPager(GLMFinder)>>newFirstTransmission
GLMPager(GLMFinder)>>addPaneFromOuter:
GLMPager(GLMFinder)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTDebuggerInspector(GLMCompositePresentation)>>do:
GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
GLMPanePort(GLMPort)>>value:
GTDebuggerInspector(GLMPresentation)>>entity:
GTDebuggerInspector(GLMCompositePresentation)>>startOn:
Context>>gtConstructDebuggerInspectorIn:for:
GTGenericStackDebugger>>inspectorIn:on:
[ :anObject | self inspectorIn: GLMCompositePresentation new on: anObject ] in GTGenericStackDebugger>>inspectorIn: in Block: [ :anObject | self inspectorIn: GLMCompositePresen...etc...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
EpLogBrowserPresenter class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
EpLogBrowserPresenter class(ClassDescription)>>compile:classified:withStamp:notifying:
EpLogBrowserPresenter class(ClassDescription)>>compile:classified:notifying:
EpLogBrowserPresenter class(ClassDescription)>>compile:classified:
[ aMethod origin
	compile: aMethod ast formattedCode
	classified: aMethod protocol ] in Deprecation>>transform in Block: [ aMethod origin...
BlockClosure>>ensure:
Author>>useAuthor:during:
Author class>>useAuthor:during:
Deprecation>>transform
EpLogBrowserPresenter(Object)>>deprecated:transformWith:
EpLogBrowserPresenter>>toolbarModel
EpLogBrowserPresenter>>beRevertMode
EpLogBrowserPresenter>>openPreviewToRevertSelectedChanges
[ self perform: oldStyleMenuItemArray second ] in [ :anItem | 
anItem
	name: oldStyleMenuItemArray first;
	description: oldStyleMenuItemArray third;
	icon: (self iconNamed: oldStyleMenuItemArray fourth);
	action: [ self perform: oldStyleMenuItemArray second ] ] in [ :oldStyleMenuItemArray | 
aGroup
	addItem: [ :anItem | 
		anItem
			name: oldStyleMenuItemArray first;
			description: oldStyleMenuItemArray third;
			icon: (self iconNamed: oldStyleMenuItemArray fourth);
			action: [ self perform: oldStyleMenuItemArray second ] ] ] in [ :aGroup | 
self menuActionsForSelectedItems
	do: [ :oldStyleMenuItemArray | 
		aGroup
			addItem: [ :anItem | 
				anItem
					name: oldStyleMenuItemArray first;
					description: oldStyleMenuItemArray third;
					icon: (self iconNamed: oldStyleMenuItemArray fourth);
					action: [ self perform: oldStyleMenuItemArray second ] ] ] ] in EpLogBrowserPresenter>>addMenuItemsForSelectedItemsIn: in Block: [ self perform: oldStyleMenuItemArray second ]
BlockClosure>>cull:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0min Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
GLMTransmission>>postCopy
GLMTransmission(Object)>>copy
GLMPager(GLMFinder)>>newFirstTransmission
GLMPager(GLMFinder)>>addPaneFromOuter:
GLMPager(GLMFinder)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTDebuggerInspector(GLMCompositePresentation)>>do:
GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
GLMPanePort(GLMPort)>>value:
GTDebuggerInspector(GLMPresentation)>>entity:
GTDebuggerInspector(GLMCompositePresentation)>>startOn:
Context>>gtConstructDebuggerInspectorIn:for:
GTGenericStackDebugger>>inspectorIn:on:
[ :anObject | self inspectorIn: GLMCompositePresentation new on: anObject ] in GTGenericStackDebugger>>inspectorIn: in Block: [ :anObject | self inspectorIn: GLMCompositePresen...etc...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
Message>>sentTo:
a subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
Message>>sentTo:
a subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
Message>>sentTo:
a subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrixOperationVisualizer class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
GLMTransmission>>postCopy
GLMTransmission(Object)>>copy
GLMPager(GLMFinder)>>newFirstTransmission
GLMPager(GLMFinder)>>addPaneFromOuter:
GLMPager(GLMFinder)>>outerPortEvent:
[ :each | each outerPortEvent: aPortEvent ] in GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent: in Block: [ :each | each outerPortEvent: aPortEvent ]
OrderedCollection>>do:
GTDebuggerInspector(GLMCompositePresentation)>>do:
GTDebuggerInspector(GLMCompositePresentation)>>outerPortEvent:
GLMPane>>portEvent:
[ self silentValue: anObject.
self pane
	portEvent:
		(GLMPortEvent
			on: self
			previouslyValued: oldValue
			in: aTransmissionContext) ] in GLMPanePort>>changeValueTo:in: in Block: [ self silentValue: anObject....
GLMPane>>notingPresentationChangeDo:
GLMPanePort>>changeValueTo:in:
GLMPanePort>>value:in:
GLMPanePort(GLMPort)>>value:
GTDebuggerInspector(GLMPresentation)>>entity:
GTDebuggerInspector(GLMCompositePresentation)>>startOn:
Context>>gtConstructDebuggerInspectorIn:for:
GTGenericStackDebugger>>inspectorIn:on:
[ :anObject | self inspectorIn: GLMCompositePresentation new on: anObject ] in GTGenericStackDebugger>>inspectorIn: in Block: [ :anObject | self inspectorIn: GLMCompositePresen...etc...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMDynamicPresentation(GLMPresentation)>>displayValue
GLMDynamicPresentation>>currentPresentation
[0m[31mInstance of a subclass of UndefinedObject did not understand #ast
[0ma subclass of UndefinedObject(Object)>>doesNotUnderstand: #ast
MetalinkTargetResolver class>>lookupASTForMethodNamed:in:
MetalinkTargetResolver class>>methodNamed:for:
a subclass of UndefinedObject(Object)>>link:toMethodNamed:
[ :elementCopy | 
"elementCopy is the copied object which we use to set a link to value:"
"with that we know if it's selecting left and right markers or only one of them"
| leftMatrixMarkerHightlightLink |
leftMatrixMarkerHightlightLink := MetaLink new.
leftMatrixMarkerHightlightLink
	metaObject: [ "the link is set to right only according to the method code"
		"left is never the object which is copied in this situation"
		self highlightModel: leftMatrixMarker inGroup: #left.
		Transcript
			show:
				'highlight left '
					, (leftMatrixMarker row @ leftMatrixMarker column) asString;
			cr.
		delay wait
		"leftMatrixMarkerHightlightLink uninstall" ].
leftMatrixMarkerHightlightLink selector: #value.
leftMatrixMarkerHightlightLink control: #after.
elementCopy
	link: leftMatrixMarkerHightlightLink
	toMethodNamed: #value:.
"highlight the right marker and uninstall itself after first use"
self highlightModel: element inGroup: #right.
Transcript
	show: 'highlight right ' , (element row @ element column) asString;
	cr.
delay wait.
"add to metaLinks in case it won't run to uninstall after animation ends"
metaLinks add: leftMatrixMarkerHightlightLink.
rightMarkerHighlightLink uninstall ] in [ :element | 
| rightMarkerHighlightLink |
rightMatrixMarker := element.
"highlights marker if it was copied - most common path in the method"
"uninstalls itself after one use since the algorithm does not revert"
rightMarkerHighlightLink := MetaLink new.
rightMarkerHighlightLink
	metaObject: [ :elementCopy | 
		"elementCopy is the copied object which we use to set a link to value:"
		"with that we know if it's selecting left and right markers or only one of them"
		| leftMatrixMarkerHightlightLink |
		leftMatrixMarkerHightlightLink := MetaLink new.
		leftMatrixMarkerHightlightLink
			metaObject: [ "the link is set to right only according to the method code"
				"left is never the object which is copied in this situation"
				self highlightModel: leftMatrixMarker inGroup: #left.
				Transcript
					show:
						'highlight left '
							, (leftMatrixMarker row @ leftMatrixMarker column) asString;
					cr.
				delay wait
				"leftMatrixMarkerHightlightLink uninstall" ].
		leftMatrixMarkerHightlightLink selector: #value.
		leftMatrixMarkerHightlightLink control: #after.
		elementCopy
			link: leftMatrixMarkerHightlightLink
			toMethodNamed: #value:.
		"highlight the right marker and uninstall itself after first use"
		self highlightModel: element inGroup: #right.
		Transcript
			show: 'highlight right ' , (element row @ element column) asString;
			cr.
		delay wait.
		"add to metaLinks in case it won't run to uninstall after animation ends"
		metaLinks add: leftMatrixMarkerHightlightLink.
		rightMarkerHighlightLink uninstall ].
rightMarkerHighlightLink selector: #value:.
rightMarkerHighlightLink arguments: #(value).
rightMarkerHighlightLink control: #after.
element link: rightMarkerHighlightLink toMethodNamed: #copy.
metaLinks add: rightMarkerHighlightLink.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
element isNotNil
	ifTrue: [ self selectModel: element inGroup: #right.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksOn: in Block: [ :elementCopy | ...
a subclass of UndefinedObject>>copy
RBMethodNode(RBProgramNode)>>postCopy
RBMethodNode>>postCopy
RBMethodNode(Object)>>copy
OpalCompiler>>callPlugins
[ self parse.
self doSemanticAnalysis.
self callPlugins ] in [ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ self parse....
BlockClosure>>on:do:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31mError: Unable to resolve external type: unsigned
[0mFFICallout(Object)>>error:
FFICallout>>resolveType:
FFICallout>>typeName:pointerArity:
FFICallout>>returnType:
FFIFunctionParser>>parseReturn
FFIFunctionParser>>parseNamedFunction:
FFICalloutMethodBuilder>>parseSignature:
FFICalloutMethodBuilder>>generate
FFICalloutMethodBuilder>>build:
FFICalloutAPI>>function:module:
CairoFontFace class(Object)>>ffiCall:
CairoFontFace class>>countReferences:
CairoFontFace class>>hasSharedResourceData:
CairoFontFaceExecutor>>finalize
WeakFinalizerItem>>finalizeValues
[ each finalizeValues ] in [ :each | [ each finalizeValues ] on: Exception fork: [ :ex | ex pass ] ] in WeakRegistry>>finalizeValues in Block: [ each finalizeValues ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31mInstance of Error did not understand #pointerArity:
[0mError(Object)>>doesNotUnderstand: #pointerArity:
FFICallout>>typeName:pointerArity:
FFICallout>>returnType:
FFIFunctionParser>>parseReturn
FFIFunctionParser>>parseNamedFunction:
FFICalloutMethodBuilder>>parseSignature:
FFICalloutMethodBuilder>>generate
FFICalloutMethodBuilder>>build:
FFICalloutAPI>>function:module:
CairoFontFace class(Object)>>ffiCall:
CairoFontFace class>>countReferences:
CairoFontFace class>>hasSharedResourceData:
CairoFontFaceExecutor>>finalize
WeakFinalizerItem>>finalizeValues
[ each finalizeValues ] in [ :each | [ each finalizeValues ] on: Exception fork: [ :ex | ex pass ] ] in WeakRegistry>>finalizeValues in Block: [ each finalizeValues ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31mInstance of Error did not understand #pointerArity:
[0mError(Object)>>doesNotUnderstand: #pointerArity:
Message>>sentTo:
Error(Object)>>doesNotUnderstand: #pointerArity:
FFICallout>>typeName:pointerArity:
FFICallout>>returnType:
FFIFunctionParser>>parseReturn
FFIFunctionParser>>parseNamedFunction:
FFICalloutMethodBuilder>>parseSignature:
FFICalloutMethodBuilder>>generate
FFICalloutMethodBuilder>>build:
FFICalloutAPI>>function:module:
CairoFontFace class(Object)>>ffiCall:
CairoFontFace class>>countReferences:
CairoFontFace class>>hasSharedResourceData:
CairoFontFaceExecutor>>finalize
WeakFinalizerItem>>finalizeValues
[ each finalizeValues ] in [ :each | [ each finalizeValues ] on: Exception fork: [ :ex | ex pass ] ] in WeakRegistry>>finalizeValues in Block: [ each finalizeValues ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31mInstance of Error did not understand #pointerArity:
[0mError(Object)>>doesNotUnderstand: #pointerArity:
Message>>sentTo:
Error(Object)>>doesNotUnderstand: #pointerArity:
Message>>sentTo:
Error(Object)>>doesNotUnderstand: #pointerArity:
FFICallout>>typeName:pointerArity:
FFICallout>>returnType:
FFIFunctionParser>>parseReturn
FFIFunctionParser>>parseNamedFunction:
FFICalloutMethodBuilder>>parseSignature:
FFICalloutMethodBuilder>>generate
FFICalloutMethodBuilder>>build:
FFICalloutAPI>>function:module:
CairoFontFace class(Object)>>ffiCall:
CairoFontFace class>>countReferences:
CairoFontFace class>>hasSharedResourceData:
CairoFontFaceExecutor>>finalize
WeakFinalizerItem>>finalizeValues
[ each finalizeValues ] in [ :each | [ each finalizeValues ] on: Exception fork: [ :ex | ex pass ] ] in WeakRegistry>>finalizeValues in Block: [ each finalizeValues ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0m[31mInstance of Error did not understand #pointerArity:
[0mError(Object)>>doesNotUnderstand: #pointerArity:
Message>>sentTo:
Error(Object)>>doesNotUnderstand: #pointerArity:
Message>>sentTo:
Error(Object)>>doesNotUnderstand: #pointerArity:
Message>>sentTo:
Error(Object)>>doesNotUnderstand: #pointerArity:
FFICallout>>typeName:pointerArity:
FFICallout>>returnType:
FFIFunctionParser>>parseReturn
FFIFunctionParser>>parseNamedFunction:
FFICalloutMethodBuilder>>parseSignature:
FFICalloutMethodBuilder>>generate
FFICalloutMethodBuilder>>build:
FFICalloutAPI>>function:module:
CairoFontFace class(Object)>>ffiCall:
CairoFontFace class>>countReferences:
CairoFontFace class>>hasSharedResourceData:
CairoFontFaceExecutor>>finalize
WeakFinalizerItem>>finalizeValues
[ each finalizeValues ] in [ :each | [ each finalizeValues ] on: Exception fork: [ :ex | ex pass ] ] in WeakRegistry>>finalizeValues in Block: [ each finalizeValues ]
BlockClosure>>on:do:
[ Processor terminateActive ] in [ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx := thisContext.
thisCtx := onDoCtx home.

"find the context on stack for which this method's is sender"
[ onDoCtx sender == thisCtx ]
	whileFalse: [ onDoCtx := onDoCtx sender.
		onDoCtx
			ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler." ^ handlerAction cull: ex ] ].
bottom := [ Processor terminateActive ] asContext.
onDoCtx privSender: bottom.
handler := [ handlerAction cull: ex ] asContext.
handler privSender: thisContext sender.
(Process forContext: handler priority: Processor activePriority)
	resume.

"cut the stack of current process"
thisContext privSender: thisCtx.
nil ] in BlockClosure>>on:fork: in Block: [ Processor terminateActive ]
[0mrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :outer | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :end | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
a subclass of COOSparseMatrix>>byMatrix:
ReflectiveMethod>>run:with:in:
[ leftMatrix byMatrix: rightMatrix ] in COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>multiplyAnimated:by: in Block: [ leftMatrix byMatrix: rightMatrix ]
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mCOOSparseMatrixOperationVisualizer(Object)>>halt
[ :element | 
| leftMarkerHighlightLink |
"draw the marker element on the view if its the initialization"
leftMarkerElement isNil
	ifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ]
	ifFalse: [ "select the element and update the view otherwise"
		self halt.
		self selectModel: element.
		Transcript
			show: 'select left ' , (element row @ element column) asString;
			cr.
		leftMarkerElement updateModelAndRedraw: element.
		element isNotNil
			ifTrue: [ "bind the actual element to the highlight"
				leftMarkerHighlightLink := MetaLink new.
				leftMarkerHighlightLink
					metaObject: [ self highlightModel: element.
						Transcript
							show: 'highlight left ' , (element row @ element column) asString;
							cr.
						delay wait.
						leftMarkerHighlightLink uninstall ].
				leftMarkerHighlightLink selector: #value.
				leftMarkerHighlightLink control: #after.
				element
					link: leftMarkerHighlightLink
					toSlotNamed: #value
					option: #read ] ] ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :element | ...
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :outer | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to ne[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :element | 
| rightMarkerHighlightLink |
"bind the highlight to actual marker element"
"element isNotNil
				ifTrue: [ rightMarkerHighlightLink := MetaLink new.
					rightMarkerHighlightLink
						metaObject: [ self highlightModel: element.
							Transcript
								show: 'highlight right ' , (element row @ element column) asString;
								cr.
							delay wait ].
					rightMarkerHighlightLink selector: #value.
					rightMarkerHighlightLink control: #after.
					element
						link: rightMarkerHighlightLink
						toSlotNamed: #value
						option: #read ]."
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ]
	ifFalse: [ self selectModel: element.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element ] ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :element | ...
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :next | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNi[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :element | 
| rightMarkerHighlightLink |
"bind the highlight to actual marker element"
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ]
	ifFalse: [ self selectModel: element.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		element isNotNil
			ifTrue: [ rightMarkerHighlightLink := MetaLink new.
				rightMarkerHighlightLink
					metaObject: [ self highlightModel: element.
						Transcript
							show: 'highlight right ' , (element row @ element column) asString;
							cr.
						delay wait ].
				rightMarkerHighlightLink selector: #value.
				rightMarkerHighlightLink control: #after.
				element
					link: rightMarkerHighlightLink
					toSlotNamed: #value
					option: #read ].
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :element | ...
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :next | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRo[31mError: This Delay has already been scheduled.
[0mDelaySemaphoreScheduler(Object)>>error:
DelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
[ :element | 
| leftMarkerHighlightLink |
"draw the marker element on the view if its the initialization"
leftMarkerElement isNil
	ifTrue: [ leftMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ]
	ifFalse: [ "select the element and update the view otherwise"
		self selectModel: element.
		Transcript
			show: 'select left ' , (element row @ element column) asString;
			cr.
		leftMarkerElement updateModelAndRedraw: element.
		element isNotNil
			ifTrue: [ "bind the actual element to the highlight"
				leftMarkerHighlightLink := MetaLink new.
				leftMarkerHighlightLink
					metaObject: [ self highlightModel: element.
						Transcript
							show: 'highlight left ' , (element row @ element column) asString;
							cr.
						delay wait.
						leftMarkerHighlightLink uninstall ].
				leftMarkerHighlightLink selector: #value.
				leftMarkerHighlightLink control: #after.
				element
					link: leftMarkerHighlightLink
					toSlotNamed: #value
					option: #read ].
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :element | ...
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :next | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [31mHalt
[0mCOOSparseMatrixOperationVisualizer(Object)>>halt
[ :sumValue | 
sumValue ~= 0
	ifTrue: [ self halt.
		self
			highlightModels:
				{leftMatrixMarker.
				rightMatrixMarker} ] ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :sumValue | ...
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :next | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :outer | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
					[31mError: Instances of Point are not indexable
[0mPoint(Object)>>error:
Point(Object)>>errorNotIndexable
Point(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[ :sumValue | 
sumValue ~= 0
	ifTrue: [ self
			highlightModels:
				{leftMatrixMarker.
				rightMatrixMarker}.
		Transcript
			show:
				'highlight ' , (leftMatrixMarker row @ leftMatrixMarker column) , '&'
					, (rightMatrixMarker row @ rightMatrixMarker column);
			cr.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :sumValue | ...
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :next | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :outer | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTr[31mError: cannot remove an element that is not part of a view
[0mRTElement(Object)>>error:
RTElement>>remove
ByteSymbol(Symbol)>>value:
RTGroup(OrderedCollection)>>do:
RTView>>removeElements:
RTComposer>>removeGroup:
RTComposer>>replaceElementsInGroup:with:
COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>updateResultWith:
[ self updateResultWith: value.
Transcript
	show: 'updated last in result -> new 2nd rec link';
	cr ] in [ | newResultUpdateLastLink |
self updateResultWith: value.
Transcript
	show: 'updated last in result -> 2nd rec link';
	cr.
resultMatrixUpdateLinkLast uninstall.
newResultUpdateLastLink := MetaLink new.
newResultUpdateLastLink
	metaObject: [ self updateResultWith: value.
		Transcript
			show: 'updated last in result -> new 2nd rec link';
			cr ].
newResultUpdateLastLink selector: #value.
newResultUpdateLastLink control: #after.
value link: newResultUpdateLastLink toSlotNamed: #last option: #write.
semaphore signal.
process suspend ] in [ :value | 
| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |
resultMatrix := value.
"initialize the view for the updates not to fail"
self initializeMultiplicationView.
self setPositionsForMultiplication.
"resultMatrixUpdateLinkFirst := MetaLink new.
			resultMatrixUpdateLinkFirst
				metaObject: [ self updateResultWith: value.
					Transcript
						show: 'updated first in result -> 2nd rec link';
						cr ].
			resultMatrixUpdateLinkFirst selector: #value.
			resultMatrixUpdateLinkFirst control: #after.
			value
				link: resultMatrixUpdateLinkFirst
				toSlotNamed: #first
				option: #write."
resultMatrixUpdateLinkLast := MetaLink new.
resultMatrixUpdateLinkLast
	metaObject: [ | newResultUpdateLastLink |
		self updateResultWith: value.
		Transcript
			show: 'updated last in result -> 2nd rec link';
			cr.
		resultMatrixUpdateLinkLast uninstall.
		newResultUpdateLastLink := MetaLink new.
		newResultUpdateLastLink
			metaObject: [ self updateResultWith: value.
				Transcript
					show: 'updated last in result -> new 2nd rec link';
					cr ].
		newResultUpdateLastLink selector: #value.
		newResultUpdateLastLink control: #after.
		value
			link: newResultUpdateLastLink
			toSlotNamed: #last
			option: #write.
		semaphore signal.
		process suspend ].
resultMatrixUpdateLinkLast selector: #value.
resultMatrixUpdateLinkLast control: #after.
value
	link: resultMatrixUpdateLinkLast
	toSlotNamed: #last
	option: #write ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ self updateResultWith: value....
a subclass of COOSparseMatrix>>last:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :outer | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :end | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
a subclass of COOSparseMatrix>>byMatrix:
ReflectiveMethod>>run:with:in:
[ leftMatrix byMatrix: rightMatrix ] in COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>multiplyAnimated:by: in Block: [ leftMatrix byMatrix: rightMatrix ]
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :element | 
rightMatrixMarker := element.
"| rightMarkerHighlightLink |
			rightMarkerHighlightLink := MetaLink new.
			rightMarkerHighlightLink
				metaObject: [ self highlightModel: element.
					Transcript
						show: 'highlight right ' , (element row @ element column) asString;
						cr.
					delay wait ].
			rightMarkerHighlightLink selector: #value.
			rightMarkerHighlightLink control: #after."
"bind the highlight to actual marker element"
rightMarkerElement isNil
	ifTrue: [ "rightMarkerLinkBefore := MetaLink new.
					rightMarkerLinkBefore
						metaObject: [ :value | 
							value isNotNil
								ifTrue: [ self deselectModel: value.
									Transcript
										show: 'deselect right ' , (value row @ value column) asString;
										cr. ] ].
					rightMarkerLinkBefore selector: #value:.
					rightMarkerLinkBefore arguments: #(value).
					rightMarkerLinkBefore control: #before.
					matrixInstance
						link: rightMarkerLinkBefore
						toTemporaryNamed: #rightMatrixMarker
						inMethod: method
						option: #write."
		rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ]
	ifFalse: [ self selectModel: element.
		Transcript
			show: 'select right ' , (element row @ element column) asString;
			cr.
		rightMarkerElement updateModelAndRedraw: element.
		delay wait ] ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :element | ...
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [ :next | ...
a subclass of COOSparseMatrix(COOSparseMatrix)>>withEscaper:
[ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
		rightMatrixMarker := transposed first ].
"reset left marker to row beginning"
leftMatrixMarker := leftSavedMatrixMarker.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0 ] ] in [ :end | 
[ leftMatrixMarker isNotNil or: [ rightMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.
						rightMatrixMarker := transposed first ].
				"reset left marker to row beginning"
				leftMatrixMarker := leftSavedMatrixMarker.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0 ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0 ] ] ] in a subclass of COOSparseMatrix>>byMatrix: in Block: [31mHalt
[0mCOOSparseMatrixOperationVisualizer(Object)>>halt
[ :element | 
rightMatrixMarker := element.
rightMarkerElement isNil
	ifTrue: [ rightMarkerElement := (COOSparseMatrixVisualizer new
			getElementShapeScaled: 5) elementOn: element ].
self halt.
self selectModel: element.
Transcript
	show: 'select right ' , (element row @ element column) asString;
	cr.
rightMarkerElement updateModelAndRedraw: element.
delay wait ] in COOSparseMatrixOperationVisualizer>>setMultiInitLinksOn: in Block: [ :element | ...
a subclass of COOSparseMatrix>>byMatrix:
ReflectiveMethod>>run:with:in:
[ leftMatrix byMatrix: rightMatrix ] in COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>multiplyAnimated:by: in Block: [ leftMatrix byMatrix: rightMatrix ]
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self setMultiInitLinksOn: leftMatrix.
process resume.
semaphore wait ] in COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>multiplyAnimated:by: in Block: [ self setMultiInitLinksOn: leftMatrix....
BlockClosure>>on:do:
BlockClosure>>on:fork:
COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>multiplyAnimated:by:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0mrixMarker.
		rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
		(Delay forSeconds: delay) wait ].
"reset left marker to row beginning"
composer deselectModel: leftMatrixMarker inGroup: #left.
(Delay forSeconds: delay) wait.
leftMatrixMarker := leftSavedMatrixMarker.
composer selectModel: leftMatrixMarker inGroup: #left.
leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
(Delay forSeconds: delay) wait.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex
	model:
		{currentLeftRow.
		currentRightColumn}.
nowProcessingElementIndex update.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
								(Delay forSeconds: delay) wait.
								leftMatrixMarker := leftMatrixMarker rightNeighbour.
								composer selectModel: leftMatrixMarker inGroup: #left.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								(Delay forSeconds: delay) wait ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
						composer highlightModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						composer deselectModel: leftMatrixMarker inGroup: #left.
						composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: leftMatrixMarker inGroup: #left.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0.
		composer replaceElementsInGroup: #result with: result.
		composer move: #result onTheRightOf: #right.
		composer redrawNamesFor: namedGroups.
		composer redrawBackgroundsFor: backgroundGroups ] ] in [ :end | 
[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ rightMatrixMarker := transposed first.
						leftSavedMatrixMarker := leftMatrixMarker.
						composer selectModel: leftMatrixMarker inGroup: #left.
						composer selectModel: rightMatrixMarker inGroup: #right.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						(Delay forSeconds: delay) wait ].
				"reset left marker to row beginning"
				composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftSavedMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				nowProcessingElementIndex
					model:
						{currentLeftRow.
						currentRightColumn}.
				nowProcessingElementIndex update.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										composer selectModel: leftMatrixMarker inGroup: #left.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										(Delay forSeconds: delay) wait ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										composer selectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
												(Delay forSeconds: delay) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												composer selectModel: leftMatrixMarker inGroup: #left.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: delay) wait ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
										composer highlightModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										sum := sum
											+ (leftMatrixMarker value * rightMatrixMarker value).
										composer deselectModel: leftMatrixMarker inGroup: #left.
										composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										composer selectModel: leftMatrixMarker inGroup: #left.
										composer selectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						composer replaceElementsInGroup: #result with: result.
						composer move: #result onTheRightOf: #right.
						composer redrawNamesFor: namedGroups.
						composer redrawBackgroundsFor: backgroundGroups ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum :=[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :el | el row @ el column ] in COOSparseMatrixVisualizer(MatrixVisualizer)>>getElementShapeScaled: in Block: [ :el | el row @ el column ]
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTLabel>>text: in Block: [ :anElement | aValueOrAOneArgBlock rtValue: anEle...etc...
BlockClosure>>rtValue:
RTLabel>>textFor:
RTLabel>>updateFor:trachelShape:
[ :tupple :shapeIndex | 
| s |
tupple first
	updateFor: anElement
	trachelShape: (anElement trachelShape shapes at: shapeIndex).
s := anElement trachelShape shapes at: shapeIndex.
Array with: s with: tupple second ] in RTCompositeShape>>updateFor:trachelShape: in Block: [ :tupple :shapeIndex | ...
OrderedCollection>>withIndexCollect:
OrderedCollection(SequenceableCollection)>>collectWithIndex:
RTCompositeShape>>updateFor:trachelShape:
RTCompositeShape(RTShape)>>updateFor:
RTElement(RTShapedObject)>>updateShape
RTElement(RTShapedObject)>>update
RTElement(RTShapedObject)>>updateModelAndRedraw:
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
				composer selectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
				composer highlightModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				composer deselectModel: leftMatrixMarker inGroup: #left.
				composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				composer selectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ rightMatrixMarker := transposed first.
		leftSavedMatrixMarker := leftMatrixMarker.
		composer selectModel: leftMatrixMarker inGroup: #left.
		composer selectModel: rightMatrixMarker inGroup: #right.
		leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
		rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
		(Delay forSeconds: delay) wait ].
"reset left marker to row beginning"
composer deselectModel: leftMatrixMarker inGroup: #left.
(Delay forSeconds: delay) wait.
leftMatrixMarker := leftSavedMatrixMarker.
composer selectModel: leftMatrixMarker inGroup: #left.
leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
(Delay forSeconds: delay) wait.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex
	model:
		{currentLeftRow.
		currentRightColumn}.
nowProcessingElementIndex update.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
								(Delay forSeconds: delay) wait.
								leftMatrixMarker := leftMatrixMarker rightNeighbour.
								composer selectModel: leftMatrixMarker inGroup: #left.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								(Delay forSeconds: delay) wait ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
						composer highlightModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						composer deselectModel: leftMatrixMarker inGroup: #left.
						composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: leftMatrixMarker inGroup: #left.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0.
		composer replaceElementsInGroup: #result with: result.
		composer move: #result onTheRightOf: #right.
		composer redrawNamesFor: namedGroups.
		composer redrawBackgroundsFor: backgroundGroups ] ] in [ :end | 
[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ rightMatrixMarker := transposed first.
						leftSavedMatrixMarker := leftMatrixMarker.
						composer selectModel: leftMatrixMarker inGroup: #left.
						composer selectModel: rightMatrixMarker inGroup: #right.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						(Delay forSeconds: delay) wait ].
				"reset left marker to row beginning"
				composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftSavedMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				nowProcessingElementIndex
					model:
						{currentLeftRow.
						currentRightColumn}.
				nowProcessingElementIndex update.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										composer selectModel: leftMatrixMarker inGroup: #left.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										(Delay forSeconds: delay) wait ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										composer selectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
												(Delay forSeconds: delay) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												composer selectModel: leftMatrixMarker inGroup: #left.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: delay) wait ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
										composer highlightModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										sum := sum
											+ (leftMatrixMarker value * rightMatrixMarker value).
										composer deselectModel: leftMatrixMarker inGroup: #left.
										composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										composer selectModel: leftMatrixMarker inGroup: #left.
										composer selectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						composer replaceElementsInGroup: #result with: result.
						composer move: #result onTheRightOf: #right.
						composer redrawNamesFor: namedGroups.
						composer redrawBackgroundsFor: backgroundGroups ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0.
				composer replaceElementsInGroup: #result with: result.
				composer move: #result onTheRightOf: #right.
				composer redrawNamesFor: namedGroups.
				composer redrawBackgroundsFor: backgroundGroups ] ] ] in [ leftSavedMatrixMarker := leftMatrixMarker := first.
composer selectModel: leftMatrixMarker inGroup: #left.
rightMatrixMarker := transposed first.
composer selectModel: rightMatrixMarker inGroup: #right.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex := (RTLabel
	text:
		[ :indices | 'Now processing ' , (indices first @ indices last) asString ])
	elementOn:
		{currentLeftRow.
		currentRightColumn}.
composer view add: nowProcessingElementIndex.
composer group: #nowProcessing.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer move: #nowProcessing above: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
namedGroups := #(#left #result #right #leftMarker #rightMarker).
backgroundGroups := #(#left #result #right).
composer view signalUpdate.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								composer selectModel: leftMatrixMarker inGroup: #left.
								composer selectModel: rightMatrixMarker inGroup: #right.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ].
						"reset left marker to row beginning"
						composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait.
						currentLeftRow := leftMatrixMarker row.
						currentRightColumn := rightMatrixMarker row.
						nowProcessingElementIndex
							model:
								{currentLeftRow.
								currentRightColumn}.
						nowProcessingElementIndex update.
						self
							withEscaper: [ :next | 
								[ leftMatrixMarker isNotNil
									and: [ rightMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
									whileTrue: [ priorityColumn := {leftMatrixMarker column.
										rightMatrixMarker column} max.
										"Find same column as prioritized or higher in left"
										[ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow
													and: [ leftMatrixMarker column < priorityColumn ] ] ]
											whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
												(Delay forSeconds: delay) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												composer selectModel: leftMatrixMarker inGroup: #left.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: delay) wait ].
										leftMatrixMarker isNil
											ifTrue: [ [ rightMatrixMarker isNotNil
													and: [ rightMatrixMarker row = currentRightColumn ] ]
													whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
											[31mError: genJumpLong: distance index -1037 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
[0m[31mError: genJumpLong: distance index -1030 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
[0m[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :el | el row @ el column ] in COOSparseMatrixVisualizer(MatrixVisualizer)>>getElementShapeScaled: in Block: [ :el | el row @ el column ]
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTLabel>>text: in Block: [ :anElement | aValueOrAOneArgBlock rtValue: anEle...etc...
BlockClosure>>rtValue:
RTLabel>>textFor:
RTLabel>>updateFor:trachelShape:
[ :tupple :shapeIndex | 
| s |
tupple first
	updateFor: anElement
	trachelShape: (anElement trachelShape shapes at: shapeIndex).
s := anElement trachelShape shapes at: shapeIndex.
Array with: s with: tupple second ] in RTCompositeShape>>updateFor:trachelShape: in Block: [ :tupple :shapeIndex | ...
OrderedCollection>>withIndexCollect:
OrderedCollection(SequenceableCollection)>>collectWithIndex:
RTCompositeShape>>updateFor:trachelShape:
RTCompositeShape(RTShape)>>updateFor:
RTElement(RTShapedObject)>>updateShape
RTElement(RTShapedObject)>>update
RTElement(RTShapedObject)>>updateModelAndRedraw:
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
				composer selectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
				composer highlightModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				composer deselectModel: leftMatrixMarker inGroup: #left.
				composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				composer selectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ rightMatrixMarker := transposed first.
		leftSavedMatrixMarker := leftMatrixMarker.
		composer
			selectModels:
				{leftMatrixMarker.
				rightMatrixMarker}.
		leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
		rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
		(Delay forSeconds: delay) wait ].
"reset left marker to row beginning"
composer deselectModel: leftMatrixMarker inGroup: #left.
(Delay forSeconds: delay) wait.
leftMatrixMarker := leftSavedMatrixMarker.
composer selectModel: leftMatrixMarker inGroup: #left.
leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
(Delay forSeconds: delay) wait.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex
	model:
		{currentLeftRow.
		currentRightColumn}.
nowProcessingElementIndex update.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
								(Delay forSeconds: delay) wait.
								leftMatrixMarker := leftMatrixMarker rightNeighbour.
								composer selectModel: leftMatrixMarker inGroup: #left.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								(Delay forSeconds: delay) wait ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
						composer highlightModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						composer deselectModel: leftMatrixMarker inGroup: #left.
						composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: leftMatrixMarker inGroup: #left.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0.
		composer replaceElementsInGroup: #result with: result.
		composer move: #result onTheRightOf: #right.
		composer redrawNamesFor: namedGroups.
		composer redrawBackgroundsFor: backgroundGroups ] ] in [ :end | 
[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ rightMatrixMarker := transposed first.
						leftSavedMatrixMarker := leftMatrixMarker.
						composer
							selectModels:
								{leftMatrixMarker.
								rightMatrixMarker}.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						(Delay forSeconds: delay) wait ].
				"reset left marker to row beginning"
				composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftSavedMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				nowProcessingElementIndex
					model:
						{currentLeftRow.
						currentRightColumn}.
				nowProcessingElementIndex update.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										composer selectModel: leftMatrixMarker inGroup: #left.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										(Delay fo[31mError: genJumpLong: distance index -1028 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
DebugContext>>recompileCurrentMethodTo:notifying:
DebugContext>>blockNotFoundDialog:with:
DebugContext>>locateClosureHomeWithContent:
DebugSession>>recompileMethodTo:inContext:notifying:
GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnCompileText:
[0m[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :el | el row @ el column ] in COOSparseMatrixVisualizer(MatrixVisualizer)>>getElementShapeScaled: in Block: [ :el | el row @ el column ]
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTLabel>>text: in Block: [ :anElement | aValueOrAOneArgBlock rtValue: anEle...etc...
BlockClosure>>rtValue:
RTLabel>>textFor:
RTLabel>>updateFor:trachelShape:
[ :tupple :shapeIndex | 
| s |
tupple first
	updateFor: anElement
	trachelShape: (anElement trachelShape shapes at: shapeIndex).
s := anElement trachelShape shapes at: shapeIndex.
Array with: s with: tupple second ] in RTCompositeShape>>updateFor:trachelShape: in Block: [ :tupple :shapeIndex | ...
OrderedCollection>>withIndexCollect:
OrderedCollection(SequenceableCollection)>>collectWithIndex:
RTCompositeShape>>updateFor:trachelShape:
RTCompositeShape(RTShape)>>updateFor:
RTElement(RTShapedObject)>>updateShape
RTElement(RTShapedObject)>>update
RTElement(RTShapedObject)>>updateModelAndRedraw:
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
				composer selectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
				composer highlightModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				composer deselectModel: leftMatrixMarker inGroup: #left.
				composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				rightMatrixMarker isNotNil
					ifTrue:
						[ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
				composer
					selectModels:
						{leftMatrixMarker.
						rightMatrixMarker}.
				(Delay forSeconds: delay) wait ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ rightMatrixMarker := transposed first.
		leftSavedMatrixMarker := leftMatrixMarker.
		composer
			selectModels:
				{leftMatrixMarker.
				rightMatrixMarker}.
		leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
		rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
		(Delay forSeconds: delay) wait ].
"reset left marker to row beginning"
composer deselectModel: leftMatrixMarker inGroup: #left.
(Delay forSeconds: delay) wait.
leftMatrixMarker := leftSavedMatrixMarker.
composer selectModel: leftMatrixMarker inGroup: #left.
leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
(Delay forSeconds: delay) wait.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex
	model:
		{currentLeftRow.
		currentRightColumn}.
nowProcessingElementIndex update.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
								(Delay forSeconds: delay) wait.
								leftMatrixMarker := leftMatrixMarker rightNeighbour.
								composer selectModel: leftMatrixMarker inGroup: #left.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								(Delay forSeconds: delay) wait ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
						composer highlightModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						composer deselectModel: leftMatrixMarker inGroup: #left.
						composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMatrixMarker isNotNil
							ifTrue:
								[ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
						composer
							selectModels:
								{leftMatrixMarker.
								rightMatrixMarker}.
						(Delay forSeconds: delay) wait ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0.
		composer replaceElementsInGroup: #result with: result.
		composer move: #result onTheRightOf: #right.
		composer redrawNamesFor: namedGroups.
		composer redrawBackgroundsFor: backgroundGroups ] ] in [ :end | 
[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ rightMatrixMarker := transposed first.
						leftSavedMatrixMarker := leftMatrixMarker.
						composer
							selectModels:
								{leftMatrixMarker.
								rightMatrixMarker}.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						(Delay forSeconds: delay) wait ].
				"reset left marker to row beginning"
				composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftSavedMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				nowProcessingElementIndex
					model:
						{currentLeftRow.
						currentRightColumn}.
				nowProcessingElementIndex update.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										composer selectModel: leftMatrixMarker inGroup: #left.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										(Delay forSeconds: delay) wait ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										composer selectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
												(Delay forSeconds: delay) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												composer selectModel: leftMatrixMarker inGroup: #left.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: delay) wait ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
										composer highlightModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										sum := sum
											+ (leftMatrixMarker value * rightMatrixMarker value).
										composer deselectModel: leftMatrixMarker inGroup: #left.
										composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										rightMatrixMarker isNotNil
											ifTrue:
												[ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
										composer
											selectModels:
												{leftMatrixMarker.
												rightMatrixMarker}.
										(Delay forSeconds: delay) wait ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						composer replaceElementsInGroup: #result with: result.
						composer move: #result onTheRightOf: #right.
						composer redrawNamesFor: namedGroups.
						composer redrawBackgroundsFor: backgroundGroups ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0.
				composer replaceElementsInGroup: #result with: result.
				composer move: #result onTheRightOf: #right.
				composer redrawNamesFor: namedGroups.
				composer redrawBackgroundsFor: backgroundGroups ] ] ] in [31mError: genJumpLong: distance index -1031 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
DebugContext>>recompileCurrentMethodTo:notifying:
DebugContext>>blockNotFoundDialog:with:
DebugContext>>locateClosureHomeWithContent:
DebugSession>>recompileMethodTo:inContext:notifying:
GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnCompileText:
[0m[31mError: genJumpLong: distance index -1042 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
[0m[31mError: genJumpLong: distance index -1042 is out of range -1024 to 1023
[0mEncoderForV3PlusClosures(Object)>>error:
EncoderForV3PlusClosures(BytecodeEncoder)>>outOfRangeError:index:range:to:
EncoderForV3PlusClosures(EncoderForV3)>>genJumpLong:
IRBytecodeGenerator>>jumpBackward:
IRBytecodeGenerator>>from:goto:
Message>>sendTo:
IRBytecodeGenerator>>updateJump:
[ :changed :seqId | (self updateJump: seqId) or: [ changed ] ] in IRBytecodeGenerator>>updateJumpOffsets in Block: [ :changed :seqId | (self updateJump: seqId) or: [...etc...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
IRBytecodeGenerator>>updateJumpOffsets
IRBytecodeGenerator>>bytecodes
IRBytecodeGenerator>>compiledMethodWith:header:literals:
IRBytecodeGenerator>>compiledMethodWith:
IRTranslatorV2>>compiledMethod
IRMethod>>generate:
IRMethod>>compiledMethodWith:
RBMethodNode>>generate:
[ [ self parse.
self doSemanticAnalysis.
self callPlugins ]
	on: ReparseAfterSourceEditing
	do: [ :notification | 
		self source: notification newSource.
		notification retry ].
cm := compilationContext optionEmbeddSources
	ifTrue: [ ast generateWithSource ]
	ifFalse: [ ast generate: self compilationContext compiledMethodTrailer ] ] in OpalCompiler>>compile in Block: [ [ self parse....
BlockClosure>>on:do:
OpalCompiler>>compile
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:logSource:
COOSparseMatrix class(ClassDescription)>>compile:classified:withStamp:notifying:
COOSparseMatrix class(ClassDescription)>>compile:classified:notifying:
ClyMethodCodeEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyMethodCodeEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
[0m[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :el | el row @ el column ] in COOSparseMatrixVisualizer(MatrixVisualizer)>>getElementShapeScaled: in Block: [ :el | el row @ el column ]
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTLabel>>text: in Block: [ :anElement | aValueOrAOneArgBlock rtValue: anEle...etc...
BlockClosure>>rtValue:
RTLabel>>textFor:
RTLabel>>updateFor:trachelShape:
[ :tupple :shapeIndex | 
| s |
tupple first
	updateFor: anElement
	trachelShape: (anElement trachelShape shapes at: shapeIndex).
s := anElement trachelShape shapes at: shapeIndex.
Array with: s with: tupple second ] in RTCompositeShape>>updateFor:trachelShape: in Block: [ :tupple :shapeIndex | ...
OrderedCollection>>withIndexCollect:
OrderedCollection(SequenceableCollection)>>collectWithIndex:
RTCompositeShape>>updateFor:trachelShape:
RTCompositeShape(RTShape)>>updateFor:
RTElement(RTShapedObject)>>updateShape
RTElement(RTShapedObject)>>update
RTElement(RTShapedObject)>>updateModelAndRedraw:
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
				composer selectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
				composer highlightModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				composer deselectModel: leftMatrixMarker inGroup: #left.
				composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				rightMatrixMarker isNotNil
					ifTrue: [ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
				composer
					selectModels:
						{leftMatrixMarker.
						rightMatrixMarker}.
				(Delay forSeconds: delay) wait ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ rightMatrixMarker := transposed first.
		leftSavedMatrixMarker := leftMatrixMarker.
		composer
			selectModels:
				{leftMatrixMarker.
				rightMatrixMarker}.
		leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
		rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
		(Delay forSeconds: delay) wait ].
"reset left marker to row beginning"
composer deselectModel: leftMatrixMarker inGroup: #left.
(Delay forSeconds: delay) wait.
leftMatrixMarker := leftSavedMatrixMarker.
composer selectModel: leftMatrixMarker inGroup: #left.
leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
(Delay forSeconds: delay) wait.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex
	model:
		{currentLeftRow.
		currentRightColumn}.
nowProcessingElementIndex update.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
								(Delay forSeconds: delay) wait.
								leftMatrixMarker := leftMatrixMarker rightNeighbour.
								composer selectModel: leftMatrixMarker inGroup: #left.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								(Delay forSeconds: delay) wait ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
						composer highlightModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						composer deselectModel: leftMatrixMarker inGroup: #left.
						composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMatrixMarker isNotNil
							ifTrue: [ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
						composer
							selectModels:
								{leftMatrixMarker.
								rightMatrixMarker}.
						(Delay forSeconds: delay) wait ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0.
		visualizer updateResultWith: result ] ] in [ :end | 
[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ rightMatrixMarker := transposed first.
						leftSavedMatrixMarker := leftMatrixMarker.
						composer
							selectModels:
								{leftMatrixMarker.
								rightMatrixMarker}.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						(Delay forSeconds: delay) wait ].
				"reset left marker to row beginning"
				composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftSavedMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				nowProcessingElementIndex
					model:
						{currentLeftRow.
						currentRightColumn}.
				nowProcessingElementIndex update.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										composer selectModel: leftMatrixMarker inGroup: #left.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										(Delay forSeconds: delay) wait ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										composer selectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
												(Delay forSeconds: delay) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												composer selectModel: leftMatrixMarker inGroup: #left.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: delay) wait ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
										composer highlightModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										sum := sum
											+ (leftMatrixMarker value * rightMatrixMarker value).
										composer deselectModel: leftMatrixMarker inGroup: #left.
										composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										rightMatrixMarker isNotNil
											ifTrue: [ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
										composer
											selectModels:
												{leftMatrixMarker.
												rightMatrixMarker}.
										(Delay forSeconds: delay) wait ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						visualizer updateResultWith: result ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0.
				visualizer updateResultWith: result ] ] ] in [ leftSavedMatrixMarker := leftMatrixMarker := first.
rightMatrixMarker := transposed first.
composer
	selectModels:
		{rightMatrixMarker.
		leftMatrixMarker}.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex := (RTLabel
	text:
		[ :indices | 'Now processing ' , (indices first @ indices last) asString ])
	elementOn:
		{currentLeftRow.
		currentRightColumn}.
composer view add: nowProcessingElementIndex.
composer group: #nowProcessing.
leftMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: leftMatrixMarker.
composer view add: leftMarkerElement.
composer group: #leftMarker.
rightMarkerElement := (COOSparseMatrixVisualizer new
	getElementShapeScaled: 5) elementOn: rightMatrixMarker.
composer view add: rightMarkerElement.
composer group: #rightMarker.
composer move: #leftMarker below: #left.
composer move: #rightMarker below: #right.
composer move: #nowProcessing above: #right.
composer nameGroup: #leftMarker as: 'left marker'.
composer nameGroup: #rightMarker as: 'right marker'.
composer groupToExisting: #labels.
visualizer
	namedGroups: #(#left #result #right #leftMarker #rightMarker).
visualizer backgroundGroups: #(#left #result #right).
composer view signalUpdate.
sum := 0.
self
	withEscaper: [ :end | 
		[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
			whileTrue: [ self
					withEscaper: [ :outer | 
						"Switch to next row in left and reset right marker if right ended"
						rightMatrixMarker isNil
							ifTrue: [ rightMatrixMarker := transposed first.
								leftSavedMatrixMarker := leftMatrixMarker.
								composer
									selectModels:
										{leftMatrixMarker.
										rightMatrixMarker}.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ].
						"reset left marker to row beginning"
						composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftSavedMatrixMarker.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait.
						currentLeftRow := leftMatrixMarker row.
[31m#row was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #row
[ :el | el row @ el column ] in COOSparseMatrixVisualizer(MatrixVisualizer)>>getElementShapeScaled: in Block: [ :el | el row @ el column ]
BlockClosure>>rtValue:
[ :anElement | aValueOrAOneArgBlock rtValue: anElement model ] in RTLabel>>text: in Block: [ :anElement | aValueOrAOneArgBlock rtValue: anEle...etc...
BlockClosure>>rtValue:
RTLabel>>textFor:
RTLabel>>updateFor:trachelShape:
[ :tupple :shapeIndex | 
| s |
tupple first
	updateFor: anElement
	trachelShape: (anElement trachelShape shapes at: shapeIndex).
s := anElement trachelShape shapes at: shapeIndex.
Array with: s with: tupple second ] in RTCompositeShape>>updateFor:trachelShape: in Block: [ :tupple :shapeIndex | ...
OrderedCollection>>withIndexCollect:
OrderedCollection(SequenceableCollection)>>collectWithIndex:
RTCompositeShape>>updateFor:trachelShape:
RTCompositeShape(RTShape)>>updateFor:
RTElement(RTShapedObject)>>updateShape
RTElement(RTShapedObject)>>update
RTElement(RTShapedObject)>>updateModelAndRedraw:
[ :next | 
[ leftMatrixMarker isNotNil
	and: [ rightMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
	whileTrue: [ priorityColumn := {leftMatrixMarker column.
		rightMatrixMarker column} max.
		"Find same column as prioritized or higher in left"
		[ leftMatrixMarker isNotNil
			and: [ leftMatrixMarker row = currentLeftRow
					and: [ leftMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait ].
		leftMatrixMarker isNil
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].

				"If no intersection - end"
				rightMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		leftMatrixMarker row ~= currentLeftRow
			ifTrue: [ [ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
								rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
								(Delay forSeconds: delay) wait ] ].
				next value ].
		priorityColumn := leftMatrixMarker column.

		"Find same column as prioritized or higher in right"
		[ rightMatrixMarker isNotNil
			and: [ rightMatrixMarker row = currentRightColumn
					and: [ rightMatrixMarker column < priorityColumn ] ] ]
			whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				rightMatrixMarker isNotNil
					ifTrue:
						[ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
				composer selectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait ].
		rightMatrixMarker isNil
			ifTrue: [ [ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].

				"If no intersections - end"
				leftMatrixMarker isNil
					ifTrue: [ end value ].
				"Else - continue loop"
				next value ].
		rightMatrixMarker row ~= currentRightColumn
			ifTrue: [ next value ].
		leftMatrixMarker column = rightMatrixMarker column
			ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
				composer highlightModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
				composer deselectModel: leftMatrixMarker inGroup: #left.
				composer deselectModel: rightMatrixMarker inGroup: #right.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftMatrixMarker rightNeighbour.
				rightMatrixMarker := rightMatrixMarker rightNeighbour.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				rightMatrixMarker isNotNil
					ifTrue: [ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
				composer
					selectModels:
						{leftMatrixMarker.
						rightMatrixMarker}.
				(Delay forSeconds: delay) wait ]
			ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ] in [ :outer | 
"Switch to next row in left and reset right marker if right ended"
rightMatrixMarker isNil
	ifTrue: [ rightMatrixMarker := transposed first.
		leftSavedMatrixMarker := leftMatrixMarker.
		composer
			selectModels:
				{leftMatrixMarker.
				rightMatrixMarker}.
		leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
		rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
		(Delay forSeconds: delay) wait ].
"reset left marker to row beginning"
composer deselectModel: leftMatrixMarker inGroup: #left.
(Delay forSeconds: delay) wait.
leftMatrixMarker := leftSavedMatrixMarker.
composer selectModel: leftMatrixMarker inGroup: #left.
leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
(Delay forSeconds: delay) wait.
currentLeftRow := leftMatrixMarker row.
currentRightColumn := rightMatrixMarker row.
nowProcessingElementIndex
	model:
		{currentLeftRow.
		currentRightColumn}.
nowProcessingElementIndex update.
self
	withEscaper: [ :next | 
		[ leftMatrixMarker isNotNil
			and: [ rightMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
			whileTrue: [ priorityColumn := {leftMatrixMarker column.
				rightMatrixMarker column} max.
				"Find same column as prioritized or higher in left"
				[ leftMatrixMarker isNotNil
					and: [ leftMatrixMarker row = currentLeftRow
							and: [ leftMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						composer selectModel: leftMatrixMarker inGroup: #left.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						(Delay forSeconds: delay) wait ].
				leftMatrixMarker isNil
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].

						"If no intersection - end"
						rightMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				leftMatrixMarker row ~= currentLeftRow
					ifTrue: [ [ rightMatrixMarker isNotNil
							and: [ rightMatrixMarker row = currentRightColumn ] ]
							whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
								(Delay forSeconds: delay) wait.
								rightMatrixMarker := rightMatrixMarker rightNeighbour.
								rightMatrixMarker isNotNil
									ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
										rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
										(Delay forSeconds: delay) wait ] ].
						next value ].
				priorityColumn := leftMatrixMarker column.

				"Find same column as prioritized or higher in right"
				[ rightMatrixMarker isNotNil
					and: [ rightMatrixMarker row = currentRightColumn
							and: [ rightMatrixMarker column < priorityColumn ] ] ]
					whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						rightMatrixMarker isNotNil
							ifTrue:
								[ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
						composer selectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait ].
				rightMatrixMarker isNil
					ifTrue: [ [ leftMatrixMarker isNotNil
							and: [ leftMatrixMarker row = currentLeftRow ] ]
							whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
								(Delay forSeconds: delay) wait.
								leftMatrixMarker := leftMatrixMarker rightNeighbour.
								composer selectModel: leftMatrixMarker inGroup: #left.
								leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
								(Delay forSeconds: delay) wait ].

						"If no intersections - end"
						leftMatrixMarker isNil
							ifTrue: [ end value ].
						"Else - continue loop"
						next value ].
				rightMatrixMarker row ~= currentRightColumn
					ifTrue: [ next value ].
				leftMatrixMarker column = rightMatrixMarker column
					ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
						composer highlightModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						sum := sum + (leftMatrixMarker value * rightMatrixMarker value).
						composer deselectModel: leftMatrixMarker inGroup: #left.
						composer deselectModel: rightMatrixMarker inGroup: #right.
						(Delay forSeconds: delay) wait.
						leftMatrixMarker := leftMatrixMarker rightNeighbour.
						rightMatrixMarker := rightMatrixMarker rightNeighbour.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMatrixMarker isNotNil
							ifTrue: [ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
						composer
							selectModels:
								{leftMatrixMarker.
								rightMatrixMarker}.
						(Delay forSeconds: delay) wait ]
					ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
sum = 0
	ifFalse: [ newNode := COOSparseMatrixNode
			row: currentLeftRow
			column: currentRightColumn
			value: sum.
		result last rightNeighbour: newNode.
		newNode leftNeighbour: result last.
		result last: newNode.
		sum := 0.
		visualizer updateResultWith: result ] ] in [ :end | 
[ rightMatrixMarker isNotNil or: [ leftMatrixMarker isNotNil ] ]
	whileTrue: [ self
			withEscaper: [ :outer | 
				"Switch to next row in left and reset right marker if right ended"
				rightMatrixMarker isNil
					ifTrue: [ rightMatrixMarker := transposed first.
						leftSavedMatrixMarker := leftMatrixMarker.
						composer
							selectModels:
								{leftMatrixMarker.
								rightMatrixMarker}.
						leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
						rightMarkerElement updateModelAndRedraw: rightMatrixMarker.
						(Delay forSeconds: delay) wait ].
				"reset left marker to row beginning"
				composer deselectModel: leftMatrixMarker inGroup: #left.
				(Delay forSeconds: delay) wait.
				leftMatrixMarker := leftSavedMatrixMarker.
				composer selectModel: leftMatrixMarker inGroup: #left.
				leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
				(Delay forSeconds: delay) wait.
				currentLeftRow := leftMatrixMarker row.
				currentRightColumn := rightMatrixMarker row.
				nowProcessingElementIndex
					model:
						{currentLeftRow.
						currentRightColumn}.
				nowProcessingElementIndex update.
				self
					withEscaper: [ :next | 
						[ leftMatrixMarker isNotNil
							and: [ rightMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ rightMatrixMarker row = currentRightColumn ] ] ] ]
							whileTrue: [ priorityColumn := {leftMatrixMarker column.
								rightMatrixMarker column} max.
								"Find same column as prioritized or higher in left"
								[ leftMatrixMarker isNotNil
									and: [ leftMatrixMarker row = currentLeftRow
											and: [ leftMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										composer selectModel: leftMatrixMarker inGroup: #left.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										(Delay forSeconds: delay) wait ].
								leftMatrixMarker isNil
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].

										"If no intersection - end"
										rightMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								leftMatrixMarker row ~= currentLeftRow
									ifTrue: [ [ rightMatrixMarker isNotNil
											and: [ rightMatrixMarker row = currentRightColumn ] ]
											whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
												(Delay forSeconds: delay) wait.
												rightMatrixMarker := rightMatrixMarker rightNeighbour.
												rightMatrixMarker isNotNil
													ifTrue: [ composer selectModel: rightMatrixMarker inGroup: #right.
														rightMarkerElement
															updateModelAndRedraw: rightMatrixMarker.
														(Delay forSeconds: delay) wait ] ].
										next value ].
								priorityColumn := leftMatrixMarker column.

								"Find same column as prioritized or higher in right"
								[ rightMatrixMarker isNotNil
									and: [ rightMatrixMarker row = currentRightColumn
											and: [ rightMatrixMarker column < priorityColumn ] ] ]
									whileTrue: [ composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										rightMatrixMarker isNotNil
											ifTrue:
												[ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
										composer selectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait ].
								rightMatrixMarker isNil
									ifTrue: [ [ leftMatrixMarker isNotNil
											and: [ leftMatrixMarker row = currentLeftRow ] ]
											whileTrue: [ composer deselectModel: leftMatrixMarker inGroup: #left.
												(Delay forSeconds: delay) wait.
												leftMatrixMarker := leftMatrixMarker rightNeighbour.
												composer selectModel: leftMatrixMarker inGroup: #left.
												leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
												(Delay forSeconds: delay) wait ].

										"If no intersections - end"
										leftMatrixMarker isNil
											ifTrue: [ end value ].
										"Else - continue loop"
										next value ].
								rightMatrixMarker row ~= currentRightColumn
									ifTrue: [ next value ].
								leftMatrixMarker column = rightMatrixMarker column
									ifTrue: [ composer highlightModel: leftMatrixMarker inGroup: #left.
										composer highlightModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										sum := sum
											+ (leftMatrixMarker value * rightMatrixMarker value).
										composer deselectModel: leftMatrixMarker inGroup: #left.
										composer deselectModel: rightMatrixMarker inGroup: #right.
										(Delay forSeconds: delay) wait.
										leftMatrixMarker := leftMatrixMarker rightNeighbour.
										rightMatrixMarker := rightMatrixMarker rightNeighbour.
										leftMarkerElement updateModelAndRedraw: leftMatrixMarker.
										rightMatrixMarker isNotNil
											ifTrue: [ rightMarkerElement updateModelAndRedraw: rightMatrixMarker ].
										composer
											selectModels:
												{leftMatrixMarker.
												rightMatrixMarker}.
										(Delay forSeconds: delay) wait ]
									ifFalse: [ priorityColumn := rightMatrixMarker column ] ] ].
				sum = 0
					ifFalse: [ newNode := COOSparseMatrixNode
							row: currentLeftRow
							column: currentRightColumn
							value: sum.
						result last rightNeighbour: newNode.
						newNode leftNeighbour: result last.
						result last: newNode.
						sum := 0.
						visualizer updateResultWith: result ] ].
		sum = 0
			ifFalse: [ newNode := COOSparseMatrixNode
					row: currentLeftRow
					column: currentRightColumn
					value: sum.
				result last rightNeighbour: newNode.
				newNode leftNeighbour: result last.
				result last: newNode.
				sum := 0.
				visualizer updateResultWith: result ] ] ] in [31mUser Interrupt
[0mAlien class>>invokeCallbackContext:
LGitRemote>>remote_push:refspecs:opts:
LGitSafeFFICalloutAPI(FFICalloutAPI)>>function:module:
LGitRemote(LGitExternalObject)>>call:options:
LGitRemote>>remote_push:refspecs:opts:
[ self remote_push: self refspecs: refspecs opts: pushOptions ] in LGitRemote>>pushWithRefSpec:pushOptions: in Block: [ self remote_push: self refspecs: refspecs opts: ...etc...
LGitRemote(LGitExternalObject)>>withReturnHandlerDo:
LGitRemote>>pushWithRefSpec:pushOptions:
IceGitLocalBranch>>pushBranchToRemote:gitRemote:progress:
[ | pushProgress |
pushProgress := IcePushTransferProgress new.
"Push branch"
self
	pushBranchToRemote: aRemote
	gitRemote: gitRemote
	progress: pushProgress.
"Push tags"
self
	pushTagsToRemote: aRemote
	gitRemote: gitRemote
	progress: pushProgress.

"Verify we have an stream"
self setUpstreamIfMissing: aRemote ] in IceGitLocalBranch>>basicPushTo: in Block: [ | pushProgress |...
BlockClosure>>on:do:
IceGitLocalBranch>>basicPushTo:
[ self basicPushTo: aRemote ] in IceGitLocalBranch>>pushTo: in Block: [ self basicPushTo: aRemote ]
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitLocalBranch>>pushTo:
IceGitLocalBranch(IceLocalBranch)>>push
IceLibgitRepository(IceRepository)>>push
[ self repository push ] in IceTipPushAction>>basicExecute in Block: [ self repository push ]
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during: in Block: [ :bar | ...
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring: in Block: [ :bar | aBlock value: bar ]
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ ^ block cull: self ]
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during: in Block: [ activeProcess psValueAt: index put: anObject....
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ self prepareForRunning....
BlockClosure>>ensure:
Job>>run
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m