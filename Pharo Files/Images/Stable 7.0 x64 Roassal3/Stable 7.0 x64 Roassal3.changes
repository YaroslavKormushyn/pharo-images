----QUIT----2019-04-12T16:55:02.007919+02:00 Pharo7.0.3-0-32bit-0903ade.image priorSource: 0!----QUIT----2019-04-12T16:55:17.898582+02:00 Pharo7.0.3-0-32bit-0903ade.image priorSource: 0!!BaselineOfRoassal3 commentStamp: '' prior: 0!Baseline for https://github.com/ObjectProfile/Roassal3!!BaselineOfRoassal3 methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ | dep |			spec package: 'Athens-SVG' with: [				spec repository: 'http://www.smalltalkhub.com/mc/Pharo/Athens/main' ].			spec package: 'Geometry' with: [ 				spec repository: 'github://TelescopeSt/Geometry:v1.1.0/src' ].			dep := (AthensCairoCanvas canUnderstand: #fillRuleEvenOdd)				ifTrue: [ #('Athens-SVG') ]				ifFalse: [ #('Athens-SVG' 'Roassal3-Pharo7') ].			spec				package: #'Roassal3-Pharo7';				package: #'Roassal3-Trachel' with: [spec requires: dep];				package: #'Roassal3-Scales';				package: 'Roassal3-Animation';				package: #'Roassal3-Trachel-Shapes';				package: #'Roassal3' with: [spec requires: #('Geometry')];				package: #'Roassal3-Utils';								package: #'Roassal3-Layouts';				package: #'Roassal3-Trachel-Shapes';				package: #'Roassal3-Examples';				package: #'Roassal3-Tests'.							spec 				group: 'Core' with: #(					'Roassal3'					'Roassal3-Layouts'					'Roassal3-Utils'					'Roassal3-Scales'					'Roassal3-Animation'					'Roassal3-Trachel'					'Roassal3-Trachel-Shapes');				group: 'Examples'  with: #('Core' 'Roassal3-Examples');				group: 'Tests' with: #('Core' 'Roassal3-Tests');				group: 'default' with: #('Core' 'Tests' 'Examples') ]						! !"BaselineOfRoassal3"!!ASConverter commentStamp: 'StephaneDucasse 12/6/2014 07:12' prior: 0!A converter is a kind of parser.!!ASPathConverter commentStamp: '<historical>' prior: 0!The syntax of path data is concise in order to allow for minimal file size and efficient downloads, since many SVG files will be dominated by their path data. Some of the ways that SVG attempts to minimize the size of path data are as follows:● All instructions are expressed as one character (e.g., a moveto is expressed as an M).● Superfluous white space and separators such as commas can be eliminated (e.g., "M 100 100 L 200 200"contains unnecessary spaces and could be expressed more compactly as "M100 100L200 200").● The command letter can be eliminated on subsequent commands if the same command is used multiple timesin a row (e.g., you can drop the second "L" in "M 100 200 L 200 100 L -100 -200" and use "M 100 200 L 200100 -100 -200" instead).● Relative versions of all commands are available (uppercase means absolute coordinates, lowercase meansrelative coordinates).● Alternate forms of lineto are available to optimize the special cases of horizontal and vertical lines (absolute andrelative).● Alternate forms of curve are available to optimize the special cases where some of the control points on thecurrent segment can be determined automatically from the control points on the previous segment.!!ASElement commentStamp: 'StephaneDucasse 12/6/2014 07:18' prior: 0!Root ot the SVG ElementsAn SVG Element has 	- attributes			- id			- parentPay attention that some methods contain _ because of an automatic conversion.Read 	attributeSetter: aString		"fill-opacity   =>>  fill_opacity:		x =>> x:		"!!ASContainerElement commentStamp: 'StephaneDucasse 12/6/2014 07:27' prior: 0!An ASContainerElement is ASElement with children.Instance Variables	children!!ASVGRoot commentStamp: '<historical>' prior: 0!i am root element of SVG document, correspond to a <svg> tag in document.!!ASRect commentStamp: '<historical>' prior: 0!The 'rect' element defines a rectangle which is axis-aligned with the current user coordinate system. Rounded rectangles can be achieved by setting appropriate values for attributes rx and ry.If a properly specified value is provided for rx but not for ry, then the user agent processes the 'rect' element with the effective value for ry as equal to rx. If a properly specified value is provided for ry but not for rx, then the user agent processes the 'rect' element with the effective value for rx as equal to ry. If neither rx nor ry has a properly specified value, then the user agent processes the 'rect' element as if no rounding had been specified, resulting in square corners. If rx is greater than half of the width of the rectangle, then the user agent processes the 'rect' element with the effective value for rx as half of the width of the rectangle. If ry is greater than half of the height of the rectangle, then the user agent processes the 'rect' element with the effective value for ry as half of the height of the rectangle.Mathematically, a 'rect' element can be mapped to an equivalent 'path' element as follows: (Note: all coordinate and length values are first converted into user space coordinates according to Units.)● perform an absolute moveto operation to location (x+rx,y), where x is the value of the 'rect' element's x attribute converted to user space, rx is the effective value of the rx attribute converted to user space and y is the value of the y attribute converted to user space● perform an absolute horizontal lineto operation to location (x+width-rx,y), where width is the 'rect' element's width attribute converted to user space● perform an absolute elliptical arc operation to coordinate (x+width,y+ry), where the effective values for the rx and ry attributes on the 'rect' element converted to user space are used as the rx and ry attributes on the elliptical arc command, respectively, the x-axis-rotation is set to zero, the large-arc-flag is set to zero, and the sweep-flag is set to one● perform a absolute vertical lineto to location (x+width,y+height-ry), where height is the 'rect' element's height attribute converted to user space● perform an absolute elliptical arc operation to coordinate (x+width-rx,y+height)● perform an absolute horizontal lineto to location (x+rx,y+height)● perform an absolute elliptical arc operation to coordinate (x,y+height-ry)● perform an absolute absolute vertical lineto to location (x,y+ry)● perform an absolute elliptical arc operation to coordinate (x+rx,y)!!ASLength commentStamp: '<historical>' prior: 0!A coordinate or length value can be expressed as a number following by a unit identifier (e.g., "25cm" or "15em"). The list of unit identifiers in SVG matches the list of unit identifiers in CSS: em, ex, px, pt, pc, cm, mm, in and percentages. The following describes how the various unit identifiers are processed:!!ASVGMorph class methodsFor: 'instance creation' stamp: 'IgorStasenko 4/23/2012 16:52'!fromFile: aFileName	| svg |	svg := AthensSVGConverter fromFile: aFileName.	^ self new svg: svg ! !!ASVGMorph methodsFor: 'session management' stamp: 'IgorStasenko 4/11/2013 14:58'!checkSession	session == Smalltalk session ifFalse: [		self initializeForNewSession		]! !!ASVGMorph methodsFor: 'drawing' stamp: 'IgorStasenko 4/11/2013 14:58'!drawOn: aCanvas	self checkSession.	surface drawDuring: [:canvas |  				surface clear."		canvas setPaint: Color red;		drawShape:  (0@0 corner: self extent)."		canvas pathTransform restoreAfter: [			canvas pathTransform scaleBy:zoom.			svg renderOn: canvas viewportExtent: self extent.		]	 ].	aCanvas translucentImage: surface asForm at: self innerBounds origin! !!ASVGMorph methodsFor: 'initialize' stamp: 'IgorStasenko 4/24/2012 17:28'!initialize	super initialize. 	zoom :=1.! !!ASVGMorph methodsFor: 'session management' stamp: 'IgorStasenko 4/11/2013 20:32'!initializeForNewSession		| w h |	svg width ifNotNil: [		w := svg width valueForDPI: self screenDPI.		h := svg height valueForDPI: self screenDPI.		] ifNil: [		w := 500. h := 400.		].	surface := AthensCairoSurface extent: (w asInteger @ (h asInteger + 1)).		self extent: surface extent.		session := Smalltalk session.		! !!ASVGMorph methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:37'!screenDPI 	^ 96 "just a guess "! !!ASVGMorph methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:07'!setZoom: factor	| w h |	w := svg width valueForDPI: self screenDPI.	h := svg height valueForDPI: self screenDPI.	zoom := factor.	surface := AthensCairoSurface extent: (w*factor) asInteger @ ((h*factor) asInteger + 1).		self extent: surface extent.	self changed! !!ASVGMorph methodsFor: 'accessing' stamp: 'IgorStasenko 4/11/2013 15:00'!svg: aSVGRoot		svg := aSVGRoot.		self initializeForNewSession.		self changed! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:52'!animateZoomTo: zoomLevel	targetZoom := zoomLevel.	animStartZoom := currentZoom.	currentAnimation := ASAnimation new subject: self.	currentAnimation stopCondition: [:anim | anim duration >= self maxAnimationDuration ].	currentAnimation stepAction:  [:anim | | duration |		duration := (anim duration min: self maxAnimationDuration) / self maxAnimationDuration asFloat.				self setZoom:  animStartZoom * (1-duration) + (targetZoom * duration).		 ].	currentAnimation finishAction: [:anim |		self stopStepping.		self setZoom: targetZoom.		currentAnimation := nil.		].		currentAnimation start.	self startStepping! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 15:14'!drawDropShadowOn: aCanvas! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:36'!drawOn: aCanvas		svg ifNotNil: [				surface drawDuring: [:canvas |  					surface clear.			canvas pathTransform restoreAfter: [				canvas pathTransform scaleBy: (currentZoom * svgZoom) asFloat.				svg renderOn: canvas.			]		 ].		aCanvas translucentImage: surface asForm at: self innerBounds origin			] ifNil: [		super drawOn: aCanvas.	]! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:52'!extent: pos	super extent: pos.		animCenter := self bounds center.	! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 15:17'!handlesDropShadowInHand	"Answer whether the receiver will handle drop shadow drawing when picked up in the hand."	^ true! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 11:11'!handlesMouseOver: evt	^ true! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 12:50'!initialize 	super initialize.		currentZoom := 1.	basicExtent  := self extent.! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:49'!justDroppedInto: aMorph event: anEvent	super justDroppedInto: aMorph event: anEvent.		animCenter := self bounds center.! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:54'!maxAnimationDuration	^ 100! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:09'!maxZoom		^ maxZoom ifNil: [ maxZoom := 2 ]! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:10'!maxZoom: aValue	maxZoom := aValue max: 1! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 15:04'!mouseEnter: evt	self comeToFront.	self animateZoomTo: self maxZoom! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 11:14'!mouseLeave: evt	self animateZoomTo: 1! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:51'!position: pos	super position: pos.		animCenter := self bounds center.	! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 13:59'!screenDPI 	^ 96 "just a guess "! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:50'!setZoom: aZoom	|  newExtent oldCenter |	currentZoom := aZoom.	newExtent := basicExtent * aZoom.		oldCenter := animCenter.	self bounds: (animCenter - (newExtent /2) extent: newExtent).	animCenter := oldCenter.		self changed! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 11:44'!step	currentAnimation ifNotNil: [		currentAnimation step		]! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 12:01'!stepTime	^ 20! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:28'!svg: anSVG	^ self svg: anSVG zoom: 1! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:37'!svg: anSVG zoom: anSvgZoom	| w h |		svg := anSVG.	svg isString ifTrue: [ svg :=  AthensSVGConverter fromFile: svg ].	svgExtent := self extent.		svg width ifNotNil: [		w := svg width valueForDPI: self screenDPI.		h := svg height valueForDPI: self screenDPI.		svgExtent := (w@h) * anSvgZoom + (2@2).		svgZoom := anSvgZoom.	] ifNil: [		svgExtent := self extent.		svgZoom := 1.	].	surface := AthensCairoSurface extent: (svgExtent * self maxZoom + (1@1)) asIntegerPoint.	basicExtent := svgExtent.	self extent: svgExtent.	currentZoom := 1.		self changed! !!ASZoomerMorph methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 6/10/2012 14:48'!wantsToBeDroppedInto: aMorph	^ aMorph isWorldMorph! !!String methodsFor: '*Athens-SVG' stamp: 'AliakseiSyrel 7/30/2015 15:35'!asFillOn: aConverter	^ aConverter fromString: self trimBoth! !!AthensCairoPathBuilder methodsFor: '*Athens-SVG' stamp: 'IgorStasenko 4/11/2013 15:18'!ellipticalArc: radii xrot: rotation large: largeFlag sweep: sweepFlag to: pt	 self cwArcTo: pt angle: 45 degreesToRadians  ! !!Color methodsFor: '*Athens-SVG' stamp: 'AliakseiSyrel 7/30/2015 15:37'!asFillOn: aConverter	^ aConverter fromColor: self! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:29'!duration 	^ Time millisecondClockValue - started! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:15'!finishAction	^ finishAction! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:15'!finishAction: anObject	finishAction := anObject! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:28'!start	started := Time millisecondClockValue.! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:34'!step	(stopCondition value: self )		ifTrue: [ finishAction value: self ] 		ifFalse: [ stepAction value: self  ]! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:15'!stepAction	^ stepAction! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:29'!stepAction: aBlock	stepAction := aBlock! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:30'!stopCondition: aBlock	stopCondition := aBlock! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:15'!subject	^ subject! !!ASAnimation methodsFor: 'accessing' stamp: 'IgorStasenko 6/10/2012 11:15'!subject: anObject	subject := anObject! !!ASConverter methodsFor: 'parsing-public' stamp: 'IgorStasenko 4/27/2012 16:17'!nextNumber	"read the number from stream.	or answer nil if not successfull"	"<number> (real number value): The specification of real number values is different for property values than for XML attribute values.❍ CSS2 [CSS2] states that a property value which is a <number> is specified in decimal notation (i.e., a <decimal-number>), which consists of either an <integer>, or an optional sign character followed byzero or more digits followed by a dot (.) followed by one or more digits. Thus, for conformance withCSS2, any property in SVG which accepts <number> values is specified in decimal notation only.❍ For SVG's XML attributes, to provide as much scalability in numeric values as possible, real numbervalues can be provided either in decimal notation or in scientific notation (i.e., a <scientific-number>), which consists of a <decimal-number> immediately followed by the letter ''e'' or ''E'' immediately followed by an <integer>.Unless stated otherwise for a particular attribute or property, a <number> has the capacity for at least a single- precision floating point number (see [ICC32]) and has a range (at a minimum) of -3.4e+38F to +3.4e+38F.It is recommended that higher precision floating point storage and computation be performed on operations such as coordinate system transformations to provide the best possible precision and to prevent round-off errors.Conforming High-Quality SVG Viewers are required to use at least double-precision floating point (see [ICC32]) for intermediate calculations on certain numerical operations.Within the SVG DOM, a <number> is represented as a float or an SVGAnimatedNumber."		| result char sign esign pos int frac exponent |		esign := sign := 1.	pos := stream position.		stream peek = $- ifTrue: [ sign := -1.  stream next ].	int := self readInteger.		stream peek = $. ifTrue: [		stream next.		frac := self readFraction.	].		(stream peek = $e or: [ stream peek = $E ]) ifTrue: [		stream next.		stream peek = $- ifTrue: [ esign := -1.  stream next ].		exponent := self readInteger * esign ].		"failed"	(int isNil and: [ frac isNil ]) ifTrue: [ stream position: pos.  ^ nil ].		int ifNil: [ int := 0 ].	frac ifNil: [ frac := 0 ].	exponent ifNil: [ exponent := 0 ].		result :=  (int + frac * (10 raisedTo: exponent) * sign).		result isFraction ifTrue: [  ^ result asFloat ] ifFalse: [ ^ result ]! !!ASConverter methodsFor: 'accessing' stamp: 'IgorStasenko 4/27/2012 11:50'!noFill	^ ASNoFill soleInstance ! !!ASConverter methodsFor: 'parsing' stamp: 'IgorStasenko 4/24/2012 16:40'!parseColor: aString	^ Color fromString: aString! !!ASConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/24/2012 19:11'!readFraction"read fraction, what is after the decimal point:.12345"	| result mul |	(stream atEnd or: [ stream peek isDigit not ]) ifTrue: [ ^ nil ].		mul := 1/10. 	result := 0.	[ stream peek notNil and: [ stream peek isDigit ] ] whileTrue: [		result := result + ( (stream next digitValue) * mul ).		mul := mul / 10	].	^ result! !!ASConverter methodsFor: 'write and read' stamp: 'IgorStasenko 4/24/2012 16:07'!readInteger	| result |	(stream atEnd or: [ stream peek isDigit not ]) ifTrue: [ ^ nil ].		result := 0.	[ stream peek notNil and: [ stream peek isDigit ] ] whileTrue: [		result := result * 10 + (stream next digitValue)	].	^ result! !!ASConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/23/2012 15:48'!skipBlanks	[ stream atEnd not and: [ stream peek isSeparator ] ] whileTrue: [ stream next ].! !!ASConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/25/2012 16:30'!skipBlanksAndComma	[ stream atEnd not and: [ stream peek isSeparator or: [stream peek =$,]] ] whileTrue: [ stream next ].! !!ASConverter methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 15:58'!stream	^ stream! !!ASConverter methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 15:49'!stream: aStream	stream := aStream! !!ASFillConverter methodsFor: 'parsing' stamp: 'AliakseiSyrel 7/30/2015 15:20'!fromColor: aColor	^ ASColorPaint new color: aColor! !!ASFillConverter methodsFor: 'parsing' stamp: 'AliakseiSyrel 7/30/2015 15:13'!fromHex: aString	^ ASColorPaint new color: (self parseColor: aString allButFirst)! !!ASFillConverter methodsFor: 'parsing' stamp: 'AliakseiSyrel 7/30/2015 15:23'!fromName: aString	^ ASColorPaint new color: (Color perform: aString asSymbol)! !!ASFillConverter methodsFor: 'parsing' stamp: 'AliakseiSyrel 7/30/2015 15:18'!fromRgb: aString	| str numbers |	str := (aString copyAfter: $( ) copyUpTo: $).	numbers := (str substrings: ',') collect: [:ea| ea trimBoth asNumber].	^ ASColorPaint new color: (		Color r: numbers first			g: numbers second			b: numbers third			range: 255)! !!ASFillConverter methodsFor: 'parsing' stamp: 'AliakseiSyrel 7/30/2015 15:36'!fromString: aString	(self isHex: aString) ifTrue: [		^ self fromHex: aString ].		(self isNone: aString) ifTrue: [		^ self noFill ].		(self isUrl: aString) ifTrue: [		^ self fromUrl: aString ].		(self isRgb: aString) ifTrue: [		^ self fromRgb: aString ].		(self isName: aString) ifTrue: [		^ self fromName: aString ].		Error signal: ('Unknown fill property: ', aString asString)! !!ASFillConverter methodsFor: 'parsing' stamp: 'AliakseiSyrel 7/30/2015 15:17'!fromUrl: aString	^ ASLink new url: ( (aString copyAfter: $( ) copyUpTo: $) )! !!ASFillConverter methodsFor: 'testing' stamp: 'AliakseiSyrel 7/30/2015 15:29'!isHex: aString	^ aString first = $#! !!ASFillConverter methodsFor: 'testing' stamp: 'AliakseiSyrel 7/30/2015 15:28'!isName: aString	^ Color respondsTo: aString asSymbol! !!ASFillConverter methodsFor: 'testing' stamp: 'AliakseiSyrel 7/30/2015 15:27'!isNone: aString	^ aString = 'none'! !!ASFillConverter methodsFor: 'testing' stamp: 'AliakseiSyrel 7/30/2015 15:25'!isRgb: aString	^ aString beginsWith: 'rgb'! !!ASFillConverter methodsFor: 'testing' stamp: 'AliakseiSyrel 7/30/2015 15:26'!isUrl: aString	^ aString beginsWith: 'url'! !!ASFillConverter methodsFor: 'translate' stamp: 'AliakseiSyrel 7/30/2015 15:46'!translate: anObject		^ anObject asFillOn: self! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/25/2012 17:06'!A	self absolute; ellipticalArc! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/23/2012 19:16'!C	^ self absolute; cubicBezier ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:15'!H	self absolute; hLineTo ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/23/2012 19:21'!L	self absolute; lineTo.! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/23/2012 19:17'!M	"move-to absolute"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	self absolute; moveTo.! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:20'!Q	self absolute; quadraticBezier! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:18'!S	self absolute; reflectedCubicBezier! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:20'!T	self absolute; smoothQuadraticBezier! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:15'!V	self absolute; vLineTo ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:09'!Z	self close! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/25/2012 17:06'!a	self relative; ellipticalArc! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/25/2012 08:38'!absolute	absolute := true.	self addSegment ! !!ASPathConverter methodsFor: 'adding' stamp: 'IgorStasenko 4/25/2012 08:41'!addSegment	| sel args |	sel := 	thisContext sender selector.	args := thisContext sender arguments.	"update min/max for calculatin bounding box"		path add: { sel. args }! !!ASPathConverter methodsFor: 'converting' stamp: 'IgorStasenko 4/23/2012 18:29'!assertValidCommand: aCharacter 	( #( $M $m $Z $z $L $l $H $h $V $v $C $c $S $s $Q $q $T $t $A $a ) includes: aCharacter ) ifFalse: [		self error: 'invalid path segment command' ]! !!ASPathConverter methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 08:42'!bbox	^ 100@100! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/23/2012 19:16'!c	^ self relative; cubicBezier ! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/24/2012 16:32'!close	self addSegment ! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/23/2012 19:26'!convertPathData	path := OrderedCollection new.		[ self skipBlanks. stream atEnd ] whileFalse: [		| cmd |		cmd := stream next.		self assertValidCommand: cmd.		self perform: cmd asString asSymbol.	].	^ path	! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/24/2012 18:14'!cubicBezier"C/c (x1 y1 x2 y2 x y)+Draws a cubic Bézier curve from the current point to (x,y) using (x1,y1) as the control point at the beginning of the curve and (x2,y2) as the control point at the end of the curve. C (uppercase) indicates that absolute coordinates will follow; c (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybézier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybézier."	| p1 p2 p3 |		p1 := self readPoint.	p2 := self readPoint.	p3 := self readPoint.		p3 ifNil: [ self error: 'Invalid path data: 3 points expected for cubic bezier '].	self curveVia: p1 and:  p2 to: p3. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p3 := self readPoint.		p3 ifNil: [ self error: 'Invalid path data: 3 points expected for cubic bezier '].		self curveVia: p1 and:  p2 to: p3. 	] repeat.! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/24/2012 16:32'!curveVia: aPoint and: aPoint2 to: aPoint3 	self addSegment ! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/24/2012 16:32'!curveVia: aPoint to: aPoint2 	self addSegment ! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/25/2012 21:12'!ellipticalArc "A (absolute) a (relative)elliptical arc(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+Draws an elliptical arc from the current point to (x, y). The size and orientation of the ellipse are defined by two radii (rx, ry) and an x-axis-rotation, which indicates how the ellipse as a whole is rotated relative to the current coordinate system. The center (cx, cy) of the ellipse is calculated automatically to satisfy the constraints imposed by the other parameters. large-arc-flag and sweep- flag contribute to the automatic calculations and help determine how the arc is drawn."	| r xrot large sweep pt |		[	r := self readPoint.	r ifNil: [ ^ self ].		self skipBlanksAndComma.		xrot := self nextNumber.	self skipBlanksAndComma.		large := self nextNumber.	self skipBlanksAndComma.	sweep := self nextNumber.		pt := self readPoint.		pt ifNil: [ self error: 'Invalid path data for elliptical arc segment'].	self ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt.	] repeat.! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/11/2013 15:14'!ellipticalArc: r xrot: xrot large: large sweep: sweep to: pt	self addSegment! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:15'!h	self relative; hLineTo ! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/24/2012 16:14'!hLineTo"H (absolute) h (relative)x +Draws a horizontal line from the current point (cpx, cpy) to (x, cpy). H (uppercase) indicates that absolute coordinates will follow; h (lowercase) indicates that relative coordinates will follow. Multiple x values can be provided (although usually this doesn't make sense). At the end of the command, the new current point becomes (x, cpy) for the final value of x."	| x |		self skipBlanks.	x := self nextNumber ifNil: [ ^ self error: 'number expected for horizontal line segment'   ].		self hLineTo: x.		[ self skipBlanks. x := self nextNumber. x notNil ] whileTrue: [		self hLineTo: x	].! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/24/2012 16:32'!hLineTo: aNumber	self addSegment ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:09'!l	self relative; lineTo.! !!ASPathConverter methodsFor: 'operations' stamp: 'JochenRick 1/8/2014 06:01'!lastBezierPoint	path reverseDo: [ :arr | arr first caseOf: { 		[ #relative ] -> [ "ignore" ] } ]! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/23/2012 19:23'!lineTo" L (absolute) l (relative)lineto(x y)+Draw a line from the current point to the given (x,y) coordinate which becomes the new current point. L (uppercase) indicates that absolute coordinates will follow; l (lowercase) indicates that relative coordinates will follow. A number of coordinates pairs may be specified to draw a polyline. At the end of the command, the new current point is set to the final set of coordinates provided."	| pt |	pt := self readPoint.		pt ifNil: [ self error: 'point expected for line segment' ].		self lineTo: pt.		[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/24/2012 16:32'!lineTo: aPoint 	self addSegment ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/27/2012 14:20'!m	"move-to relative"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	| pt reset |	pt := self readPoint.	pt ifNil: [ self error: 'a point expected following after M/m command'].	path isEmpty ifTrue: [ 			self absolute; moveTo: pt; relative ] 		ifFalse: [ self relative; moveTo: pt ].	[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/23/2012 19:17'!moveTo	"move-to"	" 		Start a new sub-path at the given (x,y) coordinate. M (uppercase) indicates that absolute coordinates will follow; m (lowercase) indicates that relative coordinates will follow. 		If a relative moveto (m) appears as the first element of the path, then it is treated as a pair of absolute coordinates. 		If a moveto is followed by multiple pairs of coordinates, the subsequent pairs are treated as implicit lineto commands.		"	| pt |	pt := self readPoint.	pt ifNil: [ self error: 'a point expected following after M/m command'].		self moveTo: pt.		[ pt := self readPoint. pt notNil ] whileTrue: [ self lineTo: pt ]! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/24/2012 16:32'!moveTo: aPoint 	self addSegment ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:20'!q	self relative; quadraticBezier! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/24/2012 16:28'!quadraticBezier "Q/q (x1 y1 x y)+Draws a quadratic Bézier curve from the current point to (x,y) using (x1,y1) as the control point. Q (uppercase) indicates that absolute coordinates will follow; q (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybézier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybézier."	| p1 p2 |		p1 := self readPoint.	p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for quadratic bezier '].		self curveVia: p1 to: p2. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for quadratic bezier '].		self curveVia: p1 to: p2. 	] repeat.! !!ASPathConverter methodsFor: 'operations' stamp: 'JochenRick 1/6/2014 09:38'!readPoint	" A path data permits specifying points without comma separator "	| x y pos |	self skipBlanksAndComma.	pos := stream position.	x := self nextNumber ifNil: [ ^ nil ].		self skipBlanksAndComma.		y := self nextNumber ifNil: [ stream position: pos. ^ nil ].		^ x @ y! !!ASPathConverter methodsFor: 'operations' stamp: 'JochenRick 1/8/2014 06:19'!reflectedCubicBezier"S/s (x2 y2 x y)+cubic Bézier curve from the current point to (x,y). The first control point is assumed to be the reflection of the second control point on the previous command relative to the current point. (If there is no previous command or if the previous command was not an C, c, S or s, assume the first control point is coincident with the current point.) (x2,y2) is the second control point (i.e., the control point at the end of the curve). S (uppercase) indicates that absolute coordinates will follow; s (lowercase) indicates that relative coordinates will follow. Multiple sets of coordinates may be specified to draw a polybézier. At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the polybézier."	| p1 p2 |		p1 := self readPoint.	p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for reflected cubic bezier '].	self reflectedCurveVia: p1 to: p2. 		[ 		(p1 := self readPoint) ifNil: [ ^ self ].		p2 := self readPoint.		p2 ifNil: [ self error: 'Invalid path data: 2 points expected for reflected cubic bezier '].		self reflectedCurveVia: p1 to: p2. 	] repeat.! !!ASPathConverter methodsFor: 'builder commands' stamp: 'JochenRick 1/8/2014 06:11'!reflectedCurveVia: aPoint to: aPoint2 	self addSegment ! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/25/2012 08:38'!relative	absolute := false.	self addSegment ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:18'!s	self relative; reflectedCubicBezier! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/24/2012 16:20'!smoothQuadraticBezier	self notYetImplemented ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:20'!t	self relative; smoothQuadraticBezier! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/24/2012 16:15'!v	self relative; vLineTo ! !!ASPathConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/24/2012 16:15'!vLineTo"V (absolute) v (relative)Draws a vertical line from the current point (cpx, cpy) to (cpx, y). V (uppercase) indicates that absolute coordinates will follow; v (lowercase) indicates that relative coordinates will follow. Multiple y values can be provided (although usually this doesn't make sense). At the end of the command, the new current point becomes (cpx, y) for the final value of y."	| y |		self skipBlanks.	y := self nextNumber ifNil: [ ^ self error: 'number expected for horizontal line segment'   ].		self vLineTo: y.		[ self skipBlanks. y := self nextNumber. y notNil ] whileTrue: [		self vLineTo: y	].! !!ASPathConverter methodsFor: 'builder commands' stamp: 'IgorStasenko 4/24/2012 16:32'!vLineTo: aNumber		self addSegment ! !!ASPathConverter methodsFor: 'path commands' stamp: 'IgorStasenko 4/23/2012 19:24'!z	self close! !!ASTransformConverter methodsFor: 'operations' stamp: 'JochenRick 1/24/2014 10:41'!matrix	"matrix(<a> <b> <c> <d> <e> <f>), which specifies a transformation in the form of a transformation matrix of six values. matrix(a,b,c,d,e,f) is equivalent to applying the transformation matrix [a b c d e f]."		| m |	m := AthensAffineTransform new."Athens matrix: | sx   shx   x   || shy sy     y   ||  0     0     1   | "	"SVG matrix: | a   c   e   || b   d  f  ||  0     0     1   | "		"a"	self skipBlanks.	m sx: self nextNumber."b"	self skipBlanksAndComma.	m shy: self nextNumber."c"	self skipBlanksAndComma.	m shx: self nextNumber."d"	self skipBlanksAndComma.	m sy: self nextNumber."e"	self skipBlanksAndComma.	m x: self nextNumber.	"f"	self skipBlanksAndComma.	m y: self nextNumber.	transform multiplyBy: m	! !!ASTransformConverter methodsFor: 'operations' stamp: 'IgorStasenko 4/27/2012 14:02'!rotate	"rotate(<rotate-angle> [<cx> <cy>]), which specifies a rotation by <rotate-angle> degrees about a given point.If optional parameters <cx> and <cy> are not supplied, the rotate is about the origin of the current user coordinate system. The operation corresponds to the matrix [cos(a) sin(a) -sin(a) cos(a) 0 0].If optional parameters <cx> and <cy> are supplied, the rotate is about the point (<cx>, <cy>). The operation represents the equivalent of the following specification: translate(<cx>, <cy>) rotate(<rotate- angle>) translate(-<cx>, -<cy>).		"	| angle cx cy |		angle := self nextNumber.	cx := self nextNumber.	cy := self nextNumber.	cx ifNil: [		transform rotateByDegrees: angle negated .			] ifNotNil: [		"if cx is given, cy should also be present"		self assert: cy notNil. 			transform translateX: cx Y: cy. 		transform rotateByDegrees: angle negated.				transform translateX: cx negated  Y: cy negated. 	].! !!ASTransformConverter methodsFor: 'accessing' stamp: 'IgorStasenko 4/7/2012 16:19'!scale	"	scale(<sx> [<sy>]), which specifies a scale operation by sx and sy. If <sy> is not provided, it is assumedto be equal to <sx>.		"		| sx sy |		sx := self nextNumber.	self skipBlanks.	sy := self nextNumber ifNil: [ sx ].		transform scaleX: sx Y: sy! !!ASTransformConverter methodsFor: 'public access' stamp: 'IgorStasenko 4/27/2012 13:28'!translate	"	translate(<tx> [<ty>]), which specifies a translation by tx and ty. If <ty> is not provided, it is assumed to be zero.	"	| tx ty |	tx := self nextNumber.	self skipBlanks.	ty := 0.	(stream peek = $,) ifTrue: [		stream next.		self skipBlanks.		ty := self nextNumber ifNil: [ 0 ]].		transform translateX: tx Y: ty! !!ASTransformConverter methodsFor: 'operations' stamp: 'JochenRick 1/24/2014 10:28'!translateString: aString 	"translate the transform data 		'rotate(10) scale (1) translate (100,10)'	"	stream := aString readStream.	transform := AthensAffineTransform new.			[ stream atEnd ] whileFalse: [ | type |		type := (stream upTo: $() trimBoth.			self perform: type asSymbol.				stream upTo: $).		self skipBlanks		 ].	^ transform! !!ASContainerElement methodsFor: 'rendering' stamp: 'IgorStasenko 4/25/2012 05:50'!renderShapeOn: aCanvas	"render on Athens canvas"	children do: [:child | child renderOn: aCanvas ]! !!ASContainerElement methodsFor: 'internal' stamp: 'StephaneDucasse 12/6/2014 07:27'!resolveIds: idDict	self resolveMyIds: idDict.	children do: [ :each | each resolveIds: idDict ]! !!ASContainerElement methodsFor: 'translate' stamp: 'PeterUhnak 8/12/2017 21:24'!translate: node	super translate: node.	children := node nodes asArray		select: [ :each | each isStringNode not ]		thenCollect: [ :child | 			| nodeClass |			nodeClass := ASVGNodeClasses fromName: child name.			nodeClass new				parent: self;				translate: child;				yourself ]! !!ASDefs methodsFor: 'rendering' stamp: 'IgorStasenko 4/25/2012 05:19'!renderOn: aCanvas	"defs are not rendered directly"! !!ASDefs methodsFor: 'rendering' stamp: 'IgorStasenko 4/25/2012 05:50'!renderShapeOn: aCanvas	"defs are not rendered directly"! !!ASGradient methodsFor: 'operations' stamp: 'IgorStasenko 4/27/2012 15:02'!colorRampWithOpacity: aFloat 		(stops isNil or: [stops  isEmpty ]) ifTrue: [		self xlink_href ifNotNil: [:link |			^ link colorRampWithOpacity: aFloat			].		^ #().		].		^ stops collect: [:ea | ea asRampColorWithOpacity: aFloat]! !!ASGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:37'!gradientTransform: aString	gradientTransform := ASTransformConverter new translateString: aString! !!ASGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:37'!gradientUnits: aString 	gradientUnits := aString! !!ASGradient methodsFor: 'initialize' stamp: 'IgorStasenko 6/10/2012 11:02'!initialize 	super initialize.	gradientTransform := AthensAffineTransform new.! !!ASGradient methodsFor: 'rendering' stamp: 'IgorStasenko 4/27/2012 12:35'!renderOn: aCanvas	"do nothing, i'm cannot be rendered directly"! !!ASGradient methodsFor: 'operations' stamp: 'IgorStasenko 4/27/2012 15:56'!spreadMethod: aByteString 	"not yet"! !!ASLinearGradient methodsFor: 'converting' stamp: 'IgorStasenko 4/24/2012 17:18'!asAthensPaintOn: anAthensCairoCanvas 	^ self! !!ASLinearGradient methodsFor: 'operations' stamp: 'IgorStasenko 4/21/2013 14:57'!fill: aShape on: aCanvas	| ramp grad p1 p2 fo |	aCanvas paintTransform restoreAfter: [		ramp := self colorRampWithOpacity: aShape fill_opacity * aShape opacity. 		p1 := gradientTransform transform: x1@y1.		p2 := gradientTransform transform: x2@y2.				grad := aCanvas surface createLinearGradient:  ramp start: p1  stop: p2.				aCanvas setPaint: grad.		aCanvas draw	].! !!ASLinearGradient methodsFor: 'initialize' stamp: 'IgorStasenko 4/24/2012 18:10'!initialize 	super initialize.	gradientTransform := AthensAffineTransform new.! !!ASLinearGradient methodsFor: 'operations' stamp: 'NicolaiHess 4/28/2015 16:46'!stroke: aShape on: aCanvas	| ramp grad p1 p2 |	aCanvas paintTransform restoreAfter: [		ramp := self colorRampWithOpacity: aShape stroke_opacity * aShape opacity. 		p1 := gradientTransform transform: x1@y1.		p2 := gradientTransform transform: x2@y2.				grad := aCanvas surface createLinearGradient:  ramp start: p1  stop: p2.				aCanvas setStrokePaint: grad.		aCanvas draw	].! !!ASLinearGradient methodsFor: 'translate' stamp: 'IgorStasenko 4/27/2012 10:48'!translate: node	super translate: node.	stops := children ! !!ASLinearGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 13:58'!x1: aString 	x1 := self translateNumber: aString! !!ASLinearGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 14:49'!x2: aString 	x2 := self translateNumber: aString! !!ASLinearGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 14:48'!y1: aString 	y1 := self translateNumber: aString! !!ASLinearGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 14:50'!y2: aString 	y2 := self translateNumber: aString! !!ASRadialGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:32'!cx: aString 	cx := self translateLength: aString! !!ASRadialGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:32'!cy: aString 	cy := self translateLength: aString! !!ASRadialGradient methodsFor: 'operations' stamp: 'IgorStasenko 4/27/2012 15:27'!fill: shape on: aCanvas		| ramp grad p1 p2 |	aCanvas paintTransform restoreAfter: [		ramp := self colorRampWithOpacity: shape fill_opacity * shape opacity. 		p1 := gradientTransform transform: cx@cy.				fx ifNil: [ fx := cx ].		fy ifNil: [ fy := cy ].					p2 := gradientTransform transform: fx@fy.				grad := aCanvas surface createRadialGradient: ramp center: p1 radius: r focalPoint: p2.				aCanvas setPaint: grad.		aCanvas draw	].! !!ASRadialGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:34'!fx: aString 	fx := self translateLength: aString! !!ASRadialGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:34'!fy: aString 	fy := self translateLength: aString! !!ASRadialGradient methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:34'!r: aString 	r := self translateLength: aString! !!ASRadialGradient methodsFor: 'operations' stamp: 'IgorStasenko 4/27/2012 15:00'!stroke: shape on: aCanvas		| ramp grad p1 p2 |	aCanvas paintTransform restoreAfter: [		ramp := self colorRampWithOpacity: shape stroke_opacity * shape opacity. 		p1 := gradientTransform transform: cx@cy.				fx ifNil: [ fx := cx ].		fy ifNil: [ fy := cy ].					p2 := gradientTransform transform: fx@fy.				grad := aCanvas surface createRadialGradient: ramp center: p1 radius: r focalPoint: p2.				aCanvas setStrokePaint: grad.		aCanvas draw	].! !!ASGroupElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/25/2012 06:25'!stroke_opacity: aString 	stroke_opacity := self translateNumber: aString! !!ASVGRoot methodsFor: 'to be done' stamp: 'IgorStasenko 4/23/2012 17:34'!baseProfile: aString 	self yourself! !!ASVGRoot methodsFor: 'to be done' stamp: 'IgorStasenko 4/23/2012 17:31'!contentScriptType: aString 	"ignore"! !!ASVGRoot methodsFor: 'to be done' stamp: 'IgorStasenko 4/23/2012 17:34'!contentStyleType: aString 	self yourself ! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:53'!height	^ height! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:26'!height: aString 	height := ASLength fromString: aString! !!ASVGRoot methodsFor: 'attribute management' stamp: 'IgorStasenko 4/25/2012 22:12'!inheritedAttributeAt: name	"i am root, nobody to inherit from"	^ attributes at: name ifAbsent: nil! !!ASVGRoot methodsFor: 'initialize' stamp: 'JochenRick 1/24/2014 11:00'!initialize 	super initialize.	ids := Dictionary new.! !!ASVGRoot methodsFor: 'to be done' stamp: 'IgorStasenko 4/23/2012 17:35'!preserveAspectRatio: aString 	self yourself ! !!ASVGRoot methodsFor: 'rendering' stamp: 'IgorStasenko 4/25/2012 07:40'!renderOn: aCanvas viewportExtent: extent	viewBox ifNil: [ ^self renderOn: aCanvas ].		aCanvas pathTransform restoreAfter: [		aCanvas pathTransform			translateX: viewBox origin x negated Y: viewBox origin y negated;			scaleX: (extent x / viewBox width) asFloat Y: (extent y / viewBox height) asFloat.		self renderOn: aCanvas.			]! !!ASVGRoot methodsFor: 'internal' stamp: 'IgorStasenko 4/24/2012 16:34'!resolveIds 	^ self resolveIds: ids! !!ASVGRoot methodsFor: 'internal' stamp: 'IgorStasenko 4/24/2012 15:05'!setId: anId for: object	ids at: anId put: object! !!ASVGRoot methodsFor: 'translate' stamp: 'IgorStasenko 4/25/2012 07:01'!translate: node	super translate: node.	self resolveIds.! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 17:34'!version: aString 		self yourself ! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 06:09'!viewBox: aString 	"min-x min-y width height"		| conv mx my w h |		conv := ASConverter new stream: aString readStream.		mx := conv skipBlanks nextNumber.	my := conv skipBlanks nextNumber.	w := conv skipBlanks nextNumber.	h := conv skipBlanks nextNumber.	viewBox := Rectangle origin: mx@my extent: w@h! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:53'!width	^ width! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:26'!width: aString		width := ASLength fromString: aString! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 17:35'!x: aString 	self yourself ! !!ASVGRoot methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 17:36'!y: aString 	self yourself ! !!ASVGRoot methodsFor: 'internal' stamp: 'IgorStasenko 4/23/2012 17:32'!zoomAndPan: aString 	"self shouldBeImplemented."! !!ASElement class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/7/2012 14:29'!convertXML: aXMLElement 	^ self new convertXML: aXMLElement! !!ASElement class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 06:28'!initialize	EmptyDict := IdentityDictionary new.! !!ASElement class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/7/2012 14:37'!translateNode: xmlNode	| nodeClass |	nodeClass := ASVGNodeClasses fromName: xmlNode name.	^ nodeClass new translate: xmlNode! !!ASElement class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 15:03'!translateNode: xmlNode parent: aParent	| nodeClass |	nodeClass := ASVGNodeClasses fromName: xmlNode name.	^ nodeClass new translate: xmlNode parent: aParent! !!ASElement methodsFor: 'attribute management' stamp: 'StephaneDucasse 12/6/2014 07:18'!attributeAt: name	^ attributes at: name ifAbsent: nil! !!ASElement methodsFor: 'attribute management' stamp: 'StephaneDucasse 12/6/2014 07:18'!attributeAt: name put: value	attributes == EmptyDict		ifTrue: [ attributes := IdentityDictionary new ].	^ attributes at: name put: value! !!ASElement methodsFor: 'operations' stamp: 'StephaneDucasse 12/6/2014 07:18'!attributeSetter: aString	"fill-opacity   =>>  fill_opacity:	x =>> x:"	| sel |	sel := aString collect: [ :c | ('-:' includes: c) ifTrue: [ $_] ifFalse: [ c ]].	^ (sel copyWith: $:) asSymbol ! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/27/2012 17:09'!color: aByteString 	self attributeAt: #color put: aByteString ! !!ASElement methodsFor: 'attribute management' stamp: 'StephaneDucasse 12/6/2014 07:18'!defaultAttributeAt: aName	^ self defaultAttributes at: aName ifAbsent: nil! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:19'!display	^ self attributeAt: #display ! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/25/2012 07:08'!display: aString	self attributeAt: #display put: aString! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:56'!fill	^ self inheritedAttributeAt: #fill ifAbsent: [ ASColorPaint new color: Color black ]! !!ASElement methodsFor: 'attributes' stamp: 'AliakseiSyrel 7/30/2015 15:41'!fill: anObject	self attributeAt: #fill put: (ASFillConverter new translate: anObject)! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 09:23'!fill_opacity	^ self inheritedAttributeAt: #fill_opacity ifAbsent: [ self opacity ]! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:19'!fill_opacity: aString 	self attributeAt: #fill_opacity  put: (self translateNumber: aString)! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/27/2012 16:09'!fill_rule: aString	self attributeAt: #fill_rule put: aString! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:15'!filter: aString 	"<uri> | none | inherit"	self attributeAt: #filter put: aString! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/27/2012 15:57'!font_size: aString 	self attributeAt: #font_size put: aString! !!ASElement methodsFor: 'accessing' stamp: 'IgorStasenko 4/27/2012 12:47'!id	^ id! !!ASElement methodsFor: 'accessing' stamp: 'StephaneDucasse 12/6/2014 07:15'!id: aString 	id := aString.	self registerId.! !!ASElement methodsFor: 'attribute management' stamp: 'IgorStasenko 4/24/2012 14:53'!ignoredAttribute	"just a stub to indicate an ignored attribute"! !!ASElement methodsFor: 'attribute management' stamp: 'JochenRick 1/24/2014 09:30'!inheritedAttributeAt: name	^ attributes at: name ifAbsent: [ parent		ifNil: [ self error: 'Attribute ', name asString, ' not found.' ]		ifNotNil: [ parent inheritedAttributeAt: name ] ]! !!ASElement methodsFor: 'attribute management' stamp: 'JochenRick 1/24/2014 09:25'!inheritedAttributeAt: name ifAbsent: aBlock	^ attributes at: name ifAbsent: [ parent		ifNil: [ aBlock value ]		ifNotNil: [ parent inheritedAttributeAt: name ifAbsent: aBlock ] ]! !!ASElement methodsFor: 'initialize' stamp: 'IgorStasenko 4/25/2012 07:07'!initialize 	attributes := EmptyDict.! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/27/2012 17:10'!marker: aString 	self attributeAt: #marker put: aString! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/27/2012 17:11'!marker_mid: aString 	self attributeAt: #marker_mid put: aString! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/27/2012 17:10'!marker_start: aByteString 	self attributeAt: #marker_start put: aByteString ! !!ASElement methodsFor: 'accessing' stamp: 'IgorStasenko 4/27/2012 11:50'!noFill	^ ASNoFill soleInstance ! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 09:21'!opacity	^ self inheritedAttributeAt: #opacity ifAbsent: 1! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/25/2012 21:46'!opacity: aString 	self attributeAt: #opacity put: (self translateNumber: aString)! !!ASElement methodsFor: 'accessing' stamp: 'IgorStasenko 4/7/2012 16:34'!parent	^ parent! !!ASElement methodsFor: 'accessing' stamp: 'IgorStasenko 4/7/2012 16:34'!parent: anObject	parent := anObject! !!ASElement methodsFor: 'internal' stamp: 'StephaneDucasse 12/6/2014 07:22'!registerId	"register receiver in global id table"	self root setId: id for: self! !!ASElement methodsFor: 'rendering' stamp: 'StephaneDucasse 12/6/2014 07:15'!renderOn: aCanvas	"render on Athens canvas"	self transform		ifNotNil: [ :tr | 			aCanvas pathTransform				restoreAfter: [ 					aCanvas pathTransform multiplyBy: tr.					self renderShapeOn: aCanvas ] ]		ifNil: [ self renderShapeOn: aCanvas ]! !!ASElement methodsFor: 'rendering' stamp: 'IgorStasenko 4/25/2012 05:48'!renderShapeOn: aCanvas! !!ASElement methodsFor: 'internal' stamp: 'StephaneDucasse 12/6/2014 07:25'!resolveIdForAttribute: aName dict: dict	| value |	value := self perform: aName.	value class == ASLink		ifTrue: [ self attributeAt: aName put: (value resolveIds: dict) ]! !!ASElement methodsFor: 'internal' stamp: 'StephaneDucasse 12/6/2014 07:22'!resolveIds: idDict	self resolveMyIds: idDict! !!ASElement methodsFor: 'internal' stamp: 'StephaneDucasse 12/6/2014 07:25'!resolveMyIds: idDict	#(#fill #stroke #xlink_href) 		do: [ :each | self resolveIdForAttribute: each dict: idDict ]! !!ASElement methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 15:01'!root	^ parent ifNil: [ self ] ifNotNil: [ parent root ]! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:56'!stroke	^ self inheritedAttributeAt: #stroke ifAbsent: [ ASNoFill soleInstance ]! !!ASElement methodsFor: 'attributes' stamp: 'AliakseiSyrel 7/30/2015 15:42'!stroke: anObject 	self attributeAt: #stroke put: (ASFillConverter new translate: anObject )! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:16'!stroke_dasharray	^ self inheritedAttributeAt: #stroke_dasharray ifAbsent: nil! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:19'!stroke_dasharray: aString 	self attributeAt: #stroke_dasharray put: aString! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:59'!stroke_dashoffset	^ self inheritedAttributeAt: #stroke_dashoffset ifAbsent: 0! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:19'!stroke_dashoffset: aString 	self attributeAt: #stroke_dashoffset put: (self translateLength: aString)! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:57'!stroke_linecap	^ self inheritedAttributeAt: #stroke_linecap ifAbsent: #butt! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/25/2012 16:43'!stroke_linecap: aString 	self attributeAt: #stroke_linecap put: aString! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:57'!stroke_linejoin	^ self inheritedAttributeAt: #stroke_linejoin ifAbsent: #miter! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:23'!stroke_linejoin: aString 	self attributeAt: #stroke_linejoin put: aString! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:57'!stroke_miterlimit	^ self inheritedAttributeAt: #stroke_miterlimit ifAbsent: 4! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/27/2012 11:47'!stroke_miterlimit: aString	self attributeAt: #stroke_miterlimit put: (self translateNumber: aString)! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:47'!stroke_opacity	^ self inheritedAttributeAt: #stroke_opacity ifAbsent: [ self opacity ]! !!ASElement methodsFor: 'attributes' stamp: 'StephaneDucasse 12/6/2014 07:20'!stroke_opacity: aString 	self attributeAt: #stroke_opacity  put: (self translateNumber: aString)! !!ASElement methodsFor: 'attributes' stamp: 'JochenRick 1/24/2014 10:57'!stroke_width	^ self inheritedAttributeAt: #stroke_width ifAbsent: 1! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/25/2012 22:14'!stroke_width: aString 	self attributeAt: #stroke_width  put: (self translateNumber: aString)! !!ASElement methodsFor: 'operations' stamp: 'PeterUhnak 8/12/2017 21:09'!style: aString 	| values |	values := aString substrings: ';'.		values do: [:keyval | | key val setter |		key := (keyval copyUpTo: $:) trimBoth.		val := (keyval copyAfter: $:) trimBoth.		setter := self attributeSetter: key.		(self respondsTo: setter) ifTrue: [ self perform: setter with: val ]		ifFalse: [ self attributeAt: setter allButLast asSymbol  put: val ]		]! !!ASElement methodsFor: 'operations' stamp: 'IgorStasenko 4/25/2012 07:11'!transform	^ self attributeAt: #transform! !!ASElement methodsFor: 'operations' stamp: 'StephaneDucasse 12/6/2014 07:16'!transform: aString	" rotate(10) scale (1) translate (100,10) "	self attributeAt: #transform put: (ASTransformConverter new translateString: aString)! !!ASElement methodsFor: 'translate' stamp: 'IgorStasenko 4/7/2012 14:41'!translate: xmlNode	self translateAttributes: xmlNode attributes.! !!ASElement methodsFor: 'translate' stamp: 'StephaneDucasse 12/6/2014 07:23'!translate: aXMLElement parent: node 	parent := node.	^ self translate: aXMLElement! !!ASElement methodsFor: 'translate' stamp: 'IgorStasenko 4/27/2012 16:06'!translateAttributes: attrs	attrs associationsDo: [:assoc |		| setter |		setter := self attributeSetter: assoc key.		(self respondsTo: setter) ifTrue: [			self perform: setter with: assoc value trimBoth ]		ifFalse: [ self attributeAt: setter allButLast asSymbol put: assoc value trimBoth ]	]! !!ASElement methodsFor: 'translate' stamp: 'IgorStasenko 4/24/2012 14:58'!translateColor: aString 	"right now we do like that"	^ Color fromString: aString! !!ASElement methodsFor: 'translate' stamp: 'IgorStasenko 4/24/2012 16:04'!translateLength: aString 	^ self translateNumber: aString! !!ASElement methodsFor: 'translate' stamp: 'IgorStasenko 4/23/2012 18:10'!translateNumber: aString 	^ (ASConverter new stream: aString readStream ) nextNumber ! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/24/2012 14:53'!xlink_actuate: aString 	self ignoredAttribute ! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/25/2012 22:28'!xlink_href	^ self attributeAt: #xlink_href! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/25/2012 22:24'!xlink_href: aString 	self attributeAt: #xlink_href put: (ASLink url: aString)! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/24/2012 14:54'!xlink_show: aByteString 	self ignoredAttribute ! !!ASElement methodsFor: 'attributes' stamp: 'IgorStasenko 4/24/2012 14:52'!xlink_type: aString 	self ignoredAttribute! !!ASFilter methodsFor: 'as yet unclassified' stamp: 'StephaneDucasse 12/6/2014 07:31'!color_interpolation_filters: aString 	self attributeAt: #color_interpolation_filters put: aString! !!ASFilter methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 16:41'!filterUnits: aString 	self attributeAt: #filterUnits put: aString! !!ASFilter methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:40'!height: aString 	height := self translateLength: aString! !!ASFilter methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 16:41'!primitiveUnits: aString 	self attributeAt: #primitiveUnits put: aString! !!ASFilter methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:40'!width: aString 	width := self translateLength: aString! !!ASFilter methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:39'!x: aString 	x := self translateLength: aString! !!ASFilter methodsFor: 'accessing' stamp: 'IgorStasenko 4/25/2012 16:40'!y: aString 	y := self translateLength: aString! !!ASGradientStop methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 14:48'!asRampColorWithOpacity: aFloat 		^ Association key: offset value: (color alpha: self opacity * aFloat)! !!ASGradientStop methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 10:50'!offset	^ offset! !!ASGradientStop methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:59'!offset: aString 	offset := self translateNumber: aString! !!ASGradientStop methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 14:44'!opacity 	^ opacity ifNil: [1]! !!ASGradientStop methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 17:52'!setOpacity: number	color := color alpha: number.! !!ASGradientStop methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:57'!stop_color: aString 	color := self translateColor: aString! !!ASGradientStop methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 15:14'!stop_opacity: aString 	opacity := self translateNumber: aString.! !!ASCircle methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 16:05'!cx: aString "cx = <coordinate>The x-axis coordinate of the center of the circle.If the attribute is not specified, the effect is as if a value of '0'  were specified."	cx := self translateLength: aString! !!ASCircle methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 16:06'!cy: aString "cy = <coordinate>The y-axis coordinate of the center of the circle.If the attribute is not specified, the effect is as if a value of 0 were specified. Animatable: yes."	cy := self translateLength: aString! !!ASCircle methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 16:49'!initialize 	super initialize.		cx := cy := 0.! !!ASCircle methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 18:49'!r: aString "r = <length>The radius of the circle.A negative value is an error (see Error processing). A value of zero disables rendering of the element.Animatable: yes."	r := self translateLength: aString.	! !!ASCircle methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:58'!setShapeOn: aCanvas	| circle |	circle := aCanvas createPath: [:builder |		builder 			absolute;			moveTo: (cx - r @ cy);			cwArcTo: (cx + r @ cy )  angle: 180 degreesToRadians;			cwArcTo: (cx - r @ cy)  angle: 180 degreesToRadians		].	aCanvas setShape: circle.! !!ASEllipse methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:20'!cx: aString "cx = <coordinate>The x-axis coordinate of the center of the circle.If the attribute is not specified, the effect is as if a value of '0'  were specified."	cx := self translateLength: aString! !!ASEllipse methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:21'!cy: aString "cy = <coordinate>The y-axis coordinate of the center of the circle.If the attribute is not specified, the effect is as if a value of 0 were specified. Animatable: yes."	cy := self translateLength: aString! !!ASEllipse methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:21'!rx: aString 	rx := self translateLength: aString.	! !!ASEllipse methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:21'!ry: aString 	ry := self translateLength: aString.	! !!ASEllipse methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:58'!setShapeOn: aCanvas	| circle |		circle := aCanvas createPath: [:builder |		builder 			absolute;			moveTo: (cx - rx @ cy);			cwArcTo: (cx + rx @ cy )  angle: 180 degreesToRadians;			cwArcTo: (cx - rx @ cy)  angle: 180 degreesToRadians		].	aCanvas setShape: circle.! !!ASLine methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:48'!setShapeOn: aCanvas	| path |		path := aCanvas createPath: [:builder |		builder 			absolute;			moveTo: x1@y1;			lineTo: x2@y2.	].		aCanvas setShape: path.! !!ASLine methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:11'!x1: aString 	x1 := self translateLength: aString! !!ASLine methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:11'!x2: aString 	x2 := self translateLength: aString! !!ASLine methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:11'!y1: aString 	y1 := self translateLength: aString! !!ASLine methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:11'!y2: aString 	y2 := self translateLength: aString! !!ASPath methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 17:17'!buildPathOn: aCanvas 	pathCache := WeakArray with: aCanvas surface.	athensPath := aCanvas createPath: [:builder |				pathData do: [:each |			builder perform: each first withArguments: each second			]	]! !!ASPath methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 17:15'!checkCacheFor: aCanvas 	pathCache ifNil: [ ^ self buildPathOn: aCanvas ].	pathCache first == aCanvas surface ifFalse: [ ^ self buildPathOn: aCanvas ]! !!ASPath methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 08:37'!d: aString "	d = 'path data'	A path is defined by including a 'path' element which contains a d=(path data) attribute, where the d attribute contains the moveto, 	line, curve (both cubic and quadratic Béziers), arc and closepath instructions."	| conv |	conv := ASPathConverter new stream: aString readStream.	pathData := conv convertPathData.	bbox := conv bbox.! !!ASPath methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 14:29'!setShapeOn: aCanvas	self checkCacheFor: aCanvas.	aCanvas setShape: athensPath.	! !!ASPolyLine methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 07:15'!setShapeOn: aCanvas	| path |	path := aCanvas createPath: [:builder |		builder 			absolute;			moveTo: points first.				points allButFirstDo: [:pt | builder lineTo: pt ].			].		aCanvas setShape: path.! !!ASPolygon methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/23/2012 16:00'!points: aString 	"parse polygon points"	| pts x y conv stream |		points := OrderedCollection new.	stream := aString readStream.		conv := ASConverter new stream: stream.	[ stream atEnd ] whileFalse: [		conv skipBlanks.		x := conv nextNumber.		x ifNil: [ ^ self ].				conv skipBlanks.		stream peek = $, ifFalse: [ ^ self].		stream next.		conv skipBlanks.		y := conv nextNumber.		y ifNil: [ ^ self ].				points add: (x@y)			].	^ points	! !!ASPolygon methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:57'!setShapeOn: aCanvas	| path |	path := aCanvas createPath: [:builder |		builder 			absolute;			moveTo: points first.				points allButFirstDo: [:pt | builder lineTo: pt ].				builder close	].		aCanvas setShape: path.! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/23/2012 18:12'!height: aString 	height := self translateNumber: aString! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:42'!initialize	super initialize.		x := y := rx := ry := 0.! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:55'!rx: aString 	rx := self translateNumber: aString! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:55'!ry: aString 	ry := self translateNumber: aString! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:56'!setShapeOn: aCanvas	aCanvas setShape: (Rectangle origin: x@y extent: width@height).	"todo: take rx, ry into account"! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/23/2012 18:10'!width: aString 	width := self translateNumber: aString! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:54'!x: aString 	x := self translateNumber: aString! !!ASRect methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:55'!y: aString 	y := self translateNumber: aString! !!ASShape methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 12:56'!renderShapeOn: aCanvas"	(self id ='path3070-4' ) ifTrue: [ self halt ]."		self display = 'none' ifTrue: [ ^ self ].		self setShapeOn: aCanvas.	self fill fill: self on: aCanvas.	self stroke stroke: self on: aCanvas.! !!ASShape methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:55'!setShapeOn: aCanvas	self subclassResponsibility ! !!ASText methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:14'!font_family: aByteString 	! !!ASText methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:13'!font_size: aByteString 	! !!ASText methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:15'!setShapeOn: aCanvas	! !!ASText methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:13'!x: aByteString 	! !!ASText methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:13'!y: aByteString 	! !!ASLength class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/23/2012 16:27'!fromString: aString	| conv l |	conv := (ASConverter new stream: aString readStream).	l := self new.	l value:  conv nextNumber.	l units: conv stream upToEnd.	^ l! !!ASLength methodsFor: 'printing' stamp: 'IgorStasenko 4/23/2012 16:28'!printOn: aStream	aStream print: value; nextPutAll: units! !!ASLength methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:22'!units	^ units! !!ASLength methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:22'!units: anObject	units := anObject! !!ASLength methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:23'!value	^ value! !!ASLength methodsFor: 'accessing' stamp: 'IgorStasenko 4/23/2012 16:22'!value: anObject	value := anObject! !!ASLength methodsFor: 'converting' stamp: 'IgorStasenko 4/27/2012 15:57'!valueForDPI: dpi	units = 'cm' ifTrue: [		^ value * (dpi / 2.54) asFloat		].		units = 'mm' ifTrue: [		^ value * (dpi / 25.4) asFloat		].	units = 'px' ifTrue: [ ^ value ].	units = 'pt' ifTrue: [ ^ value ].		units isEmpty ifTrue: [ ^ value ].		self halt.! !!ASLink class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 10:41'!url: aString	^ self new url: aString! !!ASLink methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 15:57'!id	^ id! !!ASLink methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 15:57'!isId	^ isId == true! !!ASLink methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 16:43'!resolveIds: dict 		self isId ifTrue: [		^ dict at: id ifAbsent: [ self error: 'unknown id: ', id ]		].		self error: 'cannot resolve url: ' , url! !!ASLink methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 15:54'!url	^ url! !!ASLink methodsFor: 'accessing' stamp: 'IgorStasenko 4/24/2012 15:58'!url: aString	url := aString.		isId := url first = $#.	isId ifTrue: [ id := url allButFirst ]! !!ASNoFill class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 16:46'!soleInstance	^ soleInstance ifNil: [ soleInstance  := self new ]	! !!ASNoFill methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 11:58'!fill: aShape on: aCanvas	"do nothing"! !!ASNoFill methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 16:48'!resolveIds: aDictionary 	^ self! !!ASNoFill methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 11:57'!stroke: aShape on: aCanvas	"do nothing" ! !!ASColorPaint methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 17:45'!color: aColor	color := aColor! !!ASColorPaint methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 11:57'!fill: shape on: aCanvas	aCanvas setPaint: (color alpha: (color alpha * shape fill_opacity)).		aCanvas draw! !!ASColorPaint methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 17:45'!resolveIds: aDictionary 	^ self ! !!ASColorPaint methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 12:30'!stroke: shape on: aCanvas	| stroke |	stroke := aCanvas setStrokePaint: (color alpha: (color alpha * shape stroke_opacity)).		stroke width: shape stroke_width.		aCanvas draw! !!ASVGNodeClasses class methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 16:12'!fromName: aNodeName	(self canUnderstand: aNodeName asSymbol) ifTrue: [ ^ self new perform: aNodeName asSymbol ]	ifFalse: [ ^ ASMetadata ]! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:55'!circle	^ ASCircle! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 19:18'!defs	^ ASDefs! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:10'!desc	^ ASMetadata! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 05:41'!ellipse	^ ASEllipse ! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 16:39'!filter	^ ASFilter! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/7/2012 16:23'!g	^ ASGroupElement! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:11'!line	^ ASLine! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 13:56'!linearGradient	^ ASLinearGradient! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 19:17'!metadata	^ ASMetadata! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/23/2012 18:13'!path	^ ASPath ! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/7/2012 16:24'!polygon	^ ASPolygon! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 07:16'!polyline	^ ASPolyLine ! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/25/2012 16:31'!radialGradient	^ ASRadialGradient! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/23/2012 18:08'!rect	^ ASRect! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/24/2012 14:56'!stop		^ ASGradientStop! !!ASVGNodeClasses methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/27/2012 13:13'!text	^ ASText! !!AthensSVGConverter class methodsFor: 'instance creation' stamp: 'IgorStasenko 4/6/2012 17:03'!fromFile: aFileName	| doc |	doc := XMLDOMParser parseFileNamed: aFileName.	^ self new importXMLDocument: doc! !!AthensSVGConverter class methodsFor: 'instance creation' stamp: 'IgorStasenko 4/6/2012 17:02'!fromURL: anUrl	| doc |	doc := XMLDOMParser parse: anUrl asZnUrl retrieveContents asString.	^ self new importXMLDocument: doc! !!AthensSVGConverter methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/7/2012 14:27'!g	"group"		node attributes! !!AthensSVGConverter methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/7/2012 14:39'!importXMLDocument: doc	| root |	root := doc nodes elements.		((root size > 1) or: [ root first name ~= 'svg'])  ifTrue: [ self error: 'A root svg element expected' ].	^ ASVGRoot new translate: root first.! !!AthensSVGConverter methodsFor: 'as yet unclassified' stamp: 'IgorStasenko 4/6/2012 17:29'!visitNode: aNode	| oldNode |	oldNode := node.	node := aNode.	self perform: aNode name asSymbol.	! !"Athens-SVG"!!GRectangle commentStamp: '' prior: 0!I am a rectangle. See my parent for API!!GCollection commentStamp: '' prior: 0!I am a collection of several shapes. Useful for finding an intersection of a more complex shape.!!GCircle commentStamp: '' prior: 0!I am a circle. I have a center in (cx, cy) and radius. My equation is: (x-cx)^2  + (y-cy)^2 = radius^2 or a * (x^2) + a * (y^2) + d * x + e * y + f = 0 !!GCircleArc commentStamp: '' prior: 0!I represent a circle arc described by the underlying GCircle and the start and end angle (in radians).!!GEllipse commentStamp: '' prior: 0!I am an Ellipse geometry.I am described by center and two radii.- `center `is the center point of the ellipse- `a` is the major radius along the x axis- `b` is the minor radius along the y axis!!GLine commentStamp: '' prior: 0!A GLine has 3 instance variables, which are koeficients  of line:ax+by+c=0!!GLineSegment commentStamp: '' prior: 0!I am a copy of RTLineSegment from Roassal.!!GPolygon commentStamp: '' prior: 0!I'm polygon builded on my vertices.!!GRay commentStamp: '' prior: 0!I am a vector builded on line ax+by+c=0 and have my start in point v1.!!GRoundedRectangle commentStamp: '' prior: 0!I represent a rectangle whose corners are rounded.!!GSegment commentStamp: '' prior: 0!I am a segment between two vertices!!GTriangle commentStamp: '' prior: 0!I am a triangle!!GRectangle methodsFor: 'accessing'!encompassingRectangle	^ self! !!GRectangle methodsFor: 'comparing'!intersectLineSegment: aLineSegment	^ aLineSegment intersectRectangle: self! !!Rectangle class methodsFor: '*Geometry'!geomCenter: centerPoint extent: extentPoint 	"Answer an instance of me whose center is centerPoint and width 	by height is extentPoint.  "	^self origin: centerPoint - (extentPoint / 2) extent: extentPoint! !!Rectangle methodsFor: '*Geometry'!edges	^ { 		GSegment with: (self origin ) with: (self origin x @ self corner y). 		GSegment with: (self origin x @ self corner y) with: (self corner).		GSegment with: (self corner ) with: (self corner x @ self origin y). 		GSegment with: (self corner x @ self origin y) with: (self origin).}! !!Rectangle methodsFor: '*Geometry'!geomCenter	"Answer the point at the center of the receiver."	^self topLeft + self bottomRight / 2! !!Rectangle methodsFor: '*Geometry'!hasOnBoundary: point| a |	a := self edges select: [:edge | a := edge hasPoint: point].	^a isNotEmpty! !!Rectangle methodsFor: '*Geometry'!hasOnOneSide: point1 and: point2  ^		((point1 x = point2 x and:[point1 x = self origin x or:[point1 x = self corner x]] )or:[point1 y = point2 y and:[point1 y = self origin y or:[point1 y = self corner y]] ])! !!Rectangle methodsFor: '*Geometry'!hasPoint: point "inside the frame and on the boundary" ^	((self origin x <= point x and: [point x <= self corner x])	and:[ (self origin y <= point y and: [point y <= self corner y]) 	or:[self origin y >= point y and: [point y >= self corner y]]])	or:	[(self origin x >= point x and: [point x >= self corner x ])	and:[ (self origin y <= point y and: [point y <= self corner y]) 	or:[self origin y >= point y and: [point y >= self corner y]]]	]! !!Rectangle methodsFor: '*Geometry'!intersectionPointWithRay: ray^ self edges collect:[ :edge | edge intersectionPointWithRay: ray]  				thenReject: #isNil.	! !!Rectangle methodsFor: '*Geometry'!intersectionPointsWithLine: line	|points ps|	ps := OrderedCollection new.	points := OrderedCollection new. 	self edges do:[ :edge | 		|p|		p := edge intersectionPointWithLine: line.		p isNotNil 			ifTrue:[ (ps noneSatisfy: [:pi| pi =~p]) ifTrue:[			ps add: p ]]]. 	^ ps"^ self edges collect:[ :edge | edge intersectionPointWithLine: line]  				thenReject: #isNil."	! !!Rectangle methodsFor: '*Geometry'!intersectionPointsWithSegment: segm^ self edges collect:[ :edge | edge intersectionPointWithSegment: segm]  				thenReject: #isNil.	! !!Rectangle methodsFor: '*Geometry'!sideWhichHas: point		^ self edges detect: [ :edge | edge hasPoint: point ]! !!Rectangle methodsFor: '*Geometry'!vertices	^ { origin . 		origin x @ corner y . 		corner. 		corner x @ origin y }! !!Point methodsFor: '*Geometry'!=~ aPoint	^ (self dist: aPoint) =~ 0! !!Point methodsFor: '*Geometry'!has: aPoint onTheSameSideAs: p	(self x <= p x) 		ifTrue:[ self y <= p y			ifTrue:[ ^ (self x <= aPoint x) and:[ self y <= aPoint y ] ]			ifFalse:[ ^ (self x <= aPoint x) and:[ self y > aPoint y ] ] ]		ifFalse:[ self y <= p y			ifTrue:[ ^ (self x > aPoint x) and:[ self y <= aPoint y ] ]			ifFalse:[ ^ (self x > aPoint x) and:[ self y > aPoint y ] ] ]	 ! !!Point methodsFor: '*Geometry'!ray: aPoint 	^ GRay origin: self direction: aPoint ! !!Point methodsFor: '*Geometry'!segment: aPoint 	^ GSegment with: self with: aPoint ! !!Point methodsFor: '*Geometry'!signFuz	^ (x signFuz @ y signFuz)! !!Point methodsFor: '*Geometry'!~=~ aPoint	^ (self =~ aPoint) not! !!GCollection methodsFor: 'accessing'!center	^ self encompassingRectangle center! !!GCollection methodsFor: 'accessing'!encompassingRectangle	^ self		ifEmpty: [ 0 @ 0 corner: 0 @ 0 ]		ifNotEmpty: [ Rectangle merging: (self collect: #encompassingRectangle) ]! !!GCollection methodsFor: 'accessing'!height	^ self encompassingRectangle height! !!GCollection methodsFor: 'comparing'!intersectLine: aLine	self logCr: (self flatCollect: [ :each | aLine intersect: each ]).	^ (self flatCollect: [ :each | aLine intersect: each ]) asArray! !!GCollection methodsFor: 'intersection'!intersectLineSegment: aLineSegment	^ self flatCollect: [ :each | each intersectLineSegment: aLineSegment ]! !!GCollection methodsFor: 'accessing'!width	^ self encompassingRectangle width! !!Number class methodsFor: '*geometry'!epsilon	^ 0.00001! !!Number methodsFor: '*Geometry'!=~ aNumber 	^((self - aNumber) abs) < Number epsilon.! !!Number methodsFor: '*Geometry'!isBetween: a and: b with: eps 	|mi ma|	(a =~ self or:[ b =~ self or:[ a + (2 * eps) =~ self or:[ a - (2 * eps) =~ self or:[ b + (2 * eps) =~ self or:[ b - (2 * eps) =~ self ]]]]] )		ifTrue:[ ^ true]		ifFalse:[			mi := a min: b. 			ma := a max: b. 	( self + (2 * eps) >=~ mi and:[ self + (2 * eps) <=~ ma ] )	ifTrue:[ ^ true]	ifFalse:[ 					^  self between: mi and: ma ]] "( ( self - mi ) abs >=~ eps ) and:[ ( ma - self ) abs >=~ eps ]"! !!Number methodsFor: '*Geometry'!signFuz	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."	self >~ 0 ifTrue: [ ^  1 ].	self <~ 0 ifTrue: [ ^ -1 ].	^ 0! !!Number methodsFor: '*Geometry'!~=~ aNumber   ^ (self =~ aNumber) not! !!GCircle class methodsFor: 'as yet unclassified'!center: aPoint1 radius: aNumber	^ self new initializeWithCenter: aPoint1 radius: aNumber! !!GCircle methodsFor: 'comparing'!= circ	^( self radius =~ circ radius and:[ self center =~ circ center ])! !!GCircle methodsFor: 'comparing'!boundaryContains: aPoint^(self radius =~ (self center dist: aPoint))! !!GCircle methodsFor: 'comparing'!boundaryContainsThis: points ^(points select:[ :point| self boundaryContains: point]) isNotEmpty ! !!GCircle methodsFor: 'comparing'!boundaryContainsWhichOf: points ^ points select:[ :point| self boundaryContains: point]! !!GCircle methodsFor: 'accessing'!center	^center ! !!GCircle methodsFor: 'testing'!contains: aPoint^ (self radius > (self center dist: aPoint)) and:[ (self boundaryContains: aPoint) not ]! !!GCircle methodsFor: 'comparing'!cosBetween: p1 and: p2^ (( GRay origin: self center direction: p1 ) * ( GRay origin: self center direction: p2 )) /( ( GRay origin: self center direction: p1 )length * (( GRay origin: self center direction: p2 ) length ) )! !!GCircle methodsFor: 'accessing'!encompassingRectangle	^ (center - radius) corner: (center + radius)! !!GCircle methodsFor: 'comparing'!equal: circ withApproximation: aNumber"self halt."	^( (self radius - circ radius ) abs < aNumber )	and:[ 		( (self center x - circ center x)abs < aNumber)		""and:[  (self center y - circ center y)abs < aNumber ]""		]! !!GCircle methodsFor: 'initialization'!initializeWithCenter: aPoint1 radius: aNumber	super initialize.	center := aPoint1.	radius := aNumber.! !!GCircle methodsFor: 'accessing'!inscribedRectangle		^ Rectangle		origin: center - (radius / 2 sqrt)		corner: center + (radius / 2 sqrt)				! !!GCircle methodsFor: 'comparing'!intersectLineSegment: aLineSegment	^ aLineSegment intersectCircle: self! !!GCircle methodsFor: 'public interface'!intersectWith: line  ! !!GCircle methodsFor: 'accessing'!length	^ 2 * (self radius)* (Float pi)! !!GCircle methodsFor: 'public interface'!point: p1 isTooCloseTo: p2	^ 1 -( self cosBetween: p1 and: p2 ) <~ 0.1! !!GCircle methodsFor: 'public interface'!polygonOn: points|polygonSegm firstP notUsedPoints currentP|	currentP := points anyOne.	firstP := currentP.	notUsedPoints := points asOrderedCollection remove: currentP; yourself.	polygonSegm := OrderedCollection new.		[ notUsedPoints isNotEmpty ] whileTrue: [		| nextP |		nextP := notUsedPoints detectMin: [ :point | point dist: currentP ].		polygonSegm add:( GSegment with: currentP with: nextP).		currentP := nextP.		notUsedPoints remove: currentP ].	polygonSegm add:( GSegment with: currentP with: firstP).	^ polygonSegm! !!GCircle methodsFor: 'accessing'!radius^radius ! !!GCircle methodsFor: 'public interface'!upperPoint	^ center x @ ( center y + radius )! !!GCircle methodsFor: 'public interface'!with: p1 boundaryContains1: aPoint ( self boundaryContains: aPoint )	ifFalse:[		(self point: p1 isTooCloseTo: aPoint) 			ifTrue:[ |cir newCenter| 				newCenter := (self center + (self center dist: aPoint))/2.				cir := GCircle center: newCenter radius: (self radius + (self radius dist: aPoint))/2 ]				]! !!GCircle methodsFor: 'public interface'!with: p1 boundaryContains: aPoint^ ( self boundaryContains: aPoint ) or:[self point: p1 isTooCloseTo: aPoint]! !!GCircleArc class methodsFor: 'instance creation'!center: aCenter radius: aRadius startAngle: aStart endAngle: anEnd	^ self new		setCircle: (GCircle center: aCenter radius: aRadius) startAngle: aStart endAngle: anEnd;		yourself! !!GCircleArc class methodsFor: 'instance creation'!circle: aCircle startAngle: aStart endAngle: anEnd	^ self new		setCircle: aCircle startAngle: aStart endAngle: anEnd;		yourself! !!GCircleArc methodsFor: 'comparing'!= anArc	self species = anArc species		ifFalse: [ ^ false ].	^ self circle = anArc circle		and: [ self startAngle = anArc startAngle and: [ self endAngle = anArc endAngle ] ]! !!GCircleArc methodsFor: 'accessing'!center	^ circle center! !!GCircleArc methodsFor: 'accessing'!circle	^ circle! !!GCircleArc methodsFor: 'accessing'!endAngle	^ endAngle! !!GCircleArc methodsFor: 'comparing'!intersectLineSegment: aLineSegment	^ aLineSegment intersectCircleArc: self! !!GCircleArc methodsFor: 'accessing'!radius	^ circle radius! !!GCircleArc methodsFor: 'initialization'!setCircle: aCircle startAngle: aStart endAngle: anEnd	circle := aCircle.	startAngle := aStart.	endAngle := anEnd! !!GCircleArc methodsFor: 'accessing'!startAngle	^ startAngle! !!GEllipse class methodsFor: 'instance creation'!center: aPoint a: xRadius b: yRadius	^ self new setCenter: aPoint a: xRadius b: yRadius! !!GEllipse methodsFor: 'comparing'!= anEllipse	self species = anEllipse species		ifFalse: [ ^ false ].	^ self center = anEllipse center & (self a = anEllipse a) & (self b = anEllipse b)! !!GEllipse methodsFor: 'accessing'!a	^ a! !!GEllipse methodsFor: 'accessing'!b	^ b! !!GEllipse methodsFor: 'accessing'!center	^ center! !!GEllipse methodsFor: 'accessing'!encompassingRectangle	^ center - (a @ b) corner: center + (a @ b)! !!GEllipse methodsFor: 'comparing'!hash	^ (a bitXor: b) bitXor: center hash! !!GEllipse methodsFor: 'comparing'!intersectLineSegment: aLineSegment	^ aLineSegment intersectEllipse: self! !!GEllipse methodsFor: 'initialization'!setCenter: aCenter a: xRadius b: yRadius	center := aCenter.	a := xRadius.	b := yRadius! !!GLine class methodsFor: 'as yet unclassified'!a: aNumber1 b: aNumber2 c: aNumber3	^ self new initializeWithA: aNumber1 b: aNumber2 c: aNumber3! !!GLine class methodsFor: 'as yet unclassified'!through: aPoint1 and: aPoint2|ai bi ci|(aPoint1 y) = (aPoint2 y) ifTrue:[ ^ GLine		a: 0 b: 1 c: ((aPoint1 y) negated)].(aPoint1 x) = (aPoint2 x) ifTrue:[ 	^ GLine		a: 1 b: 0 c: ((aPoint1 x) negated)].	ai := (aPoint1 y) - (aPoint2 y). bi := (aPoint2 x) - (aPoint1 x).ci := ((aPoint1 x) - (aPoint2 x)) * (aPoint1 y) + ( ((aPoint2 y) - (aPoint1 y)) * (aPoint1 x) ).^ self	 a:ai b: bi c: ci! !!GLine methodsFor: 'comparing'!= line ^( self a asFloat =~ line a asFloat and: [ self b asFloat =~ line b asFloat and: [ self c asFloat =~ line c asFloat ] ] )  or:[ ( line a ~=~ 0 and: [ line b ~=~ 0 and: [ line c ~=~ 0 ] ] ) 	ifTrue: [ ( self a / line a ) asFloat =~ ( self b / line b ) asFloat and: [ ( self b / line b ) asFloat =~ ( self c / line c ) asFloat] ]	ifFalse:[ ( self a ~=~ 0 and: [self b ~=~ 0 and: [ self c ~=~ 0 ]]) 		ifTrue: [ ( line a / self a ) asFloat =~ ( line b / self b) asFloat and: [ ( line b / self b ) asFloat =~ ( line c / self c ) asFloat ] ]		ifFalse:[ ( line a ~=~ 0 and: [ line c ~=~ 0 ] )			ifTrue:[ ( self a / line a ) asFloat =~ ( self c / line c ) asFloat]			ifFalse:[ ( line b ~=~ 0 and:[ line c ~=~ 0] )				ifTrue:[ ( self b / line b ) asFloat =~ ( self c / line c ) asFloat ] 				ifFalse:[ ( line a ~=~ 0 and:[ line b ~=~ 0] )					ifTrue:[ ( self a / line a ) asFloat =~ ( self b / line b ) asFloat ] 					ifFalse:[ ( line a =~ 0 and: [ line c =~ 0 ] ) or: [ ( line b =~ 0 and: [ line c =~ 0 ] ) ]					]				] 			]]]	]! !!GLine methodsFor: 'accessing'!a	^a! !!GLine methodsFor: 'converting'!asLine	^ self ! !!GLine methodsFor: 'accessing'!b	^b! !!GLine methodsFor: 'accessing'!c	^c! !!GLine methodsFor: 'properties'!cutWith: frame| coll |coll := OrderedCollection new.frame edges	collect: [ :edge | edge intersectionPointWithLine: self ]	thenDo: [ :p |		(p notNil and: [ coll noneSatisfy: [ :p2 | p2 =~ p ] ])			ifTrue: [ coll add: p ] ] .coll isEmpty	ifTrue:  [ ^ nil ]	ifFalse: [ ^ GSegment with: coll first with: coll second ]					! !!GLine methodsFor: 'distance functions'!dist: p	^ ( ( a * p x ) + ( b * p y ) + c )abs	/	( ( a * a + ( b * b ) ) sqrt)! !!GLine methodsFor: 'properties'!hasPoint: aPoint	^ a * aPoint x + (b * aPoint y) + c =~ 0! !!GLine methodsFor: 'properties'!hasPoint: aPoint withApproximation: approx	(self a * aPoint x) + (self b * aPoint y) + self c - (((self a * approx) + (self b * approx))abs + self c)  <=~ 0.	^ "(self a * aPoint x) + (self b * aPoint y) + self c <=~ (2 * approx)"	(self dist: aPoint) <=~ (2 * approx)	! !!GLine methodsFor: 'comparing'!hash^( a hash  + b hash + c hash ) hashMultiply! !!GLine methodsFor: 'initialization'!initializeWithA: aNumber1 b: aNumber2 c: aNumber3	super initialize.	a := aNumber1.	b := aNumber2.	c := aNumber3.! !!GLine methodsFor: 'rectangle functions'!intersect: aGLine 	| xi yi |	(self parallelTo: aGLine) ifTrue: [ ^ nil ].						yi := (self c * (aGLine a) - (self a * (aGLine c)))			/ 			(self a * (aGLine b) - (self b * (aGLine a))).	xi := self a isZero		ifTrue: [			 ( aGLine b * yi + (aGLine c)) negated / (aGLine a)]		ifFalse: [			 ( self b * yi + self c) negated / self a].		^xi@yi.! !!GLine methodsFor: 'properties'!parallelTo: aLine	^ (self a isZero & aLine a isZero) or:	[ (self b isZero & aLine b isZero) or:	[ (aLine a isZero | aLine b isZero) not and:	[ (self a / aLine a) = (self b / aLine b) ] ] ]! !!GLine methodsFor: 'properties'!pointsWithDist1: aNumber to: aPoint	| deltaX delta |		"(self hasPoint: aPoint) ifFalse: [		Error signal: 'This line does not contain ', aPoint asString ]."	b = 0 ifTrue: [		^ { aPoint + (0 @ aNumber) . aPoint - (0 @ aNumber) } ].		deltaX := aNumber / ((a / b) squared + 1) sqrt.			delta := deltaX @ (deltaX * a / b) negated.	^ { aPoint + delta . aPoint - delta }	! !!GLine methodsFor: 'properties'!pointsWithDist: aNumber to: aPoint	| deltaX delta |		(self hasPoint: aPoint) ifFalse: [		Error signal: 'This line does not contain ', aPoint asString ].	b = 0 ifTrue: [		^ { aPoint + (0 @ aNumber) . aPoint - (0 @ aNumber) } ].		deltaX := aNumber / ((a / b) squared + 1) sqrt.			delta := deltaX @ (deltaX * a / b) negated.	^ { aPoint + delta . aPoint - delta }	! !!GLine methodsFor: 'printing'!printOn: aStream	a printOn: aStream.	aStream nextPutAll: 'x '.	b sign >= 0 ifTrue: [ 		aStream nextPut: $+ ].	b printOn: aStream.	aStream nextPutAll: 'y '.	c sign >= 0 ifTrue: [ 		aStream nextPut: $+ ].	c printOn: aStream.	aStream nextPutAll: ' = 0'.	! !!GLine methodsFor: 'properties'!through: aPoint1 and: aPoint2 hasPoint: aPoint	^(GTriangle with: aPoint1 with: aPoint2 with: aPoint) isDegenerate . ! !!GLine methodsFor: 'properties'!xFor: anY	^ ((anY * b + c) / a) negated! !!GLine methodsFor: 'properties'!yFor: anX	^ ((anX * a + c) / b) negated! !!GLineSegment class methodsFor: 'instance-creation'!from: fromPoint to: toPoint	^ self new		from: fromPoint to: toPoint;		yourself! !!GLineSegment methodsFor: 'comparing'!= anotherSegment	"Answer true if the receiver's species, from and to matches anotherSegment."	^ self species = anotherSegment species		ifTrue: [ ^ from = anotherSegment from and: [ to = anotherSegment to ] ]		ifFalse: [ ^ false ]! !!GLineSegment methodsFor: 'line forms'!a	"value from normal form (ax + by + c) of line on which line segment lies on"	^ to y - from y! !!GLineSegment methodsFor: 'geometry'!angleInDeg	^ self vector degrees! !!GLineSegment methodsFor: 'geometry'!angleInRad	^ self angleInDeg degreesToRadians! !!GLineSegment methodsFor: 'line forms'!b	"value from normal form (ax + by + c) of line on which line segment lies on"	^ from x - to x! !!GLineSegment methodsFor: 'accessing'!bottom	^ from y < to y		ifTrue: [ from ]		ifFalse: [ to ]! !!GLineSegment methodsFor: 'line forms'!c	"value from normal form (ax + by + c) of line on which line segment lies on"	^ (self a * from x + (self b * from y)) negated! !!GLineSegment methodsFor: 'geometry'!cotan	| vector |	vector := self vector.	vector y isZero		ifTrue: [ ^ nil ].	^ vector x / vector y! !!GLineSegment methodsFor: 'comparing'!finiteLinesIntersectFrom: current to: next	| uat ubt uy z1 z2 z3 z4 ua ub |	z1 := from.	z2 := to.	z3 := current.	z4 := next.	uat := ((z4 x - z3 x)*(z1 y - z3 y))-((z4 y - z3 y)*(z1 x - z3 x)).	ubt := ((z2 x - z1 x)*(z1 y - z3 y))-((z2 y - z1 y)*(z1 x - z3 x)).	uy := ((z4 y - z3 y)*(z2 x - z1 x))-((z4 x - z3 x)*(z2 y - z1 y)).	uy isZero not ifTrue: [ 		ua := uat / uy.		ub := ubt / uy.		((ua between: 0 and: 1) and: [ ub between: 0 and: 1 ]) 			ifTrue: [ ^ (z1 x + (ua *(z2 x - z1 x)))@(z1 y + (ua *(z2 y - z2 y)))  ]			ifFalse: [ ^ nil ]		 ] 	ifFalse: [ 		(uat isZero or: [ ubt isZero ]) ifTrue: [ 			"Parallel, coincident lines. Check if overlap"			(Array with: z1 x with: z2 x with: z4 x) sort second = z4 x 				ifTrue: [ ^ z4 ].			(Array with: z1 x with: z2 x with: z3 x) sort second = z3 x 				ifTrue: [ ^ z3 ].			(Array with: z3 x with: z4 x with: z2 x) sort second = z2 x 				ifTrue: [ ^ z2 ].			^ nil. ]		ifFalse: [ ^ nil ].	 ]	! !!GLineSegment methodsFor: 'accessing'!from	^ from! !!GLineSegment methodsFor: 'accessing'!from: fromPoint	from := fromPoint! !!GLineSegment methodsFor: 'accessing'!from: fromPoint to: toPoint	from := fromPoint.	to := toPoint.  ! !!GLineSegment methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^ from hash bitXor: to hash! !!GLineSegment methodsFor: 'initialization'!initialize	super initialize.	from := 0 @ 0.	to := 0 @ 0! !!GLineSegment methodsFor: 'rectangle functions'!intersect: otherShape	^ otherShape intersectLineSegment: self! !!GLineSegment methodsFor: 'comparing'!intersectCircle: aCircle	| e l d det t1 t2 a b c result root |	e := from - aCircle center.	l := to - aCircle center.	d := l - e.	a := d x squared + d y squared.	b := 2 * e x * d x + (2 * e y * d y).	c := e x squared + e y squared - aCircle radius squared.	det := b squared - (4 * a * c).	det < 0		ifTrue: [ ^ #() ].	a = 0		ifTrue: [ ^ #() ].	root := det sqrt.	t1 := (b negated + root) / (2 * a).	t2 := (b negated - root) / (2 * a).	result := (Set with: t1 with: t2) collect: [ :each | e + (each * d) + aCircle center ].	^ (result select: [ :each | each onLineFrom: self from to: self to ]) asArray! !!GLineSegment methodsFor: 'comparing'!intersectCircleArc: aCircleArc	| intersections |	intersections := self intersectCircle: aCircleArc circle.	intersections ifEmpty: [ ^ #() ].	^ intersections		select: [ :each | 			| angle |			angle := ((each y - aCircleArc center y) negated arcTan: each x - aCircleArc center x)				% Float twoPi.			angle between: aCircleArc startAngle and: aCircleArc endAngle ]! !!GLineSegment methodsFor: 'comparing'!intersectEllipse: anEllipse	| hr_sq vr_sq lp ldir diff mdir mdiff a b c det result |	hr_sq := anEllipse a squared.	vr_sq := anEllipse b squared.	lp := Array with: from with: to.		ldir := lp second - lp first.	diff := lp first - anEllipse center.	mdir := ldir x / hr_sq @ (ldir y / vr_sq).	mdiff := diff x / hr_sq @ (diff y / vr_sq).		a := ldir dotProduct: mdir.	b := ldir dotProduct: mdiff.	c := (diff dotProduct: mdiff) - 1.	det := b squared - a*c.	a = 0 ifTrue: [ ^#() ].		result := OrderedCollection new.	det = 0 ifTrue: [ |t|		t := b negated / a.		result add: (lp first + ((lp second - lp first) * t))	].	(det > 0) ~= false ifTrue: [ |root t_a t_b|		root := det sqrt.		t_a := b negated - root / a.		t_b := b negated + root / a.		result add: (lp first + ((lp second - lp first) * t_a)).		result add: (lp first + ((lp second - lp first) * t_b)).	].	^ result select: [ :each | each onLineFrom: self from to: self to ]! !!GLineSegment methodsFor: 'private'!intersectHorizontal: other	"Intersection with other line segment. Self must be horizontal (optimization purposes)"	| pt |	(pt := self intersectHorizontalLine: other) ifNil: [ ^ nil ].	pt x < self left x | (pt x > self right x) | (pt y < other bottom y) | (pt y > other top y)		ifTrue: [ ^ nil ].	^ pt! !!GLineSegment methodsFor: 'private'!intersectHorizontalLine: other	"point of intersection of line on which line segment lies with line of other line segment or nil if parallel. Self must be horizontal (optimization purposes)"	| x y vector |	vector := other vector.	vector y isZero		ifTrue: [ ^ nil ].	y := self from y.	x := (self from y - other from y) * other cotan + other from x.	^ x @ y! !!GLineSegment methodsFor: 'comparing'!intersectLine: other	"point of intersection of line on which line segment lies with line of other line segment or nil if parallel"	| det x y |	self isHorizontal		ifTrue: [ ^ self intersectHorizontalLine: other ].	self isVertical		ifTrue: [ ^ self intersectVerticalLine: other ].	det := self a * other b - (other a * self b).	det isZero		ifTrue: [ ^ nil ].	x := (self b * other c - (other b * self c)) / det.	y := (other a * self c - (self a * other c)) / det.	^ x @ y! !!GLineSegment methodsFor: 'comparing'!intersectLines: other	^ self intersectLine: other! !!GLineSegment methodsFor: 'comparing'!intersectPolygon: polygon	"^ self intersectRectangle: polygon encompasingRectangle."	| intersections vertices next intersection |	intersections := Set new.	vertices := polygon vertices.	vertices doWithIndex: [ :current :i | 		next := i = vertices size			ifTrue: [ vertices first ]			ifFalse: [ vertices at: i+1 ].		intersection := self finiteLinesIntersectFrom: current to: next.		intersection 			ifNotNil: [ intersections add: intersection ] ].	^ intersections! !!GLineSegment methodsFor: 'comparing'!intersectRectangle: aRectangle	"collection of points of intersection with not rotated rectangle"	| pts bottomLeft bottomRight topLeft topRight |	bottomLeft := aRectangle bottomLeft.	bottomRight := aRectangle bottomRight.	topLeft := aRectangle topLeft.	topRight := aRectangle topRight.	pts := Set new.	pts add: ((self class from: topLeft to: topRight) intersectHorizontal: self).	pts add: ((self class from: bottomLeft to: bottomRight) intersectHorizontal: self).	pts add: ((self class from: topLeft to: bottomLeft) intersectVertical: self).	pts add: ((self class from: topRight to: bottomRight) intersectVertical: self).	pts remove: nil ifAbsent: [  ].	^ pts! !!GLineSegment methodsFor: 'private'!intersectVertical: other	"Intersection with other line segment. Self must be vertical (optimization purposes)"	| pt |	pt := self transposed intersectHorizontal: other transposed.	pt ifNil: [ ^ nil ].	^ pt transposed! !!GLineSegment methodsFor: 'private'!intersectVerticalLine: other	"point of intersection of line on which line segment lies with line of other line segment or nil if parallel. Self must be vertical (optimization purposes)"	| pt |	pt := self transposed intersectHorizontalLine: other transposed.	pt ifNil: [ ^ nil ].	^ pt transposed! !!GLineSegment methodsFor: 'comparing'!intersection: other	"point of intersection with other line segment or nil if it does not exists"	| intersection |	self isHorizontal		ifTrue: [ ^ self intersectHorizontal: other ].	self isVertical		ifTrue: [ ^ self intersectVertical: other ].	intersection := self intersectLines: other.	intersection ifNil: [ ^ nil ].	(intersection onLineFrom: self from to: self to) & (intersection onLineFrom: other from to: other to)		ifFalse: [ ^ nil ].	^ intersection! !!GLineSegment methodsFor: 'testing'!isHorizontal	^ from y = to y! !!GLineSegment methodsFor: 'testing'!isVertical	^ from x = to x! !!GLineSegment methodsFor: 'accessing'!left	^ from x < to x		ifTrue: [ from ]		ifFalse: [ to ]! !!GLineSegment methodsFor: 'geometry'!length	^ self vector r! !!GLineSegment methodsFor: 'geometry'!parameters	| k q |	"y = kx + q	k = (y2-y1) / (x2-x1)	q = y1 - k * x1	"	k := (to y - from y) / (to x - from x).	q := from y - (k * from x).	^ Array with: k with: q! !!GLineSegment methodsFor: 'geometry'!pointForBalance: aNumber	"Return point on the line as specified by the balance.	Balance is		\in <0,1> for relative (e.g. 0 start, 1 end, 0.5 middle).		>1 for absolute starting from source (e.g. '10' is 10 pixels from the FROM)		<1 for absolute starting from end (e.g. '-10' is 10 pixesl from the TO)	"	| balance |	balance := aNumber.	(aNumber between: 0 and: 1)		ifTrue: [ balance := self length * aNumber ].	balance < 0		ifTrue: [ balance := self length - balance negated ].	^ self length > 0		ifTrue: [ from + (self vector / self length * balance) ]		ifFalse: [ from ]! !!GLineSegment methodsFor: 'accessing'!right	^ from x > to x		ifTrue: [ from ]		ifFalse: [ to ]! !!GLineSegment methodsFor: 'geometry'!sideOfPoint: aPoint	"Compute on which side of the segment a point is.	For line going from left A=(a_x, a_y) to right B=(b_x, b_y) the value is	d = (x - a_x)(b_y - a_y) - (y - a_y)(b_x - a_x)	1 - above the line	0 - on the line  -1 - below the line	"	^ ((aPoint x - from x) * (to y - from y) - ((aPoint y - from y) * (to x - from x))) sign! !!GLineSegment methodsFor: 'geometry'!tan	| vector |	vector := self vector.	vector x isZero		ifTrue: [ ^ nil ].	^ vector y / vector x! !!GLineSegment methodsFor: 'accessing'!to	^ to! !!GLineSegment methodsFor: 'accessing'!to: toPoint	to := toPoint! !!GLineSegment methodsFor: 'accessing'!top	^ from y > to y		ifTrue: [ from ]		ifFalse: [ to ]! !!GLineSegment methodsFor: 'geometry'!transposed	^ self class from: from transposed to: to transposed! !!GLineSegment methodsFor: 'geometry'!vector	^ to - from! !!GPolygon class methodsFor: 'as yet unclassified'!convexHullOn: aCollection	| lastPoint nextPoint convexHull |"self halt."	convexHull := OrderedCollection new.		nextPoint := aCollection detectMin: #x.	 [		lastPoint := nextPoint.		convexHull add: lastPoint.		nextPoint := aCollection detect: [ :point | point ~= lastPoint ].		(aCollection copyWithout: nextPoint) do: [ :point |			| turn |					turn :=				(nextPoint x - lastPoint x) * (point y - lastPoint y) -				((point x - lastPoint x) * (nextPoint y - lastPoint y)).			(turn < 0 or:				[ turn = 0 and:				[ (lastPoint dist: point) > (lastPoint dist: nextPoint) ] ]) ifTrue:					[ nextPoint := point ] ] ] doWhileTrue: [				convexHull first ~= nextPoint ].			^ self newVertices: convexHull				! !!GPolygon class methodsFor: 'as yet unclassified'!newVertices: aCollection		^ self new		initializeVertices: aCollection;		yourself.! !!GPolygon methodsFor: 'accessing'!center	| min max x y |	min := vertices min.	max := vertices max.	x := (min x + max x)/2.0.	y := (min y + max y)/2.0.	^ x @ y	! !!GPolygon methodsFor: 'accessing'!edges	| edges firstVert prevVert |	edges := OrderedCollection new.		firstVert := vertices at: 1.	prevVert := firstVert.	vertices allButFirstDo: [ :curVert |		edges add: (GSegment with: prevVert with: curVert).		prevVert := curVert ].	edges add: (GSegment with: (vertices at: (vertices size)) with: firstVert).	^ edges! !!GPolygon methodsFor: 'accessing'!encompasingRectangle	|leftMost rightMost top bottom|	leftMost := vertices first. 	rightMost := vertices first.	top := vertices first. 	bottom:= vertices first.	vertices allButFirst do:[ :v | 		(v y > top y) ifTrue:[ top := v ].		(v y < bottom y) ifTrue:[ bottom := v ].		(v x < leftMost x) ifTrue:[ leftMost := v ].		(v x > rightMost x) ifTrue:[ rightMost := v ]].	^Rectangle left: leftMost x right: rightMost x top: top y bottom: bottom y! !!GPolygon methodsFor: 'converting'!fitInExtent: extent	"I take as parameter a point and will fit the polygon in a rectangle whose dimensions is defined by the extent.		To do that, I will first fit my vertices in a square of lenght of 1, then I will multiply my vertices by the extent required."	| max verticesInSquareOfSizeOne |	max := (self vertices collect: #x) max max: ((self vertices collect: #y )) max. "We do not take `self vertices max` because we want to preserve proportions"	"Fit the polygon in a square of size 1 by doing a division of it's vertices by 2 times the value of the furthest point from the center of the polygon."	verticesInSquareOfSizeOne := self vertices collect: [ :point | point / (max * 2) ].		vertices := (verticesInSquareOfSizeOne collect: [ :point | point * extent ])! !!GPolygon methodsFor: 'testing'!includesPoint: point  ^ ( AthensPolygonTester new polygon: vertices ) includesPoint: point.! !!GPolygon methodsFor: 'initialization'!initializeVertices: aCollection	self initialize.		vertices := aCollection ! !!GPolygon methodsFor: 'comparing'!intersectLineSegment: aLineSegment	^ aLineSegment intersectPolygon: self! !!GPolygon methodsFor: 'converting'!moveBy: aPoint	"Move a polygon by a delta defined by aPoint"	vertices := self vertices collect: [ :point | point + aPoint ]! !!GPolygon methodsFor: 'accessing'!vertices		^ vertices! !!GRay class methodsFor: 'as yet unclassified'!new	^ self basicNew initializeWithOrigin: 0@0 direction: 0@0! !!GRay class methodsFor: 'as yet unclassified'!origin: aPoint1 direction: aPoint2	^ self new initializeWithOrigin: aPoint1 direction: aPoint2! !!GRay methodsFor: 'arithmetic'!* aRay^ ( self origin x - self direction x ) * ( aRay origin x - aRay direction x ) + (( self origin y - self direction y ) * ( aRay origin y - aRay direction y ) )! !!GRay methodsFor: 'arithmetic'!+ aRay	| newOrigin vector |		newOrigin := self origin + aRay origin / 2.		vector := (self direction - self origin) + 				 (aRay direction - aRay origin).	^ GRay origin: newOrigin direction: newOrigin + vector ! !!GRay methodsFor: 'comparing'!= aRay^ self origin =~ aRay origin and: [ (self origin bearingToPoint: self direction) =~ (aRay origin bearingToPoint: aRay direction) ]! !!GRay methodsFor: 'converting'!asLine|ai bi ci|(self origin  y) = (self direction  y) ifTrue:[ ^ GLine		a: 0 b: 1 c: ((self origin y) negated)].(self origin x) = (self direction x) ifTrue:[ 	^ GLine		a: 1 b: 0 c: ((self origin x) negated)].	ai := (self origin y) - (self direction y). bi := (self direction x) - (self origin x).ci := ((self origin x) - (self direction x)) * (self origin y) + ( ((self direction y) - (self origin y)) * (self origin x) ).^ GLine		a:ai b: bi c: ci! !!GRay methodsFor: 'converting'!asSegment	^ GSegment with: origin with: direction! !!GRay methodsFor: 'properties'!cutWith: frame| coll |coll := OrderedCollection new.frame edges	collect: [ :edge | edge intersectionPointWithRay: self ]	thenDo: [ :p |		(p notNil and: [ coll noneSatisfy: [ :p2 | p2 =~ p ] ])			ifTrue: [ coll add: p ] ] .coll isEmpty ifTrue:[^ nil]				 ifFalse:[coll size = 2 					ifTrue:  [ ^GSegment with: coll first with: coll second ]					ifFalse: [ ^GSegment with: coll first with: self origin ] ]! !!GRay methodsFor: 'accessing'!direction	^direction ! !!GRay methodsFor: 'accessing'!direction: aPoint	direction := aPoint! !!GRay methodsFor: 'rectangle functions'!extendBy1: num|vect k  xn yn|	( self origin x = self direction x ) 		ifTrue:[ xn := self origin x.			( self origin y > self direction y )				ifFalse:[ yn := self direction y + num. ] 				ifTrue:[ yn := self direction y - num ] ]		ifFalse:[			k := ( self origin y - ( self direction y ) )/( self origin x - ( self direction x ) ).			( self origin x > self direction x ) 				ifFalse:[ xn := self direction x + num. ] 				ifTrue:[ xn := self direction x - num. ].			yn := self direction y + ( k *( xn - self direction x ))].	vect := GRay origin: self origin direction: ( xn @ yn ).	(vect asLine = self asLine)	ifTrue:[^vect]! !!GRay methodsFor: 'rectangle functions'!extendBy: num|cos sin|self length = 0 	ifTrue:[ self direction: ( (direction - origin) x * num  ) @ ((direction - origin) y * num ) ]	ifFalse:[cos := (direction - origin) x / self length.sin := (direction - origin) y / self length.	self direction: ( cos * num * self length ) @ ( sin * num * self length )].^ self ! !!GRay methodsFor: 'rectangle functions'!extendWith: num|cos sin|cos := (direction - origin) x / self length.sin := (direction - origin) y / self length.	self direction: ( self direction x +  (cos * num) ) @ ( self direction y + (sin * num) ).^ self ! !!GRay methodsFor: 'properties'!flipped	^ GRay origin: self origin direction: (origin + (origin - direction))! !!GRay methodsFor: 'properties'!hasPoint: aPoint^ (( origin - direction ) signFuz = ( origin - aPoint ) signFuz  or:					[ origin = aPoint ]) ! !!GRay methodsFor: 'comparing'!hash	^ ( self origin hash hashMultiply +		(self origin bearingToPoint: self direction) hash ) hashMultiply! !!GRay methodsFor: 'initialization'!initialize	super initialize.	origin := 0@0.	direction := 0@0! !!GRay methodsFor: 'initialization'!initializeWithOrigin: aPoint1 direction: aPoint2	super initialize.	origin  := aPoint1.	direction  := aPoint2 ! !!GRay methodsFor: 'accessing'!length	^ (( self origin x - self direction x ) * ( self origin x - self direction x )	+	(( self origin y - self direction y ) * ( self origin y - self direction y )))sqrt	! !!GRay methodsFor: 'accessing'!origin 	^origin! !!GRoundedRectangle class methodsFor: 'instance creation'!rectangle: aRectangle borderRadius: aRadius	^ self new		setRectangle: aRectangle borderRadius: aRadius;		yourself! !!GRoundedRectangle methodsFor: 'comparing'!= aRect	self species = aRect species		ifFalse: [ ^ false ].	^ self rectangle = aRect rectangle and: [ self borderRadius = aRect borderRadius ]! !!GRoundedRectangle methodsFor: 'accessing'!borderRadius	^ borderRadius! !!GRoundedRectangle methodsFor: 'accessing'!center	^ self rectangle center! !!GRoundedRectangle methodsFor: 'accessing'!corners	| r |	r := borderRadius.	^ Array		with:			(GCircleArc				center: rectangle topRight + (r negated @ r)				radius: r				startAngle: 0				endAngle: Float halfPi)		with:			(GCircleArc				center: rectangle topLeft + (r @ r)				radius: r				startAngle: Float halfPi				endAngle: Float pi)		with:			(GCircleArc				center: rectangle bottomLeft + (r @ r negated)				radius: r				startAngle: Float pi				endAngle: Float threePi / 2)		with:			(GCircleArc				center: rectangle bottomRight + (r negated @ r negated)				radius: r				startAngle: Float threePi / 2				endAngle: Float twoPi)! !!GRoundedRectangle methodsFor: 'accessing'!encompassingRectangle	^ self rectangle! !!GRoundedRectangle methodsFor: 'comparing'!intersectLine: aLine	(self corners flatCollect: [ :each | aLine intersectCircleArc: each ])		ifNotEmpty: [ :col | ^ col ].	^ aLine intersectRectangle: self rectangle! !!GRoundedRectangle methodsFor: 'comparing'!intersectLineSegment: aLine	(self corners flatCollect: [ :each | aLine intersectCircleArc: each ])		ifNotEmpty: [ :col | ^ col ].	^ aLine intersectRectangle: self rectangle! !!GRoundedRectangle methodsFor: 'accessing'!rectangle	^ rectangle! !!GRoundedRectangle methodsFor: 'initialization'!setRectangle: aRectangle borderRadius: aRadius	rectangle := aRectangle.	borderRadius := aRadius! !!GSegment class methodsFor: 'as yet unclassified'!with: aPoint1 with: aPoint2	^ self new initializeWith: aPoint1 with: aPoint2! !!GSegment methodsFor: 'initialization'!= segment^((self v1 =~ segment v1) and: [self v2 =~ segment v2]) or: [(self v1 =~ segment v2) and: [self v2 =~ segment v1]]! !!GSegment methodsFor: 'properties'!alreadyExistIn: aSet  	aSet do:[:eachS | (eachS asLine = (self asLine) )ifTrue:[ ^ true ]].	^ false! !!GSegment methodsFor: 'properties'!asLine	^ GLine through: v1 and: v2! !!GSegment methodsFor: 'properties'!belowPoint:p^( (self v2 x - self v1 x)*(p y - self v1 y)-((self v2 y - self v1 y)*(p x - self v1 x))> 0 )	! !!GSegment methodsFor: 'properties'!boundBy: aPoint	^ self v1 = aPoint or: [ self v2 = aPoint ]! !!GSegment methodsFor: 'properties'!cutWith: frame| coll |coll := OrderedCollection new.frame edges	collect: [ :edge | edge intersectionPointWithSegment: self ]	thenDo: [ :p |		(p notNil and: [ coll noneSatisfy: [ :p2 | p2 =~ p ] ])			ifTrue: [ coll add: p ] ].coll ifEmpty: [ "self halt".	(frame hasPoint: self v1)		ifTrue:  [ ^ self ]		ifFalse: [ ^ nil ] ].coll size = 2 	ifTrue: [ ^ GSegment with: coll first with: coll second ].(frame hasPoint: self v1) 	ifTrue:  [ ^ GSegment with: coll first with: self v1 ] 	ifFalse: [ ^ GSegment with: coll first with: self v2 ]								! !!GSegment methodsFor: 'properties'!dist: p	^ self asLine dist: p! !!GSegment methodsFor: 'properties'!distTo: point	^ (( 		((self v2 y - self v1 y) * point x) - ((self v2 x - self v1 x) * point y) + ((self v2 x) * (self v1 y )) - ((self v1 x) * (self v2 y ))		)abs)	/		((  (self v1 y - self v2 y) * (self v1 y - self v2 y) 		+			((self v1 x - self v2 x) * (self v1 x - self v2 x))		 )sqrt)	! !!GSegment methodsFor: 'properties'!extendSegmVert: v to: frame	|points ver p|	points := frame intersectionPointsWithLine: self asLine.	ver := self vertices detect:[:vi | (vi = v) not].	( ver x = v x ) 		ifTrue:[ ( ver y > v y )			ifTrue: [ p := points detect:[ :pi | pi y < v y] ]			ifFalse:[ p := points detect:[ :pi | pi y > v y] ]]		ifFalse:	[ ( ver x > v x )			ifTrue: [ p := points detect:[ :pi | pi x < v x] ]			ifFalse:[ p := points detect:[ :pi | pi x > v x] ]			 ].^ GSegment with: ver with: p								! !!GSegment methodsFor: 'properties'!extendWith: point and: frame	|points v|	(self asLine hasPoint: point) 		ifTrue:[ 			(( self v1 dist: point ) < ( self v2 dist: point ))				ifTrue:[ v1 := point]				ifFalse:[ v2 := point].			v := self vertices detect:[:p | (p = point) not ].			points := frame intersectionPointsWithLine: (self asLine).			points size = 2 				ifTrue:[  ( ( GSegment with: point with: points first ) hasPoint: v )  					ifTrue:[ ^ GSegment with: point with: points first ]					ifFalse:[ ^ GSegment with: point with: points second] ]]		! !!GSegment methodsFor: 'properties'!has: p	(self asLine hasPoint: p)	ifFalse:[^false]	ifTrue:[ ^((		((self v1 x <= p x and:[ p x <= self v2 x]) 						or:[ self v2 x <= p x and:[ p x <= self v1 x]]))		and:[ 			((self v1 y <= p y and:[ p y <= self v2 y]) 						or:[ self v2 y <= p y and:[ p y <= self v1 y]])])		]! !!GSegment methodsFor: 'properties'!hasOnLinePoint: p	| e k edges tr v|	(self v1 =~ p or:[ self v2 =~ p] ) 		ifTrue:[^true]		ifFalse:[			tr := ( GTriangle with: p with: self v1 with: self v2 ).			edges:= tr edges.			k := edges detectMax: [:ed | ed length].			e := (1/2)*(					(( self v1 x - self v2 x ) * ( p y - self v2 y )-					(( self v1 y - self v2 y ) * ( p x - self v2 x )))					abs			/k length).			v := tr vertices detect:[ :vi |  vi~= k v1 and:[ vi ~= k v2 ]].			^ "k asLine hasPoint: v withApproximation: e."			(k dist: v) <=~ (2*e)] 	! !!GSegment methodsFor: 'properties'!hasOnLinePoint: p withRespectTo: vert	| e k edges tr v|	(self v1 =~ p or:[ self v2 =~ p] ) 		ifTrue:[^ true]		ifFalse:[ "(vert x < self v2 x)			ifTrue:[				(vert x < p x and:[ p x < self v2 x ])				or:[ (vert x < self v2 x and:[ p x > self v2 x ])]]"			((			( p x between: vert x and: self v2 x)and:			[ p y between: vert y and: self v2 y]) 		or:[ (self v2 x between: vert x and: p x) and:			(self v2 y between: vert y and: p y)])				ifFalse:[^ false]				ifTrue:[					tr := ( GTriangle with: p with: self v1 with: self v2 ).					edges:= tr edges.					k := edges detectMax: [:ed | ed length].					e := (1/2)*(							(( self v1 x - self v2 x ) * ( p y - self v2 y )-							(( self v1 y - self v2 y ) * ( p x - self v2 x )))							abs					/k length).					v := tr vertices detect:[ :vi |  vi~= k v1 and:[ vi ~= k v2 ]].					^ "k asLine hasPoint: v withApproximation: e."					(k dist: v) <=~ (2*e)]] 	! !!GSegment methodsFor: 'properties'!hasOnLinePoint: p withRespectTo: vert withApprox: apro	| e k edges tr v eps |	(self v1 =~ p or:[ self v2 =~ p] ) 		ifTrue:[^ true]		ifFalse:[ 			tr := ( GTriangle with: p with: self v1 with: self v2 ).			edges := tr edges.			k := edges detectMax: [:ed | ed length].			eps := (1/2)*(							(( self v1 x - self v2 x ) * ( p y - self v2 y )-							(( self v1 y - self v2 y ) * ( p x - self v2 x )))							abs					/k length).			e := apro min: eps.			(((			( p x isBetween: vert x and: self v2 x with: e)and:			[ p y isBetween: vert y and: self v2 y with: e]) 		or:[ (self v2 x isBetween: vert x and: p x with: e) and:			(self v2 y isBetween: vert y and: p y with: e)]) "and:[ self asLine hasPoint: p withApproximation: e ]")				ifFalse:[^ false]				ifTrue:[					"tr := ( GTriangle with: p with: self v1 with: self v2 ).					edges:= tr edges.					k := edges detectMax: [:ed | ed length].					e := (1/2)*(							(( self v1 x - self v2 x ) * ( p y - self v2 y )-							(( self v1 y - self v2 y ) * ( p x - self v2 x )))							abs					/k length)."					v := tr vertices detect:[ :vi |  vi~= k v1 and:[ vi ~= k v2 ]].					(k dist: v) <=~ (2*e) 						ifTrue:[ ^ true"(k asLine hasPoint: v withApproximation: e)"]						ifFalse:[ ^ false]					]]	! !!GSegment methodsFor: 'properties'!hasPoint:aPoint  ^( (self v1 x <=~ aPoint x and: [aPoint x <=~ self v2 x])  or:		[self v2 x <=~ aPoint x and: [aPoint x <=~ self v1 x]]  ) and:    [ (self v1 y <=~ aPoint y and: [aPoint y <=~ self v2 y])  or:		[self v2 y <=~ aPoint y and: [aPoint y <=~ self v1 y]]   ]  .   ! !!GSegment methodsFor: 'initialization'!hash^( v1 hash  + v2 hash ) hashMultiply! !!GSegment methodsFor: 'initialization'!initializeWith: aPoint1 with: aPoint2	super initialize.	v1 := aPoint1.	v2 := aPoint2! !!GSegment methodsFor: 'properties'!intersect: aSegment(self v1 to: self v2 intersects: aSegment v1 to: aSegment v2) 	ifTrue:	[^self asLine intersect: (aSegment asLine)]	ifFalse: [^nil]! !!GSegment methodsFor: 'properties'!intersectionPointWithLine: aLine	^ (self asLine intersect: aLine) ifNotNil: [ :point | 		(self hasPoint: point)			ifTrue:  [ point ]			ifFalse: [ nil ] ]! !!GSegment methodsFor: 'properties'!intersectionPointWithRay: ray	^ (self asLine intersect: ray asLine) ifNotNil: [ :point | 		((self hasPoint: point) and:				[ray hasPoint: point])			ifTrue:  [ point ]			ifFalse: [ nil ] ]! !!GSegment methodsFor: 'properties'!intersectionPointWithSegment: segm	^ (self asLine intersect: segm asLine) ifNotNil: [ :point | 		((self hasPoint: point) and:[segm hasPoint: point])			ifTrue:  [ point ]			ifFalse: [ nil ] ]! !!GSegment methodsFor: 'properties'!isOnLineWith: segm	self = segm 		ifTrue:[^ true]		ifFalse:[^ self asLine = (segm asLine)]! !!GSegment methodsFor: 'properties'!length	^ v1 dist: v2! !!GSegment methodsFor: 'properties'!locationOf: aPoint        ^ ((self v2 x - self v1 x) * (aPoint y - self v1 y) -       ((self v2 y - self v1 y) * (aPoint x - self v1 x))) signFuz! !!GSegment methodsFor: 'properties'!midPoint ^ (v1 + v2) / 2.! !!GSegment methodsFor: 'properties'!perpendicularBisector^GLinea:  (v2 x - v1 x)b:  (v2 y - v1 y)c: ((v1 x * v1 x) - (v2 x * v2 x) + (v1 y * v1 y) - (v2 y * v2 y))/2! !!GSegment methodsFor: 'printing'!printOn: aStream	v1 printOn: aStream.	aStream nextPutAll: '>-<'.	v2 printOn: aStream! !!GSegment methodsFor: 'accessing'!v1^v1! !!GSegment methodsFor: 'accessing'!v2^v2! !!GSegment methodsFor: 'initialization'!vertices	^ { v1 . v2 }! !!GTriangle class methodsFor: 'as yet unclassified'!with: aPoint1 with: aPoint2 with: aPoint3	^ self new initializeWith: aPoint1 with: aPoint2 with: aPoint3! !!GTriangle methodsFor: 'properties'!area	| semiperimeter|	semiperimeter := self semiperimeter.	^ (self edges 		inject: semiperimeter		into: [ :subProduct :edge |			(semiperimeter - edge length) * subProduct ]) sqrt! !!GTriangle methodsFor: 'figures'!circumscribedCircle	| center radius |	center := self edges first perpendicularBisector intersect: self edges last perpendicularBisector.	center isNil ifTrue: [ ^nil ] ifFalse: [ radius := (v1 dist: v2) * (v2 dist: v3) * (v3 dist: v1) / (4 * self area).		^GCircle center: center radius: radius ] 		"^ GCircle		center:			(self edges first perpendicularBisector intersect:			 self edges last perpendicularBisector)		radius: (v1 dist: v2) * (v2 dist: v3) * (v3 dist: v1) / (4 * self area)"! !!GTriangle methodsFor: 'accessing'!edges	^ self edgesByOpositeVertex values! !!GTriangle methodsFor: 'accessing'!edgesByOpositeVertex	^ edgesByOpositeVertex ifNil: [		edgesByOpositeVertex := {			v1 -> (GSegment with: v2 with: v3) .			v2 -> (GSegment with: v3 with: v1) .	   		v3 -> (GSegment with: v1 with: v2)  } asDictionary ]! !!GTriangle methodsFor: 'properties'!hasTwoIntersectionWithSegm: segm	|i|	i := 0.	self edges do:[:e | (e intersect: segm) isNotNil ifTrue:[ i := i + 1 ] ].	^ (i = 2 or:[ i = 3])! !!GTriangle methodsFor: 'initialization'!initializeWith: aPoint1 with: aPoint2 with: aPoint3	super initialize.	v1 := aPoint1.	v2 := aPoint2.	v3 := aPoint3 ! !!GTriangle methodsFor: 'figures'!isDegenerate(v1 = v2 or:[ v1 = v3 or:[ v2 = v3 ]])	ifTrue:[^ true]	ifFalse:[	^  (self edges first length + self edges second length ="closeTo:" (self edges third length)) or: [ 		(self edges second length + self edges third length ="closeTo:" (self edges first length)) or: [ 		 self edges third length + self edges first length ="closeTo:" (self edges second length) ] ]]! !!GTriangle methodsFor: 'properties'!perimeter	^ self edges		inject: 0		into: [ :subSum :edge |			subSum + edge length ]! !!GTriangle methodsFor: 'properties'!semiperimeter	^ self perimeter / 2! !!GTriangle methodsFor: 'accessing'!vertices	^ { v1 . v2 . v3 }! !!Object methodsFor: '*Geometry'!<=~ other	^ self < other or: [ self =~ other ]! !!Object methodsFor: '*Geometry'!<~ other	^ (self >=~ other) not! !!Object methodsFor: '*Geometry'!>=~ other	^ other <=~ self! !!Object methodsFor: '*Geometry'!>~ other	^ other <~ self! !"Geometry"!!AthensCairoCanvas methodsFor: '*Roassal3-Pharo7'!fillRuleEvenOdd	"I am a extention method basic because pharo7 does not have this method	we added in this package with the Baseline of roassal3	this is a patch and we will find the right anwser to avoid this issue"! !"Roassal3-Pharo7"!!TSObject commentStamp: '' prior: 0!Root of most of the Trachel classes.!!TSCamera commentStamp: '' prior: 0!I am main tool which helps to move across Trachel's canvas.My two main properties are position and scale.- position   is a point representing coordinates of the canvas on which the "viewing window" will be centered.  position can be changes with:  * #translateBy:  * #translateTo:  both methods accept canvas based coordinates- scale  defines a magnitude of zooming applied to the canvas and it's elements.!!TSCanvas commentStamp: '' prior: 0!I represent the basic canvas or paint area. I have a collection of shapes!!TSQuadTree commentStamp: '' prior: 0!TODO!!TSRenderer commentStamp: '' prior: 0!I am the abstract of the renderes!!TSAthensRenderer commentStamp: '' prior: 0!I can create a visual components in a athensCanvas surface.!!TSEvent commentStamp: '' prior: 0!TSEvent is the root of all the events handled by Trachel (and therefore Roassal).!!TSCanvasEvent commentStamp: '' prior: 0!I am top class for canvas event!!TSShapeAddedEvent commentStamp: '' prior: 0!When the canvas add a shape!!TSShapeRemovedEvent commentStamp: '' prior: 0!When a canvas removes a shape!!TSShapeEvent commentStamp: '' prior: 0!TSShapeEvent represent all events with shapes and the canvas!!TSExtentChangedEvent commentStamp: '' prior: 0!When a bounding shape uses extent:, width: or height: I will trigger !!TSPositionChangedEvent commentStamp: '' prior: 0!When the shape uses translateBy: or translateTo:, position: does not trigger this event!!TSUserInputEvent commentStamp: '' prior: 0!for user input events!!TSAbstractMouseEvent commentStamp: '' prior: 0!Abstract for mouse events!!TSAbstractMouseClick commentStamp: '' prior: 0!abstract for mouse click events!!TSMouseClick commentStamp: '' prior: 0!Common event for mouse clicks!!TSMouseLeftClick commentStamp: '' prior: 0!Common event for mouse left click!!TSMouseRightClick commentStamp: '' prior: 0!Common event for mouse right clicks!!TSMouseDoubleClick commentStamp: '' prior: 0!Events for double clicks!!TSMouseDoubleLeftClick commentStamp: '' prior: 0!Double click for the left button!!TSMouseDoubleRightClick commentStamp: '' prior: 0!Double clicks for right button!!TSMouseUp commentStamp: '' prior: 0!Events for mouseUp!!TSMouseUpLeft commentStamp: '' prior: 0!left buttom!!TSMouseUpRight commentStamp: '' prior: 0!Event for mouse up right!!TSMouseDragEnd commentStamp: '' prior: 0!When: at the end of DragDrop eventTarget: dragged element!!TSMouseDragStart commentStamp: '' prior: 0!When: when a valid draggable element is grabbedTarget: dragged element!!TSMouseLeftDragStart commentStamp: '' prior: 0!left buttom!!TSMouseMiddleDragStart commentStamp: '' prior: 0!middle button!!TSMouseRightDragStart commentStamp: '' prior: 0!right button!!TSMouseDragging commentStamp: '' prior: 0!When: during dragging of the elementTarget: dragged element!!TSMouseEnter commentStamp: '' prior: 0!When: when a mouse cursor entered an elementTarget: entered element!!TSMouseLeave commentStamp: '' prior: 0!When: when a mouse cursor left an elementTarget: entered element!!TSMouseMove commentStamp: '' prior: 0!Performed while mouse is moving over the morph!!TSMouseWheelEvent commentStamp: '' prior: 0!I'm a mouse wheel scrolling event.!!TSKeyboardEvent commentStamp: '' prior: 0!A base class for keyboard events.!!TSKeyDown commentStamp: '' prior: 0!Event representing a key pressing (but not releasing)-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=c := TSCanvas new.e := TSEllipse new.c addShape: e.e when: TRKeyDown do: [ :event |	event keyCombination = $r asKeyCombination ifTrue: [		e color: Color random.		v signalUpdate.	]].c open-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=!!TSKeyUp commentStamp: '' prior: 0!Event representing a key release.[[[c := TSCanvas new.c when: TRKeyDown do: [ :event |	self log: '[DOWN]'; logCr: event keyCombination.].c when: TRKeyUp do: [ :event |	self log: '[UP]'; logCr: event keyCombination.].c open]]]!!TSAthensMorph commentStamp: '' prior: 0!A TSAthensMorph is at the interface between Morphic and Trachel. !!AthensCairoPathBuilder methodsFor: '*Roassal3-Trachel'!arcAround: aCenterPoint radius: aRadius startAngle: aStartAngle endAngle: anEndAngle	self 		arcCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius 		startAngle: aStartAngle 		endAngle: anEndAngle ! !!AthensCairoPathBuilder methodsFor: '*Roassal3-Trachel'!arcAround: aCenterPoint radius: aRadius startAngle: aStartAngle endAngle: anEndAngle cw: aBool	aBool ifTrue: [ 		self		arcNegativeCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius		startAngle: aStartAngle		endAngle: anEndAngle ]	ifFalse: [ self		arcCenterX: aCenterPoint x		centerY: aCenterPoint y		radius: aRadius		startAngle: aStartAngle		endAngle: anEndAngle ]	! !!AthensCairoPathBuilder methodsFor: '*Roassal3-Trachel'!arcCos: num	| temp |	temp := num.	num < -1.0 ifTrue: [ temp := -1.0 ].	num > 1.0 ifTrue: [ temp := 1.0 ].		^ temp arcCos! !!AthensCairoPathBuilder methodsFor: '*Roassal3-Trachel'!ellipticalArc2: radii xrot: rotationAxis large: largeFlag sweep: sweepFlag to: aPoint	"raddi Point, rotationAxis Number, largeFlag Number, sweepFlag Number, aPoint Point"	"implentation based on the svg specification"	| ep x0 y0 x y dx2 dy2 theta x1 y1 tcos tsin rx ry prx pry px1 py1 d sign coef cx1 cy1 sx2 sy2 cx cy ux uy vx vy n p angleStart angleExtent pi2 |	self flag: 'Not yet for real elliptic arcs'.	pi2 := Float pi * 2.	(radii x = 0 or: [ radii y = 0 ]) ifTrue: [ 		^ self lineTo: aPoint ].	ep := self getCurrentPoint.	x0 := ep x.	y0 := ep y.	x := aPoint x.	y := aPoint y.	dx2 := (x0 - x)/2.0.	dy2 := (y0 - y)/2.0.	theta := rotationAxis degreesToRadians.	tcos := theta cos.	tsin := theta sin.	x1 := (tcos * dx2) + (tsin * dy2).	y1 := (tsin negated* dx2) + (tcos * dy2).	rx := radii x abs.	ry := radii y abs.	prx := rx * rx.	pry := ry * ry.	px1 := x1 * x1.	py1 := y1 * y1.	d := (px1 / prx) + (py1 / pry).	d > 1 ifTrue: [ 		rx := rx * d sqrt.		ry := ry * d sqrt.		prx := rx * rx.		pry := ry * ry ].		sign := largeFlag = sweepFlag ifTrue: [ -1 ] ifFalse: [ 1 ].	coef := sign * (( (prx * pry) - (prx * py1) - (pry * px1) )/( (prx * py1) + (pry * px1) ) max: 0) sqrt.		cx1 := coef * rx * y1 / ry.	cy1 := coef * (ry * x1 / rx) negated.		sx2 := (x0 + x)/2.	sy2 := (y0 + y)/2.	cx := sx2 + ((tcos * cx1) - (tsin * cy1)).	cy := sy2 + ((tsin * cx1) + (tcos * cy1)).		ux := (x1 - cx1)/rx.	uy := (y1 - cy1)/ry.	vx := (x1 + cx1) negated /rx.	vy := (y1 + cy1) negated /ry.	"Angle start"	n := ((ux * ux) + (uy * uy)) sqrt.	p := ux.	sign := uy < 0 ifTrue: [ -1 ] ifFalse: [ 1 ].	angleStart := sign * (self arcCos: p / n).	"angle extent"	n := (((ux * ux) + (uy * uy)) * ((vx * vx) + (vy * vy))) sqrt.	p := (ux * vx) + (uy * vy).	sign := ((ux * vy) - (uy * vx)) < 0 ifTrue: [ -1 ] ifFalse: [ 1 ].	angleExtent := sign * (self arcCos: p / n).	(sweepFlag = 0 and: [ angleExtent > 0]) ifTrue: [ 		angleExtent := angleExtent - pi2.	 ] ifFalse: [ (sweepFlag = 1 and: [ angleExtent < 0 ]) ifTrue: [ 		angleExtent := angleExtent + pi2.		 ] ].	angleExtent := angleExtent % pi2.	angleStart := angleStart % pi2.	self		arcAround: (cx asFloat)@ (cy asFloat)		radius: rx asFloat		startAngle: angleStart asFloat		endAngle: angleExtent asFloat + angleStart		cw: sweepFlag = 0.! !!AthensCairoCanvas methodsFor: '*Roassal3-Trachel'!fillPreserve	^ self nbCall: #(#void #cairo_fill_preserve #(#self))	! !!AthensCairoCanvas methodsFor: '*Roassal3-Trachel'!textPath: anUTF8String	"A drawing operator that generates the shape from a string of UTF-8 characters, rendered according to the current font_face, font_size (font_matrix), and font_options. "		^ self nbCall: #(void cairo_text_path (self, char * anUTF8String ))! !!TSCamera methodsFor: 'accessing'!canvas	^ canvas! !!TSCamera methodsFor: 'accessing'!canvas: aCanvas	canvas := aCanvas! !!TSCamera methodsFor: 'convertion'!distanceFromPixelToSpace: aPoint	^ (aPoint / self scale) asFloatPoint! !!TSCamera methodsFor: 'convertion'!fromPixelToSpace: aPoint	^ AthensAffineTransform new		translateBy: self position;		scaleBy: 1 / self scale;		translateBy: (self canvas extent / 2) negated;		transform: aPoint! !!TSCamera methodsFor: 'convertion'!fromSpaceToPixel: aPoint	^ AthensAffineTransform new		translateBy: self canvas extent / 2;		scaleBy: self scale;		translateBy: self position negated;		transform: aPoint	! !!TSCamera methodsFor: 'initialization'!initialize	super initialize.	position := 0@0.	scale := 1.0000001.! !!TSCamera methodsFor: 'accessing'!position	^ position! !!TSCamera methodsFor: 'accessing'!position: aPoint 	position := aPoint! !!TSCamera methodsFor: 'accessing'!scale	^ scale! !!TSCamera methodsFor: 'accessing'!scale: aNumber	scale := aNumber! !!TSCamera methodsFor: 'actions'!translateBy: aPoint	self translateTo: self position + aPoint.! !!TSCamera methodsFor: 'actions'!translateTo: aPoint	self position: aPoint! !!TSCamera methodsFor: 'actions'!zoomToFit: anExtent	self 		zoomToFit: anExtent 		rectangle: canvas encompassingRectangle	! !!TSCamera methodsFor: 'actions'!zoomToFit: anExtent extent: otherExtent	self 		zoomToFit: anExtent 		rectangle: (Rectangle rsCenter: 0@0 extent: otherExtent)	! !!TSCamera methodsFor: 'actions'!zoomToFit: anExtent rectangle: rect	| sc |	sc := anExtent / (rect extent max: 1 @ 1).	sc := sc x min: sc y.	self 		translateTo: rect rsCenter;		scale: sc.! !!TSCanvas methodsFor: 'visiting'!accept: visitor	visitor visitCanvas: self! !!TSCanvas methodsFor: 'animations'!addAnimation: anAnimation	animations add: anAnimation.	anAnimation canvas: self.	anAnimation start.	self signalUpdate! !!TSCanvas methodsFor: 'adding removing shapes'!addBasicShape: aShape	shapes add: aShape! !!TSCanvas methodsFor: 'adding removing shapes'!addFixedShape: aShape	fixedShapes add: aShape! !!TSCanvas methodsFor: 'adding removing shapes'!addShape: aShape	| evt |	aShape addedIn: self.	evt := TSShapeAddedEvent new shape: aShape.	self announce: evt.	aShape announce: evt.! !!TSCanvas methodsFor: 'animations'!animation 	^ self animation: TSTransitionAnimation new.! !!TSCanvas methodsFor: 'animations'!animation: anAnimation	self addAnimation: anAnimation.	^ anAnimation! !!TSCanvas methodsFor: 'animations'!animationFrom: array	| animation |	animation := TSSequentialAnimation new.	animation addAll: array.	^ self animation: animation.! !!TSCanvas methodsFor: 'animations'!animations	^ animations! !!TSCanvas methodsFor: 'events'!announce: anEvent	announcer ifNil: [ ^ self ].	announcer announce: anEvent value! !!TSCanvas methodsFor: 'events'!announcer	announcer isNil ifTrue: [ announcer := Announcer new ].	^ announcer! !!TSCanvas methodsFor: 'events'!announcer: anAnnouncer	announcer := anAnnouncer! !!TSCanvas methodsFor: 'accessing'!camera	^ camera! !!TSCanvas methodsFor: 'accessing'!camera: aCamera	camera := aCamera! !!TSCanvas methodsFor: 'accessing'!canvas	^ self! !!TSCanvas methodsFor: 'testing'!clearBackground	^ clearBackground! !!TSCanvas methodsFor: 'actions'!clearBackground: aBool	clearBackground := aBool! !!TSCanvas methodsFor: 'accessing'!color 	^ color! !!TSCanvas methodsFor: 'accessing'!color: aColor	color := aColor.	color isColor ifTrue: [ ^ self ].	color := Color colorFrom: aColor.! !!TSCanvas methodsFor: 'instance creation'!createMorph	morph := TSAthensMorph new. 	morph renderer: TSAthensRenderer new.	morph canvas: self.	^ morph! !!TSCanvas methodsFor: 'accessing'!encompassingRectangle	| r e |	r := shapes		ifEmpty: [ 0@0 corner: 0@0 ]		ifNotEmpty: [ Rectangle merging: (shapes collect: #encompassingRectangle) ].	e := r extent max: 1 @ 1.	^ r topLeft extent: e! !!TSCanvas methodsFor: 'accessing'!extent	^ extent! !!TSCanvas methodsFor: 'accessing'!extent: aPoint	| evt |	evt := TSExtentChangedEvent new		shape: self;		oldExtent: extent;		newExtent: (extent := aPoint).	self announce: evt! !!TSCanvas methodsFor: 'accessing'!fixedShapes	^ fixedShapes ! !!TSCanvas methodsFor: 'animations'!hasAnimation	"True if at least one animation is running"	^ animations notEmpty! !!TSCanvas methodsFor: 'animations'!hasAnimation: anAnimation	"True if anAnimation is running"	^ animations includes: anAnimation! !!TSCanvas methodsFor: 'actions'!hideEncompassingRectangles	showRectangles := false.! !!TSCanvas methodsFor: 'initialization'!initialize	super initialize.	showRectangles := false.	shapes := OrderedCollection new.	fixedShapes := OrderedCollection new.	animations := OrderedCollection new.	clearBackground := true.	color := Color white.	extent := 500@500.	camera := TSCamera new		canvas: self;		yourself.! !!TSCanvas methodsFor: 'instance creation'!morph	^ morph! !!TSCanvas methodsFor: 'animations'!numberOfAnimations	"Return the number of animations contained in the canvas"	^ animations size! !!TSCanvas methodsFor: 'accessing'!numberOfFixedShapes	"Return the number of fixed shapes"	^ fixedShapes size! !!TSCanvas methodsFor: 'accessing'!numberOfShapes	"Return the number of non-fixed shapes"	^ shapes size! !!TSCanvas methodsFor: 'instance creation'!open	| window |	self createMorph.	window := morph openInWindow.	window extent: 500@500.	morph privateOwner: window.	^ window	! !!TSCanvas methodsFor: 'accessing'!parent	^ self! !!TSCanvas methodsFor: 'animations'!playAnimations	| shouldClean |	shouldClean := false.	animations do: [ :animation | 		animation refresh. 		animation hasCompleted 			ifTrue: [ shouldClean := true. ] ].	shouldClean ifTrue: [ 		animations copy do: [ :animation |			animation hasCompleted ifTrue: [ animation remove ] ] ].! !!TSCanvas methodsFor: 'actions'!pushBack: aShape	| col |	col := aShape isFixed 		ifTrue: [ fixedShapes ]		ifFalse: [ shapes ].	col 		remove: aShape;		addFirst: aShape.! !!TSCanvas methodsFor: 'actions'!pushFront: aShape	| col |	col := aShape isFixed 		ifTrue: [ fixedShapes ]		ifFalse: [ shapes ].	col 		remove: aShape;		addLast: aShape.! !!TSCanvas methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!TSCanvas methodsFor: 'adding removing shapes'!removeFixedShape: aShape	fixedShapes remove: aShape! !!TSCanvas methodsFor: 'adding removing shapes'!removeShape: shape	| evt |	shapes remove: shape ifAbsent: [ self removeFixedShape: shape ].	shape parent: nil.	evt := TSShapeRemovedEvent new shape: shape.	self announce: evt.	shape announce: evt.	! !!TSCanvas methodsFor: 'adding removing shapes'!setAsFixed: aShape	self		removeShape: aShape;		addFixedShape: aShape.	aShape isFixed: true.! !!TSCanvas methodsFor: 'accessing'!shapeWithAction: eventClass forPositionInPixels: position	"position is in pixel, it corresponds to the physical location in the window.	e.g., 0 @ 0 is top left of the window"	| block |	block := [ :list :pos| 		list reverseDo: [ :s | | shape |			shape := s shapeWithAction: eventClass forPosition: pos.			shape ifNotNil: [ ^ shape ] ] ].	block value: fixedShapes value: position.	block value: shapes value: (self camera fromPixelToSpace: position).	^ self! !!TSCanvas methodsFor: 'accessing'!shapeWithActionForPositionInPixels: position	"position is in pixel, it corresponds to the physical location in the window.	e.g., 0 @ 0 is top left of the window"	| block |	block := [ :list :pos |		list reverseDo: [ :s | | shape |			shape := s shapeWithActionForPosition: pos.			shape ifNotNil: [^ shape ] ] ].	block value: fixedShapes value: position.	block value: shapes value: (self camera fromPixelToSpace: position).	^ self	! !!TSCanvas methodsFor: 'accessing'!shapes	^shapes! !!TSCanvas methodsFor: 'actions'!showEncompassingRectangles	showRectangles := true.! !!TSCanvas methodsFor: 'testing'!showRectangles	^ showRectangles! !!TSCanvas methodsFor: 'updating'!signalUpdate	morph changed! !!TSCanvas methodsFor: 'animations'!tAnimation 	^ TSTransitionAnimation new.! !!TSCanvas methodsFor: 'accessing'!topParent	^ self! !!TSCanvas methodsFor: 'accessing'!view	^ view! !!TSCanvas methodsFor: 'accessing'!view: aRSView	view := aRSView! !!TSCanvas methodsFor: 'events'!when: event do: aBlock	self announcer when: event do: aBlock! !!TSCanvas methodsFor: 'actions'!zoomToFit	self camera zoomToFit: self extent * 0.9! !!TSAthensRenderer methodsFor: 'utilities'!applyRadius: radius on: controlPoints from: start to: end	"based on https://riptutorial.com/html5-canvas/example/18766/render-a-rounded-polygon-"	| cp p1 p2 p3 arc v1 len1 a1 v2 len2 a2 sinA sin90 	angle radDir drawDir halfAngle cRadius lenOut p a b len |	cp := controlPoints.	len := cp size.	p1 := p2 := p3 := nil.	arc := [ 		v1 := p1 - p2.		len1 := ((v1 x * v1 x) + (v1 y * v1 y)) sqrt.		v1 := v1 / len1.		a1 := v1 angle.				v2 := p3 - p2.		len2 := ((v2 x * v2 x) + (v2 y * v2 y)) sqrt.		v2 := v2 / len2.		a2 := v2 angle.					sinA := (v1 x * v2 y) - (v1 y * v2 x).		sin90 := (v1 x * v2 x) - (v1 y * v2 y negated).		angle := sinA arcSin.		radDir := 1.		drawDir := false.		sin90 < 0 ifTrue: [ 			angle < 0 ifTrue: [ 				angle := angle + Float pi ]			ifFalse: [ 				angle := angle - Float pi.				radDir := -1.				drawDir := true ] ]		ifFalse: [ 			angle > 0 ifTrue: [ 				radDir := -1.				drawDir := true. ] ].		halfAngle := angle / 2.		sinA :=  halfAngle sin.		lenOut := (halfAngle cos * radius/ sinA) abs.		cRadius := radius.		lenOut > ((len1 / 2) min: (len2 / 2)) ifTrue: [ 			lenOut := (len1 / 2) min: (len2 / 2).			cRadius := (lenOut * halfAngle tan) abs.			].		p := p2 + (v2 * lenOut) + (v2 y negated@ v2 x * cRadius * radDir).		a := a1 + (Float halfPi * radDir).		b := a2 - (Float halfPi * radDir). 		builder 			arcAround: p			radius: cRadius			startAngle: a			endAngle: b			cw: drawDir. ].	start to: end do: [ :i |		p1 := cp at: (i)%len + 1.		p2 := cp at: (i + 1)%len + 1.		p3 := cp at: (i + 2)%len + 1.		(p1 = p2 or: [p2 = p3]) ifFalse: [ arc value ] ].	! !!TSAthensRenderer methodsFor: 'utilities'!arcCornerTangets: p0 p1: p1 r: r1 rc: rc cw: cw	| x01 y01 lo ox oy x1 y1 x2 y2 x3 y3 dx dy d2 r d D cx0 cy0 cx1 cy1 dx0 dy0 dx1 dy1 |	x01 := p0 x - p1 x.	y01 := p0 y - p1 y.	lo := (cw ifTrue:[rc ] ifFalse: [ rc negated ]) / ((x01 * x01) + (y01*y01)) sqrt.	ox := lo * y01.	oy := lo negated * x01.	x1 := p0 x + ox.	y1 := p0 y + oy.	x2 := p1 x + ox.	y2 := p1 y + oy.	x3 := (x1 + x2)/2.	y3 := (y1 + y2)/2.	dx := x2 - x1.	dy := y2 - y1.	d2 := (dx * dx) + (dy * dy).	r := r1 - rc.	D := (x1 * y2) - (x2 * y1).	d := (dy < 0 ifTrue: [ -1 ] ifFalse: [ 1 ]) * (0 max: ((r*r *d2) - (D * D) ) ) sqrt.	cx0 := ((D * dy) - (dx * d)) / d2.	cy0 := ( (D negated * dx) - (dy * d) ) / d2.	cx1 := ((D * dy) + (dx * d)) / d2.	cy1 := ( (D negated * dx) + (dy * d) ) / d2.	dx0 := cx0 - x3.	dy0 := cy0 - y3.	dx1 := cx1 - x3.	dy1 := cy1 - y3.	((dx0 * dx0) + (dy0 * dy0)) > ((dx1 * dx1) + (dy1 * dy1)) ifTrue: [ 		cx0 := cx1.		cy0 := cy1 ].	^  (cx0 - ox)@ (cy0 - oy) negated -> ((cx0 * r1 / r)@(cy0 * r1/r) negated).! !!TSAthensRenderer methodsFor: 'utilities'!arcSweep: p1 and: p2	^ ((p1 x - p2 x)* p1 y) - ((p1 y - p2 y) * p1 x) > 0		ifTrue: [ 1 ] 		ifFalse: [ 0 ]! !!TSAthensRenderer methodsFor: 'utilities'!asin: x	^ x >= 1	ifTrue: [ 1.5707963267948966 ]	ifFalse: [ x <= -1		ifTrue: [ -1.5707963267948966 ]		ifFalse: [ x arcSin ] ].	! !!TSAthensRenderer methodsFor: 'creating path'!buildBezierPath: bezier	| points |	points := bezier controlPoints.	points size = 2 ifTrue: [ 		builder 			absolute; 			moveTo: points first; 			lineTo: points second.		^ self ].	points size = 3 ifTrue: [ 		builder 			absolute; 			moveTo: points first; 			curveVia: points second 				to: points third.		^ self ].	points size = 4 ifTrue: [ 		builder			absolute; 			moveTo: points first; 			curveVia: points second 				and: points third 				to: points fourth  ].	! !!TSAthensRenderer methodsFor: 'creating path'!buildBoxPath: box	| rectangle simple corner |	rectangle := box baseRectangle.	simple := [ 		builder			absolute;			moveTo: rectangle topLeft;			lineTo: rectangle topRight;			lineTo: rectangle bottomRight;			lineTo: rectangle bottomLeft;			lineTo: rectangle topLeft;			closePath ].	corner := [ 		| c |		c := box cornerRadius.		builder			absolute;			moveTo: rectangle topLeft + (c topLeft@0);			lineTo: rectangle topRight - (c topRight@0);			cwArcTo: rectangle topRight + (0@c topRight) angle: Float halfPi;			lineTo: rectangle bottomRight- (0 @ c bottomRight);			cwArcTo: rectangle bottomRight - (c bottomRight @ 0) angle: Float halfPi;			lineTo: rectangle bottomLeft + (c bottomLeft @ 0);			cwArcTo: rectangle bottomLeft - (0@ c bottomLeft) angle: Float halfPi;			lineTo: rectangle topLeft + (0@ c topLeft);			cwArcTo: rectangle topLeft + (c topLeft@0) angle: Float halfPi;			closePath		 ].	box hasCornerRadius 		ifTrue: corner		ifFalse: simple	! !!TSAthensRenderer methodsFor: 'creating path'!buildEllipsePath: ellipse	| extent halfWidth halfHeight |	extent := ellipse extent.	halfWidth := extent x / 2 asFloat.	halfHeight := extent y / 2 asFloat.		builder		absolute;		moveTo: 0@0;		relative;		moveTo: halfWidth negated @ 0;		curveVia: 0 @ (halfHeight negated * 0.55)			and: (0.45 * halfWidth) @ halfHeight negated			to: halfWidth @ halfHeight negated;		curveVia: (halfWidth * 0.55) @ 0			and: halfWidth @ (0.45 * halfHeight)			to: halfWidth @ halfHeight;		curveVia: 0 @ (halfHeight * 0.55)			and: (0.45 * halfWidth negated) @ halfHeight			to: halfWidth negated @ halfHeight;		curveVia: (halfWidth negated * 0.55) @ 0			and: halfWidth negated @ (halfHeight negated * 0.45)			to: halfWidth negated @ halfHeight negated.	! !!TSAthensRenderer methodsFor: 'creating path'!buildLinePath: line	builder		absolute;		moveTo: line startPoint;		lineTo: line endPoint.! !!TSAthensRenderer methodsFor: 'creating path'!buildPolygonPath: polygon	| first radius cp |	builder absolute.	radius := polygon cornerRadii.	cp := polygon points.	[	(radius ~= 0 and: [ cp size > 2 ]) ifTrue: [ 		builder moveTo: (cp first + cp second) /2.		self applyRadius: radius on: cp from: 0 to: cp size-1.		^ self ].	first := true.	cp do: [ :point |		first ifTrue: [ 			first := false.			builder moveTo: point ]		ifFalse: [ 			builder lineTo: point ] ].	] ensure: [ builder closePath. ].			! !!TSAthensRenderer methodsFor: 'creating path'!buildPolyinePath: line	| first cp radius |	builder absolute.	cp := line controlPoints.	radius := line cornerRadii.	(radius ~= 0 and: [ cp size > 2 ]) ifTrue: [ 		builder moveTo: cp first.		self applyRadius: radius on: cp from: 0 to: cp size - 3.		builder lineTo: cp last.		^ self ].	first := true.	cp do: [ :point | 		first ifTrue: [ 			first := false.			builder moveTo: point ]		ifFalse: [ 			builder lineTo: point ] ]! !!TSAthensRenderer methodsFor: 'creating path'!buildRingPath: ring	| aAngle bAngle xAngle i e center ap epsilon aAngle2 bAngle2 rp da da0 da1 rc x1 x2 x3 x4 y1 y2 y3 y4 rc0 rc1 t41 t23  t14 t32 |	epsilon := 1e-12.	ap := (ring segmentSpacing / 2) degreesToRadians.	aAngle := ring alphaAngle degreesToRadians.	bAngle := ring betaAngle degreesToRadians.	da := da0 := da1 := (aAngle - bAngle) abs.	aAngle2 := aAngle.	bAngle2 := bAngle.	center := 0@0.	i := ring innerRadius asFloat.	e := ring externalRadius.		builder absolute.	"is it a point? "	e < epsilon ifTrue: [ ^ builder  moveTo: center ].		"or is a circle? "	da0 > (Float pi * 2 - epsilon) ifTrue: [ 		builder 			moveTo: ((e * aAngle cos)@( e * aAngle sin negated)) + center ;			arcAround: center radius: e startAngle: aAngle endAngle: bAngle.		i > epsilon ifTrue: [ 			builder				moveTo: (i * (aAngle cos @ aAngle sin negated) )+ center ;				arcAround: center radius: i startAngle: aAngle endAngle: bAngle ].		builder close.		^ self ]. 	"circle part"	xAngle := (aAngle + bAngle)/2.	rp := ((i*i) + (e*e)) sqrt.	"apply padding"	rp > epsilon ifTrue: [ | p0 p1 |		p0 := i isZero 			ifTrue: [ self asin: Float infinity ]			ifFalse: [ self asin: (rp / i * ap sin) ].		p1 := self asin: (rp / e * ap sin).		da0 := da0 - (p0*2).		da0 > epsilon			ifTrue: [ aAngle2 := aAngle2 + p0. bAngle2 := bAngle - p0 ] 				ifFalse: [ aAngle2 := bAngle2 := (aAngle + bAngle)/2. ].		da1 := da1 - (p1*2).		da1 > epsilon			ifTrue: [ aAngle := aAngle + p1. bAngle := bAngle - p1 ]			ifFalse: [ aAngle := bAngle := xAngle] ].	x1 := e*aAngle cos.	y1 := e*aAngle sin.	x2 := e*bAngle cos.	y2 := e*bAngle sin.	x4 := i*aAngle2 cos.	y4 := i*aAngle2 sin.	x3 := i*bAngle2 cos.	y3 := i*bAngle2 sin.		"is it small circle part?"	(aAngle - bAngle) abs < 0.001 ifTrue: [ 		builder 			moveTo: (x3@y3) + center;"			lineTo: (x2@y2) + center;"			close.		^ self ].	"apply corner radius"	rc := ((i -e) abs /2) min: ring cornerRadii.	rc0 := rc1 := rc.	(da > epsilon and: [ rc > 0.001 ]) ifTrue: [ 			da < Float pi ifTrue: [ 			| oc ax ay bx by kc lc |			oc := self geomPolygonIntersectC: x1@y1 d: x4@y4 a: x2@y2  b: x3@y3.			ax := x1 - oc x.			ay := y1 - oc y.			bx := x2 - oc x.			by := y2 - oc y.			kc := 1 / (( ((ax*bx) + (ay*by)) /  ( ((ax*ax)+ (ay*ay)) sqrt * ( (bx*bx)+(by*by) ) sqrt ) ) arcCos / 2) sin.			lc := ((oc x * oc x) + (oc y*oc y)) sqrt.			rc0 := rc0 min: ((e - lc) / (kc + 1)).			rc1 := rc1 min: ((i - lc) / (kc - 1)).			].		].	t41 := self arcCornerTangets: x4@y4 p1: x1@y1 r: e rc: rc0 cw: true.	t23 := self arcCornerTangets: x2@y2 p1: x3@y3 r: e rc: rc0 cw: true.	builder moveTo: t41 key + center.	rc0 == rc ifTrue: [ 		builder 			ellipticalArc2: rc0@rc0 				xrot: 0				large: 0				sweep: 0				to: t41 value + center;			ellipticalArc2: e@e				xrot: 0				large: (self arcSweep: t41 value and: t23 value)				sweep: 0				to: t23 value + center;			ellipticalArc2: rc0@rc0				xrot: 0				large: 0				sweep: 0				to: t23 key + center.			 ]	ifFalse: [ 		builder 			ellipticalArc2: rc0@rc0 				xrot: 0 				large: 1 				sweep: 0				to: t23 key + center ].		(x4 isZero & y4 isZero) ifTrue: [ 		builder lineTo: center. ]	ifFalse: [ 		t14 := self arcCornerTangets: x1@y1 p1: x4@y4 r: i rc: rc1 negated cw: true.		t32 := self arcCornerTangets: x3@y3 p1: x2@y2 r: i rc: rc1 negated cw: true.		builder lineTo: t32 key + center.		(rc == rc1 and: [da0 > 0 ]) ifTrue: [ 			builder 				ellipticalArc2: rc1@ rc1					xrot: 0					large: 0					sweep: 0					to: t32 value + center;				ellipticalArc2: i@i					xrot: 0					large: (self arcSweep: t14 value and: t32 value) 					sweep: 1					to: t14 value + center;				ellipticalArc2: rc1@rc1					xrot: 0					large: 0					sweep: 0					to: t14 key + center		] ifFalse: [ 			builder 				ellipticalArc2: rc1@ rc1					xrot: 0					large: 0					sweep: 0					to: t14 key + center	 	] ] .	builder close.! !!TSAthensRenderer methodsFor: 'creating path'!buildSVGLinePath: line	| string |	string := line svgPath value: line startPoint value: line endPoint.		string isString ifTrue: [ | converter |		converter := ASPathConverter new stream: string readStream.		converter convertPathData do: [ :each | 			builder 				perform: each first 				withArguments: each second ]	] ifFalse: [		string value: builder.	].	! !!TSAthensRenderer methodsFor: 'creating path'!buildSVGPath: svg	svg segments ifNil: [ ^ self ].	svg segments		do: [ :each | builder perform: each first withArguments: each second ]! !!TSAthensRenderer methodsFor: 'accessing'!builder	^ builder! !!TSAthensRenderer methodsFor: 'utilities'!geomPolygonIntersectC: c d: d a: a b: b	| x1 x3 x21 x43 y1 y3 y21 y43 ua |	x1 := c x.	x3 := a x.	x21 := d x - x1.	x43 := b x - x3.	y1 := c y.	y3 := a y.	y21 := d y - y1.	y43 := b y - y3.	ua := ((x43 *  (y1 - y3)) - (y43 * (x1 - x3))) / ((y43 * x21) - (x43 * y21 )).	^ (x1 + (ua * x21))@	(y1 +(ua * y21))! !!TSAthensRenderer methodsFor: 'creating path'!getOrCreatePathOf: shape	| path |	path := shape path.	path ifNotNil: [ ^ path ].	path ifNil: [ 		path := athensCanvas			createPath: [ :pathBuilder |				builder := pathBuilder.				shape buildPathOn: self ].		builder := nil.		shape path: path ].	^ path! !!TSAthensRenderer methodsFor: 'paint'!paintForBitmap: shape	| paint |	^ CairoBackendCache soleInstance 		at: shape form		ifAbsentPut: [ 			paint := (AthensCairoPatternSurfacePaint 				createForSurface: (AthensCairoSurface 				fromForm: shape form)).			paint origin: (shape form extent /2) negated asFloatPoint.			paint  ]! !!TSAthensRenderer methodsFor: 'visiting'!visitBorder: border	| stroke style |	stroke := athensCanvas setStrokePaint: border paint.	stroke width: border width asFloat.	style := border style.	style ifNil: [ ^ stroke ].	style dashArray 		ifNotNil: [ :a | stroke dashes: a offset: style dashOffset ].	style capStyle		ifNotNil: [:s | stroke perform: s].	style joinStyle		ifNotNil: [:s | stroke perform: s].	^ stroke.	! !!TSAthensRenderer methodsFor: 'visiting - helpers'!visitBorderIfNecessary: shape	shape hasBorder ifFalse: [ ^ self ].	athensCanvas setShape: shape path.	shape border accept: self.	athensCanvas draw.! !!TSAthensRenderer methodsFor: 'visiting'!visitBoundingShape: shape	| path paint |	path := self getOrCreatePathOf: shape.	athensCanvas pathTransform restoreAfter: [ 		athensCanvas pathTransform			multiplyBy: shape matrix asFloatTransform.		paint := shape paintOn: self.		paint ifNotNil: [ 			athensCanvas 				fillRuleEvenOdd;				setPaint: paint;				drawShape: path ].		self visitBorderIfNecessary: shape.		shape shapes ifNotNil: [ 			shape shapes do: [ :s |				s accept: self ] ]		].	! !!TSAthensRenderer methodsFor: 'visiting'!visitLabel: label	athensCanvas pathTransform restoreAfter: [ 		| utf8String act f stroke |		athensCanvas pathTransform			multiplyBy: label matrix asFloatTransform;			translateBy: ((label textWidth / -2) @ (label textHeight / 2)) asFloatPoint;			translateBy: (0 @ label descent negated) asFloatPoint.					utf8String := label path.			utf8String ifNil: [ 				act := AthensCairoText new.				utf8String := act convertTextUtf8: label text.				label path: utf8String.			 ].			f := CairoScaledFont fromFreetypeFont: label font realFont.						athensCanvas newPath.			f lock.			athensCanvas 				setPathMatrix;				setScaledFont: f.			label paint ifNotNil: [ 				(label paint asAthensPaintOn: athensCanvas)"					setMatrix: athensCanvas paintTransform inverted;"					loadOnCairoCanvas: athensCanvas. ].			athensCanvas textPath: utf8String.			label paint ifNotNil: [ athensCanvas fillPreserve ].			label hasBorder ifTrue: [ 				label border paint loadOnCairoCanvas: athensCanvas.				stroke := label border accept: self.				stroke prepareForDrawingOn: athensCanvas.				athensCanvas stroke.			 ].			f unlock.		].	! !!TSAthensRenderer methodsFor: 'visiting'!visitLine: line	| path paint |	athensCanvas pathTransform restoreAfter: [ 		path := self getOrCreatePathOf: line.		paint := line paintOn: self.		paint ifNotNil: [ 			athensCanvas				setPaint: paint;				drawShape: path ].		self visitBorderIfNecessary: line.		self visitMarkersIfNecessary: line.		].! !!TSAthensRenderer methodsFor: 'visiting - helpers'!visitMarker: marker to: from vector: vector	| shape angle pos |	shape := marker shape.	angle := vector angle + Float halfPi.	pos := from.	shape matrix		loadIdentity;		rotateByRadians: angle.	(marker offset isZero and: [ marker offsetRatio isZero ]) ifFalse: [ 		| unit |		unit := vector / (vector r max: 1).		pos := pos -(vector * marker offsetRatio) - (unit * marker offset)		 ].	shape		position: pos;		accept: self.! !!TSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkerEnd: marker with: controlPoints	| from to |	marker ifNil: [ ^ self ].	from := controlPoints at: controlPoints size - 1.	to := controlPoints last.	self visitMarker: marker to: to vector: to-from. ! !!TSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkerMid: marker with: controlPoints	marker ifNil: [ ^ self ].	controlPoints size < 3 ifTrue: [ ^ self ].	1 to: controlPoints size -2 do: [ :i | | a b |		a := controlPoints at: i.		b := controlPoints at: i + 1.		self visitMarker: marker to: b vector: b - a. 	 ].	! !!TSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkerStart: marker with: controlPoints	| from to |	marker ifNil: [ ^ self ].	from := controlPoints first.	to := controlPoints second.	self visitMarker: marker to: from vector: from - to. ! !!TSAthensRenderer methodsFor: 'visiting - helpers'!visitMarkersIfNecessary: line	| cp |	line hasMarkers ifFalse: [ ^ self ].	cp := line controlPoints.	self visitMarkerStart: line markerStart with: cp.	self visitMarkerMid: line markerMid with: cp.	self visitMarkerEnd: line markerEnd with: cp.! !!TSRenderer methodsFor: 'accessing'!canvas	^ athensCanvas ! !!TSRenderer methodsFor: 'accessing'!canvas: aCanvas	"aCanvas is AthensCanvas"	athensCanvas := aCanvas! !!Announcer methodsFor: '*Roassal3-Trachel'!handleEventClass: eventClass	"Return true if the receiver has a callback subscripbed for the event class"	^ self subscriptions handleEventClass: eventClass! !!TSEvent methodsFor: 'accessing'!canvas	^ canvas ifNil: [ canvas := shape canvas ].! !!TSEvent methodsFor: 'accessing'!canvas: aTrachelCanvas	"Set the Trachel canvas"	canvas := aTrachelCanvas! !!TSEvent methodsFor: 'accessing'!morph	^ morph ifNil: [ ^ morph := self canvas morph ]! !!TSEvent methodsFor: 'accessing'!morph: aMorph	morph := aMorph! !!TSEvent methodsFor: 'accessing'!shape	^ shape! !!TSEvent methodsFor: 'accessing'!shape: aTrachelShape	shape := aTrachelShape! !!TSEvent methodsFor: 'accessing'!signalUpdate	morph notNil ifTrue: [ morph changed ]	! !!TSExtentChangedEvent methodsFor: 'accessing'!newExtent	^ newExtent! !!TSExtentChangedEvent methodsFor: 'accessing'!newExtent: anObject	newExtent := anObject! !!TSExtentChangedEvent methodsFor: 'accessing'!oldExtent	^ oldExtent! !!TSExtentChangedEvent methodsFor: 'accessing'!oldExtent: anExtent	oldExtent := anExtent! !!TSPositionChangedEvent methodsFor: 'accessing'!newPosition	^ newPosition! !!TSPositionChangedEvent methodsFor: 'accessing'!newPosition: anObject	newPosition := anObject! !!TSPositionChangedEvent methodsFor: 'accessing'!oldPosition	^ oldPosition! !!TSPositionChangedEvent methodsFor: 'accessing'!oldPosition: anObject	oldPosition := anObject! !!TSShapeEvent methodsFor: 'accessing'!position 	^ position ifNil: [ self shape position ]! !!TSShapeEvent methodsFor: 'accessing'!position: anObject	position := anObject ! !!TSShapeEvent methodsFor: 'accessing'!positionFromCamera	"Return the position from the camera. I.e., 0 @ 0 is at the center of the window if the camera has not been translated"	^ canvas 		ifNotNil: [ canvas camera fromPixelToSpace: self position ]		ifNil: [ -250 @ -250 ]! !!TSAbstractMouseEvent methodsFor: 'testing'!isPositionAboveShape	^ shape encompassingRectangle containsPoint: self positionFromCamera! !!TSMouseDragging class methodsFor: 'instance creation'!step: aStepAsPoint	^ self new step: aStepAsPoint! !!TSMouseDragging methodsFor: 'initialize - release'!initialize	super initialize.	step := 0 @ 0.! !!TSMouseDragging methodsFor: 'accessing'!step	^ step! !!TSMouseDragging methodsFor: 'accessing'!step: aPoint	step := aPoint! !!TSMouseWheelEvent methodsFor: 'accessing'!direction	^ direction! !!TSMouseWheelEvent methodsFor: 'accessing'!direction: anObject	direction := anObject! !!TSMouseWheelEvent methodsFor: 'testing'!isDown	^ direction = Character arrowDown! !!TSMouseWheelEvent methodsFor: 'testing'!isLeft	^ direction = Character arrowLeft! !!TSMouseWheelEvent methodsFor: 'testing'!isRight	^ direction = Character arrowRight! !!TSMouseWheelEvent methodsFor: 'testing'!isUp	^ direction = Character arrowUp! !!TSKeyboardEvent methodsFor: 'comparing'!= anotherKeyDown	"Do we really need this method? It has been imported from Roassal1"	(self class == anotherKeyDown) ifFalse: [  ^ false ].	^ self keyValue = anotherKeyDown keyValue! !!TSKeyboardEvent methodsFor: 'initialize'!initialize	super initialize.	keyValue := 0! !!TSKeyboardEvent methodsFor: 'accessing'!keyCombination	^ keyCombination! !!TSKeyboardEvent methodsFor: 'accessing'!keyCombination: anObject	keyCombination := anObject! !!TSKeyboardEvent methodsFor: 'accessing'!keyValue	^ keyValue! !!TSKeyboardEvent methodsFor: 'accessing'!keyValue: anObject	keyValue := anObject! !!TSUserInputEvent class methodsFor: 'instance creation'!fromEvent: aUserInputEvent	^ self new		commandKeyPressed: aUserInputEvent commandKeyPressed;		controlKeyPressed: aUserInputEvent controlKeyPressed;		shiftKeyPressed: aUserInputEvent shiftPressed;		optionKeyPressed: aUserInputEvent optionKeyPressed;		yourself! !!TSUserInputEvent methodsFor: 'modifier state'!altKeyPressed	"Answer true if the alt/option key on the keyboard was being held down when this event occurred."	^ self optionKeyPressed! !!TSUserInputEvent methodsFor: 'modifier state'!anyModifierKeyPressed	"Answer true if command, option/alt or control key on the keyboard was being held down when this event occurred. Ignores shift key."	^ self commandKeyPressed or: [ self optionKeyPressed or: [ self controlKeyPressed ] ]! !!TSUserInputEvent methodsFor: 'modifier state'!commandKeyPressed	"Answer true if the command key on the keyboard was being held down when this event occurred."	^ commandKeyPressed! !!TSUserInputEvent methodsFor: 'private - accessing'!commandKeyPressed: aBoolean	commandKeyPressed := aBoolean! !!TSUserInputEvent methodsFor: 'modifier state'!controlKeyPressed	"Answer true if the control key on the keyboard was being held down when this event occurred."	^ controlKeyPressed! !!TSUserInputEvent methodsFor: 'private - accessing'!controlKeyPressed: aBoolean	controlKeyPressed := aBoolean! !!TSUserInputEvent methodsFor: 'initialization'!initialize	super initialize.	commandKeyPressed := false.	controlKeyPressed := false.	optionKeyPressed := false.	shiftKeyPressed := false! !!TSUserInputEvent methodsFor: 'private - accessing'!modifiers: modifiers	commandKeyPressed := modifiers anyMask: 2r01000000.	controlKeyPressed := modifiers anyMask: 2r00010000.	optionKeyPressed := modifiers anyMask: 2r00100000.	shiftKeyPressed := modifiers anyMask: 2r00001000! !!TSUserInputEvent methodsFor: 'modifier state'!optionKeyPressed	"Answer true if the alt/option key on the keyboard was being held down when this event occurred."	^ optionKeyPressed! !!TSUserInputEvent methodsFor: 'private - accessing'!optionKeyPressed: aBoolean	optionKeyPressed := aBoolean! !!TSUserInputEvent methodsFor: 'modifier state'!shiftKeyPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred"	^ shiftKeyPressed! !!TSUserInputEvent methodsFor: 'private - accessing'!shiftKeyPressed: aBoolean	shiftKeyPressed := aBoolean! !!TSUserInputEvent methodsFor: 'modifier state'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred.	This method is here for Morphic compatibility"	^ self shiftKeyPressed! !!SubscriptionRegistry methodsFor: '*Roassal3-Trachel'!handleEventClass: eventClass	"Return true if the receiver has a callback subscripbed for the event class"	^ subscriptions anySatisfy: [ :sub | 		(sub announcementClass == eventClass) or: 			[ sub announcementClass inheritsFrom: eventClass ] ]! !!AthensCairoSurface methodsFor: '*Roassal3-Trachel'!hasBeenFreed	"Return true if the external resource has been freed"	^ handle isNull! !!AthensAffineTransform methodsFor: '*Roassal3-Trachel'!asFloatTransform	^ self copy floatValues; yourself	! !!AthensAffineTransform methodsFor: '*Roassal3-Trachel'!floatValues	"convert all the values to float"	x := x asFloat.	y := y asFloat.	sx := sx asFloat.	sy := sy asFloat.	shx := shx asFloat.	shy := shy asFloat.		! !!TSAthensMorph methodsFor: 'accessing'!canvas	^ trachelCanvas! !!TSAthensMorph methodsFor: 'accessing'!canvas: aTrachelCanvas	trachelCanvas := aTrachelCanvas! !!TSAthensMorph methodsFor: 'session management'!checkSession	session == Smalltalk session ifTrue: [ ^ self ].	surface := nil.	trachelCanvas shapes do: [ :s | s path: nil ].	trachelCanvas fixedShapes do: [ :s | s path: nil ].	self createSurface! !!TSAthensMorph methodsFor: 'surface management'!createSurface	surface := AthensCairoSurface extent: self extent asIntegerPoint.	session := Smalltalk session.! !!TSAthensMorph methodsFor: 'drawing'!drawOn: aCanvas	isDrawing ifTrue: [ ^ self ].	isDrawing := true.	self checkSession.	self recreateSurfaceIfNecessary.	aCanvas fillRectangle: bounds color: trachelCanvas color.	trachelCanvas playAnimations.	self drawShapes.	surface hasBeenFreed		ifTrue: [ self createSurface ].	[ aCanvas		image: surface asForm		at: self bounds origin asIntegerPoint		sourceRect: (0 @ 0 extent: surface extent)		rule: 34 ]		on: Exception		do: [ :ex |  ].	isDrawing := false! !!TSAthensMorph methodsFor: 'drawing'!drawOnMockCanvas	"This method is used to trigger all the rendering in a temporary FormCanvas. This method is useful when a bug happens when rendering. Such situation are difficult to debug to the multi-threading and low level graphical primitive. The method #drawOnMockCanvas helps addressing this.Here is an example:v := RTView new.es := RTBox elementsOn: (1 to: 10).v addAll: es.RTGridLayout on: es.v canvas buildMorph drawOnMockCanvas	"	self drawOn: (FormCanvas extent: self extent)! !!TSAthensMorph methodsFor: 'drawing'!drawShapes	"The drawing has to be done when a change in the shapes occured or when there is an animation."	surface drawDuring: [ :athensCanvas | 		trachelCanvas clearBackground			ifTrue: [ surface clear ].		"We display the elements that are subject to the camera"		athensCanvas pathTransform			translateBy: (self extent / 2) asFloatPoint;			scaleBy: trachelCanvas camera scale asFloat;			translateBy: trachelCanvas camera position negated asFloatPoint.		renderer canvas: athensCanvas.					trachelCanvas shapes do: [ :trachelShape | 			trachelShape accept: renderer.			self showRectangleIfNecessary: trachelShape.		 ].		"We display the elements that are _NOT_ subject to the camera"		athensCanvas pathTransform loadIdentity scaleBy: 1.0001.		trachelCanvas fixedShapes do: [ :trachelShape | 			trachelShape accept: renderer.			self showRectangleIfNecessary: trachelShape. ] ]		! !!TSAthensMorph methodsFor: 'event-processed'!eventOfClass: anEventClass actionClass: anActionClass from: aMorphicEvent	| relativePosition trEvent shape |	relativePosition := self relativePositionFor: aMorphicEvent.	shape := self shapeWithAction: anActionClass forPositionInPixels: relativePosition. 		trEvent := anEventClass fromEvent: aMorphicEvent.	trEvent		morph: self;		canvas: trachelCanvas;		shape: shape;		position: relativePosition.	^ trEvent! !!TSAthensMorph methodsFor: 'event-processed'!eventOfClass: anEventClass from: aMorphicEvent	^ self eventOfClass: anEventClass actionClass: anEventClass from: aMorphicEvent! !!TSAthensMorph methodsFor: 'event-processed'!eventOfClass: anEventClass shape: aShape from: aMorphicEvent	| relativePosition trEvent |	relativePosition := self relativePositionFor: aMorphicEvent.	trEvent := anEventClass fromEvent: aMorphicEvent.	trEvent		morph: self;		canvas: trachelCanvas;		shape: aShape;		position: relativePosition.	^ trEvent! !!TSAthensMorph methodsFor: 'events-processing'!handleKeyUp: anEvent	super handleKeyUp: anEvent.	self trKeyUp: anEvent! !!TSAthensMorph methodsFor: 'event handling'!handleKeystroke: anEvent	self trKeyDown: anEvent.! !!TSAthensMorph methodsFor: 'events-processing'!handleMouseMove: anEvent	super handleMouseMove: anEvent.	anEvent anyButtonPressed ifFalse: [ self trMouseMove: anEvent ].		! !!TSAthensMorph methodsFor: 'events-processing'!handleMouseOver: aMorphicEvent	| currentElement trEvent |	super handleMouseOver: aMorphicEvent.	aMorphicEvent wasHandled		ifTrue: [ ^ self ].	"Do nothing if it was already handled"	self isDragging		ifTrue: [ ^ self ].	"Do nothing if we are dragging"	shapeBeingPointed ifNil: [ shapeBeingPointed := self shapeForEvent: aMorphicEvent ].	currentElement := self shapeForEvent: aMorphicEvent.	currentElement == shapeBeingPointed		ifTrue: [ ^ self ].	trEvent := self eventOfClass: TSMouseLeave from: aMorphicEvent.	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.	shapeBeingPointed := currentElement.	self trMouseEnter: aMorphicEvent! !!TSAthensMorph methodsFor: 'testing'!handlesKeyboard: evt	^true! !!TSAthensMorph methodsFor: 'event handling'!handlesMouseDown: anEvent	^ anEvent wasHandled not	"not interested if handled"! !!TSAthensMorph methodsFor: 'event handling'!handlesMouseOver: evt	^ true! !!TSAthensMorph methodsFor: 'events-processing'!handlesMouseWheel: evt	^true! !!TSAthensMorph methodsFor: 'event handling'!hasFocus	^ true! !!TSAthensMorph methodsFor: 'initialization'!initialize	super initialize.	self createSurface.	session := Smalltalk session.	isDrawing := false! !!TSAthensMorph methodsFor: 'testing'!isDragging	^ eventBeginingDragging notNil! !!TSAthensMorph methodsFor: 'accessing'!isDrawing	^ isDrawing! !!TSAthensMorph methodsFor: 'initialization'!layoutChanged	"react on morph resize"	super layoutChanged.	self checkSession.	! !!TSAthensMorph methodsFor: 'event handling'!mouseDown: evt	eventBeginingDragging		ifNil:			[ evt hand				waitForClicksOrDrag: self				event: evt				selectors: {#trMouseClick:. #trMouseDoubleClick:. nil. #trMouseDragStart:. }				threshold: 5.			^ self ].	evt anyButtonPressed		ifTrue: [ self trMouseDragging: evt ].	evt wasHandled: true! !!TSAthensMorph methodsFor: 'event handling'!mouseEnter: evt	evt anyButtonPressed		ifFalse: [ self trMouseEnter: evt ].	evt wasHandled: true! !!TSAthensMorph methodsFor: 'event-processed'!mouseEventOfClass: defaultClass ifLeftButton: leftButtonClass ifRightButton: rightButtonClass from: aMorphicEvent	| trEventClass |	trEventClass := defaultClass.	aMorphicEvent redButtonChanged		ifTrue: [ trEventClass := leftButtonClass ].	aMorphicEvent yellowButtonChanged		ifTrue: [ trEventClass := rightButtonClass ].	^ self eventOfClass: trEventClass actionClass: defaultClass from: aMorphicEvent! !!TSAthensMorph methodsFor: 'event handling'!mouseLeave: evt	evt anyButtonPressed		ifFalse: [ self trMouseLeave: evt ].	evt wasHandled: true! !!TSAthensMorph methodsFor: 'event handling'!mouseMove: evt	evt anyButtonPressed		ifTrue: [ self trMouseDragging: evt ]		ifFalse: [ self trMouseMove: evt ].	evt wasHandled: true! !!TSAthensMorph methodsFor: 'event handling'!mouseUp: evt	self isDragging		ifTrue: [ self trMouseDragEnd: evt ]		ifFalse: [ self trMouseUp: evt ].	evt wasHandled: true! !!TSAthensMorph methodsFor: 'event handling'!mouseWheel: evt	self trMouseWheel: evt.	evt wasHandled: true! !!TSAthensMorph methodsFor: 'recategorized'!recreateSurfaceIfNecessary	surface		ifNotNil: [ self extent asIntegerPoint ~= surface extent				ifTrue: [ self createSurface.					trachelCanvas extent: self extent ] ]! !!TSAthensMorph methodsFor: 'events-roassal'!relativePositionFor: evt	^ evt position - self bounds origin! !!TSAthensMorph methodsFor: 'dependencies'!release	"This method is useful in case some references of TRMorph cannot be garbage collected, as it may happen with GT."	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!TSAthensMorph methodsFor: 'accessing'!renderer	^ renderer! !!TSAthensMorph methodsFor: 'accessing'!renderer: aRenderer	renderer := aRenderer! !!TSAthensMorph methodsFor: 'event-processed'!shapeForEvent: anEvent	"Return the Trachel shape for the event provided as argument"	^ self shapeWithActionForPositionInPixels: (self relativePositionFor: anEvent)! !!TSAthensMorph methodsFor: 'accessing'!shapeForPositionInPixels: point	"Return the shape located that contains point"	 ^ trachelCanvas shapeForPositionInPixels: point! !!TSAthensMorph methodsFor: 'accessing'!shapeWithAction: eventClass forPositionInPixels: position	"Return the shape with event handler located that contains point"	 ^ trachelCanvas shapeWithAction: eventClass forPositionInPixels: position! !!TSAthensMorph methodsFor: 'accessing'!shapeWithActionForPositionInPixels: point	"Return the shape with event handler located that contains point"	 ^ trachelCanvas shapeWithActionForPositionInPixels: point! !!TSAthensMorph methodsFor: 'drawing'!showRectangleIfNecessary: shape	| box rect |	trachelCanvas showRectangles ifFalse: [ ^ self ].	rect := shape encompassingRectangle.	box := TSBox new		position: rect rsCenter;		extent: rect extent;		color: (Color blue alpha: 0.2).	box accept: renderer.! !!TSAthensMorph methodsFor: 'signaling'!signalUpdate	self changed! !!TSAthensMorph methodsFor: 'signaling'!step	self wantsSteps ifFalse: [ ^ self ].	self changed! !!TSAthensMorph methodsFor: 'signaling'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ 20! !!TSAthensMorph methodsFor: 'accessing'!surface	^ surface! !!TSAthensMorph methodsFor: 'events-processing'!takesKeyboardFocus	^ true! !!TSAthensMorph methodsFor: 'event-processed'!trKeyDown: aMorphicEvent	| trEvent |	(aMorphicEvent commandKeyPressed and: [ aMorphicEvent keyCharacter = $w ])		ifTrue: [ self owner delete ].	trEvent := self eventOfClass: TSKeyDown from: aMorphicEvent.	trEvent		position: (trachelCanvas camera fromPixelToSpace: trEvent position);		keyValue: aMorphicEvent keyValue;		keyCombination: aMorphicEvent asKeyCombination.	trEvent shape announce: trEvent! !!TSAthensMorph methodsFor: 'event-processed'!trKeyUp: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: TSKeyUp from: aMorphicEvent.	trEvent		position: (trachelCanvas camera fromPixelToSpace: trEvent position);		keyValue: aMorphicEvent keyValue;		keyCombination: aMorphicEvent asKeyCombination.	trEvent shape announce: trEvent! !!TSAthensMorph methodsFor: 'event-processed'!trMouseClick: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: TSMouseClick		ifLeftButton: TSMouseLeftClick		ifRightButton: TSMouseRightClick		from: aMorphicEvent.	trEvent position: (trachelCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!TSAthensMorph methodsFor: 'event-processed'!trMouseDoubleClick: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: TSMouseDoubleClick		ifLeftButton: TSMouseDoubleLeftClick		ifRightButton: TSMouseDoubleRightClick		from: aMorphicEvent.	trEvent position: (trachelCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!TSAthensMorph methodsFor: 'event-processed'!trMouseDragEnd: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: TSMouseDragEnd from: aMorphicEvent.	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.		eventBeginingDragging := nil.	shapeBeingPointed := nil.! !!TSAthensMorph methodsFor: 'event-processed'!trMouseDragStart: aMorphicEvent	| trEvent trEventClass |	eventBeginingDragging := aMorphicEvent copy.		trEventClass := TSMouseDragStart.	aMorphicEvent redButtonChanged		ifTrue: [ trEventClass := TSMouseLeftDragStart ].	aMorphicEvent yellowButtonChanged		ifTrue: [ trEventClass := TSMouseRightDragStart ].	aMorphicEvent blueButtonChanged		ifTrue: [ trEventClass := TSMouseMiddleDragStart ].	trEvent := self eventOfClass: trEventClass actionClass: TSMouseDragging from: aMorphicEvent.	shapeBeingPointed := trEvent shape.	shapeBeingPointed announce: trEvent.	! !!TSAthensMorph methodsFor: 'event-processed'!trMouseDragging: aMorphicEvent	| trEvent step |	eventBeginingDragging ifNil: [ ^ self ].	step := aMorphicEvent position - eventBeginingDragging position.	trEvent := self eventOfClass: TSMouseDragging from: aMorphicEvent.	trEvent position: (trachelCanvas camera fromPixelToSpace: trEvent position).	trEvent step: step.	shapeBeingPointed ifNil: [ shapeBeingPointed := trEvent shape ].	"If the element was removed during the drag then cancel the event"	shapeBeingPointed parent ifNil: [		eventBeginingDragging := nil.		shapeBeingPointed := nil.		^ self ].	trEvent shape: shapeBeingPointed.	shapeBeingPointed announce: trEvent.	eventBeginingDragging := aMorphicEvent copy.	! !!TSAthensMorph methodsFor: 'event-processed'!trMouseEnter: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: TSMouseEnter from: aMorphicEvent.	trEvent shape announce: trEvent.! !!TSAthensMorph methodsFor: 'event-processed'!trMouseLeave: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: TSMouseLeave from: aMorphicEvent.	trEvent shape announce: trEvent.! !!TSAthensMorph methodsFor: 'event-processed'!trMouseMove: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: TSMouseMove from: aMorphicEvent.	trEvent position: (trachelCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!TSAthensMorph methodsFor: 'event-processed'!trMouseUp: aMorphicEvent	| trEvent |	trEvent := self		mouseEventOfClass: TSMouseUp		ifLeftButton: TSMouseUpLeft  		ifRightButton: TSMouseUpRight		from: aMorphicEvent.	trEvent position: (trachelCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!TSAthensMorph methodsFor: 'event-processed'!trMouseWheel: aMorphicEvent	| trEvent |	trEvent := self eventOfClass: TSMouseWheelEvent from: aMorphicEvent.	trEvent		direction: aMorphicEvent direction;		position: (trachelCanvas camera fromPixelToSpace: trEvent position).	trEvent shape announce: trEvent.! !!TSAthensMorph methodsFor: 'accessing'!trachelCanvas	^ trachelCanvas! !!TSAthensMorph methodsFor: 'testing'!wantsSteps	^ trachelCanvas hasAnimation ! !!TSAthensMorph methodsFor: 'event handling'!wouldAcceptKeyboardFocusUponTab	"Answer whether the receiver might accept keyboard focus if 	tab were hit in some container playfield"	^ true! !!Rectangle class methodsFor: '*Roassal3-Trachel'!rsCenter: centerPoint extent: extentPoint	"Answer an instance of me whose center is centerPoint and width 	by height is extentPoint.  "	^ self		origin: centerPoint - (extentPoint / 2.0)		extent: extentPoint asNonFractionalPoint! !!Rectangle methodsFor: '*Roassal3-Trachel'!rsCenter	^(origin + corner) / 2.0! !"Roassal3-Trachel"!!TSInterpolator commentStamp: '' prior: 0!I determine the correct interpolator for a kind of datamy subclasses CAColorInterpolatorRTNumberInterpolatorThe basic interpolation is between 2 values 0 and 1, usually the value between these values is called 't'!!TSAbstractInterpolator commentStamp: '' prior: 0!I have two ranges the start an the stop!!TSColorRGBAInterpolator commentStamp: '' prior: 0!I am the interpolator  for colors!!TSColorHSLAInterpolator commentStamp: '' prior: 0!reate a color with the given hue, saturation, lightness, and alpha.!!TSColorHSVAInterpolator commentStamp: '' prior: 0!Same as TSColorRGBAInterpolation but for hsva  !!TSNumberInterpolator commentStamp: '' prior: 0!I am the basic interpolator for numbers!!TSRoundInterpolator commentStamp: '' prior: 0!I am a interpolator to round numbers!!TSPerlinNoise commentStamp: '' prior: 0!Based on http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf!!TSPerlinNoise2 commentStamp: '' prior: 0!Based on Ken Perlin!!TSPerlinNoise3 commentStamp: '' prior: 0!based on https://mrl.nyu.edu/~perlin/noise/!!TSScale commentStamp: '' prior: 0!I am a common scale interpolator, just put your entry value and this objects scale and return the value in your domain.I am inspired in the d3 implementation of scales you can find the source code in https://github.com/d3/d3-scale!!TSScaleBilinear commentStamp: '' prior: 0!I represent a bilinear range for 2 limits, start and end!!TSScaleLinear commentStamp: '' prior: 0!I follow the linear function!!TSScaleLog commentStamp: '' prior: 0!for scale log!!TSScalePow commentStamp: '' prior: 0!I scale using pow function!!TSScaleOrdinal commentStamp: '' prior: 0!I am a scale for ordinal ranges!!TSScalePolylinear commentStamp: '' prior: 0!I can handle a several kind of values!!TSScalePowPow commentStamp: '' prior: 0!I am a utility clas for CAScalePow!!TSUninterpolate commentStamp: '' prior: 0!I am the basic uninterpolator, my subclasses areTSUninterpolateClampTSUninterpolateNumber!!TSUninterpolateClamp commentStamp: '' prior: 0!I do not allow a value get off the scale of 0 to 1!!TSUninterpolateNumber commentStamp: '' prior: 0!I uninterpolate a value of x acording to 2 limits, a and b!!TSAbstractInterpolator methodsFor: 'accessing'!start: anObject	start := anObject! !!TSAbstractInterpolator methodsFor: 'accessing'!stop: anObject	stop := anObject! !!TSColorHSLAInterpolator methodsFor: 'interpolation'!interpolate: t	^ Color		h: start hue + ((stop hue - start hue) * t)		s: start hslSaturation + ((stop hslSaturation - start hslSaturation)  * t)		l: start luminance + ((stop luminance - start luminance) * t)		alpha: start alpha + ((stop alpha - start alpha) * t)! !!TSColorHSVAInterpolator methodsFor: 'interpolation'!interpolate: t	^ Color		h: start hue + ((stop hue - start hue) * t)		s: start hsvSaturation + ((stop hsvSaturation - start hsvSaturation)  * t)		l: start luminance + ((stop luminance - start luminance) * t)		alpha: start alpha + ((stop alpha - start alpha) * t)! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!category10	^ self colorHex: #(2062260 16744206 2924588 14034728 9725885 9197131 14907330 8355711 12369186 1556175)	! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!category20	^ self colorHex: #(2062260 11454440 16744206 16759672 2924588 10018698 14034728 16750742 9725885 12955861 9197131 12885140 14907330 16234194 8355711 13092807 12369186 14408589 1556175 10410725)	! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!category20b	^ self colorHex: #(3750777 5395619 7040719 10264286 6519097 9216594 11915115 13556636 9202993 12426809 15186514 15190932 8666169 11356490 14049643 15177372 8077683 10834324 13528509 14589654)	! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!category20c	^ self colorHex: #(3244733 7057110 10406625 13032431 15095053 16616764 16625259 16634018 3253076 7652470 10607003 13101504 7695281 10394312 12369372 14342891 6513507 9868950 12434877 14277081)	! !!TSColorRGBAInterpolator class methodsFor: 'helpers'!colorHex: arr	^ arr collect: [ :value | Color colorFrom: (		(self hex: value >> 16),		(self hex: value >> 8 & 255), 		(self hex: value & 255))		 ].	! !!TSColorRGBAInterpolator class methodsFor: 'interpolation'!colorInterpolator	^ self! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!eva10	^ #('A57DBF' '562A65' 'A1DC5C' '46705C' 'B5A7DD' 'F1C123' 'C9783E' '605EA9' '730D0B' '5B5C65') 		collect: [ :s | Color colorFrom: s ].! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!google20	^ self colorHex: #(3368652 14432530 16750848 1087000 10027161 39366 14500983 6728192 12070446 3236757 10044569 2271897 11184657 6697932 15102720 9111303 6623335 3314274 5600422 3882668)! !!TSColorRGBAInterpolator class methodsFor: 'helpers'!hex: v	^ (v < 16 ifTrue: [ '0' ] ifFalse: [ '' ]), v printStringHex! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!paired12	^ self colorHex: #(10931939 2062516 11722634 3383340 16489113 14883356 16629615 16744192 13284054 6962586 16777113 11622696)! !!TSColorRGBAInterpolator class methodsFor: 'color categories'!sky8	^ self colorHex: #(13623528 12048360 8895960 14347240 12372694 9280950 6714002 15852509)! !!TSColorRGBAInterpolator methodsFor: 'interpolation'!interpolate: t	^ Color		r: start red + ((stop red - start red) * t)		g: start green + ((stop green - start green)  * t)		b: start blue + ((stop blue - start blue) * t)		alpha: start alpha + ((stop alpha - start alpha) * t)! !!TSColorRGBAInterpolator methodsFor: 'interpolation'!start: anObject	start := Color colorFrom: anObject! !!TSColorRGBAInterpolator methodsFor: 'interpolation'!stop: anObject	stop := Color colorFrom: anObject! !!TSNumberInterpolator methodsFor: 'interpolation'!interpolate: t	^ (start * (1 - t)) + (stop * t).! !!TSRoundInterpolator class methodsFor: 'interpolation'!interpolate: a and: b	^ self new start: a; stop: b.! !!TSRoundInterpolator methodsFor: 'interpolation'!interpolate: t	^  (start + (stop * t)) rounded! !!TSRoundInterpolator methodsFor: 'accessing'!stop: b	stop := b - start! !!TSInterpolator class methodsFor: 'interpolation'!colorInterpolator	^ TSColorRGBAInterpolator! !!TSInterpolator class methodsFor: 'interpolation'!interpolate: a and: b	| clazz |	clazz := self interpolatorFor: b.	^ clazz new start: a; stop: b.! !!TSInterpolator class methodsFor: 'interpolation'!interpolatorFor: b	(b isString or: [ b isColor ]) ifTrue: [ ^ self colorInterpolator ].	b isNumber ifTrue: [ ^ TSNumberInterpolator ].	b isPoint ifTrue: [ ^ TSNumberInterpolator ].	self error: 'Invalid value for interpolator'! !!TSInterpolator methodsFor: 'interpolation'!interpolate: anObject	self subclassResponsibility! !!TSPerlinNoise methodsFor: 'private'!dot: arr and: x and: y	^ (arr first * x) + (arr second * y)! !!TSPerlinNoise methodsFor: 'accessing'!grad3At: index	^ grad3 at: index + 1! !!TSPerlinNoise methodsFor: 'initialization'!initialize	| p |	super initialize.	grad3 := #( 		#(1 1 0) 		#(-1 1 0) 		#(1 -1 0)		#(-1 -1 0)		#(1 0 1)		#(-1 0 1)		#(1 0 -1)		#(-1 0 -1)		#(0 1 1)		#(0 -1 1)		#(0 1 -1)		#(0 -1 -1)).			p := #(151 160 137 91 90 15 131 13 201 95 96 53 194 233 7 225 140 36 103 30 69 142 8 99 37 240 21 10 23 190 6 148 247 120 234 75 0 26 197 62 94 252 219 203 117 35 11 32 57 177 33 88 237 149 56 87 174 20 125 136 171 168 68 175 74 165 71 134 139 48 27 166 77 146 158 231 83 111 229 122 60 211 133 230 220 105 92 41 55 46 245 40 244 102 143 54 65 25 63 161 1 216 80 73 209 76 132 187 208 89 18 169 200 196 135 130 116 188 159 86 164 100 109 198 173 186 3 64 52 217 226 250 124 123 5 202 38 147 118 126 255 82 85 212 207 206 59 227 47 16 58 17 182 189 28 42 223 183 170 213 119 248 152 2 44 154 163 70 221 153 101 155 167 43 172 9 129 22 39 253 19 98 108 110 79 113 224 232 178 185 112 104 218 246 97 228 251 34 242 193 238 210 144 12 191 179 162 241 81 51 145 235 249 14 239 107 49 192 214 31 181 199 106 157 184 84 204 176 115 121 50 45 127 4 150 254 138 236 205 93 222 114 67 29 24 72 243 141 128 195 78 66 215 61 156 180).	perm := Array new: 512.	1 to: 256 do: [ :i | | v |		v := p at: i.		perm at: i put: v.		perm at: i + 256 put: v ].	! !!TSPerlinNoise methodsFor: 'public'!noise: xin and: yin	"all this proces explained in http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf"	| f2 s i j g2 t xzero yzero x0 y0 i1 j1 x1 y1 x2 y2 ii jj gi0 gi1 gi2 t0 n0 t1 n1 t2 n2 |	f2 := 0.5 * (3 sqrt - 1).	s := (xin + yin) * f2.	i := (xin + s) floor.	j := (yin + s) floor.	g2 := (3 - 3 sqrt) / 6.	t := (i + j) * g2.	xzero := i - t.	yzero := j - t.	x0 := xin - xzero.	y0 := yin - yzero.	x0 > y0 ifTrue: [ 		i1 := 1.		j1 := 0 ]		ifFalse: [ 		i1 := 0.		j1 := 1 ].	x1 := x0 - i1 + g2.	y1 := y0 - j1 + g2.	x2 := x0 - 1 + (2* g2).	y2 := y0 - 1 + (2* g2).		ii := i & 255.	jj := j & 255.		gi0 := (self permAt: ii + (self permAt: jj)) % 12.	gi1 := (self permAt: ii + i1 + (self permAt: jj + j1)) % 12.	gi2 := (self permAt: ii + 1 + (self permAt: jj + 1) ) % 12.		t0 := 0.5 - (x0 * x0) - (y0 * y0).	t0 < 0 ifTrue: [ n0 := 0 ] ifFalse: [ 		t0 := t0 * t0.		n0 := t0 * t0 * (self dot: (self grad3At: gi0) and: x0 and: y0 ) ].	t1 := 0.5 - (x1*x1) - (y1 * y1).	t1 < 0 ifTrue: [ n1 := 0 ] ifFalse: [ 		t1 := t1 * t1.		n1 := t1 * t1 * (self dot: (self grad3At: gi1) and: x1 and: y1 ) ].	t2 := 0.5 - (x2 * x2) - (y2 * y2).	t2 < 0 ifTrue: [ n2 := 0 ] ifFalse: [ 		t2 := t2 * t2.		n2 := t2 * t2 * (self dot: (self grad3At: gi2) and: x2 and: y2) ].	^ 70.0 * (n0 + n1 + n2).	! !!TSPerlinNoise methodsFor: 'accessing'!permAt: index	^ perm at: index + 1! !!TSPerlinNoise2 methodsFor: 'public'!fade: t	^ t * t * t * (t * (t * 6 - 15) + 10 )! !!TSPerlinNoise2 methodsFor: 'public'!grad: hash x: x y: y z: z	| h u v |	h := hash & 15.	u := h < 8		ifTrue: [ x ]		ifFalse: [ y ].	v := h < 4		ifTrue: [ y ]		ifFalse: [ ((h = 12) or: [ h = 14 ])				ifTrue: [ x ]				ifFalse: [ z ] ].	^ (h & 1 = 0		ifTrue: [ u ]		ifFalse: [ u negated ])		+			((h & 2) = 0				ifTrue: [ v ]				ifFalse: [ v negated ])! !!TSPerlinNoise2 methodsFor: 'initialization'!initialize	| permutation |	super initialize.	p := Dictionary new.	permutation :=#(151 160 137 91 90 15 131 13 201 95 96 53 194 233 7 225 140 36 103 30 69 142 8 99 37 240 21 10 23 190 6 148 247 120 234 75 0 26 197 62 94 252 219 203 117 35 11 32 57 177 33 88 237 149 56 87 174 20 125 136 171 168 68 175 74 165 71 134 139 48 27 166 77 146 158 231 83 111 229 122 60 211 133 230 220 105 92 41 55 46 245 40 244 102 143 54 65 25 63 161 1 216 80 73 209 76 132 187 208 89 18 169 200 196 135 130 116 188 159 86 164 100 109 198 173 186 3 64 52 217 226 250 124 123 5 202 38 147 118 126 255 82 85 212 207 206 59 227 47 16 58 17 182 189 28 42 223 183 170 213 119 248 152 2 44 154 163 70 221 153 101 155 167 43 172 9 129 22 39 253 19 98 108 110 79 113 224 232 178 185 112 104 218 246 97 228 251 34 242 193 238 210 144 12 191 179 162 241 81 51 145 235 249 14 239 107 49 192 214 31 181 199 106 157 184 84 204 176 115 121 50 45 127 4 150 254 138 236 205 93 222 114 67 29 24 72 243 141 128 195 78 66 215 61 156 180).	0 to: 255 do: [ :i |		p at: 256 + i put: (p at: i put: (permutation at: i + 1) ) ]! !!TSPerlinNoise2 methodsFor: 'public'!lerp: t a: a b: b	^ t * (b - a) + a! !!TSPerlinNoise2 methodsFor: 'public'!noise: xin	^ self noise: xin y: 0 z: 0! !!TSPerlinNoise2 methodsFor: 'public'!noise: xin and: yin	^ self noise: xin y: yin z: 0! !!TSPerlinNoise2 methodsFor: 'public'!noise: xin y: yin z: zin	"(TSPerlinNoise2 new noise: 3.14 y: 42 z: 7) >>> 0.13691995878400012"	| x0 y0 z0 x y z u v w a aa ab b ba bb |	x0 := xin floor & 255.	y0 := yin floor & 255.	z0 := zin floor & 255.	x := xin - xin floor.	y := yin - yin floor.	z := zin - zin floor.	u := self fade: x.	v := self fade: y.	w := self fade: z.	a := (p at: x0)+y0.	aa := (p at: a)+z0.	ab := (p at: a+1)+z0.	b := (p at: x0+1)+y0.	ba := (p at: b) + z0.	bb := (p at: b+1) + z0.	"result will cover the range [-1,1]"	^ self lerp: w 		a: (self lerp: v			a: (self lerp: u 				a: (self grad: (p at: aa) x: x 	y: y z: z)				b: (self grad: (p at: ba) x: x-1	y: y z: z) )  			b: (self lerp: u				a: (self grad: (p at: ab) x: x 	y: y-1 z: z)				b: (self grad: (p at: bb) x: x-1	y: y-1 z: z) ) )		b: (self lerp: v			a: (self lerp: u 				a: (self grad: (p at: aa+1) x: x 	y: y z: z-1)				b: (self grad: (p at: ba+1) x: x-1	y: y z: z-1) )  			b: (self lerp: u				a: (self grad: (p at: ab+1) x: x 	y: y-1 z: z-1)				b: (self grad: (p at: bb+1) x: x-1	y: y-1 z: z-1) ) )! !!TSPerlinNoise2 methodsFor: 'public'!snoise: xin and: yin	"range #(0 1)"	^((self noise: xin and: yin) + 1)/2! !!TSPerlinNoise3 methodsFor: 'public'!grad2d: i x: x y: y	| v |	v := (i &1) = 0 		ifTrue: [ x ] 		ifFalse: [ y ].	^ (i & 2) = 0 ifTrue: [ v negated ] ifFalse: [ v ]! !!TSPerlinNoise3 methodsFor: 'initialization'!initialize	| r |	super initialize.	self octaves: 1.	r := Random new.	p := Dictionary new.	0 to: 511 do: [ :i | 		p at: i put: (r next * 256) asInteger ].! !!TSPerlinNoise3 methodsFor: 'public'!lerp: t a: a b: b	^ t * (b - a) + a! !!TSPerlinNoise3 methodsFor: 'public'!noise2d: xin and: yin	| x1 y1 x y fx fy p0 p1 |	x1 := xin floor & 255.	y1 := yin floor & 255.	x := xin - xin floor.	y := yin - yin floor.	fx := (3- (2 * x)) * x * x.	fy := (3 -(2 * y)) * y * y.	p0 := (p at: x1) + y1.	p1 := (p at: x1 + 1)+ y1.	^ self lerp: fy 		a: (self lerp: fx			a: (self grad2d: (p at: p0) x: x y: y)			b: (self grad2d: (p at: p1) x: x -1 y: y))		b: (self lerp: fx			a: (self grad2d: (p at: p0+1) x: x y: y-1)			b: (self grad2d: (p at: p1+1) x: x -1 y: y-1)).! !!TSPerlinNoise3 methodsFor: 'public'!noise: xin and: yin	| e k s |	e := 1.	k := 1.	s := 0.	1 to: octaves do: [ :i | 		e := e * 0.5.		s := s + (e * (1 + (self noise2d: k * xin and: k * yin)/2) ).		k := k * 2 ].	^ s! !!TSPerlinNoise3 methodsFor: 'accessing'!octaves: anInteger	octaves := anInteger! !!TSScale class methodsFor: 'instance creation'!category10	^ self fromColorCategory: #category10! !!TSScale class methodsFor: 'instance creation'!category20	^ self fromColorCategory: #category20! !!TSScale class methodsFor: 'instance creation'!category20b	^ self fromColorCategory: #category20b! !!TSScale class methodsFor: 'instance creation'!category20c	^ self fromColorCategory: #category20c! !!TSScale class methodsFor: 'instance creation'!eva10	^ self fromColorCategory: #eva10! !!TSScale class methodsFor: 'instance creation'!fromColorCategory: symbol	^ self ordinal 		range: (TSColorRGBAInterpolator perform: symbol);		yourself! !!TSScale class methodsFor: 'instance creation'!google20	^ self fromColorCategory: #google20! !!TSScale class methodsFor: 'instance creation'!linear	^ TSScaleLinear new. ! !!TSScale class methodsFor: 'instance creation'!log	^ TSScaleLog new! !!TSScale class methodsFor: 'instance creation'!ordinal"Define an ordinal scale. Here is an example:v := RSView new.colors := TSScale ordinal range: { Color red . Color yellow . Color blue }.boxes := RSShapeBuilder box				size: 20;				color: [ :vv | colors scale: vv ];				elementsOn: ((1 to: 10) collect: [:vv | vv // 2 ]) shuffled.v addAll: boxes.RSHorizontalLineLayout new gapSize: 0; on: boxes.v @ RSControlsView.v open"	^ TSScaleOrdinal new ! !!TSScale class methodsFor: 'instance creation'!paired12	^ self fromColorCategory: #paired12! !!TSScale class methodsFor: 'instance creation'!pow	^ TSScalePow new! !!TSScale class methodsFor: 'instance creation'!sky8	^ self fromColorCategory: #sky8! !!TSScale class methodsFor: 'instance creation'!sqrt	^ self pow		exponent: 0.5; 		yourself! !!TSScale methodsFor: 'accessing'!domain	^ domain! !!TSScale methodsFor: 'accessing'!domain: anObject	domain := anObject! !!TSScale methodsFor: 'accessing'!from	^ self range first! !!TSScale methodsFor: 'accessing'!from: value	self range: { value. self range last }.! !!TSScale methodsFor: 'accessing'!interpolate	^ interpolate! !!TSScale methodsFor: 'accessing'!interpolate: anObject	interpolate := anObject.! !!TSScale methodsFor: 'transformation'!invert: anObject	"This is the inverse of scale"	self subclassResponsibility.! !!TSScale methodsFor: 'accessing'!range	^ range! !!TSScale methodsFor: 'accessing'!range: anObject	range := anObject! !!TSScale methodsFor: 'hooks'!rescale	self subclassResponsibilitya! !!TSScale methodsFor: 'transformation'!rsValue: obj	^ self scale: obj! !!TSScale methodsFor: 'transformation'!scale: anObject	"do you have your domain, and your range? ok so use this method in one of my subclasses"	self subclassResponsibility! !!TSScale methodsFor: 'accessing'!to	^ self range last! !!TSScale methodsFor: 'accessing'!to: value	self range: { self range first. value }.! !!TSScale methodsFor: 'accessing'!uninterpolate	^ uninterpolate! !!TSScale methodsFor: 'accessing'!uninterpolate: anObject	uninterpolate := anObject! !!TSScaleBilinear methodsFor: 'transformation'!invert: anObject	self shouldNotImplement! !!TSScaleBilinear methodsFor: 'hooks'!rescale	u := uninterpolate uninterpolate: domain first and: domain second.	i := interpolate interpolate: range first and: range second.! !!TSScaleBilinear methodsFor: 'transformation'!scale: x	^ i interpolate: (u uninterpolate: x)! !!TSScaleLinear methodsFor: 'accessing'!clamp: aBool	"If clamp is specified, enables or disables clamping accordingly. If clamping is disabled and the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation. If clamping is enabled, the return value of the scale is always within the scale’s range."	clamp := aBool.	self rescale.! !!TSScaleLinear methodsFor: 'accessing'!domain: x	super domain: x.	self rescale.! !!TSScaleLinear methodsFor: 'initialization'!initialize	super initialize.	range := domain := #(0 1).	clamp := false.	interpolate := TSInterpolator.	self rescale.! !!TSScaleLinear methodsFor: 'accessing'!interpolate: x	interpolate := x.	self rescale.! !!TSScaleLinear methodsFor: 'transformation'!invert: y	^ input scale: y.! !!TSScaleLinear methodsFor: 'accessing'!range: r	super range: r.	self rescale.! !!TSScaleLinear methodsFor: 'accessing'!rangeRound: x	"x is a range"	self 		range: x;		interpolate: TSRoundInterpolator.! !!TSScaleLinear methodsFor: 'hooks'!rescale	| linear |	linear := (domain size min: range size ) > 2		ifTrue: [ TSScalePolylinear ]		ifFalse: [ TSScaleBilinear ].	uninterpolate := clamp		ifTrue: [ TSUninterpolateClamp ]		ifFalse: [ TSUninterpolateNumber ].	output := linear new domain: domain; range: range; 		uninterpolate: uninterpolate; interpolate: interpolate.	output rescale.	input := linear new domain: range; range: domain;		uninterpolate: uninterpolate; interpolate: TSInterpolator.	input rescale.! !!TSScaleLinear methodsFor: 'transformation'!scale: x	^ output scale: x! !!TSScaleLog methodsFor: 'accessing'!base	^ base! !!TSScaleLog methodsFor: 'accessing'!base: number	base := number.	linear domain: (domain collect: [:n | self lg: n ]).! !!TSScaleLog methodsFor: 'accessing'!clamp: x	 linear clamp: x! !!TSScaleLog methodsFor: 'accessing'!domain: arr	positive := arr first >= 0.	domain := arr.	linear domain: (arr collect: [:n | self lg: n]).! !!TSScaleLog methodsFor: 'initialization'!initialize	super initialize.	linear := self class linear.	base := 10.	positive := true.	domain := #(1 0).! !!TSScaleLog methodsFor: 'accessing'!interpolate	^ linear interpolate! !!TSScaleLog methodsFor: 'accessing'!interpolate: x	linear interpolate: x! !!TSScaleLog methodsFor: 'transformation'!invert: x	^ self pow: (linear invert: x).! !!TSScaleLog methodsFor: 'math functions'!lg: x	"logarithm"	^ (positive 		ifTrue: [ (x max: 0) ln ]		ifFalse: [ (x > 0 ifTrue: [ 0 ] ifFalse: [ 0 - x ] ) ln negated ])		/ (base ln).		! !!TSScaleLog methodsFor: 'math functions'!pow: x	^ positive  		ifTrue: [ base raisedTo: x ]		ifFalse: [ (base raisedTo: x negated) negated ].		! !!TSScaleLog methodsFor: 'accessing'!range	^ linear range! !!TSScaleLog methodsFor: 'accessing'!range: x	linear range: x! !!TSScaleLog methodsFor: 'transformation'!scale: x	^ linear scale: (self lg: x)! !!TSScalePow methodsFor: 'accessing'!clamp: x	linear clamp: x! !!TSScalePow methodsFor: 'accessing'!domain: x	linear domain: ((domain := x) collect: [ :i | powp scale: i ]).! !!TSScalePow methodsFor: 'accessing'!exponent	^ exponent! !!TSScalePow methodsFor: 'accessing'!exponent: x	exponent := x.	powp exponent: exponent.	powb exponent: 1/exponent.	linear domain: (domain collect: [ :i | powp scale: i ])! !!TSScalePow methodsFor: 'initialization'!initialize	super initialize.	linear := self class linear.	exponent := 1.	domain := #(0 1).	powp := TSScalePowPow exponent: exponent.	powb := TSScalePowPow exponent: 1 / exponent.! !!TSScalePow methodsFor: 'initialization'!interpolate	^ linear interpolate! !!TSScalePow methodsFor: 'initialization'!interpolate: x	linear interpolate: x! !!TSScalePow methodsFor: 'initialization'!invert: x	^ powb scale: (linear invert: x)! !!TSScalePow methodsFor: 'initialization'!range	^ linear range! !!TSScalePow methodsFor: 'initialization'!range: x	linear range: x! !!TSScalePow methodsFor: 'initialization'!rescale! !!TSScalePow methodsFor: 'initialization'!scale: x	^ linear scale: (powp scale: x)! !!TSScaleOrdinal methodsFor: 'accessing'!dictionary 	^ dictionary ! !!TSScaleOrdinal methodsFor: 'accessing'!domain: arr	domain := OrderedCollection new.	dictionary := Dictionary new.	arr do: [ :xi |		(dictionary includesKey: xi) ifFalse: [ 			domain add: xi.			dictionary at: xi put: domain size ] ].	self perform: ranger withArguments: argument! !!TSScaleOrdinal methodsFor: 'initialization'!initialize	super initialize.	ranger := #range:.	argument := #( #() ).	self domain: #().		! !!TSScaleOrdinal methodsFor: 'transformation'!invert: anObject	self shouldNotImplement! !!TSScaleOrdinal methodsFor: 'accessing'!range: x	range := x.	rangeBand := 0.	ranger := #range:.	argument := Array with: x.! !!TSScaleOrdinal methodsFor: 'accessing'!rangeBand	^ rangeBand! !!TSScaleOrdinal methodsFor: 'public'!rangeBands: x	self rangeBands: x padding: 0! !!TSScaleOrdinal methodsFor: 'public'!rangeBands: x padding: padding	self rangeBands: x padding: padding outerPadding: padding! !!TSScaleOrdinal methodsFor: 'public'!rangeBands: x padding: padding outerPadding: outerPadding	| start stop step reverse |	start := x first.	stop := x second.	reverse := false.	start > stop ifTrue: [| t |		t := start. start := stop. stop := t.		reverse := true. ].	step := (stop - start) / (domain size - padding + (2*outerPadding)).		range := self 		steps: start + (step * outerPadding)		and: step.	reverse ifTrue: [ range := range reverse ].	rangeBand := step * (1 - padding).	ranger := #rangeBands:padding:outerPadding:.	argument := Array with: x with: padding with: outerPadding! !!TSScaleOrdinal methodsFor: 'accessing'!rangeExtent	^ self scaleExtent: argument first! !!TSScaleOrdinal methodsFor: 'accessing'!rangeFrom: array	self range: (array collect: [ :val | Color colorFrom: val ])! !!TSScaleOrdinal methodsFor: 'public'!rangePoints: x	self rangePoints: x padding: 0! !!TSScaleOrdinal methodsFor: 'public'!rangePoints: x padding: padding	| start stop step |	start := x first.	stop := x second.	step := domain size < 2		ifTrue: [ start := (start  + stop)/2. 0 ]		ifFalse: [ (stop - start)/(domain size - 1 + padding) ].	range := self 		steps: start + (step * padding / 2)		and: step.	rangeBand := 0.		ranger := #rangePoints:padding:.	argument := Array with: x with: padding! !!TSScaleOrdinal methodsFor: 'public'!rangeRoundBands: x	self rangeRoundBands: x padding: 0! !!TSScaleOrdinal methodsFor: 'public'!rangeRoundBands: x padding: padding	self rangeRoundBands: x padding: padding outerPadding: padding! !!TSScaleOrdinal methodsFor: 'public'!rangeRoundBands: x padding: padding outerPadding: outerPadding	| start stop step reverse |	start := x first.	stop := x second.	reverse := false.	start > stop ifTrue: [| t |		t := start. start := stop. stop := t.		reverse := true. ].	step := ((stop - start) / (domain size - padding + (2*outerPadding))) floor.		range := self 		steps: start + ( (stop - start - ((domain size - padding) * step) ) / 2 ) rounded		and: step.	reverse ifTrue: [ range := range reverse ].	rangeBand := (step * (1 - padding)) rounded.	ranger := #rangeRoundBands:padding:outerPadding:.	argument := Array with: x with: padding with: outerPadding! !!TSScaleOrdinal methodsFor: 'public'!rangeRoundPoints: x	self rangeRoundPoints: x padding: 0! !!TSScaleOrdinal methodsFor: 'public'!rangeRoundPoints: x padding: padding	| start stop step |	start := x first.	stop := x second.	step := domain size < 2		ifTrue: [ start := stop := ((start + stop)/2) rounded. 0 ]		ifFalse: [[ (stop - start)/(domain size -1 + padding)]			on: Error do: [ :ex | 0 ] ].			range := self 		steps: start + ((step * padding / 2) + (stop - start - 			((domain size - 1 + padding)* step) )/ 2) rounded		and: step.	rangeBand := 0.	ranger := #rangeRoundPoints:padding:.	argument := Array with: x with: padding! !!TSScaleOrdinal methodsFor: 'transformation'!scale: x	| index |	index := dictionary at: x ifAbsent: [ nil ].	(index isNil and: [ ranger = #range:]) ifTrue: [		domain add: x.		dictionary at: x put: (index := domain size).		].	index ifNil: [ self error: 'invalid input' ].	index := index % range size.	index isZero 		ifTrue: [ index := range size ].	^ range at: index! !!TSScaleOrdinal methodsFor: 'helpers'!scaleExtent: d	| start stop |	start := d first.	stop := d last.	^ start < stop		ifTrue: [ Array with: start with: stop ]		ifFalse: [ Array with: stop with: start ]! !!TSScaleOrdinal methodsFor: 'helpers'!steps: start and: step	^ (0 to: domain size - 1) collect: [ :i | (start + (step * i)) asFloat ].! !!TSScalePolylinear methodsFor: 'private'!findJ: x	| lo hi mid |	lo := 2.	hi := k.	[ lo < hi ] whileTrue: [ 		mid := ((lo + hi) / 2) asInteger.		(domain at: mid) > x 			ifTrue: [ hi := mid ]			ifFalse: [ lo := mid + 1 ] ].	^ lo - 1 ! !!TSScalePolylinear methodsFor: 'transformation'!invert: anObject	self shouldNotImplement! !!TSScalePolylinear methodsFor: 'hooks'!rescale	| obj |	u := OrderedCollection new.	i := OrderedCollection new.	k := domain size min: range size.	obj := domain at: k.		((obj class canUnderstand: #<) and: [obj < domain first]) ifTrue: [		domain := domain reverse.		range := range reverse ].		2 to: k do: [ :j | 		u add: (uninterpolate uninterpolate: (domain at: j -1 ) and: (domain at: j)).		i add: (interpolate interpolate: (range at: j -1) and: (range at: j) )		 ].		! !!TSScalePolylinear methodsFor: 'transformation'!scale: x	| j |	j := self findJ: x.	^ (i at: j) interpolate: ((u at: j) uninterpolate: x)	! !!TSScalePowPow class methodsFor: 'instance creation'!exponent: exponent	^ self new 		exponent: exponent;		yourself! !!TSScalePowPow methodsFor: 'accessing'!exponent: aNumber	exponent := aNumber! !!TSScalePowPow methodsFor: 'transformations'!scale: x	^ x < 0		ifTrue: [ (x negated raisedTo: exponent) negated ]		ifFalse: [ x raisedTo: exponent ]! !!TSUninterpolate class methodsFor: 'interpolating'!uninterpolate: aNum1 and: aNum2	^ self new uninterpolate: aNum1 and: aNum2.	! !!TSUninterpolate methodsFor: 'interpolating'!uninterpolate: x	self subclassResponsibility.! !!TSUninterpolate methodsFor: 'accessing'!uninterpolate: aNum1 and: aNum2	a := aNum1.	b := aNum2.	a isNumber 		ifFalse: [ ^ a := b := Float nan. ].	b  := b - a.	b isZero 		ifTrue: [ b := 1 / aNum2 ].! !!TSUninterpolateClamp methodsFor: 'interpolating'!uninterpolate: x	^ 0 max: (1 min: ((x - a ) / b))! !!TSUninterpolateNumber methodsFor: 'interpolating'!uninterpolate: x	^ (x - a )/b! !!Random methodsFor: '*Roassal3-Scales'!rsNext: limit	^ self rsNext: 0 and: limit.! !!Random methodsFor: '*Roassal3-Scales'!rsNext: u and: v	^ TSScale linear range: {u. v}; scale: self next.! !"Roassal3-Scales"!!TSAbstractAnimation commentStamp: '' prior: 0!I am the abstract class that defines animations for roassal3!!TSSequentialAnimation commentStamp: '' prior: 0!I wait until one animation ends to start the another animation!!TSTransitionAnimation commentStamp: '' prior: 0!I am an animation that provides a number interpolating between 0 and 1. and apply it the value to one block!!TSEasing commentStamp: '' prior: 0!Given the specified normalized time t, typically in the range [0,1], returns the “eased” time tʹ, also typically in [0,1]. 0 represents the start of the animation and 1 represents the end. A good implementation returns 0 if t = 0 and 1 if t = 1.I am highli inspired in d3js source code https://github.com/d3/d3-transition and in the base animation of Bloc https://github.com/pharo-graphics/Bloc!!TSBackInterpolator commentStamp: '' prior: 0!TSEasing backInAnticipatory easing, like a dancer bending his knees before jumping off the floor. The degree of overshoot is configurable; if not specified, it defaults to 1.70158.TSEasing backOut Reverse anticipatory easing; equivalent to 1 - (backIn value: 1 - t).TSEasing back TSEasing backInOutSymmetric anticipatory easing; scales backIn for t in [0, 0.5] and backOut for t in [0.5, 1].!!TSBounceInterpolator commentStamp: '' prior: 0!TSEasing bounceInBounce easing, like a rubber ball.TSEasing bounceTSEasing bounceOutReverse bounce easing; equivalent to 1 - bounceIn(1 - t).TSEasing bounceInOutSymmetric bounce easing; scales bounceIn for t in [0, 0.5] and bounceOut for t in [0.5, 1].!!TSCircleInterpolator commentStamp: '' prior: 0!TSEasing circleInCircular easing.TSEasing circleOutIs Reverse circular easing; equivalent to 1 - interpolateIn: 1 - t.TSEasing circleInOutTSEasing circleSymmetric circular easing; scales circleIn for t in {0. 0.5} and circleOut for t in {0.5, 1}.!!TSCubicInterpolator commentStamp: '' prior: 0!TSEasing cubicInCubic easing; equivalent to: TSEasing poly exponent: 3.TSEasing cubicOutReverse cubic easing; equivalent to 1 - TSEasing cubicIn interpolate: (1 - t). Also equivalent to TSEasing polyOut exponent: 3.TSEasing cubic TSEasing cubicInOut Symmetric cubic easing; scales cubicIn for t in {0. 0.5} and cubicOut for t in {0.5. 1}. Also equivalent to TSEasing poly exponent: 3.!!TSElasticInterpolator commentStamp: '' prior: 0!TSEasing elasticInElastic easing, like a rubber band. The amplitude and period of the oscillation are configurable; if not specified, they default to 1 and 0.3, respectively.TSEasing elasticOutReverse elastic easing; equivalent to 1 - elasticIn(1 - t).TSEasing elastic TSEasing elasticInOut.Symmetric elastic easing; scales elasticIn for t in [0, 0.5] and elasticOut for t in [0.5, 1].!!TSExpInterpolator commentStamp: '' prior: 0!TSEasing expInExponential easing; raises 2 to the exponent 10 * (t - 1).TSEasing expOut Reverse exponential easing; equivalent to 1 - expIn(1 - t).TSEasing exp TSEasing expInOut Symmetric exponential easing; scales expIn for t in [0, 0.5] and expOut for t in [0.5, 1].!!TSPolyInterpolator commentStamp: '' prior: 0!linear := TSEasing poly exponent: 1.quad := TSEasing poly exponent: 2.cubic := TSEasing poly exponent: 3TSEasing polyIn Polynomial easing; raises t to the specified exponent. If the exponent is not specified, it defaults to 3, equivalent to cubicIn.TSEasing polyOutReverse polynomial easing; equivalent to 1 - polyIn(1 - t). If the exponent is not specified, it defaults to 3, equivalent to cubicOut.TSEasing poly TSEasing polyInOut Symmetric polynomial easing; scales polyIn for t in [0, 0.5] and polyOut for t in [0.5, 1]. If the exponent is not specified, it defaults to 3, equivalent to cubic.!!TSQuadInterpolator commentStamp: '' prior: 0!TSEasing quadInQuadratic easing. Equivalent to: TSEasing polyIn exponent: 2TSEasing quadOutReverse quadratic easing. Equivalent to 1 - (1 - t) quadIn. Also equivalent to: TSEasing polyOut exponent: 2.TSEasing quad TSEasing quadInOut Symmetric quadratic easing; scales quadIn for t in [0, 0.5] and quadOut for t in [0.5, 1].Also equivalent to TSEasing poly exponent: 2.!!TSSinInterpolator commentStamp: '' prior: 0!TSEasing sinInSinusoidal easing; returns sin(t).TSEasing sinOutReverse sinusoidal easing; equivalent to 1 - sinIn(1 - t).TSEasing sin TSEasing sinInOutSymmetric sinusoidal easing; scales sinIn for t in [0, 0.5] and sinOut for t in [0.5, 1].!!TSLinearInterpolator commentStamp: '' prior: 0!I return the linear interpolation!!TSAnimationEvent commentStamp: '' prior: 0!I an an event for animations in trachel!!TSAnimationEndEvent commentStamp: '' prior: 0!For when the animation is removed or ends from the canvas!!TSAnimationLoopEvent commentStamp: '' prior: 0!for loop events!!TSAnimationStartEvent commentStamp: '' prior: 0!When the animation starts!!TSAbstractAnimation methodsFor: 'events'!announce: anEvent	announcer ifNil: [ ^ self ].	announcer announce: anEvent value! !!TSAbstractAnimation methodsFor: 'events'!announcer	announcer isNil ifTrue: [ announcer := Announcer new ].	^ announcer! !!TSAbstractAnimation methodsFor: 'events'!announcer: anAnnouncer	announcer := anAnnouncer! !!TSAbstractAnimation methodsFor: 'accessing'!canvas	^ canvas! !!TSAbstractAnimation methodsFor: 'accessing'!canvas: aCanvas	canvas := aCanvas! !!TSAbstractAnimation methodsFor: 'actions'!continue	"| oldPaused |	oldPaused := isPaused.	isPaused := false.	oldPaused 		ifTrue: [ endPauseTime := self currentTime. ]"	isPaused ifFalse: [ ^ self ].	isPaused := false.	endPauseTime := self currentTime.	pauseTime := pauseTime + endPauseTime - startPauseTime.! !!TSAbstractAnimation methodsFor: 'accessing'!currentLoop	^ currentLoop! !!TSAbstractAnimation methodsFor: 'private'!currentTime	^ Time millisecondClockValue ! !!TSAbstractAnimation methodsFor: 'accessing'!delay 	^ delay! !!TSAbstractAnimation methodsFor: 'accessing'!delay: aDuration	delay := aDuration asMilliSeconds! !!TSAbstractAnimation methodsFor: 'accessing'!duration	^ self subclassResponsibility! !!TSAbstractAnimation methodsFor: 'accessing'!endPauseTime	^ endPauseTime! !!TSAbstractAnimation methodsFor: 'accessing'!endTime	^ endTime! !!TSAbstractAnimation methodsFor: 'testing'!hasCompleted	 ^ hasCompleted! !!TSAbstractAnimation methodsFor: 'initialization'!initialize	super initialize.	self reset.! !!TSAbstractAnimation methodsFor: 'testing'!isDelayDone	delay ifNil: [ ^ true ].	^ startTime + delay < self currentTime.! !!TSAbstractAnimation methodsFor: 'testing'!isPaused	^ isPaused! !!TSAbstractAnimation methodsFor: 'testing'!isRepeating	^ loops isInfinite.! !!TSAbstractAnimation methodsFor: 'testing'!isRunning 	^ isRunning! !!TSAbstractAnimation methodsFor: 'private'!loopDone	currentLoop := currentLoop + 1.	startPauseTime := endPauseTime := pauseTime := 0.	startLoopTime := self currentTime.	self announce: (TSAnimationLoopEvent new animation: self).! !!TSAbstractAnimation methodsFor: 'accessing'!loops	^ loops! !!TSAbstractAnimation methodsFor: 'accessing'!loops: aNumber	self assert: aNumber >= 1 description: 'The number of times to repeat this animation'.	loops := aNumber! !!TSAbstractAnimation methodsFor: 'api - running'!noRepeat	self loops: 1! !!TSAbstractAnimation methodsFor: 'actions'!pause	isPaused ifTrue: [ ^ self ].	isPaused := true.	startPauseTime := self currentTime.	! !!TSAbstractAnimation methodsFor: 'accessing'!pauseTime	^ pauseTime! !!TSAbstractAnimation methodsFor: 'refresing'!refresh	self hasCompleted		ifTrue: [ ^ self ].	self isDelayDone		ifFalse: [ ^ self ].	self isPaused 		ifTrue: [ ^ self ].	self step.	! !!TSAbstractAnimation methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!TSAbstractAnimation methodsFor: 'actions'!remove	canvas animations remove: self ifAbsent: [  ].	endTime := self currentTime.	isRunning := false.	currentLoop := nil.	startLoopTime := nil.	self announce: (TSAnimationEndEvent new animation: self)	! !!TSAbstractAnimation methodsFor: 'api - running'!repeat	"make receiver to be a repeating timer"	self loops: Float infinity! !!TSAbstractAnimation methodsFor: 'initialization'!reset	isRunning := false.	self noRepeat.	hasCompleted := false.	isPaused := false.	currentLoop := nil.	startLoopTime := nil.	startPauseTime := 0.	endPauseTime := 0.	pauseTime := 0.! !!TSAbstractAnimation methodsFor: 'actions'!start	isRunning := true.	hasCompleted := false.	startTime := self currentTime.	self announce: (TSAnimationStartEvent new animation: self)! !!TSAbstractAnimation methodsFor: 'accessing'!startLoopTime	^ startLoopTime ! !!TSAbstractAnimation methodsFor: 'accessing'!startPauseTime	^ startPauseTime! !!TSAbstractAnimation methodsFor: 'private'!startStep	currentLoop 		ifNil: [ currentLoop := 1 ].	startLoopTime 		ifNil: [ startLoopTime := self currentTime ].! !!TSAbstractAnimation methodsFor: 'accessing'!startTime	^ startTime ! !!TSAbstractAnimation methodsFor: 'refresing'!step	self subclassResponsibility! !!TSAbstractAnimation methodsFor: 'actions'!stop	isRunning := false.	hasCompleted := true.! !!TSAbstractAnimation methodsFor: 'actions'!toggle	self isPaused 		ifTrue: [ self continue ]		ifFalse: [ self pause ]! !!TSAbstractAnimation methodsFor: 'events'!when: event do: aBlock	self announcer when: event do: aBlock! !!TSSequentialAnimation methodsFor: 'adding'!add: anAnimation	self animations add: anAnimation ! !!TSSequentialAnimation methodsFor: 'adding'!addAll: array	animations addAll: array.! !!TSSequentialAnimation methodsFor: 'accessing'!animations	^ animations! !!TSSequentialAnimation methodsFor: 'actions'!continue	super continue.	self currentDo: #continue.! !!TSSequentialAnimation methodsFor: 'refresing'!current	^ animations at: currentIndex ifAbsent: [ ^ nil ].! !!TSSequentialAnimation methodsFor: 'actions'!currentDo: block	| current |	current := self current.	current ifNil: [ ^ self ].	block value: current.! !!TSSequentialAnimation methodsFor: 'refresing'!currentHasCompleted	| current |	current := self current.	current ifNil: [ ^ false ].	^ current hasCompleted! !!TSSequentialAnimation methodsFor: 'accessing'!duration	^ Duration milliSeconds: (self animations inject: 0 into: [ :sum :a| sum + (a duration asMilliSeconds * a loops) ]).! !!TSSequentialAnimation methodsFor: 'actions'!pause	super pause.	self currentDo: #pause.! !!TSSequentialAnimation methodsFor: 'initialization'!reset	super reset.	animations := OrderedCollection new.! !!TSSequentialAnimation methodsFor: 'actions'!start	super start.	currentIndex := 1.! !!TSSequentialAnimation methodsFor: 'refresing'!step	self startStep.	self stepCurrent.	self currentHasCompleted ifTrue: [ 		self current remove.		currentIndex := currentIndex + 1. ].	currentIndex > animations size ifTrue: [ 		currentIndex := 1.		self loopDone ].	hasCompleted := currentLoop > loops.! !!TSSequentialAnimation methodsFor: 'refresing'!stepCurrent	| current |	current := self current.	current ifNil: [ ^ self ].	current isRunning ifFalse: [ 		current canvas: self canvas.		current start. ].	current refresh.! !!TSTransitionAnimation methodsFor: 'accessing'!duration	^ Duration milliSeconds: duration! !!TSTransitionAnimation methodsFor: 'accessing'!duration: aDuration	duration := aDuration asMilliSeconds! !!TSTransitionAnimation methodsFor: 'accessing'!easing	^ easing! !!TSTransitionAnimation methodsFor: 'accessing'!easing: anInterpolator	easing := anInterpolator ! !!TSTransitionAnimation methodsFor: 'accessing'!from	^ scale range first! !!TSTransitionAnimation methodsFor: 'accessing'!from: anObject	scale from: anObject! !!TSTransitionAnimation methodsFor: 'initialization'!initialize	super initialize.	self onStepDo: [ :t | ].	! !!TSTransitionAnimation methodsFor: 'action handling'!on: object set: setSelector	| sel |	sel := setSelector asSymbol.	self 		assert: (object class canUnderstand: sel) 		description: 'Invalid input'.		self onStepDo: [ :t |		object perform: sel withArguments: { t }.		canvas signalUpdate.	]		! !!TSTransitionAnimation methodsFor: 'action handling'!onStepDo: aBlock	stepAction := aBlock! !!TSTransitionAnimation methodsFor: 'accessing - computed'!progress 	| progress |	self startStep.	progress := (self currentTime - pauseTime - startLoopTime)/ duration asFloat.	progress > 1 ifTrue: [ 		self loopDone.		progress := 1.		 ].		^ progress! !!TSTransitionAnimation methodsFor: 'accessing'!ramp: arrayOfAssociations	"canvas animation		ramp: { 		 	0 -> (0@0).			0.25 -> (200@180).			0.75 -> (-200@ -80).			1 -> (200@0)}."	scale := TSScale linear		domain: (arrayOfAssociations collect: #key);		range: (arrayOfAssociations collect: #value)! !!TSTransitionAnimation methodsFor: 'initialization'!reset	super reset.	self duration: 2 asSeconds.	easing := TSLinearInterpolator new.	scale := TSScale linear.! !!TSTransitionAnimation methodsFor: 'accessing'!scale	^ scale! !!TSTransitionAnimation methodsFor: 'accessing'!scale: aScale	scale := aScale! !!TSTransitionAnimation methodsFor: 'refresing'!step 	| progress value |		progress := self progress.	"interpolate the progrees"	progress := easing interpolate: progress.	"apply progress to the value"	value := self scale scale: progress.		stepAction value: value.		hasCompleted := currentLoop > loops.! !!TSTransitionAnimation methodsFor: 'accessing'!to	^ scale range last! !!TSTransitionAnimation methodsFor: 'accessing'!to: aValue	scale to: aValue.! !!TSBackInterpolator methodsFor: 'initialization'!initialize	super initialize.	overshoot := 1.70158! !!TSBackInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ t * t * ((overshoot + 1) * t - overshoot)! !!TSBackInterpolator methodsFor: 'interpolation'!interpolateInOut: i	"((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;"	| t |	t := i * 2.	^ (t < 1		ifTrue: [ t * t * ((overshoot + 1) * t - overshoot) ]		ifFalse: [ 			t := t -2.			t * t * ((overshoot + 1) * t + overshoot) + 2 ])/2! !!TSBackInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i -1.	^ t * t * ((overshoot + 1) * t + overshoot) + 1! !!TSBackInterpolator methodsFor: 'accessing'!overshoot	^ overshoot! !!TSBackInterpolator methodsFor: 'accessing'!overshoot: aNumber	overshoot := aNumber! !!TSBounceInterpolator methodsFor: 'initialization'!initialize	super initialize.	b1 := 4 / 11.	b2 := 6 / 11.	b3 := 8 / 11.	b4 := 3 / 4.	b5 := 9 / 11.	b6 := 10 / 11.	b7 := 15 / 16.	b8 := 21 / 22.	b9 := 63 / 64.	b0 := 1 / b1 / b1! !!TSBounceInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ 1 - (self interpolateOut: 1 - t)! !!TSBounceInterpolator methodsFor: 'interpolation'!interpolateInOut: i	"((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;"	| t |	t := i * 2.	^ (t <= 1		ifTrue: [ 1 - (self interpolateOut: 1 -t) ]		ifFalse: [ (self interpolateOut: t - 1) + 1 ] )/2! !!TSBounceInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i.	^ t < b1 		ifTrue: [ b0 * t * t ]		ifFalse: [ 			t < b3 ifTrue: [ 				t := t - b2.				b0 * t * t + b4 ]			ifFalse: [ 				t < b6 ifTrue: [ 					t := t - b5.					b0 * t * t + b7 ]				ifFalse: [ 					t := t - b8.					b0 * t * t + b9 ] ] ] ! !!TSCircleInterpolator methodsFor: 'interpolation'!interpolateIn:  t	^ 1 - (1 - (t * t) ) sqrt! !!TSCircleInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2.	^ (t<=1		ifTrue: [ 1 - (1 - (t*t)) sqrt ]		ifFalse: [ 			t := t - 2.			(1 - (t*t)) sqrt + 1 ])/2! !!TSCircleInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i -1.	^ (1 - (t* t)) sqrt.! !!TSCubicInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ t * t * t! !!TSCubicInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2.	^ (t <= 1 		ifTrue: [ t * t * t  ]		ifFalse: [ 			t := t - 2.			t * t * t + 2 ])/2! !!TSCubicInterpolator methodsFor: 'interpolation'!interpolateOut: i	| t |	t := i -1.	^ t * t * t + 1! !!TSEasing class methodsFor: 'back'!back	^ self backInOut! !!TSEasing class methodsFor: 'back'!backIn	^ TSBackInterpolator new in! !!TSEasing class methodsFor: 'back'!backInOut	^ TSBackInterpolator new! !!TSEasing class methodsFor: 'back'!backOut	^ TSBackInterpolator new out! !!TSEasing class methodsFor: 'bounce'!bounce	^ self bounceOut! !!TSEasing class methodsFor: 'bounce'!bounceIn	^ TSBounceInterpolator new in! !!TSEasing class methodsFor: 'bounce'!bounceInOut	^ TSBounceInterpolator new! !!TSEasing class methodsFor: 'bounce'!bounceOut	^ TSBounceInterpolator new out! !!TSEasing class methodsFor: 'circle'!circle	^ self circleInOut! !!TSEasing class methodsFor: 'circle'!circleIn	^ TSCircleInterpolator new in! !!TSEasing class methodsFor: 'circle'!circleInOut	^ TSCircleInterpolator new! !!TSEasing class methodsFor: 'circle'!circleOut	^ TSCircleInterpolator new out! !!TSEasing class methodsFor: 'cubic'!cubic	^ self cubicInOut! !!TSEasing class methodsFor: 'cubic'!cubicIn	^ TSCubicInterpolator new in! !!TSEasing class methodsFor: 'cubic'!cubicInOut	^ TSCubicInterpolator new! !!TSEasing class methodsFor: 'cubic'!cubicOut	^ TSCubicInterpolator new out! !!TSEasing class methodsFor: 'elastic'!elastic	^ self elasticInOut! !!TSEasing class methodsFor: 'elastic'!elasticIn	^ TSElasticInterpolator new in! !!TSEasing class methodsFor: 'elastic'!elasticInOut	^ TSElasticInterpolator new! !!TSEasing class methodsFor: 'elastic'!elasticOut	^ TSElasticInterpolator new out! !!TSEasing class methodsFor: 'exp'!exp	^ self expInOut! !!TSEasing class methodsFor: 'exp'!expIn	^ TSExpInterpolator new in! !!TSEasing class methodsFor: 'exp'!expInOut	^ TSExpInterpolator new! !!TSEasing class methodsFor: 'exp'!expOut	^ TSExpInterpolator new out! !!TSEasing class methodsFor: 'linear'!linear	^ TSLinearInterpolator new! !!TSEasing class methodsFor: 'poly'!poly	^ self polyInOut! !!TSEasing class methodsFor: 'poly'!polyIn	^ TSPolyInterpolator new in! !!TSEasing class methodsFor: 'poly'!polyInOut	^ TSPolyInterpolator new.! !!TSEasing class methodsFor: 'poly'!polyOut	^ TSPolyInterpolator new out! !!TSEasing class methodsFor: 'quad'!quad	^ self quadInOut! !!TSEasing class methodsFor: 'quad'!quadIn	^ TSQuadInterpolator new in! !!TSEasing class methodsFor: 'quad'!quadInOut	^ TSQuadInterpolator new! !!TSEasing class methodsFor: 'quad'!quadOut	^ TSQuadInterpolator new out! !!TSEasing class methodsFor: 'sin'!sin	^ self sinInOut! !!TSEasing class methodsFor: 'sin'!sinIn	^ TSSinInterpolator new in! !!TSEasing class methodsFor: 'sin'!sinInOut	^ TSSinInterpolator new! !!TSEasing class methodsFor: 'sin'!sinOut	^ TSSinInterpolator new out! !!TSEasing methodsFor: 'actions'!in	useIn := true.! !!TSEasing methodsFor: 'actions'!inOut	useIn := useOut := false! !!TSEasing methodsFor: 'initialization'!initialize	super initialize.	self inOut.! !!TSEasing methodsFor: 'interpolation'!interpolate: t	useIn ifTrue: [ ^ self interpolateIn: t ].	useOut ifTrue: [ ^ self interpolateOut: t ].	^ self interpolateInOut: t.! !!TSEasing methodsFor: 'interpolation'!interpolateIn: t	^ self subclassResponsibility! !!TSEasing methodsFor: 'interpolation'!interpolateInOut: t	^ self subclassResponsibility ! !!TSEasing methodsFor: 'interpolation'!interpolateOut: t	^ self subclassResponsibility! !!TSEasing methodsFor: 'actions'!out 	useOut := true.! !!TSElasticInterpolator methodsFor: 'accessing'!amplitude	^ amplitude! !!TSElasticInterpolator methodsFor: 'accessing'!amplitude: a	amplitude := a.	period := period * tau.	self calculateS.! !!TSElasticInterpolator methodsFor: 'accessing'!calculateS	"var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);"	amplitude := 1 max: amplitude.	period := period / tau.	s := (1 / amplitude) arcSin * period ! !!TSElasticInterpolator methodsFor: 'initialization'!initialize	super initialize.	tau := 2* Float pi.	amplitude := 1.	period := 0.3.		self calculateS! !!TSElasticInterpolator methodsFor: 'interpolation'!interpolateIn: i	| t |	t := i -1.	^ amplitude * (2 raisedTo: 10*t) * ((s - t) / period) sin! !!TSElasticInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2 - 1.	^ (t < 0		ifTrue: [ amplitude * (2 raisedTo: 10 * t) * ((s - t)/period) sin ]		ifFalse: [ 2 - (amplitude * (2 raisedTo: -10 * t) * ((s + t)/period) sin )   ]) / 2.! !!TSElasticInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ 1 - (amplitude * (2 raisedTo: -10 * t ) * ((t + s) / period) sin )! !!TSElasticInterpolator methodsFor: 'accessing'!period	^ period! !!TSElasticInterpolator methodsFor: 'accessing'!period: p	period := p.	self calculateS.! !!TSExpInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ 2 raisedTo: (10 * t - 10).! !!TSExpInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2. 	^ (t <= 1		ifTrue: [ 2 raisedTo: 10 * t - 10 ]		ifFalse: [ 2 - (2 raisedTo: 10 - (10 * t)) ])/2! !!TSExpInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ 1 - (2 raisedTo: -10 * t).! !!TSPolyInterpolator methodsFor: 'accessing'!exponent	^ exponent! !!TSPolyInterpolator methodsFor: 'accessing'!exponent: aNumber	exponent := aNumber! !!TSPolyInterpolator methodsFor: 'initialization'!initialize	super initialize.	self exponent: 3.! !!TSPolyInterpolator methodsFor: 'interpolation'!interpolateIn: i	^ i raisedTo: exponent.! !!TSPolyInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i * 2.	^ (t <= 1		ifTrue: [ t raisedTo: exponent ]		ifFalse: [ 2 - ( ( 2 - t) raisedTo: exponent ) ]) / 2	! !!TSPolyInterpolator methodsFor: 'interpolation'!interpolateOut:  t	^ 1 - ((1 -t) raisedTo: exponent).! !!TSQuadInterpolator methodsFor: 'interpolation'!interpolateIn: t	 ^ t*t! !!TSQuadInterpolator methodsFor: 'interpolation'!interpolateInOut: i	| t |	t := i *2.	^ (t <= 1 		ifTrue: [ t*t ]		ifFalse: [ 			t := t-1.			t * (2- t)+1 ]) /2	! !!TSQuadInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ t * (2 - t)! !!TSSinInterpolator methodsFor: 'interpolation'!interpolateIn: t	^ 1 - (t * Float halfPi) cos! !!TSSinInterpolator methodsFor: 'interpolation'!interpolateInOut: t	^ (1 - (Float pi * t) cos ) / 2.! !!TSSinInterpolator methodsFor: 'interpolation'!interpolateOut: t	^ (t * Float halfPi) sin! !!TSLinearInterpolator methodsFor: 'interpolation'!interpolate: aNumber	^ aNumber! !!TSAnimationEvent methodsFor: 'accessing'!animation	^ animation! !!TSAnimationEvent methodsFor: 'accessing'!animation: anAnimation	animation := anAnimation.! !"Roassal3-Animation"!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!TMarkeable commentStamp: '' prior: 0!I am a trait to create markers in some especific classes!!TSBorder commentStamp: '' prior: 0!I represent borders and line styles!!TSCornerRadius commentStamp: '' prior: 0!I have information about the corner radius and methods to create it!!TSMarker commentStamp: '' prior: 0!I represent a marker for TSLine, TSPolygon and TSBezier!!TSShape commentStamp: '' prior: 0!I am the top class of shapes!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!TSAbstractLine commentStamp: '' prior: 0!I represent the abstract lines that have start and end points!!TSBezier commentStamp: '' prior: 0!TSBezier represents a bezier lines of one and 2 control points!!TSPolyline commentStamp: '' prior: 0!TODO!!TSAbstractDualLine commentStamp: '' prior: 0!I am an abtract shape that has an start and one end!!TSLine commentStamp: '' prior: 0!TSLine describes a line.!!TSSVGPathLine commentStamp: '' prior: 0!I represent path a complex line from one point to another with an svg path!!TSBimetricLine commentStamp: '' prior: 0!I am a line with different sizes in each side.Here is how to use it, from Roassal code```| view e1 e2 box l |	view := RSView new.	box := RSShapeBuilder box 		size: 100;		draggable.	e1 := box element.	e1 color: Color blue.	e2 := box element.	e2 translateTo: 400@0.	l := RSSingleEdgeBuilder bimetricLine		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: e1;		to: e2;		edge.	view addAll: { e1. e2. l}.	view @ RSControlsView. 	view open```!!TSBoundingShape commentStamp: '' prior: 0!My subclasses has an extent and a transformation matrix!!TSBitmap commentStamp: '' prior: 0!I can draw Forms!!TSBox commentStamp: '' prior: 0!I represent a visual component box in a canvas!!TSComposite commentStamp: '' prior: 0!I am a shape with a lot of shapes!!TSEllipse commentStamp: '' prior: 0!I am an ellipse shape!!TSLabel commentStamp: '' prior: 0!I represent simple label text!!TSPieSlice commentStamp: '' prior: 0!A ring shape to draw ring in a circle shape, not in a ellipse.!!TSPolygon commentStamp: '' prior: 0!TODO!!TSSVGPath commentStamp: '' prior: 0!TODO!!TSStrokeStyle commentStamp: '' prior: 0!I represent different styles for the stroke!!TSGroup commentStamp: '' prior: 0!A TSGroup represents collections of Roassal elements. A RTGroup is not designed to contain other things than Roassal elements. A TSGroup is polymorphic to RSElement. When an RSElement is expected, one can provide an RTGroup.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!TMarkeable methodsFor: 'accessing - markers'!marker: aMarker	| m |	m := aMarker asMarker. 	self 		markerStart: m;		markerMid: m;		markerEnd: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markerEnd	^ self markers third.! !!TMarkeable methodsFor: 'accessing - markers'!markerEnd: marker	| m| 	m := marker asMarker.	self markers at: 3 put: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markerMid	^ self markers second.! !!TMarkeable methodsFor: 'accessing - markers'!markerMid: marker	| m| 	m := marker asMarker.	self markers at: 2 put: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markerStart 	^ self markers first.! !!TMarkeable methodsFor: 'accessing - markers'!markerStart: marker	| m| 	m := marker asMarker.	self markers at: 1 put: m.	^ m! !!TMarkeable methodsFor: 'accessing - markers'!markers	^ nil! !!TSBorder methodsFor: 'visiting'!accept: visitor	^ visitor visitBorder: self! !!TSBorder methodsFor: 'style-cap'!capButt	self pStyle capStyle: #capButt.! !!TSBorder methodsFor: 'style-cap'!capRound	self pStyle capStyle: #capRound.! !!TSBorder methodsFor: 'style-cap'!capSquare	self pStyle capStyle: #capSquare.! !!TSBorder methodsFor: 'accessing'!color	^ paint! !!TSBorder methodsFor: 'accessing'!color: aColor	paint := aColor.	paint isColor ifTrue: [ ^ self ].	paint := Color colorFrom: aColor.! !!TSBorder methodsFor: 'style-dashes'!dashArray: arrayOfNumbers	self pStyle dashArray: arrayOfNumbers	! !!TSBorder methodsFor: 'accessing'!dashOffset	^ self pStyle dashOffset! !!TSBorder methodsFor: 'accessing'!dashOffset: offset	self pStyle dashOffset: offset! !!TSBorder methodsFor: 'initialization'!initialize	super initialize.	paint := Color black.	width := 1.	style := nil! !!TSBorder methodsFor: 'style-join'!joinBevel	self pStyle joinStyle: #joinBevel! !!TSBorder methodsFor: 'style-join'!joinMiter	self pStyle joinStyle: #joinMiter! !!TSBorder methodsFor: 'style-join'!joinRound	self pStyle joinStyle: #joinRound! !!TSBorder methodsFor: 'private'!pStyle 	^ style ifNil: [ style := TSStrokeStyle new ].! !!TSBorder methodsFor: 'accessing'!paint 	^ paint! !!TSBorder methodsFor: 'accessing'!paint: aPaint	paint := aPaint! !!TSBorder methodsFor: 'accessing'!style	^style! !!TSBorder methodsFor: 'accessing'!style: aStyle	style := aStyle! !!TSBorder methodsFor: 'accessing'!width 	^ width! !!TSBorder methodsFor: 'accessing'!width: anInteger 	width := anInteger! !!TSCornerRadius methodsFor: 'accessing'!bottom: aNumber	bottomLeft := bottomRight := aNumber! !!TSCornerRadius methodsFor: 'accessing'!bottomLeft 	^ bottomLeft! !!TSCornerRadius methodsFor: 'accessing'!bottomLeft: aNumber	bottomLeft := aNumber! !!TSCornerRadius methodsFor: 'accessing'!bottomRight	^ bottomRight ! !!TSCornerRadius methodsFor: 'accessing'!bottomRight: aNumber	bottomRight := aNumber! !!TSCornerRadius methodsFor: 'initialization'!initialize	super initialize.	self radius: 0.! !!TSCornerRadius methodsFor: 'accessing'!left: aNumber	topLeft := bottomLeft := aNumber! !!TSCornerRadius methodsFor: 'accessing'!max	^ topLeft max: (topRight max: (bottomLeft max: bottomRight))! !!TSCornerRadius methodsFor: 'accessing'!min	^ topLeft min: (topRight min: (bottomLeft min: bottomRight))! !!TSCornerRadius methodsFor: 'accessing'!radius: aNumber	topLeft := topRight := bottomLeft := bottomRight := aNumber! !!TSCornerRadius methodsFor: 'accessing'!right: aNumber	topRight := bottomRight := aNumber! !!TSCornerRadius methodsFor: 'accessing'!top: aNumber	topLeft := topRight := aNumber! !!TSCornerRadius methodsFor: 'accessing'!topLeft	^ topLeft ! !!TSCornerRadius methodsFor: 'accessing'!topLeft: aNumber	topLeft := aNumber! !!TSCornerRadius methodsFor: 'accessing'!topRight	^ topRight! !!TSCornerRadius methodsFor: 'accessing'!topRight: aNumber	topRight := aNumber! !!TSMarker methodsFor: 'converting'!asMarker	^ self! !!TSMarker methodsFor: 'initialization'!initialize	super initialize.	offset := 0.	offsetRatio :=0.! !!TSMarker methodsFor: 'accessing'!offset	^ offset! !!TSMarker methodsFor: 'accessing'!offset: anObject	offset := anObject! !!TSMarker methodsFor: 'accessing'!offsetRatio	^ offsetRatio! !!TSMarker methodsFor: 'accessing'!offsetRatio: aFloat	"[0 1] value"	offsetRatio := aFloat! !!TSMarker methodsFor: 'accessing'!shape	^ shape! !!TSMarker methodsFor: 'accessing'!shape: anObject	shape := anObject! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!TSAbstractControlPointsLine methodsFor: 'accessing'!controlPoints	^ controlPoints ifNil: [ #() ].! !!TSAbstractControlPointsLine methodsFor: 'accessing'!controlPoints: anArrayOfPoints	controlPoints := anArrayOfPoints collect: #asFloatPoint.	self resetPath.! !!TSAbstractControlPointsLine methodsFor: 'accessing'!endPoint	^ self controlPoints last! !!TSAbstractControlPointsLine methodsFor: 'accessing'!endPoint: aPoint	self controlPoints 		at: self controlPoints size		put: aPoint.	self resetPath.! !!TSAbstractControlPointsLine methodsFor: 'testing'!isControlPointsLine	^ true! !!TSAbstractControlPointsLine methodsFor: 'accessing'!startPoint	^ self controlPoints first! !!TSAbstractControlPointsLine methodsFor: 'accessing'!startPoint: aPoint	self controlPoints at: 1 put: aPoint.	self resetPath.! !!TSBezier methodsFor: 'visiting'!buildPathOn: visitor	visitor buildBezierPath: self.! !!TSBezier methodsFor: 'accessing'!controlPoints: anArrayOfPoints	self		assert: anArrayOfPoints notNil 		description: 'The argument can not be nil';		assert: (anArrayOfPoints size between: 2 and: 4)		description: 'The array size must be between 2 and 4 points'.	super controlPoints: anArrayOfPoints! !!TSBezier methodsFor: 'initialization'!initialize	super initialize.	controlPoints := { 0@0. 100@100 }.! !!TSBezier methodsFor: 'accessing - markers'!markers	^ markers ifNil: [ markers := Array new: 3 ].! !!TSBezier methodsFor: 'accessing - markers'!privateMarkers	^ markers! !!TSPolyline methodsFor: 'visiting'!buildPathOn: visitor	visitor buildPolyinePath: self! !!TSPolyline methodsFor: 'accessing'!cornerRadii	^ radius ifNil: [ 0 ].! !!TSPolyline methodsFor: 'accessing'!cornerRadii: aNumber	radius := aNumber abs! !!TSPolyline methodsFor: 'accessing - markers'!markers	^ markers ifNil: [ markers := Array new: 3 ].! !!TSPolyline methodsFor: 'accessing - markers'!privateMarkers	^ markers! !!TSAbstractDualLine methodsFor: 'accessing'!controlPoints 	^ Array with: self startPoint with: self endPoint! !!TSAbstractDualLine methodsFor: 'accessing'!endPoint	^ endPoint! !!TSAbstractDualLine methodsFor: 'accessing'!endPoint: point	endPoint := point.	self resetPath.	self notifyExtentChanged.! !!TSAbstractDualLine methodsFor: 'initialization'!initialize	super initialize.	startPoint := 0@0.	endPoint := 100@100.! !!TSAbstractDualLine methodsFor: 'transforming'!position	^ self encompassingRectangle rsCenter! !!TSAbstractDualLine methodsFor: 'accessing'!startPoint 	^ startPoint! !!TSAbstractDualLine methodsFor: 'accessing'!startPoint: point	startPoint := point.	self resetPath! !!TSAbstractDualLine methodsFor: 'transforming'!translateBy: delta	self		startPoint: startPoint + delta;		endPoint: endPoint + delta.	self resetPath! !!TSAbstractDualLine methodsFor: 'transforming'!translateTo: delta	| center |	center := (startPoint + endPoint ) /2.	self translateBy: delta - center! !!TSLine methodsFor: 'visiting'!buildPathOn: visitor	visitor buildLinePath: self! !!TSLine methodsFor: 'accessing'!markers	^ markers ifNil: [ markers := Array new: 3 ].! !!TSLine methodsFor: 'accessing'!privateMarkers	^ markers! !!TSBimetricLine methodsFor: 'initialization'!initialize	super initialize.	widthFrom := widthTo := 0.	self svgPath: [ :from :to | 		| e w1 w2 dist z |		e := 0.001.		w1 := widthTo max: e.		w2 := widthFrom max: e.		dist := from distanceTo: to.		dist := dist max: e.		z := (w1 + w2)*2.		z > dist ifTrue: [ 			w1 := w1 * dist / z.			w2 := w2 * dist / z.			 ].				[ :builder | | first side |			first := true.			side := [ :vector :end :size |				| left right u unit middle l r |				u := vector normal.				unit := vector / (vector r max: e).				middle := end - (unit * size).				left := (middle - (u * size)) asFloatPoint.				l := (end - (u * size)) asFloatPoint.				right := (middle + (u * size)) asFloatPoint.				r := (end + (u * size)) asFloatPoint.				first 					ifTrue: [ builder moveTo: left ]					ifFalse: [ builder lineTo: left ].				builder					curveVia: l to: end;					curveVia: r to: right.				 ].			builder absolute.			side value: to - from value: to value: w1 / 2.			first := false.			side value: from - to value: from value: w2 / 2.			builder close.						].		].! !!TSBimetricLine methodsFor: 'accessing'!widthFrom	^ widthFrom! !!TSBimetricLine methodsFor: 'accessing'!widthFrom: aNumber	widthFrom := aNumber! !!TSBimetricLine methodsFor: 'accessing'!widthTo	^ widthTo! !!TSBimetricLine methodsFor: 'accessing'!widthTo: aNumber	widthTo := aNumber! !!TSSVGPathLine methodsFor: 'visiting'!buildPathOn: visitor	visitor buildSVGLinePath: self.! !!TSSVGPathLine methodsFor: 'accessing'!svgPath	^svgPath! !!TSSVGPathLine methodsFor: 'accessing'!svgPath: aBlock	"aBlock return a string and recives 2 arguments, the start point and the end point"	svgPath := aBlock 	! !!TSAbstractLine methodsFor: 'visiting'!accept: visitor	visitor visitLine: self.! !!TSAbstractLine methodsFor: 'style-cap'!capButt	self border capButt! !!TSAbstractLine methodsFor: 'style-cap'!capRound	self border capRound! !!TSAbstractLine methodsFor: 'style-cap'!capSquare	self border capSquare! !!TSAbstractLine methodsFor: 'accessing'!color	^ self strokePaint! !!TSAbstractLine methodsFor: 'accessing'!color: aColor	self strokePaint: aColor! !!TSAbstractLine methodsFor: 'accessing'!controlPoints	^ self subclassResponsibility! !!TSAbstractLine methodsFor: 'style-dashes'!dashArray: arrayOfNumbers	self border dashArray: arrayOfNumbers	! !!TSAbstractLine methodsFor: 'accessing'!encompassingRectangle	| cp |	cp := self controlPoints.	cp ifEmpty: [ ^ Rectangle center: 0@0 extent: 0@0 ].	^ Rectangle encompassing: cp! !!TSAbstractLine methodsFor: 'accessing'!endPoint	^ self subclassResponsibility! !!TSAbstractLine methodsFor: 'accessing'!endPoint: aPoint	self subclassResponsibility! !!TSAbstractLine methodsFor: 'testing'!hasMarkers	| m |	m := self privateMarkers.	^ m notNil and: [ 		m anySatisfy: [ :mar | mar notNil ].  ]! !!TSAbstractLine methodsFor: 'initialization'!initialize 	super initialize.	paint := nil.	border := TSBorder new.	! !!TSAbstractLine methodsFor: 'testing'!isControlPointsLine	^ false! !!TSAbstractLine methodsFor: 'style-join'!joinBevel	self border joinBevel! !!TSAbstractLine methodsFor: 'style-join'!joinMiter	self border joinMiter! !!TSAbstractLine methodsFor: 'style-join'!joinRound	self border joinRound! !!TSAbstractLine methodsFor: 'actions'!loadShape: other	self shouldBeImplemented ! !!TSAbstractLine methodsFor: 'event handling'!notifyExtentChanged	self announce: [ TSExtentChangedEvent new 		shape: self;		oldExtent: nil;		newExtent: self controlPoints first - self controlPoints last ]! !!TSAbstractLine methodsFor: 'private'!privateMarkers	^ nil! !!TSAbstractLine methodsFor: 'accessing'!startPoint	^ self subclassResponsibility! !!TSAbstractLine methodsFor: 'accessing'!startPoint: aPoint	self subclassResponsibility! !!TSAbstractLine methodsFor: 'accessing'!strokeColor: aColor	self strokePaint: aColor! !!TSAbstractLine methodsFor: 'accessing'!strokePaint	^ self border paint! !!TSAbstractLine methodsFor: 'accessing'!strokePaint: aPaint	self border paint: aPaint.! !!TSAbstractLine methodsFor: 'accessing'!width: aNumber	self border width: aNumber.! !!TSBitmap methodsFor: 'private'!computeRectangle	extent := form 		ifNil: [ 0@0 ]		ifNotNil: [ form extent ]! !!TSBitmap methodsFor: 'accessing'!extent: newExtent	| oldExtent |	oldExtent := self extent.	(oldExtent = (0 @ 0)) ifTrue: [ ^ self ].	matrix scaleBy: newExtent / oldExtent.! !!TSBitmap methodsFor: 'accessing'!form	^ form! !!TSBitmap methodsFor: 'accessing'!form: aForm	aForm ifNil: [ ^ self ].	form := aForm.	self computeRectangle.! !!TSBitmap methodsFor: 'accessing'!paintOn: visitor	^ visitor paintForBitmap: self! !!TSBitmap methodsFor: 'visiting'!path	^ self baseRectangle! !!TSBoundingShape methodsFor: 'visiting'!accept: visitor	visitor visitBoundingShape: self! !!TSBoundingShape methodsFor: 'accessing'!baseRectangle	^ Rectangle rsCenter: 0@0 extent: extent! !!TSBoundingShape methodsFor: 'accessing'!encompassingRectangle 	^ Rectangle rsCenter: self position extent: extent.! !!TSBoundingShape methodsFor: 'accessing'!extent	^ extent! !!TSBoundingShape methodsFor: 'accessing'!extent: aPoint	| oldExtent |	extent = aPoint ifTrue: [ ^ self ].	self assert: aPoint isPoint.	oldExtent := extent.	extent := aPoint.	self resetPath.	self announce: [ TSExtentChangedEvent new 		shape: self;		oldExtent: oldExtent;		newExtent: extent ]! !!TSBoundingShape methodsFor: 'accessing'!height: aNumber	self extent: self extent x @ aNumber! !!TSBoundingShape methodsFor: 'testing'!includesPoint: aPoint	| invertedPoint |	invertedPoint := matrix inverseTransform: aPoint.	^ self baseRectangle containsPoint: invertedPoint.! !!TSBoundingShape methodsFor: 'initialization'!initialize	super initialize.	self initializeMatrix.	extent := 0@0! !!TSBoundingShape methodsFor: 'initialization'!initializeMatrix	matrix := AthensAffineTransform new! !!TSBoundingShape methodsFor: 'actions'!loadBoundingShape: aShape	self 		extent: aShape extent;		matrix: aShape matrix;		border: aShape border;		paint: aShape paint;		announcer: aShape announcer;		parent: aShape parent.! !!TSBoundingShape methodsFor: 'actions'!loadShape: aShape	self loadBoundingShape: aShape.! !!TSBoundingShape methodsFor: 'matrix'!matrix	^ matrix! !!TSBoundingShape methodsFor: 'matrix'!matrix: aMatrix	matrix := aMatrix! !!TSBoundingShape methodsFor: 'matrix'!matrixDo: aBlock	aBlock value: matrix! !!TSBoundingShape methodsFor: 'matrix'!position 	^ matrix translation! !!TSBoundingShape methodsFor: 'matrix'!position: aPoint	matrix translation: aPoint! !!TSBoundingShape methodsFor: 'matrix'!rotateByDegrees: angle	matrix rotateByDegrees: angle.! !!TSBoundingShape methodsFor: 'matrix'!scale	^ matrix scale! !!TSBoundingShape methodsFor: 'matrix'!scaleBy: scale 	matrix scaleBy: scale! !!TSBoundingShape methodsFor: 'accessing'!shapes	"only TSComposite can use shapes "	^ nil! !!TSBoundingShape methodsFor: 'accessing'!size: anInteger	self extent: anInteger asPoint! !!TSBoundingShape methodsFor: 'accessing'!translateBy: delta	self translateTo: self position + delta.	! !!TSBoundingShape methodsFor: 'accessing'!translateTo: aPoint	| oldPosition |	oldPosition := self position.	oldPosition = aPoint ifTrue: [ ^ self ].	self position: aPoint.	self announce: [TSPositionChangedEvent new 		shape: self; 		oldPosition: oldPosition;		newPosition: aPoint ].! !!TSBoundingShape methodsFor: 'accessing'!width: aNumber	self extent: aNumber @ self extent y! !!TSBox methodsFor: 'visiting'!buildPathOn: visitor	visitor buildBoxPath: self! !!TSBox methodsFor: 'accessing'!cornerRadius	^ cornerRadius! !!TSBox methodsFor: 'accessing'!cornerRadius: aTSCornerRadius	aTSCornerRadius isNumber ifTrue: [ 		cornerRadius := TSCornerRadius new radius: aTSCornerRadius.		^ self	 ].	cornerRadius := aTSCornerRadius ! !!TSBox methodsFor: 'testing'!hasCornerRadius	^ cornerRadius notNil and: [ cornerRadius max > 0 and: [(cornerRadius min < 0) not] ].! !!TSComposite methodsFor: 'adding'!add: aShape	aShape addedIn: self! !!TSComposite methodsFor: 'adding'!addAll: aCollection	aCollection do: [ :s| self add: s trachelShape ].! !!TSComposite methodsFor: 'adding'!addBasicShape: aShape	self shapes add: aShape! !!TSComposite methodsFor: 'adding'!addFixedShape: aShape	self error: 'Composite can not add a fixed shape'! !!TSComposite methodsFor: 'initialization'!initialize	super initialize.	paint := nil.	self resetPath.	! !!TSComposite methodsFor: 'accessing'!padding: anObject	"anObject can be a number, a point or Margin"	"Shapes should be set in the composite before calling #padding:"		| margin rect center temp |	temp := shapes 		ifNil: [ TSGroup new:0 ]		ifNotNil: [shapes].	margin := anObject asMargin. 	rect := temp encompassingRectangle.	rect := margin expandRectangle: rect.	self extent: rect extent.		(center := rect rsCenter) = (0@0) ifTrue: [ ^ self ].	center := center negated.	temp do: [ :s | s translateBy: center ].! !!TSComposite methodsFor: 'removing'!removeShape: shape	| evt |	shapes remove: shape.	shape parent: nil.	evt := TSShapeRemovedEvent new shape: shape.	self announce: evt.	shape announce: evt.	! !!TSComposite methodsFor: 'path'!resetPath	path := Rectangle rsCenter: 0@0 extent: extent asFloatPoint.! !!TSComposite methodsFor: 'accessing - computed'!shapeWithAction: eventClass forPosition: position	| res pos |	pos := self matrix inverseTransform: position.	self shapes reverseDo: [ :s |		res := s shapeWithAction: eventClass forPosition: pos.		res ifNotNil: [ ^ res] ].		^ super shapeWithAction: eventClass forPosition: position.! !!TSComposite methodsFor: 'accessing - computed'!shapeWithActionForPosition: position	| res pos |	pos := self matrix inverseTransform: position.	self shapes reverseDo: [ :s |		res := s shapeWithActionForPosition: pos.		res ifNotNil: [ ^ res] ].	^ super shapeWithActionForPosition: position.! !!TSComposite methodsFor: 'accessing'!shapes	^ shapes ifNil: [ shapes := TSGroup new ]! !!TSComposite methodsFor: 'accessing'!shapes: aTSGroup	"	create a groups of elements or trachel shapes, then added them to this composite shape	this method changes the position of the shapes and set the position of this composite shape	to the center of the encompassingRectangle.	"	| rect delta |	rect := aTSGroup encompassingRectangle.	delta := rect rsCenter.	aTSGroup do: [ :s | 		s isInACanvas ifTrue: [ s remove ].		s translateBy: delta negated ].	self 		extent: rect extent;		translateTo: delta.	self addAll: aTSGroup.	! !!TSEllipse methodsFor: 'visiting'!buildPathOn: visitor	visitor buildEllipsePath: self! !!TSEllipse methodsFor: 'testing'!includesPoint: aPoint	"Implementation is taken over from EllipseMorph>>containsPoint:"	| invertedPoint radius other delta xOverY t1 t2 rect |	invertedPoint := matrix inverseTransform: aPoint.	rect := self baseRectangle.	(rect containsPoint: invertedPoint) ifFalse: [ ^ false ]. "quick elimination"	radius := rect height asFloat / 2.	other := rect width asFloat / 2.	delta := invertedPoint - rect topLeft - (other@radius).	xOverY := rect width asFloat / rect height asFloat.	t1 := (delta x asFloat / xOverY) squared + delta y squared.	t2 := radius squared.	^ (t1 < t2)  or: [ t1 closeTo: t2 ].! !!TSEllipse methodsFor: 'accessing'!radius	^ self extent x / 2! !!TSEllipse methodsFor: 'accessing'!radius: integer	self extent: integer * 2 asPoint! !!TSLabel class methodsFor: 'public'!familyFontName	"	self familyFontName	"	| fontList |	fontList := LogicalFontManager current allFamilies collect: #familyName.		(fontList includes: 'Source Sans Pro') ifTrue: [ ^ 'Source Sans Pro' ].	(fontList includes: 'DejaVu Sans') ifTrue: [ ^ 'DejaVu Sans' ].	fontList ifEmpty: [ ^ StandardFonts defaultFont familyName ].		(fontList includes: StandardFonts listFont familyName ) 		ifTrue: [ ^ StandardFonts listFont familyName ].				^  StandardFonts defaultFont familyName ! !!TSLabel methodsFor: 'visiting'!accept: visitor	visitor visitLabel: self.! !!TSLabel methodsFor: 'managing font'!bold	self emphasis: (Array with: TextEmphasis bold).! !!TSLabel methodsFor: 'accessing'!descent	^ font descent! !!TSLabel methodsFor: 'accessing'!emphasis	^ emphasis! !!TSLabel methodsFor: 'accessing'!emphasis: anEmphasis	emphasis := anEmphasis isCollection		ifTrue: [ anEmphasis ]		ifFalse: [ Array with: anEmphasis ].	self resetCache.! !!TSLabel methodsFor: 'accessing'!font	^ font! !!TSLabel methodsFor: 'accessing'!font: aFont	font := aFont! !!TSLabel methodsFor: 'accessing'!fontName	^ fontName! !!TSLabel methodsFor: 'accessing'!fontName: string	"	LogicalFontManager current allFamilies inspect	"	fontName := string.	self resetCache.	! !!TSLabel methodsFor: 'accessing'!fontSize	^ fontSize ! !!TSLabel methodsFor: 'accessing'!fontSize: integer	fontSize := integer.	self resetCache! !!TSLabel methodsFor: 'initialization'!initialize	super initialize.	text := nil.	fontSize := 12.	emphasis := #().	self fontName: self class familyFontName.! !!TSLabel methodsFor: 'managing font'!italic	self emphasis: (Array with: TextEmphasis italic).! !!TSLabel methodsFor: 'managing font'!resetCache 	font := LogicalFont 		familyName: fontName		pointSize: fontSize.		font := font emphasized: (emphasis inject: 0 into: [:sum :next | sum + next emphasisCode]).	cachedWidth := nil.	cachedHeight := nil.	self extent: self textWidth @ self textHeight.! !!TSLabel methodsFor: 'accessing'!text	^ text! !!TSLabel methodsFor: 'accessing'!text: string	text = string ifTrue: [ ^ self ].	text := string.	self resetCache; resetPath.! !!TSLabel methodsFor: 'accessing'!textHeight	"without any transformation"	^ cachedHeight		ifNil: [ [ cachedHeight := font height ]				on: Error				do: [ :ex | cachedHeight := 10 ] ]! !!TSLabel methodsFor: 'accessing'!textWidth	"without any transformation"	"font widthOfString: is a really expensive operation, so we cache it"	^ cachedWidth		ifNil: [ [ cachedWidth := font widthOfString: text ]				on: Error				do: [ :ex | cachedWidth := 5 ] ]! !!TSPieSlice methodsFor: 'accessing'!alphaAngle	^ alphaAngle! !!TSPieSlice methodsFor: 'accessing'!alphaAngle: stAngle	"Starting angle"	| old |	old := alphaAngle.	alphaAngle := stAngle.	old = alphaAngle ifTrue: [ ^ self ].	self resetPath.! !!TSPieSlice methodsFor: 'public'!arcRadiusAuto	| e i |	e := externalRadius .	i := innerRadius.	self cornerRadii: ((i * i) + (e * e)) sqrt! !!TSPieSlice methodsFor: 'accessing'!betaAngle	^ betaAngle! !!TSPieSlice methodsFor: 'accessing'!betaAngle: ndAngle	"Finishing angle"	| old |	old := betaAngle.	betaAngle := ndAngle.	old = betaAngle ifTrue: [ ^ self ].	self resetPath.! !!TSPieSlice methodsFor: 'visiting'!buildPathOn: visitor	visitor buildRingPath: self! !!TSPieSlice methodsFor: 'accessing'!centroid: off	| r a |	r := (innerRadius + externalRadius)/2 + off.	a := ((alphaAngle + betaAngle) / 2) degreesToRadians.	^ (a cos @ (a sin negated) * r).! !!TSPieSlice methodsFor: 'accessing'!cornerRadii	^ cornerRadii! !!TSPieSlice methodsFor: 'accessing'!cornerRadii: aNumber	| old |	self 		assert: [ aNumber >= 0 ]		description: 'Corner radius must be a non-negative!!'.	old := cornerRadii.	cornerRadii := aNumber.	old = cornerRadii ifTrue: [ ^ self ].	self resetPath.! !!TSPieSlice methodsFor: 'accessing'!extent: aPoint	super extent: aPoint.	externalRadius := (aPoint x min: aPoint y)/2.! !!TSPieSlice methodsFor: 'accessing'!externalRadius	^ externalRadius! !!TSPieSlice methodsFor: 'accessing'!externalRadius: eR	self extent: (eR * 2) asPoint.! !!TSPieSlice methodsFor: 'testing'!includesPoint: aPoint	| invertedPoint a b i e n d |	invertedPoint := matrix inverseTransform: aPoint.	(self baseRectangle containsPoint: invertedPoint)		ifFalse: [ ^ false ].	i := innerRadius.	e := externalRadius.	d := invertedPoint dist: 0@0.	(d between: i and: e)		ifFalse: [ ^ false ].		n := invertedPoint angle negated radiansToDegrees.	a := alphaAngle.	b := betaAngle.		n := (360 + (n % 360))%360.	a := (3600000 + a) % 360.	b := (3600000 + b) % 360.		^ a < b 		ifTrue: [ (a <= n) & (n<=b) ]		ifFalse: [ (a<=n) | (n <= b) ]	! !!TSPieSlice methodsFor: 'initialization'!initialize	super initialize.	cornerRadii := innerRadius := externalRadius := betaAngle := alphaAngle := segmentSpacing := 0.	! !!TSPieSlice methodsFor: 'accessing'!innerRadius	^ innerRadius! !!TSPieSlice methodsFor: 'accessing'!innerRadius: iR	| old |	old := innerRadius.	innerRadius := iR asFloat.	old = innerRadius ifTrue: [ ^ self ].	self resetPath.! !!TSPieSlice methodsFor: 'accessing'!segmentSpacing	^ segmentSpacing! !!TSPieSlice methodsFor: 'accessing'!segmentSpacing: anAngleInDegrees	| old |	old := segmentSpacing.	segmentSpacing := anAngleInDegrees.	old = segmentSpacing ifTrue: [ ^self ].	self resetPath.! !!TSPolygon class methodsFor: 'utilities'!fitPolygonToSquare: points	| maxx minx maxy miny sx sy x y |	minx := maxx :=  points first x.	miny := maxy :=  points first y.	points do: [ :p | 		minx := minx min: p x.		miny := miny min: p y.		maxx := maxx max: p x.		maxy := maxy max: p y ].	"stretch factors"	sx := 2/(maxx - minx).	sy := 2/(maxy - miny).	points doWithIndex: [ :p :i|		x := p x * sx.		y := p y * sy.		points at: i put: x@y.		minx := minx min: x.		miny := miny min: y.		maxx := maxx max: x.		maxy := maxy max: y ].	miny < -1 ifTrue: [ 		points doWithIndex: [ :p :i |			points at: i put: p x @ ( p y - 1 - miny ) ] ].	^ points.! !!TSPolygon class methodsFor: 'utilities'!generatePointsFitSquare: sides	| points |	points := self generateUnitNgonPoints: sides rotation: 0.	points := self fitPolygonToSquare: points.	^ points! !!TSPolygon class methodsFor: 'utilities'!generateUnitNgonPoints: sides rotation: rotationAngle		^ self generateUnitNgonPoints: sides  rotation: rotationAngle		angle: [ :a :i | a negated ] 		radius: [ :a :i | 1 ]! !!TSPolygon class methodsFor: 'utilities'!generateUnitNgonPoints: sides rotation: rotationAngle angle: angleBloc radius: radiusBloc	"sides a Number	rotation is a number in radians	angle is a function of 2 args(current angle and index of angle) this return an angle	radius is a function of 2 args (current angle and index of angle) this retunr a number "	| increment startAngle points currentAngle currentRadius |	increment := 1.0 / sides * 2 * Float pi.	startAngle := sides even		ifTrue: [ (Float pi / 2) + (increment / 2) ]		ifFalse: [ Float pi / 2 ].	startAngle := startAngle + rotationAngle.	points := Array new: sides.	0 to: sides - 1 do: [ :i | 		currentAngle := i * increment + startAngle.		currentAngle := angleBloc value: currentAngle value: i.		currentRadius := radiusBloc value: currentAngle value: i.		points at: i+1 put: (currentAngle cos @ currentAngle sin) * currentRadius ].	^ points! !!TSPolygon methodsFor: 'visiting'!buildPathOn: visitor	visitor buildPolygonPath: self.! !!TSPolygon methodsFor: 'public'!centerPoints	| r center |	r := Rectangle encompassing: points.	center := r rsCenter.	points doWithIndex: [ :p :i | 		points at: i put: p - center.		 ].	^ r.! !!TSPolygon methodsFor: 'accessing'!cornerRadii 	^ radius ifNil: [ 0 ]! !!TSPolygon methodsFor: 'accessing'!cornerRadii: aNumber	radius := aNumber abs.! !!TSPolygon methodsFor: 'private'!extent: newExtent	| min max s |	extent = newExtent		ifTrue: [ ^ self ].	min := points min.	max := points max.	s := newExtent / (max - min).	points := points collect: [ :p | p * s ].	super extent: newExtent! !!TSPolygon methodsFor: 'testing'!includesPoint: aPoint	| res invertedPoint |	res := super includesPoint: aPoint.	res ifFalse: [ ^ false ].	invertedPoint := matrix inverseTransform: aPoint.	^ (AthensPolygonTester new polygon: points) includesPoint: invertedPoint! !!TSPolygon methodsFor: 'initialization'!initialize	super initialize.	points := #().! !!TSPolygon methodsFor: 'accessing'!points	^ points! !!TSPolygon methodsFor: 'accessing'!points: anArray	| rec |	self privatePoints: anArray.	rec := self centerPoints.	self		translateTo: rec rsCenter;		extent: rec extent! !!TSPolygon methodsFor: 'private'!privatePoints: anArray	points := anArray! !!TSSVGPath methodsFor: 'visiting'!buildPathOn: visitor	visitor buildSVGPath: self.! !!TSSVGPath methodsFor: 'private'!centerSegments	| rect absolute position |	rect := self segmentsRectangle.	position := rect rsCenter.	absolute := true.	segments do: [ :segment | 		| key args |		key := segment first.		args := segment second.		key = #absolute ifTrue: [ absolute := true ].		key = #relative ifTrue: [ absolute := false ].		absolute ifTrue: [ 			args doWithIndex: [ :point :index | 				point isPoint 					ifTrue: [ args at: index put: point - position ]					ifFalse: [ args at: index put: point - position x ] ] ] ].					polygons do: [ :polygon |		polygon doWithIndex: [ :point :index |			polygon at: index put: point - position ] ].	rect := self segmentsRectangle.	self position: position.	extent := rect extent.! !!TSSVGPath methodsFor: 'private'!computePolygons	| subPath absolute position point |	polygons := OrderedCollection new.	subPath := OrderedCollection new.	absolute := true.	position := 0@0.	point := [:da | position := absolute 		ifTrue:[ da ] 		ifFalse: [ position + da ].		subPath add: position ].	segments do: [ :segment | | key args |		key := segment first.		args := segment second.		key = #absolute ifTrue: [ absolute := true ].		key = #relative ifTrue: [ absolute := false ].				key = #moveTo: ifTrue: [ 			subPath ifNotEmpty: [ polygons add: subPath ]. 			subPath:= OrderedCollection new.			point value: args first ].		key = #curveVia:and:to: ifTrue: [ 			point value: args third ].		key = #curveVia:to: ifTrue: [ 			point value: args second ].		key = #lineTo: ifTrue: [ 			point value: args first ].		key = #reflectedCurveVia:to: ifTrue: [ 			point value: args second ].		key = #hLineTo: ifTrue: [			position := absolute				ifTrue: [ args first @ position y ]				ifFalse: [ position + (args first @ 0) ].			subPath add: position ].		key = #vLineTo: ifTrue: [ 			position := absolute				ifTrue: [ position x @ args first ]				ifFalse: [ position + (0 @ args first) ].			subPath add: position ].		].	polygons add: subPath	! !!TSSVGPath methodsFor: 'private'!computeSegments	| pathData | 	pathData := ASPathConverter new stream: svgPath readStream.	segments := pathData convertPathData.! !!TSSVGPath methodsFor: 'accessing'!extent: newExtent	| min max s |	extent = newExtent 		ifTrue: [ ^ self ].	min := self position - (extent / 2).	max := self position + (extent / 2).	s := newExtent / (max - min).	segments do: [ :segment | 		segment args doWithIndex: [ :point :index |			segment at: index put: point * s ] ].	polygons do: [ :polygon|		polygon doWithIndex: [ :point :index |			polygon at: index put: point * s ]  ].	super extent: newExtent.! !!TSSVGPath methodsFor: 'accessing'!segments	^ segments! !!TSSVGPath methodsFor: 'private'!segmentsRectangle	| allPoints |	allPoints := polygons flatCollect: [:poly | poly ].	^ Rectangle encompassing: allPoints! !!TSSVGPath methodsFor: 'accessing'!svgPath 	^ svgPath! !!TSSVGPath methodsFor: 'accessing'!svgPath: aString 	svgPath := aString.	self computeSegments.	self computePolygons.	self centerSegments.	self resetPath.! !!TSShape methodsFor: 'adding'!addedIn: aCanvas	self isFixed		ifTrue: [ aCanvas addFixedShape: self ]		ifFalse: [ aCanvas addBasicShape: self ].	parent ifNotNil: [ self remove ].	parent := aCanvas.! !!TSShape methodsFor: 'animation'!animation 	^ self animation: TSTransitionAnimation new.! !!TSShape methodsFor: 'animation'!animation: animation	parent animation: animation.	^ animation! !!TSShape methodsFor: 'events'!announce: anEvent	announcer ifNil: [ ^ self ].	announcer announce: anEvent value.! !!TSShape methodsFor: 'events'!announcer	announcer isNil ifTrue: [ announcer := Announcer new ].	^ announcer! !!TSShape methodsFor: 'events'!announcer: anAnnouncer	announcer := anAnnouncer! !!TSShape methodsFor: 'converting'!asMarker	^ TSMarker new shape: self! !!TSShape methodsFor: 'border'!border	^ border! !!TSShape methodsFor: 'border'!border: aBorder	border := aBorder! !!TSShape methodsFor: 'border'!borderDo: aBlock	border ifNil: [ border := TSBorder new ].	aBlock value: border! !!TSShape methodsFor: 'accessing'!color	^ paint ! !!TSShape methodsFor: 'accessing'!color: aColor	paint := aColor.	paint isColor ifTrue: [ ^ self ].	paint := Color colorFrom: aColor.! !!TSShape methodsFor: 'accessing'!encompassingRectangle	self subclassResponsibility! !!TSShape methodsFor: 'accessing'!extent	^ self encompassingRectangle extent! !!TSShape methodsFor: 'testing'!hasBorder	^ border notNil and: [ border width > 0 ].! !!TSShape methodsFor: 'testing'!hasEventCallback	"Return true if at least one event callback has been added to the shape"	^ announcer notNil and: [ announcer numberOfSubscriptions > 0 ]! !!TSShape methodsFor: 'accessing'!height	^ self extent y! !!TSShape methodsFor: 'testing'!includesPoint: aPoint	"Return true or false"	^ false! !!TSShape methodsFor: 'initialization'!initialize	super initialize.	paint := Color lightGray.	isFixed := false.! !!TSShape methodsFor: 'testing'!isFixed 	^ isFixed! !!TSShape methodsFor: 'accessing'!isFixed: aBool	isFixed := aBool! !!TSShape methodsFor: 'testing'!isInACanvas	^ parent notNil! !!TSShape methodsFor: 'actions'!loadShape: aShape	self subclassResponsibility! !!TSShape methodsFor: 'accessing'!noPaint	paint := nil! !!TSShape methodsFor: 'accessing'!paint	^ paint! !!TSShape methodsFor: 'accessing'!paint: aPaint	paint := aPaint! !!TSShape methodsFor: 'accessing'!paintOn: visitor	^ paint		! !!TSShape methodsFor: 'accessing'!parent	^ parent! !!TSShape methodsFor: 'accessing'!parent: aCanvasOrComposite	parent := aCanvasOrComposite! !!TSShape methodsFor: 'path'!path	^ path! !!TSShape methodsFor: 'path'!path: aPath	path := aPath! !!TSShape methodsFor: 'actions'!pushBack	parent pushBack: self.! !!TSShape methodsFor: 'actions'!pushFront	parent pushFront: self.! !!TSShape methodsFor: 'dependencies'!release	self class instVarNames do: [ :n | self instVarNamed: n put: nil ]! !!TSShape methodsFor: 'actions'!remove	"Do nothing if the line is not already in a canvas"	self isInACanvas ifFalse: [ ^ self ]. 	parent removeShape: self! !!TSShape methodsFor: 'path'!resetPath	path := nil! !!TSShape methodsFor: 'actions'!setAsFixed	parent ifNil: [ self error: 'Add first this shape in the canvas' ].	isFixed := true.	parent setAsFixed: self.! !!TSShape methodsFor: 'accessing - computed'!shapeWithAction: eventClass forPosition: position	^ (self hasEventCallback and: [ 		(self announcer handleEventClass: eventClass)			and: [ self includesPoint: position ] ]) 						ifTrue: [ self ]			ifFalse: [ ^ nil ]! !!TSShape methodsFor: 'accessing - computed'!shapeWithActionForPosition: position	^ (self hasEventCallback and: [ self includesPoint: position ] ) 			ifTrue: [ self ]			ifFalse: [ ^ nil ]! !!TSShape methodsFor: 'actions'!signalUpdate	"Refresh the canvas"	parent ifNil: [ ^ self ].	parent signalUpdate! !!TSShape methodsFor: 'accessing'!topParent	^ parent topParent! !!TSShape methodsFor: 'accessing'!trachelShape	^ self! !!TSShape methodsFor: 'events'!when: event do: aBlock	self announcer when: event do: aBlock! !!TSShape methodsFor: 'accessing'!width	^ self extent x! !!TSStrokeStyle methodsFor: 'accessing'!capStyle	^ capStyle! !!TSStrokeStyle methodsFor: 'accessing'!capStyle: symbol	capStyle := symbol! !!TSStrokeStyle methodsFor: 'accessing'!dashArray	^ dashArray! !!TSStrokeStyle methodsFor: 'accessing'!dashArray: array	dashArray := array! !!TSStrokeStyle methodsFor: 'accessing'!dashOffset	^ dashOffset! !!TSStrokeStyle methodsFor: 'accessing'!dashOffset: aNumber	dashOffset := aNumber! !!TSStrokeStyle methodsFor: 'initialization'!initialize	super initialize.	dashOffset := 0! !!TSStrokeStyle methodsFor: 'accessing'!joinStyle	^ joinStyle! !!TSStrokeStyle methodsFor: 'accessing'!joinStyle: symbol	joinStyle := symbol! !!TSGroup methodsFor: 'converting'!@ int	self do: [ :e | e @ int ].! !!TSGroup methodsFor: 'accessing'!add: element	self resetElementFromModelCache.	^ super add: element! !!TSGroup methodsFor: 'accessing'!addAll: elements	self resetElementFromModelCache.	^ super addAll: elements! !!TSGroup methodsFor: 'converting'!asElement 	^ self asElementOn: nil! !!TSGroup methodsFor: 'converting'!asElementOn: model	^ RSElement new 		model: model;		trachelShape: (TSComposite new 			shapes: self).! !!TSGroup methodsFor: 'accessing'!edges	^ self select: [ :o | o class == RSEdge ]! !!TSGroup methodsFor: 'accessing'!elementFromModel: anObject	"Return an element that corresponds to the object provided as parameter. If none is found, then return nil"		| t key|	self elementFromModelCache at: anObject ifPresent: [ :v |		v isCollection ifFalse: [ ^ v ] ].	"We have this line because of a bug of the implementation of CompiledMethod>>#="	t := (anObject class == CompiledMethod) 				ifTrue: [ self detect: [ :el | el model == anObject ] ifNone: [ nil ] ]				ifFalse: [ self detect: [ :el | el model = anObject ] ifNone: [ nil ] ].	"We have this hack for nil objects because in visualWorks a dictionary cannot have nil as a key"	key := anObject isNil ifTrue: [ 'KeyForNilObjects' ] ifFalse: [ anObject ].	self elementFromModelCache at: key put: t.	^ t! !!TSGroup methodsFor: 'accessing'!elementFromModelCache	"Define a cache for the element lookup from models"	elementFromModelCache ifNil: [ elementFromModelCache := Dictionary new ].	^ elementFromModelCache! !!TSGroup methodsFor: 'accessing'!elements	^ self select: [ :o | o class == RSElement ]! !!TSGroup methodsFor: 'accessing'!elementsFromModel: anObject	"Return an element that corresponds to the object provided as parameter. If none is found, then return nil"		| t key |	self elementFromModelCache at: anObject ifPresent: [ :v | v isCollection ifTrue: [ ^ v ] ].	"We have this line because of a bug of the implementation of CompiledMethod>>#="	t := (anObject class == CompiledMethod) 				ifTrue: [ self select: [ :el | el model == anObject ] ]				ifFalse: [ self select: [ :el | el model = anObject ] ].	"We have this hack for nil objects because in visualWorks a dictionary cannot have nil as a key"	key := anObject isNil ifTrue: [ 'KeyForNilObjects' ] ifFalse: [ anObject ].	self elementFromModelCache at: key put: t.	^ t! !!TSGroup methodsFor: 'accessing'!elementsFromModels: objects	"Return elements that corresponds to the objects provided as parameter. If none is found, then return an empty collection"	| answer t |	self assert: [ objects isCollection ] description: 'Provide a set of elements instead of one single element'. 	answer := TSGroup new.	objects do: [ :o |		t := self elementsFromModel: o.		t notNil ifTrue: [ answer addAll: t ] ].	^ answer! !!TSGroup methodsFor: 'accessing'!encompassingRectangle	^ self		ifEmpty: [ (0 @ 0) corner: (0 @ 0) ]		ifNotEmpty: [ 			| rec |			rec := Rectangle merging: (self collect: #encompassingRectangle) ]! !!TSGroup methodsFor: 'accessing'!extent	^ self encompassingRectangle extent! !!TSGroup methodsFor: 'accessing'!height 	^ self extent y! !!TSGroup methodsFor: 'actions'!pushBack 	self do: #pushBack! !!TSGroup methodsFor: 'accessing'!resetElementFromModelCache	"Reset the cache"	elementFromModelCache := nil! !!TSGroup methodsFor: 'transforming'!translateBy: delta	self do: [ :e | e translateBy: delta ]! !!TSGroup methodsFor: 'transforming'!translateTo: aPosition	| center |	center := self encompassingRectangle rsCenter.	self translateBy: aPosition - center! !!TSGroup methodsFor: 'accessing'!width 	^ self extent x! !!Trait method!marker: aMarker	| m |	m := aMarker asMarker. 	self 		markerStart: m;		markerMid: m;		markerEnd: m.	^ m! !!Trait method!markerEnd	^ self markers third.! !!Trait method!markerEnd: marker	| m| 	m := marker asMarker.	self markers at: 3 put: m.	^ m! !!Trait method!markerMid	^ self markers second.! !!Trait method!markerMid: marker	| m| 	m := marker asMarker.	self markers at: 2 put: m.	^ m! !!Trait method!markerStart 	^ self markers first.! !!Trait method!markerStart: marker	| m| 	m := marker asMarker.	self markers at: 1 put: m.	^ m! !!Trait method!markers	^ nil! !"Roassal3-Trachel-Shapes"!!RSObject commentStamp: '' prior: 0!Root of most of the Roassal classes.!!RSAbstractBuilder commentStamp: '' prior: 0!I am the base for custom visualization, like sunburst, treemap, grapher custom visualizations with different interactions. In order to change the domain and obtain a similar visualization!!RSAbstractModelBuilder commentStamp: '' prior: 0!I am an abstract class to create builders for roassal using DNUI can:* create commands.* create conditios* create a basic start for a new subclassesThis class allows you to create a builder of classes with a lot of methods like BlElement, and send blocks or values in their arguments!!RSAbstractShapeBuilder commentStamp: '' prior: 0!I am base class for builders with interactions!!RSShapeBuilder commentStamp: '' prior: 0!I can create shapes for roassal based on a model!!RSSingleEdgeBuilder commentStamp: '' prior: 0!I am an edge builder!!RSEdgeBuilder commentStamp: '' prior: 0!RSEdgeBuilder offers an API to easily build edges.Here is an example:```v := RSView new.classes := Collection withAllSubclasses.boxes := RSShapeBuilder box				width: [ :cls | cls instVarNames size * 5 max: 5 ];				height: [ :cls | cls numberOfMethods max: 5 ];				elementsOn: classes.boxes @ RSDraggable.v addAll: boxes.RSEdgeBuilder orthoVertical	view: v;	attachPoint: RSVerticalAttachPoint new;	elements: boxes;	connectFrom: #superclass.RSTreeLayout on: v elements.v @ RSControlsView.v open```!!RSMultiBezierEdgeBuilder commentStamp: '' prior: 0!I am a special edge builder with some especial contruction with #linePath and #multiBezierMy instances provide a new edges that you can connect with ancestors between models!!RSAction commentStamp: '' prior: 0!I am used in subclasses of RSAbstractModelBuilder. RSAbstractModelBuilder can create objects of anything based on 2 components, element and target.the element has the model, the real object. target can be another object.Instances of RSAbstractModelBuilder usually creates this 2 components and then uses accessors to modify the object created. by the commands of RSAbstractModelBuilder. CAAction allows you to modify these objects before and after their creation.!!RSAnnounceableObject commentStamp: '' prior: 0!I am the root for object with attributes and external values!!RSShapedObject commentStamp: '' prior: 0!I am usefull to define RSElement and RSEdge!!RSEdge commentStamp: '' prior: 0!I represent lines models in RSView!!RSElement commentStamp: '' prior: 0!Too abstract at this point, do we need instances of RSElement?!!RSView commentStamp: '' prior: 0!A RTView is xxxxxxxxx.Roassal structures a visualization in terms of views, elements, shapes, interactions, and animations.A ''view'' is a container of graphical elements and represents a layer that may be combined with other views.!!RSAttachPoint commentStamp: '' prior: 0!I am the base for attach points!!RSBorderAttachPoint commentStamp: '' prior: 0!I am an attach point that will end the line on the border of the end shapes.Unline ContinuousAttachPoint & co. you don't need to care about what the end shape is, as long as it is one of the basic shapes.!!RSCenteredAttachPoint commentStamp: '' prior: 0!I am the centered attach point!!RSOffsetAttachPoint commentStamp: '' prior: 0!I can define offsets in each side of the attach point!!RSHorizontalAttachPoint commentStamp: '' prior: 0!Horizontal attach points between elements when drawing lines.  Useful for horizontal tree layout.!!RSVerticalAttachPoint commentStamp: '' prior: 0!Vertical attach points between elements when drawing lines. Useful for (vertical) tree layout!!RSCommand commentStamp: '' prior: 0!I describe a command for RSAbstractModelBuilderMy main mission is* have an accessor to the message, in the DNU of RSAbstractModelBuilder* execute this message with a lot of elements* difference when apply this command to the main element or its inner component 'target'* difference when apply the argument to its model or its element 'argumentTarget'!!RSConditionCommand commentStamp: '' prior: 0!I am a condition command. my use is the next.-------------------------------builder := RSShapeBuilder box    size: 40;    if: [ : shapeIndex | shapeIndex even ] actions: [: shape |         shape color: Color red ].builder elementsOn: (1 to: 10).-------------------------------Subclasses of RSAbstractModelBuilder can use the method #if:actions: The previous method creates the RSConditionCommand to create elements based on a condition.the condition'block can be a block or a symbol, the actions'block can recive or not an argument-------------------------------(RSShapeBuilder box	size: 40;	background: Color blue;	if: #even actions: [ :s|		s background: Color red ]) elementsOn: (1 to: 10).-------------------------------!!RSInteraction commentStamp: '' prior: 0!I am the top class for interactions in roassal!!RSAbstractViewInteraction commentStamp: '' prior: 0!Subclasses of myself are interaction for the view!!RSControlsView commentStamp: '' prior: 0!I am experimental class.Add to the view the next interactions- RSZoomableView- RSDraggableView - RSMenuActivable- RSZoomMove- RSFocusOnCenterScaleMove!!RSDraggableView commentStamp: '' prior: 0!I am an interaction that makes a view draggable using the mouse.For example:-=-=-=-=-=-=-=-=-=	| v |	v := RTView new.	v @ RTDraggableView.	RTCPDiverging new viewOn: v.	^ v-=-=-=-=-=-=-=-=-=!!RSMaximizeView commentStamp: '' prior: 0!I can maximize or restore the window of one view!!RSZoomMove commentStamp: '' prior: 0!I am an interaction or for the view!!RSZoomToFitView commentStamp: '' prior: 0!I add an interaction for the view!!RSZoomableView commentStamp: '' prior: 0!I am interaction which allows view to be zoomed with a mouce wheel. While zomming mouce cursor stays on the same spot in the canvas!!RSDraggable commentStamp: '' prior: 0!I can move an element from its position!!RSLabeled commentStamp: '' prior: 0!A RSLabeled  adds a label above an element. The label may be particularized using #text: in the default string representation is not sufficient. !!RSMenuActivable commentStamp: '' prior: 0!With the mouose right click event I show a basic popup!!RSPopup commentStamp: '' prior: 0!I can add a popup on an element when a move over event occurs !!RSInteractionBuilder commentStamp: '' prior: 0!I a m the interaction builder!!TSBoundingShape methodsFor: '*Roassal3'!geometry	| rect |	rect := self encompassingRectangle.	^ GRectangle		origin: rect origin 		corner: rect corner! !!Symbol methodsFor: '*Roassal3'!rsValue: anObject 	^ anObject perform: self! !!TSEllipse methodsFor: '*Roassal3'!geometry 	| rect |	rect := self encompassingRectangle.	^ GEllipse 		center: self position 		a: rect width / 2 		b: rect height / 2! !!SubscriptionRegistry methodsFor: '*Roassal3'!getInteractionsForClass: eventClass	"Return the list of subscription for a given Event class"	| answer |	answer := OrderedCollection new.	subscriptions do: [ :sub | 		((sub subscriber class == eventClass) or: 			[ sub subscriber class inheritsFrom: eventClass ]) ifTrue: [ answer add: sub subscriber ] ].	^ answer! !!SubscriptionRegistry methodsFor: '*Roassal3'!handleSubscriberClass: eventClass	"Return true if the receiver has a callback subscripbed for the event class"	^ subscriptions anySatisfy: [ :sub | 		(sub subscriber class == eventClass) or: 			[ sub subscriber class inheritsFrom: eventClass ] ]! !!BlockClosure methodsFor: '*Roassal3'!onElement: aRTElement 	self value: aRTElement ! !!BlockClosure methodsFor: '*Roassal3'!rsValue: valueOrArray	self numArgs = 0 ifTrue: [ ^ self value ].  	self numArgs = 1 ifTrue: [ ^ self value: valueOrArray ].		"if I have more than 1 argument, then the valueOrArray is a collection"	valueOrArray isCollection ifFalse: [ self error: 'A block with more than one argument can only be evaluated with a collection ' ].		self numArgs = valueOrArray size ifTrue: [ ^ self valueWithArguments: valueOrArray ]. 		self error: 'Incorrect number of arguments'! !!Object methodsFor: '*Roassal3'!rsValue: anArgument 	^ self! !!RSAbstractBuilder methodsFor: 'building'!build	"Public method that produces the visualization"	self renderIn: self view.	^ elements! !!RSAbstractBuilder methodsFor: 'accessing'!elements	"usually to keep a referece to created elements by this builder"	^ elements ifNil: [ self view elements ].! !!RSAbstractBuilder methodsFor: 'accessing'!elements: aCollectionOfRSElements	elements := aCollectionOfRSElements! !!RSAbstractBuilder methodsFor: 'hooks'!open	^ self view open! !!RSAbstractBuilder methodsFor: 'hooks'!renderIn: aView	self subclassResponsibility! !!RSAbstractBuilder methodsFor: 'accessing'!shape	^ shape! !!RSAbstractBuilder methodsFor: 'accessing'!shape: aRSShapeBuilder	shape := aRSShapeBuilder! !!RSAbstractBuilder methodsFor: 'accessing'!view	^ view ifNil: [ view := RSView new ].! !!RSAbstractBuilder methodsFor: 'accessing'!view: aRSView	view := aRSView! !!RSAbstractModelBuilder methodsFor: 'actions'!actions	^ actions ifNil: [ #() ].! !!RSAbstractModelBuilder methodsFor: 'actions'!addAction: action	self actions isEmpty 		ifTrue: [ actions := OrderedCollection new ].	self actions add: action.! !!RSAbstractModelBuilder methodsFor: 'private'!basicElementOn: object index: index	| el shape |	self assert: [ self elementClass notNil ] description: 'Need to set a shape'.	el := self elementClass new.	el		model: object;		index: index.	shape := self innerClass new.	el trachelShape: shape.	self executeActions: #isPreload on: el.	self updateElement: el innerComponent: shape.	self executeActions: #isPostload on: el.	^ el	! !!RSAbstractModelBuilder methodsFor: 'commands'!commands	^ commands ifNil: [ #() ]! !!RSAbstractModelBuilder methodsFor: 'commands'!commands: aCollection	commands := aCollection ! !!RSAbstractModelBuilder methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	"magic"	| command |	((elementClass canUnderstand: aMessage selector) not 		and: [ (innerClass canUnderstand: aMessage selector) not ])			ifTrue: [ ^ super doesNotUnderstand: aMessage ].	command := RSCommand new 		message: aMessage;		isForModel: self isForModel;		yourself.	hasUniqueCommands ifTrue: [ | index |		index := commands indexOf: command.		index = 0 			ifTrue: [ commands add: command ] 			ifFalse: [ commands at: index put: command ] ]		ifFalse: [ commands add: command. ].	! !!RSAbstractModelBuilder methodsFor: 'public - accessing'!element	^ self elementOn: nil! !!RSAbstractModelBuilder methodsFor: 'accessing'!elementClass	^ elementClass! !!RSAbstractModelBuilder methodsFor: 'accessing'!elementClass: aClass	elementClass := aClass! !!RSAbstractModelBuilder methodsFor: 'public - accessing'!elementOn: object	^ self elementOn: object index: nil! !!RSAbstractModelBuilder methodsFor: 'public - accessing'!elementOn: object index: index	self subclassResponsibility! !!RSAbstractModelBuilder methodsFor: 'public - accessing'!elementsOn: aCollection	| g |	g := TSGroup new: aCollection size.	aCollection doWithIndex: [ :obj : index |		g add: (self elementOn: obj index: index) ].	^ g! !!RSAbstractModelBuilder methodsFor: 'actions'!executeActions: block on: element	self actions do: [ :action |		action element: element.		(block rsValue: action) 			ifTrue: [ action execute ] ].! !!RSAbstractModelBuilder methodsFor: 'reflective operations'!executeCommand: name		| res |	res := nil.	self commands 		select: [ :cmd | cmd selector = name ]		thenDo: [ :cmd | res := cmd execute ].	^ res! !!RSAbstractModelBuilder methodsFor: 'reflective operations'!executeDuring: aBlock element: element component: component	| bool cmds |	cmds := commands.	bool := isForElement.	commands := OrderedCollection new.	aBlock rsValue: self.	self updateElement: element innerComponent: component.	commands := cmds.	isForElement := bool.	! !!RSAbstractModelBuilder methodsFor: 'testing'!hasUniqueCommands	^ hasUniqueCommands! !!RSAbstractModelBuilder methodsFor: 'reflective operations'!if: booleanBlock actions: actionsBlock	commands add: (RSConditionCommand new 		message: actionsBlock;		builder: self;		condition: booleanBlock;		isForModel: self isForModel;		yourself).! !!RSAbstractModelBuilder methodsFor: 'initialization'!initialize	super initialize.	self onModel.	commands := OrderedCollection new.	hasUniqueCommands := false.! !!RSAbstractModelBuilder methodsFor: 'accessing'!innerClass	^ innerClass ! !!RSAbstractModelBuilder methodsFor: 'accessing'!innerClass: aClass	innerClass := aClass! !!RSAbstractModelBuilder methodsFor: 'testing'!isForElement	^ isForElement! !!RSAbstractModelBuilder methodsFor: 'testing'!isForModel	^ isForElement not! !!RSAbstractModelBuilder methodsFor: 'public - accessing'!onElement	isForElement := true! !!RSAbstractModelBuilder methodsFor: 'public - accessing'!onModel	isForElement := false! !!RSAbstractModelBuilder methodsFor: 'dependencies'!release 	super release.	self commands do: #release.	self commands: nil.! !!RSAbstractModelBuilder methodsFor: 'commands'!removeCommandsBySelector: selector	^ self removeCommandsBySelectors: { selector }.! !!RSAbstractModelBuilder methodsFor: 'commands'!removeCommandsBySelectors: selectors	| toDelete |	toDelete := commands select: [ :cmd | selectors includes: cmd selector ].	toDelete do: [ :cmd | commands remove: cmd ].	^ toDelete! !!RSAbstractModelBuilder methodsFor: 'public - accessing'!uniqueCommands	"with this commands are uniques and we keep the last command if they are equal.	EG with hasUniqueCommands equals true	.=.=	RSShapeBuilder box 		color: [ Color red ];		color: [ Color blue ];		color: Color blue;		color: nil.	.=.=	In this case commands collection are { [ red ]. [ blue ]. Color blue. nil }.	.=.=	RSShapeBuilder box 		uniqueCommands;		color: [ Color red ];		color: [ Color blue ];		color: Color blue;		color: nil.	.=.=	In this case commands collection are { nil }.	"	hasUniqueCommands := true! !!RSAbstractModelBuilder methodsFor: 'updating'!updateElement: element innerComponent: component	| copy |	copy := self commands copy.	copy do: [ :command |		command 			element: element;			component: component ].	copy do: #execute! !!RSAbstractShapeBuilder methodsFor: 'interactions'!draggable	self interactionDo: #draggable.! !!RSAbstractShapeBuilder methodsFor: 'interactions'!interaction	^ interaction ifNil: [		interaction := RSInteractionBuilder new.		self addAction: (RSAction new			action: [ :el | interaction setUpElement: el ]).		interaction ].! !!RSAbstractShapeBuilder methodsFor: 'interactions'!interactionDo: aBlock	aBlock value: self interaction! !!RSAbstractShapeBuilder methodsFor: 'interactions'!popup	self interactionDo: #popup.! !!RSAbstractShapeBuilder methodsFor: 'updating'!updateElement: element	self 		updateElement: element 		innerComponent: element trachelShape! !!RSAbstractShapeBuilder methodsFor: 'updating'!updateElement: element withCommand: selector	| temp |	temp := commands.	commands := commands select: [ :c | c selector = selector ].	self updateElement: element.	commands := temp.		! !!RSAbstractShapeBuilder methodsFor: 'updating'!updateElements: elements	elements do: [ :e | self updateElement: e ].! !!RSShapeBuilder class methodsFor: 'instance creation'!arc	"TODO find the best name, ring, arc, circle sector, ellipse segment, foobar, etc"	^ self new		shapeClass: TSPieSlice;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!arrow	"inverted vee"	^ self polygonWithPoints: (Array		with: 1 @ 1		with: 0 @ 0.333		with: -1 @ 1		with: 0 @ -1)! !!RSShapeBuilder class methodsFor: 'instance creation'!bitmap	 ^ self new		innerClass: TSBitmap;		elementClass: RSElement;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation'!box	^ self rectangle! !!RSShapeBuilder class methodsFor: 'instance creation'!circle	^ self ellipse! !!RSShapeBuilder class methodsFor: 'instance creation'!composite	^ self new		innerClass: TSComposite;		elementClass: RSElement;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!cross	| t t1 |	t := 2 / 6 asFloat.	t1 := t negated.	^ self polygonWithPoints:		{(-1 @ t1).		(t1 @ t1).		(t1 @ -1).		(t @ -1).		(t @ t1).		(1 @ t1).		(1 @ t).		(t @ t).		(t @ 1).		(t1@ 1).		(t1@ t).		(-1@ t)}! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!diamond	^ self polygonWithPoints: (Array		with: 0 @ 1		with: 1 @ 0		with: 0 @ -1		with: -1 @ 0)! !!RSShapeBuilder class methodsFor: 'instance creation'!ellipse	^ self new		shapeClass: TSEllipse;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!heptagon	^ self polygonWithPoints: (TSPolygon generatePointsFitSquare: 7)! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!hexagon	^ self polygonWithPoints: (TSPolygon generatePointsFitSquare: 6)! !!RSShapeBuilder class methodsFor: 'instance creation'!label"Here is an exampe on how to use it-=-=-=-=-=v := RSView new.v @ RSControlsView.sb := RSShapeBuilder label.sb interactionDo: #draggable.sb text: #asString.elements := sb elementsOn: (Collection withAllSubclasses).elements do: [ :e | e translateTo: (Random new nextInt: 300) @ (Random new nextInt: 300) ].v addAll: elements.RSNormalizer fontSize	elements: elements;	to: 30;	normalize: #numberOfMethods.v zoomToFit.v open-=-=-=-=-="	^ self new		innerClass: TSLabel;		elementClass: RSElement;		color: Color black;		addAction: (RSAction new action: [:el | 			| text |			text := el text.			text ifNil: [ text := el model ].			el text: text asString ] ) 		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!octagon	^ self polygonWithPoints: (TSPolygon generatePointsFitSquare: 8)! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!pentagon	^ self polygonWithPoints: (TSPolygon generatePointsFitSquare: 5)! !!RSShapeBuilder class methodsFor: 'instance creation'!polygon	^ self new		innerClass: TSPolygon;		elementClass: RSElement;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!polygonWithPoints: points	 ^ self polygon		privatePoints: points;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation'!rectangle	^ self new		shapeClass: TSBox;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!rhomboid	^ self polygonWithPoints: (Array		with: -1 @ -1		with: 0.333 @ -1		with: 1 @ 1		with: -0.333 @ 1)! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!square	^ self polygonWithPoints: (TSPolygon generatePointsFitSquare: 4)! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!star	| star5Points outerPoints innerPoints innerRadius ar |	star5Points := Array new: 10.	outerPoints := TSPolygon generateUnitNgonPoints: 5 rotation: 0.	innerPoints := TSPolygon generateUnitNgonPoints: 5 rotation: Float pi / -5.	"Outer radius is 1; inner radius of star is smaller"	innerRadius := 0.5.	innerPoints		doWithIndex: [ :p :i | innerPoints at: i put: (p x * innerRadius) @ (p y * innerRadius) ].	star5Points		doWithIndex: [ :p :i | 			ar := i even				ifTrue: [ outerPoints ]				ifFalse: [ innerPoints ].			star5Points at: i put: (ar at: i // 2 + (i % 2)) ].	star5Points := TSPolygon fitPolygonToSquare: star5Points.	^ self polygonWithPoints: star5Points! !!RSShapeBuilder class methodsFor: 'instance creation'!svgPath	^ self new		innerClass: TSSVGPath;		elementClass: RSElement;		yourself ! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!triangle	^ self polygonWithPoints: (TSPolygon generatePointsFitSquare: 3)! !!RSShapeBuilder class methodsFor: 'instance creation - polygon'!vee	^ self polygonWithPoints: (Array		with: -1 @ -1		with: 0 @ -0.333		with: 1 @ -1		with: 0 @ 1)! !!RSShapeBuilder methodsFor: 'public - accessing'!elementOn: object index: index	^ self basicElementOn: object index: index! !!RSShapeBuilder methodsFor: 'accessing'!shapeClass	^ self innerClass ! !!RSShapeBuilder methodsFor: 'accessing'!shapeClass: aClass	self innerClass: aClass;		elementClass: RSElement;		size: 5;		color: Color gray! !!RSEdgeBuilder methodsFor: 'public repetition'!allowRepetition	allowRepetition := true! !!RSEdgeBuilder methodsFor: 'public - configuration'!beDirectional	"When edges are created, this allow for having edges going from A to B, and from B to A"	beDirectional := true! !!RSEdgeBuilder methodsFor: 'public'!connectFrom: aBlockOrASymbol	^ self connectFrom: aBlockOrASymbol to: [ :each | each ]! !!RSEdgeBuilder methodsFor: 'public'!connectFrom: aFromBlock to: aBlockOrASymbol	| toElement fromElement |	self resetCreatedEdges.	self fromElements copy		do: [ :e | 			fromElement := self fromElements elementFromModel: (aFromBlock rsValue: e model).			toElement := self toElements elementFromModel: (aBlockOrASymbol rsValue: e model).			toElement ifNotNil: [ self createEdgeIfNecessaryFrom: fromElement to: toElement ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'public'!connectFrom: aFromBlock toAll: aBlockOrASymbol	| fromElement tes |	self resetCreatedEdges.	self fromElements copy do: [ :e | 		fromElement := self fromElements elementFromModel: (aFromBlock rsValue: e model).		tes := self toElements elementsFromModels: (aBlockOrASymbol rsValue: e model).		tes ifNotNil: [ 			tes do: [ :toE | 				self createEdgeIfNecessaryFrom: fromElement to: toE ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges ! !!RSEdgeBuilder methodsFor: 'public'!connectFromAll: aFromBlockOrSymbol	^ self connectFromAll: aFromBlockOrSymbol to: [ :each | each ]! !!RSEdgeBuilder methodsFor: 'public'!connectFromAll: aFromBlockOrSymbol to: aBlockOrASymbol	| toElement tfromElements |	self resetCreatedEdges.	self fromElements copy do: [ :e | 		tfromElements := self fromElements elementsFromModels: (aFromBlockOrSymbol rsValue: e model). 		toElement := self toElements elementFromModel: (aBlockOrASymbol rsValue: e model).		tfromElements ifNotNil: [ 			tfromElements do: [ :fromElement | 				self createEdgeIfNecessaryFrom: fromElement to: toElement ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'public'!connectTo: aBlockOrASymbol	^ self connectFrom: [ :each | each ] to: aBlockOrASymbol! !!RSEdgeBuilder methodsFor: 'public'!connectToAll: aBlockOrASymbol	"Should this method use connectFrom:ToAll: ?????"	| tmptoElements |	self resetCreatedEdges.	self fromElements copy do: [ :e | 		tmptoElements := self toElements elementsFromModels: (aBlockOrASymbol rsValue: e model).		tmptoElements ifNotNil: [ 			tmptoElements do: [ :toE | 				self createEdgeIfNecessaryFrom: e to: toE ] ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'private - utility'!createEdgeIfNecessaryFrom: fromElement to: toElement	"This is a private method. Create, if necessary, an edge between two elements"	(self shouldCreateEdgeFrom: fromElement to: toElement)		ifTrue: [ createdEdges add: (self edgeFrom: fromElement to: toElement) ]! !!RSEdgeBuilder methodsFor: 'private - utility'!edgeFrom: source to: target 	"source and target are elements"	| edge |	self from: source; to: target.	edge := self edge. 	view add: edge.	shouldNotBeUsedInLayout ifFalse: [ edge notUseInLayout ].	self processEdge: edge.	^ edge! !!RSEdgeBuilder methodsFor: 'accessing'!elements: someElements	self toElements: someElements.	self fromElements: someElements! !!RSEdgeBuilder methodsFor: 'accessing'!fromElements	self assert: [ self view notNil ] description: 'You need to set a view'.	fromElements ifNil: [ ^ self view elements ].	^ fromElements! !!RSEdgeBuilder methodsFor: 'accessing'!fromElements: someElements	fromElements := someElements! !!RSEdgeBuilder methodsFor: 'accessing'!fromObjects	"Return the list of objects considered as targets for the edges"	^ self fromElements collect: #model! !!RSEdgeBuilder methodsFor: 'accessing'!fromObjects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ viewHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	 	(someObjectsOrABlock isCollection and: [ someObjectsOrABlock isSymbol not ])		ifTrue: [ self fromElements: (view elementsFromModels: someObjectsOrABlock) ]		ifFalse: [ self fromElements: (view elements select: [ :el | someObjectsOrABlock rsValue: el model ]) ]! !!RSEdgeBuilder methodsFor: 'public - configuration'!highlightable	"Make the edges highlightable.	Here is an example:		| b edges |	b := RTMondrian new.	b shape circle size: 10; color: Color red.	b nodes: (1 to: 20).	b edges 		moveBehind; 		highlightable;		connectFrom: [ :v | v // 2 ].	b layout cluster.	b	"	actions add: [ :edge | 		edge @ RTHighlightable ] ! !!RSEdgeBuilder methodsFor: 'initialization'!initialize	super initialize.	self noRepetition.	shouldMoveBehind := false.	shouldNotBeUsedInLayout := true.		"The view has to be explicitely set by the end-user"	viewHasBeenManuallySet := false.		actions := OrderedCollection new.		"We could have edges from A to B, and from B to A"	self beDirectional! !!RSEdgeBuilder methodsFor: 'testing'!isBidirectional	"Return true or false, indicating whether the edge builder is bidirectional or not (i.e., if 	edges from A to B, __and__ B to A can be created"	^ beDirectional ! !!RSEdgeBuilder methodsFor: 'accessing'!label: twoArgBlock	"Method useful to label edges. The argument is a two arg block that accept the starting object model and the ending object model. The block has to return a String that will be used to label the edge.		Here is an example:	| b edges |	b := RTMondrian new.	b shape circle size: 10; color: Color red.	b nodes: (1 to: 20).	b edges 		moveBehind; 		highlightable;		label: [ :from :to | from asString, '>', to asString ];		connectFrom: [ :v | v // 2 ].	b layout cluster.	b	"	^ self label: twoArgBlock fontSize: TRLabelShape defaultFontSize! !!RSEdgeBuilder methodsFor: 'accessing'!label: twoArgBlock fontSize: fontSizeAsBlockOrValue	"Method useful to label edges. The argument is a two arg block that accept the starting object model and the ending object model. The block has to return a String that will be used to label the edge.		Here is an example:	| b edges |	b := RTMondrian new.	b shape circle size: 10; color: Color red.	b nodes: (1 to: 20).	b edges 		moveBehind; 		highlightable;		label: [ :from :to | from asString, '>', to asString ] fontSize: 5;		connectFrom: [ :v | v // 2 ].	b layout cluster.	b	"	actions add: [ :edge | 		| lbl lblEl |		lbl := twoArgBlock value: edge from model value: edge to model.		lblEl := RTLabel new height: fontSizeAsBlockOrValue; elementOn: lbl.		view add: lblEl.		TRConstraint stick: lblEl between: edge from and: edge to ] ! !!RSEdgeBuilder methodsFor: 'accessing'!labelElement: oneArgBlock	"Method useful to label edges. The argument is a one arg block that accept the edge. The block has to return a String that will be used to label the edge.		Here is an example:	| b edges |	b := RTMondrian new.	b shape circle size: 10; color: Color red.	b nodes: (1 to: 20).	b edges 		moveBehind; 		highlightable;		labelElement: [ :anEdge | anEdge from model asString, '>', anEdge to model asString ];		connectFrom: [ :v | v // 2 ].	b layout cluster.	b	"	^ self labelElement: oneArgBlock fontSize: TRLabelShape defaultFontSize! !!RSEdgeBuilder methodsFor: 'accessing'!labelElement: oneArgBlock fontSize: fontSizeAsBlockOrValue	"Method useful to label edges. The argument is a one arg block that accept the edge. The block has to return a String that will be used to label the edge.		Here is an example:	| b edges |	b := RTMondrian new.	b shape circle size: 10; color: Color red.	b nodes: (1 to: 20).	b edges 		moveBehind; 		highlightable;		labelElement: [ :anEdge | anEdge from model asString, '>', anEdge to model asString ] fontSize: 5;		connectFrom: [ :v | v // 2 ].	b layout cluster.	b	"	actions add: [ :edge | 		| lbl lblEl |		lbl := oneArgBlock value: edge.		lblEl := RTLabel new height: fontSizeAsBlockOrValue; elementOn: lbl.		view add: lblEl.		TRConstraint stick: lblEl between: edge from and: edge to ] ! !!RSEdgeBuilder methodsFor: 'private - utility'!linkElements: someElements	"Link the first element to the second, the second to the third and so on"	| head |	head := someElements first.	someElements allButFirst do: [ :e |		self edgeFrom: head to: e.		head := e.		]! !!RSEdgeBuilder methodsFor: 'accessing'!moveBehind	"Set the builder as such that edge that are built and added in the view _behind_ the extremities of each edges"	shouldMoveBehind := true! !!RSEdgeBuilder methodsFor: 'private - utility'!moveBehindIfNecessary: someEdges	shouldMoveBehind ifFalse: [ ^ self ].	someEdges pushBack! !!RSEdgeBuilder methodsFor: 'public - configuration'!noBidirectional	"When edges are created, this does not allow for having edges going from A to B, and from B to A. Only A to B, __OR__, B to A is created"	beDirectional := false! !!RSEdgeBuilder methodsFor: 'public - configuration'!noRepetition	"	Avoid having more than one edge between two elements	b := RTMondrian new.	b nodes: (1 to: 3).	b shape line		color: Color red trans;		withVerticallAttachPoint.	b edges noRepetition; useAssociations: { 1 -> 2 . 2 -> 3 . 1 -> 2}.	b layout grid.	b build.	b view numberOfEdges	"	allowRepetition := false! !!RSEdgeBuilder methodsFor: 'public - configuration'!notUseInLayout	"Indicate that the edges should not be used in the layout.The following example shows that the layout is driven only by the red lines, and not the blue ones:b := RTMondrian new.b nodes: RTShape withAllSubclasses.b shape line color: Color red trans.b edges connectFrom: #superclass.b shape line color: Color blue trans.b edges	notUseInLayout;	connectToAll: #dependentClasses.b layout tree.b		"	shouldNotBeUsedInLayout := false! !!RSEdgeBuilder methodsFor: 'accessing'!object: anObject	^ self objects: (Array with: anObject)! !!RSEdgeBuilder methodsFor: 'accessing'!objects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ viewHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	self toObjects: someObjectsOrABlock.	self fromObjects: someObjectsOrABlock.! !!RSEdgeBuilder methodsFor: 'private - utility'!processEdge: anEdge	actions do: [ :action | action value: anEdge ]! !!RSEdgeBuilder methodsFor: 'private - utility'!resetCreatedEdges	createdEdges := TSGroup new! !!RSEdgeBuilder methodsFor: 'public repetition'!shouldAllowRepetition	^ allowRepetition! !!RSEdgeBuilder methodsFor: 'testing'!shouldCreateEdgeFrom: fromElement to: toElement	"Return true if an edge has to be created"	fromElement == toElement ifTrue: [ ^ false ].	(fromElement isNil or: [ toElement isNil ]) ifTrue: [ ^ false ].	beDirectional ifFalse: [ ^ (toElement isDirectlyConnectedTo: fromElement) not ].	allowRepetition ifFalse: [ ^ fromElement outgoingEdges noneSatisfy: [ :edge | edge to == toElement ] ].	^ true! !!RSEdgeBuilder methodsFor: 'public using source'!source: objects connectFrom: fromblock to: toBlock	"Define some edges from objects that are not part of the view	nbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges) 				collect: [ :notUsed | nodes atRandom -> nodes atRandom ].b := RTMondrian new.b shape circle color: (Color black alpha: 0.5).b nodes: nodes.b shape line color: (Color gray alpha: 0.3).b edges	source: edges connectFrom: #key to: #value.b layout force.b	"	| assocs allObjects |	self assert: [ objects notNil ] description: 'Cannot provide a nil value as the source'.	self assert: [ objects isCollection ] description: 'Need to provide a collection as the source'.	allObjects := Set new.		assocs := objects collect: [ :o | 		| f t |		f := fromblock rsValue: o.		t := toBlock rsValue: o.		allObjects add: f; add: t.		f -> t ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSEdgeBuilder methodsFor: 'public using source'!source: objects connectFrom: fromblock toAll: toBlock	"Define some edges from objects that are not part of the view	nbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges) 				collect: [ :notUsed | nodes atRandom -> {nodes atRandom . nodes atRandom} ].b := RTMondrian new.b shape circle color: (Color black alpha: 0.5).b nodes: nodes.b shape line color: (Color gray alpha: 0.3).b edges	source: edges connectFrom: #key toAll: #value.b layout force.b	"	| assocs allObjects |	allObjects := Set new.	assocs := objects flatCollect: [ :o | 		| cc |		cc := toBlock rsValue: o.		cc collect: [ :ccc | 			| t |			t := fromblock rsValue: o.			allObjects add: t; add: ccc.			t -> ccc ] ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSEdgeBuilder methodsFor: 'public using source'!source: objects connectFromAll: fromBlock to: toBlock	"Define some edges from objects that are not part of the view	nbOfNodes := 40.nbOfRandomEdges := 40.nodes := 1 to: nbOfNodes.edges := (1 to: nbOfRandomEdges) 				collect: [ :notUsed | {nodes atRandom . nodes atRandom} -> nodes atRandom ].b := RTMondrian new.b shape circle color: (Color black alpha: 0.5).b nodes: nodes.b shape line color: (Color gray alpha: 0.3).b edges	source: edges connectFromAll: #key to: #value.b layout force.b	"	| assocs allObjects |	allObjects := Set new.	assocs := objects flatCollect: [ :o | 		| cc |		cc := fromBlock rsValue: o.		cc collect: [ :ccc | 			| t |			t := toBlock rsValue: o.			allObjects add: ccc; add: t.			ccc -> t ] ].	self objects: allObjects asArray.	^ self useAssociations: assocs! !!RSEdgeBuilder methodsFor: 'accessing'!toElements	toElements ifNil: [ ^ self view elements ].	^ toElements! !!RSEdgeBuilder methodsFor: 'accessing'!toElements: someElements	toElements := someElements! !!RSEdgeBuilder methodsFor: 'accessing'!toObject: anObject	^ self toObjects: (Array with: anObject)! !!RSEdgeBuilder methodsFor: 'accessing'!toObjects	"Return the list of objects considered as sources for the edges"	^ self toElements collect: #model! !!RSEdgeBuilder methodsFor: 'accessing'!toObjects: someObjectsOrABlock	"Identify the elements we are considering for the edge building process. Note that the view has to be set beforehand."	self assert: [ viewHasBeenManuallySet ] description: 'A view has to be set, please use #view:'.	 	(someObjectsOrABlock isCollection and: [ someObjectsOrABlock isSymbol not ])		ifTrue: [ self toElements: (view elementsFromModels: someObjectsOrABlock) ]		ifFalse: [ self toElements: (view elements select: [ :el | someObjectsOrABlock rsValue: el model ]) ]! !!RSEdgeBuilder methodsFor: 'public associations'!useAssociation: assoc	"assoc have to be between model objects"	| result |	self assert: [ assoc isKindOf: Association ] description: 'Please, provide an association instead'.		result := self useAssociations: (Array with: assoc).	result ifEmpty: [ ^ nil ].	^ result first! !!RSEdgeBuilder methodsFor: 'public associations'!useAssociations: associations	"associations have to be between model objects"		"	Here is an example	b := RTMondrian new.b nodes: (1 to: 3).b shape line	color: Color red trans;	withVerticallAttachPoint.b edges noRepetition; useAssociations: { 1 -> 2 . 2 -> 3 . 1 -> 2}.b layout grid.b 	"		| fromElement toElement |	createdEdges := TSGroup new.	associations do: [ :assoc |		fromElement := self fromElements elementFromModel: assoc key.		toElement := self toElements elementFromModel: assoc value.		(fromElement notNil and: [ toElement notNil ])			ifTrue: [ self createEdgeIfNecessaryFrom: fromElement to: toElement ] ].	self moveBehindIfNecessary: createdEdges.	^ createdEdges! !!RSEdgeBuilder methodsFor: 'public associations'!useElementAssociations: associationsBetweenElements	associationsBetweenElements do: [ :assoc |		self edgeFrom: assoc key to: assoc value ]! !!RSEdgeBuilder methodsFor: 'accessing'!view	^ view! !!RSEdgeBuilder methodsFor: 'accessing'!view: aView	viewHasBeenManuallySet := true.	view := aView! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!applyTensionOn: points	| n dp p1 ten |	n := points size - 1.	p1 := points first.	dp := points last - p1.	ten := self tension.	2 to: n do: [ :i| | p t |		p := points at: i.		t := (i -1)/n. 		points at: i put: (1 - ten) * (p1 + (t * dp)) + (ten * p)].! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!commonAncestor: edge with: selector	| a b aNodes bNodes sharedNode remove |	a := edge from.	b := edge to.	a == b ifTrue: [ ^ a ].	aNodes := self followersOf: a with: selector.	bNodes := self followersOf: b with: selector.	a := aNodes removeLast.	b := bNodes removeLast.	sharedNode := nil.	remove := [ :list | list 		ifEmpty: [ nil ]		ifNotEmpty: [ list removeLast ] ].	[ a == b ] whileTrue: [ 		sharedNode := a.		sharedNode ifNil: [ ^ nil ].		a := remove value: aNodes.		b := remove value: bNodes. ].	^ sharedNode.! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!commonElements: edge with: selector	"obtaint a list of points from the elements in the view based on a selector"	| from to ancestor elements search index |	from := edge from.	to := edge to.	ancestor := self commonAncestor: edge with: selector.	ancestor ifNil: [ 		elements := (self followersOf: from with: selector),			(self followersOf: to with: selector) reverse.		^ elements ].	search := [ :model | view elementFromModel: (selector rsValue: model) ].	elements := OrderedCollection new.	elements add: from.	[ from == ancestor ] whileFalse: [ 		from := search value: from model.		elements add: from ].	index := elements size.	[ to == ancestor ] whileFalse: [ 		elements add: to afterIndex: index.		to := search value: to model ].	elements do: [ :e | (e connectedEdges includes: edge)		ifFalse: [ e addConnectedEdge: edge ] ].	^ elements.	! !!RSMultiBezierEdgeBuilder methodsFor: 'private'!followersOf: element with: selector	| t followers |	followers := OrderedCollection new.	t := element. 	[ t notNil ] whileTrue: [ 		followers add: t.		t := view elementFromModel: (selector rsValue: t model) ].	^ followers! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!following: selector	self		onElement;		svgPath: [ :ed | [ :a :b | [:builder | | points elements att |			att := ed attributes.			elements := att				at: #commom				ifAbsentPut: [ self commonElements: ed with: selector ].			points := elements collect: [ :e | e position asFloatPoint ].			points removeFirst; removeLast; addFirst: a; addLast: b.			self applyTensionOn: points. 			builder absolute; moveTo: points first.			2 to: points size - 2 do: [ :i | | p1 p2 |				p1 := points at: i.				p2 := points at: i +1.				builder 					curveVia: p1					to: (p1 + p2)/2 ].			builder				curveVia:( points at: points size -1)				to: points last.			] ] ].! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!tension	^ tension ifNil: [ tension := 0.7 ]! !!RSMultiBezierEdgeBuilder methodsFor: 'public - line path'!tension: aNumberOrBlock	"tension should evaluate it and return a value between 0 and 1. 	0 means straight lines	1 means a curve line"	tension := aNumberOrBlock! !!RSSingleEdgeBuilder class methodsFor: 'instance variations'!arrowedLine	| marker inst |	marker := TSPolygon new		privatePoints: { -5@5. 0@0. 5@5. 0@0 };		paint: nil;		border: (TSBorder new).	inst := self line.	inst markerEnd: marker.	^ inst.! !!RSSingleEdgeBuilder class methodsFor: 'instance creation'!bezier	^ self new edgeClass: TSBezier! !!RSSingleEdgeBuilder class methodsFor: 'instance creation'!bimetricLine"Here is an example on how to use it.| view e1 e2 box l |	view := RSView new.	box := RSShapeBuilder box 		size: 100;		draggable.	e1 := box element.	e1 color: Color blue.	e2 := box element.	e2 translateTo: 400@0.	l := RSSingleEdgeBuilder bimetricLine		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: e1;		to: e2;		edge.	view addAll: { e1. e2. l}.	view @ RSControlsView. 	view open"	^ self new edgeClass: TSBimetricLine! !!RSSingleEdgeBuilder class methodsFor: 'instance variations'!horizontalBezier"Here is an examplev := RSView new.sb := RSShapeBuilder circle			size: 20;			elementsOn: (1 to: 20).v addAll: sb.sb @ RSDraggable.eb := RSEdgeBuilder horizontalBezier			view: v;			connectFrom: 1 toAll: (2 to: 20).RSCircleLayout on: sb.v zoomToFit.v open						"	^ self horizontalLine: self bezier.	! !!RSSingleEdgeBuilder class methodsFor: 'helpers'!horizontalLine: inst	inst controlPoints: [ [:from :to | 		| mid |		mid := (from + to)/2.		Array 			with: from			with: mid x @ from y			with: mid x @ to y			with: to ] ].	^ inst! !!RSSingleEdgeBuilder class methodsFor: 'instance creation'!line	^ self new edgeClass: TSLine! !!RSSingleEdgeBuilder class methodsFor: 'instance creation'!linePath	^ self new edgeClass: TSSVGPathLine! !!RSSingleEdgeBuilder class methodsFor: 'instance variations'!multiBezier	^ RSMultiBezierEdgeBuilder linePath! !!RSSingleEdgeBuilder class methodsFor: 'instance variations'!orthoHorizontal	^ self horizontalLine: self polyline.! !!RSSingleEdgeBuilder class methodsFor: 'instance variations'!orthoVertical	^ self verticalLine: self polyline.! !!RSSingleEdgeBuilder class methodsFor: 'instance creation'!polyline	^ self new edgeClass: TSPolyline! !!RSSingleEdgeBuilder class methodsFor: 'instance variations'!verticalBezier"Here is an example:v := RSView new.sb := RSShapeBuilder circle			size: 20;			elementsOn: (1 to: 20).v addAll: sb.sb @ RSDraggable.eb := RSEdgeBuilder verticalBezier			view: v;			connectFrom: 1 toAll: (2 to: 20).RSCircleLayout on: sb.v zoomToFit.v open						"	^ self verticalLine: self bezier.	! !!RSSingleEdgeBuilder class methodsFor: 'helpers'!verticalLine: inst	inst controlPoints: [ [:from :to | 		| mid |		mid := (from + to)/2.		Array			with: from			with: from x @ mid y			with: to x @ mid y			with: to ] ].	^ inst! !!RSSingleEdgeBuilder methodsFor: 'public - accessing'!edge	^ self edgeOn: fromObject -> toObject! !!RSSingleEdgeBuilder methodsFor: 'accessing'!edgeClass: aClass	self 		elementClass: RSEdge;		innerClass: aClass.! !!RSSingleEdgeBuilder methodsFor: 'public - accessing'!edgeOn: model	^ self edgeOn: model index: nil! !!RSSingleEdgeBuilder methodsFor: 'public - accessing'!edgeOn: model index: index	| ed |	ed := self basicElementOn: model index: index.	ed 		from: (fromObject rsValue: model) ;		to: (toObject rsValue: model);		update.	^ ed! !!RSSingleEdgeBuilder methodsFor: 'public - accessing'!edgesOn: aCollection	| g |	g := TSGroup new: aCollection size.	aCollection doWithIndex: [ :obj : index |		g add: (self edgeOn: obj index: index) ].	^ g! !!RSSingleEdgeBuilder methodsFor: 'public - accessing'!elementOn: model index: index	"You cannot send #elementOn: to a line. Create an edge using #edgeFrom:to:"	self shouldNotImplement! !!RSSingleEdgeBuilder methodsFor: 'accessing'!from	^ fromObject! !!RSSingleEdgeBuilder methodsFor: 'accessing'!from: anObject	fromObject := anObject.! !!RSSingleEdgeBuilder methodsFor: 'accessing'!to	^ toObject! !!RSSingleEdgeBuilder methodsFor: 'accessing'!to: anObject	toObject := anObject.! !!RSSingleEdgeBuilder methodsFor: 'accessing'!updateElement: edge	super updateElement: edge.	edge update.! !!RSSingleEdgeBuilder methodsFor: 'public - attach point'!withBorderAttachPoint	self attachPoint: RSBorderAttachPoint new.! !!RSSingleEdgeBuilder methodsFor: 'public - attach point'!withCenteredAttachPoint	self attachPoint: RSAttachPoint new.! !!RSSingleEdgeBuilder methodsFor: 'public - attach point'!withHorizontalAttachPoint	self attachPoint: RSHorizontalAttachPoint new.! !!RSSingleEdgeBuilder methodsFor: 'public - attach point'!withVerticalAttachPoint"An example:classesToVisualize := Collection withAllSubclasses.v := RSView new.boxes := RSShapeBuilder box				width: [ :cls | cls instVarNames size * 3 max: 5 ];				height: [ :cls | cls numberOfMethods max: 5 ];				elementsOn: classesToVisualize.v addAll: boxes.RSEdgeBuilder orthoVertical 	withVerticalAttachPoint	view: v;	connectFrom: #superclass.	RSTreeLayout on: boxes.v @ RSControlsView.v open			"	self attachPoint: RSVerticalAttachPoint new.! !!RSAction methodsFor: 'accessing'!action	^ action! !!RSAction methodsFor: 'accessing'!action: aBlock	action := aBlock! !!RSAction methodsFor: 'accessing'!element	^ element! !!RSAction methodsFor: 'accessing'!element: anElement	element := anElement! !!RSAction methodsFor: 'accessing'!execute	self action rsValue: self element! !!RSAction methodsFor: 'accessing'!initialize	super initialize.	self postload.! !!RSAction methodsFor: 'accessing'!isPostload	^ isPreloadAction not! !!RSAction methodsFor: 'accessing'!isPreload	^ isPreloadAction! !!RSAction methodsFor: 'accessing'!postload	isPreloadAction := false! !!RSAction methodsFor: 'accessing'!preload	isPreloadAction := true! !!RSAction methodsFor: 'dependencies'!release	super release.	action := element :=  nil.! !!RSAnnounceableObject methodsFor: 'interactions'!@ anInteractionClassOrInstance	"Add an interaction to the node"		self addInteraction: anInteractionClassOrInstance! !!RSAnnounceableObject methodsFor: 'interactions'!addInteraction: anInteractionClassOrInstance 	anInteractionClassOrInstance onElement: self! !!RSAnnounceableObject methodsFor: 'accessing'!announcer 	self subclassResponsibility! !!RSAnnounceableObject methodsFor: 'attributes'!attributeAt: aKey	"Obtain an attribute to the element. For example: 		RTElement new attributeAt: #magic put: 42; attributeAt: #magic		RTEdge new attributeAt: #magic put: 42; attributeAt: #magic	"	^ self attributes at: aKey! !!RSAnnounceableObject methodsFor: 'attributes'!attributeAt: aKey ifAbsent: aBlockClosure 		^ self attributes at: aKey ifAbsent: aBlockClosure ! !!RSAnnounceableObject methodsFor: 'attributes'!attributeAt: aKey ifAbsentPut: aBlockClosure 		^ self attributes at: aKey ifAbsentPut: aBlockClosure ! !!RSAnnounceableObject methodsFor: 'attributes'!attributeAt: aKey put: value	"Set an attribute to the element. For example: 		RTElement new attributeAt: #magic put: 42; yourself		RTEdge new attributeAt: #magic put: 42; yourself	"	^ self attributes at: aKey put: value! !!RSAnnounceableObject methodsFor: 'attributes'!attributes	"Return the list of attributes associated to the element. Attributes are useful for caching values"	^ attributes ifNil: [ attributes := Dictionary new ]! !!RSAnnounceableObject methodsFor: 'attributes'!attributesDo: block	block value: self attributes.! !!RSAnnounceableObject methodsFor: 'accessing'!getInteractionsForClass: anInteractionClass	"Return the Announcement subscriptions for the interaction"	^ self announcer subscriptions getInteractionsForClass: anInteractionClass! !!RSAnnounceableObject methodsFor: 'attributes'!hasAttribute: aKey 	"Return true if attributes includes aKey"		^ attributes notNil and: [ attributes includesKey: aKey ]! !!RSAnnounceableObject methodsFor: 'attributes'!hasAttributes 	"Return true if at least one attributes is present"		^ attributes notNil and: [ attributes notEmpty ]! !!RSAnnounceableObject methodsFor: 'interactions'!hasInteraction: anInteractionClass	"Return true or false if the receiver has an interaction. Note that the argument has to be an interaction class. And not an event"	self announcer subscriptions ifNil: [ ^ false ].	^ self announcer subscriptions handleSubscriberClass: anInteractionClass! !!RSAnnounceableObject methodsFor: 'attributes'!hasNotAttribute: aKey 	"Return false if attributes includes aKey"		^ (self hasAttribute: aKey) not ! !!RSAnnounceableObject methodsFor: 'attributes'!removeAttributeAt: aKey	^ self attributes removeKey: aKey! !!RSAnnounceableObject methodsFor: 'attributes'!removeAttributeAt: aKey ifAbsent: anErrorBlock	^ self attributes removeKey: aKey ifAbsent: anErrorBlock! !!RSAnnounceableObject methodsFor: 'interactions'!removeInteractionIfPresent: anInteractionClass	"Remove all the callbacks associated to the interaction."	(self hasInteraction: anInteractionClass) ifFalse: [ ^ self ].	(self getInteractionsForClass: anInteractionClass) do: [ :int | self announcer unsubscribe: int ]! !!RSEdge class methodsFor: 'instance creation'!from: anElement1 to: anElement2	^ self new 		from: anElement1;		to: anElement2;		yourself! !!RSEdge methodsFor: 'adding'!addedIn: aView	view := aView.	view addEdge: self.! !!RSEdge methodsFor: 'accessing'!attachPoint	^ attachPoint! !!RSEdge methodsFor: 'accessing'!attachPoint: ap	attachPoint := ap.! !!RSEdge methodsFor: 'accessing'!controlPoints 	^ controlPoints! !!RSEdge methodsFor: 'accessing'!controlPoints: aCollection	controlPoints := aCollection.	aCollection isCollection ifFalse: [ ^ self ].	controlPoints do: [ :cp | 		self setAnchor: nil element: cp ].! !!RSEdge methodsFor: 'accessing'!from	^ from! !!RSEdge methodsFor: 'accessing'!from: anElement	from := self setAnchor: from element: anElement.! !!RSEdge methodsFor: 'initialization'!initialize	super initialize.	attachPoint := RSCenteredAttachPoint new.! !!RSEdge methodsFor: 'testing'!isUsedInLayout	"This should be changed"	^ true! !!RSEdge methodsFor: 'removing'!remove	view ifNil: [ ^ self ].	view removeEdge: self.	view := nil.! !!RSEdge methodsFor: 'rendering'!renderOn: v	super renderOn: v.	self update.! !!RSEdge methodsFor: 'private'!setAnchor: ref element: anObject		(ref isNotNil and: [ anObject isPoint not ])		ifTrue: [ ref removeConnectedEdge: self ].	anObject ifNil: [ ^ nil ].	anObject isPoint | anObject isBlock		ifFalse: [ anObject addConnectedEdge: self ].	^ anObject! !!RSEdge methodsFor: 'accessing'!to 		^ to! !!RSEdge methodsFor: 'accessing'!to: anElement	to := self setAnchor: to element: anElement.! !!RSEdge methodsFor: 'updating'!update	trachelShape isControlPointsLine ifTrue: [ 		^ self updateWithControlPoints.	].	trachelShape 		startPoint: (attachPoint startingPointOf: self);		endPoint: (attachPoint endingPointOf: self);		notifyExtentChanged.! !!RSEdge methodsFor: 'updating'!updateWithControlPoints	| cp |	controlPoints ifNil: [ ^ self ]. 		cp := controlPoints isCollection ifTrue: [  		controlPoints collect: [ :anObject | | v |			v := anObject value.			v class = RSElement ifTrue: [ v := v position ].			v ].	] ifFalse: [ 		controlPoints 			value: (attachPoint startingPointOf: self)			value: (attachPoint endingPointOf: self)	].	trachelShape controlPoints: cp; notifyExtentChanged.! !!RSElement methodsFor: 'edges'!addConnectedEdge: anEdge	[ anEdge class == RSEdge ] assert.	(self connectedEdges includes: anEdge) 		ifFalse: [ self connectedEdges add: anEdge ]! !!RSElement methodsFor: 'adding'!addedIn: aView	view := aView.	view addElement: self.! !!RSElement methodsFor: 'accessing'!connectedEdges	"Return the list of connected egdes (i.e., incoming and outgoing edges)"	connectedEdges ifNil: [ connectedEdges := TSGroup new ].	^ connectedEdges! !!RSElement methodsFor: 'edges'!incomingEdges	"Return the list of incoming edges from the node"	connectedEdges ifNil: [ ^ #() ].	^ self connectedEdges select: [ :e | e to == self ]! !!RSElement methodsFor: 'initialization'!initialize	super initialize.	self updateEdgesON! !!RSElement methodsFor: 'edges'!isDirectlyConnectedTo: anElement	connectedEdges ifNil: [ ^ false ].	^ connectedEdges anySatisfy: [ :edge | edge to == anElement ]! !!RSElement methodsFor: 'edges'!outgoingEdges	"Return the list of outgoing edges from the node"	connectedEdges ifNil: [ ^ #() ].	^ self connectedEdges select: [ :e | e from == self ]! !!RSElement methodsFor: 'removing'!remove	view removeElement: self.	view := nil.	self removeConnectedEdges.! !!RSElement methodsFor: 'edges'!removeConnectedEdge: anEdge	[  anEdge class == RSEdge ] assert.	self connectedEdges remove: anEdge ifAbsent: [ ]! !!RSElement methodsFor: 'edges'!removeConnectedEdges	"Remove all the edges connected (incoming and outgoing)."	self connectedEdges copy do: [ :edge | edge remove ]! !!RSElement methodsFor: 'actions'!translateBy: delta	self translateTo: self trachelShape position + delta.	! !!RSElement methodsFor: 'actions'!translateTo: position	trachelShape translateTo: position.	self updateConnectedEdges.! !!RSElement methodsFor: 'edges'!updateConnectedEdges	shouldUpdateEdges ifFalse: [ ^ self ].	connectedEdges ifNil: [ ^ self ].	self connectedEdges do: [ :edge | edge update ]! !!RSElement methodsFor: 'edges'!updateEdgesOFF	shouldUpdateEdges := false! !!RSElement methodsFor: 'edges'!updateEdgesON	shouldUpdateEdges := true! !!RSShapedObject methodsFor: 'adding'!addedIn: c	self subclassResponsibility! !!RSShapedObject methodsFor: 'accessing'!announcer	^ trachelShape announcer! !!RSShapedObject methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^ aMessage sendTo: trachelShape ! !!RSShapedObject methodsFor: 'accessing'!index	^ index! !!RSShapedObject methodsFor: 'accessing'!index: anInteger	index := anInteger! !!RSShapedObject methodsFor: 'accessing'!model	^ model! !!RSShapedObject methodsFor: 'accessing'!model: anObject	model := anObject! !!RSShapedObject methodsFor: 'reflective operations'!onMyselfDo: ablock	ablock value: self.! !!RSShapedObject methodsFor: 'removing'!remove	self subclassResponsibility! !!RSShapedObject methodsFor: 'rendering'!renderOn: trCanvas	trachelShape isNil ifTrue: [ self error: 'Cannot add an element without a shape. Add a shape to myself, using + or addShape:' . ^ self ].	trCanvas addShape: trachelShape.	! !!RSShapedObject methodsFor: 'accessing'!trachelShape	^ trachelShape ! !!RSShapedObject methodsFor: 'accessing'!trachelShape: aShape	| old |	old := trachelShape. 	trachelShape := aShape.	old ifNil: [ ^ self ].	aShape loadShape: old.	old parent shapes replaceAll: old with: trachelShape.	! !!RSShapedObject methodsFor: 'accessing'!view	^ view! !!RSView methodsFor: 'accessing'!add: anElementOrAnEdge	self assert: [ anElementOrAnEdge ~= nil ] description: 'Nil cannot be added to a view'.	anElementOrAnEdge 		addedIn: self;		renderOn: trCanvas.	^ anElementOrAnEdge! !!RSView methodsFor: 'accessing'!addAll: someElements	someElements do: [ :e | self add: e  ].! !!RSView methodsFor: 'accessing'!addEdge: anEdge	edges add: anEdge! !!RSView methodsFor: 'accessing'!addElement: anElement	elements add: anElement! !!RSView methodsFor: 'accessing'!announcer 	^ trCanvas announcer! !!RSView methodsFor: 'accessing'!canvas	^trCanvas ! !!RSView methodsFor: 'reflective operations'!doesNotUnderstand: aMessage	^ aMessage sendTo: trCanvas! !!RSView methodsFor: 'accessing'!edges	"Return the edges that belongs to the view"	^ edges! !!RSView methodsFor: 'accessing'!elementFromModel: anObject	"Return an element that corresponds to the object provided as parameter. If none is found, then return nil"	^ elements elementFromModel: anObject! !!RSView methodsFor: 'accessing'!elements	^ TSGroup withAll: elements! !!RSView methodsFor: 'accessing'!elementsFromModel: anObject	"Return an element that corresponds to the object provided as parameter. If none is found, then return nil"	^ elements elementsFromModel: anObject! !!RSView methodsFor: 'accessing'!elementsFromModels: objects	"Return elements that corresponds to the objects provided as parameter. If none is found, then return an empty collection"	^ elements elementsFromModels: objects! !!RSView methodsFor: 'initialization'!initialize	super initialize.	self initializeContent.	self setCanvas: TSCanvas new! !!RSView methodsFor: 'initialization'!initializeContent	elements := TSGroup new.	edges := TSGroup new! !!RSView methodsFor: 'accessing'!numberOfEdges	"Return the number of edges that belongs to the view"	^ self edges size! !!RSView methodsFor: 'removing'!removeEdge: edge	edges remove: edge ifAbsent: [ ].	edge trachelShape remove.! !!RSView methodsFor: 'removing'!removeElement: anElement	elements remove: anElement ifAbsent: [ ].	anElement trachelShape remove.! !!RSView methodsFor: 'accessing'!setCanvas: aTrachelCanvas	trCanvas := aTrachelCanvas.	trCanvas view: self.! !!RSAttachPoint class methodsFor: 'instance creation'!centered	^ RSCenteredAttachPoint new! !!RSAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ self subclassResponsibility ! !!RSAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ self subclassResponsibility ! !!RSAttachPoint methodsFor: 'public - hooks'!endingPointOf: anEdge	(anEdge from = anEdge to) 		ifTrue: [ ^ self position: anEdge from ].    ^ inverted        ifTrue: [ self basicStartingPointOf: anEdge ]        ifFalse: [ self basicEndingPointOf: anEdge ]! !!RSAttachPoint methodsFor: 'public - hooks'!initialize	super initialize.	inverted := false.! !!RSAttachPoint methodsFor: 'public - hooks'!position: anObject	anObject isPoint ifTrue: [ ^ anObject ].	^ anObject position! !!RSAttachPoint methodsFor: 'public - hooks'!startingPointOf: anEdge	(anEdge from = anEdge to) 		ifTrue: [ ^ self position: anEdge from ].    ^ inverted        ifTrue: [ self basicEndingPointOf: anEdge ]        ifFalse: [ self basicStartingPointOf: anEdge ]! !!RSBorderAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ self basicPointFrom: anEdge to to: anEdge from of: anEdge! !!RSBorderAttachPoint methodsFor: 'public - hooks'!basicPointFrom: fromElement to: toElement of: anEdge	| source target line shift |	source := fromElement geometry.	target := toElement geometry.	shift := self offsetNormalFor: anEdge.	line := GLineSegment from: source center to: target center.	shift := (line vector = (0@0) 		ifTrue: [ -1 @ 0]		ifFalse: [ line vector normal ]) * shift.	anEdge from = toElement		ifTrue: [ shift := shift * -1 ].	line := GLineSegment from: source center + shift to: target center + shift.	^ self borderPointFrom: source to: target via: line! !!RSBorderAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ self basicPointFrom: anEdge from to: anEdge to of: anEdge! !!RSBorderAttachPoint methodsFor: 'public - hooks'!borderPointFrom: aSource to: aTarget via: aLine	^ ((aLine intersect: aSource) detectMin: [ :p | p dist: aLine to ])		ifNil: [ aSource center ]! !!RSBorderAttachPoint methodsFor: 'initialization'!initialize	super initialize.	offset := 5! !!RSBorderAttachPoint methodsFor: 'accessing'!offset	^ offset! !!RSBorderAttachPoint methodsFor: 'accessing'!offset: aNumber	offset := aNumber! !!RSBorderAttachPoint methodsFor: 'public - hooks'!offsetNormalFor: anEdge	"Return the offset in case of multiple edges with the same starting and ending points"	| indexOfEdge multipleEdges |	multipleEdges := OrderedCollection new.	multipleEdges		addAll:			(anEdge to connectedEdges				select: [ :e | e from == anEdge from and: [ e to == anEdge to ] ]).	multipleEdges		addAll:			(anEdge to connectedEdges				select: [ :e | e to == anEdge from and: [ e from == anEdge to ] ]).	multipleEdges size <= 1		ifTrue: [ ^ 0 @ 0 ].	indexOfEdge := multipleEdges indexOf: anEdge.	^ (indexOfEdge - 1 - (multipleEdges size / 2)) * offset! !!RSCenteredAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ self position: anEdge to	! !!RSCenteredAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ self position: anEdge from! !!RSHorizontalAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: edge	^ edge to encompassingRectangle leftCenter + (endOffset@0)! !!RSHorizontalAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: edge	^ edge from encompassingRectangle rightCenter + (startOffset@0)! !!RSOffsetAttachPoint methodsFor: 'accessing'!endOffset	^ endOffset! !!RSOffsetAttachPoint methodsFor: 'accessing'!endOffset: aNumber	endOffset := aNumber! !!RSOffsetAttachPoint methodsFor: 'public - hooks'!initialize 	super initialize.	startOffset := endOffset := 0.! !!RSOffsetAttachPoint methodsFor: 'accessing'!startOffset	^ startOffset! !!RSOffsetAttachPoint methodsFor: 'accessing'!startOffset: aNumber	startOffset := aNumber.! !!RSVerticalAttachPoint methodsFor: 'public - hooks'!basicEndingPointOf: anEdge	^ anEdge to encompassingRectangle topCenter + (0@endOffset)! !!RSVerticalAttachPoint methodsFor: 'public - hooks'!basicStartingPointOf: anEdge	^ anEdge from encompassingRectangle bottomCenter + (0@startOffset)! !!RSCommand methodsFor: 'comparing'!= aCommand	^ aCommand class == self class and: [ message selector == aCommand message selector ].! !!RSCommand methodsFor: 'accessing - computed'!argumentTarget	^ self isForModel		ifTrue: [ element model ]		ifFalse: [ element ]! !!RSCommand methodsFor: 'accessing - computed'!arguments	| args target |	args := Array new: message arguments size.	target := self argumentTarget.	message arguments doWithIndex: [ :arg :index |		args at: index put: (arg rsValue: target) ].	^ args! !!RSCommand methodsFor: 'acccessing'!component	^ component! !!RSCommand methodsFor: 'acccessing'!component: anObject	component := anObject! !!RSCommand methodsFor: 'acccessing'!element	^ element! !!RSCommand methodsFor: 'acccessing'!element: anElement	element := anElement! !!RSCommand methodsFor: 'executing'!execute	| target arguments |	target := self target.	arguments := self arguments.	target perform: self message selector withArguments: arguments.	^ arguments.! !!RSCommand methodsFor: 'comparing'!hash 	^ message selector hash! !!RSCommand methodsFor: 'testing'!isCondition 	^ false! !!RSCommand methodsFor: 'acccessing'!isForModel	^  isForModel! !!RSCommand methodsFor: 'acccessing'!isForModel: bool	isForModel := bool! !!RSCommand methodsFor: 'acccessing'!message	^ message! !!RSCommand methodsFor: 'acccessing'!message: aMessage	message := aMessage! !!RSCommand methodsFor: 'printing'!printOn: stream	self message printOn: stream! !!RSCommand methodsFor: 'dependencies'!release 	super release.	element := component := message := nil! !!RSCommand methodsFor: 'acccessing'!selector	^ message selector! !!RSCommand methodsFor: 'accessing - computed'!target	^ (element class canUnderstand: message selector) 		ifTrue: [ element ]		ifFalse: [ component ]! !!RSConditionCommand methodsFor: 'accessing'!builder	^ builder ! !!RSConditionCommand methodsFor: 'accessing'!builder: aBuilder	builder := aBuilder! !!RSConditionCommand methodsFor: 'accessing'!condition	^ condition! !!RSConditionCommand methodsFor: 'accessing'!condition: aBlock	condition := aBlock! !!RSConditionCommand methodsFor: 'executing'!execute	| target |	target := self argumentTarget.	(self condition rsValue: target) ifTrue: [ 		builder 			executeDuring: self message			element: self element			component: self component ].! !!RSConditionCommand methodsFor: 'testing'!isCondition 	^ true! !!RSConditionCommand methodsFor: 'printing'!printOn: stream	stream nextPutAll: 'if: '.	condition printOn: stream.	stream nextPutAll: ' actions: '.	message printOn: stream! !!RSConditionCommand methodsFor: 'dependencies'!release 	super release.	builder := condition := nil.! !!RSConditionCommand methodsFor: 'acccessing'!selector 	^ nil! !!RSControlsView methodsFor: 'initialization'!initialize	super initialize.	resizeCanvas := true.	steps := Set new.	speed := 1.	keyDownActions := Dictionary new		at: 28 put: -1 @ 0; "left"		at: 29 put: 1 @ 0; "right"		at: 30 put: 0 @ -1; "up"		at: 31 put: 0 @ 1; "down"		yourself.	keyUpActions := Dictionary new "mac" "TODO review asKeyCombination and this in other os"		at: 34 put: RSZoomMove in;		at: 31 put: RSZoomMove out;		at: 49 put: RSZoomToFitView new;		at: 46 put: RSMaximizeView new;		at: 123 put: -1@ 0; "left"		at: 124 put: 1 @ 0; "right"		at: 126 put: 0 @ -1; "up"		at: 125 put: 0 @ 1; "down"		yourself.! !!RSControlsView methodsFor: 'public'!noResizeCanvas	resizeCanvas := false! !!RSControlsView methodsFor: 'hooks'!onElement: aView	aView @ RSZoomableView.	aView @ RSDraggableView.	resizeCanvas ifTrue: [ 		aView zoomToFit.		aView when: TSExtentChangedEvent do: [ aView zoomToFit ]. 	 ].		aView		when: TSKeyDown do: [ :evt | | rect | 			rect := aView encompassingRectangle.			speed := (rect width min: rect height) * 0.05.			self processKeyDown: evt ];		when: TSKeyUp do: [ :evt | self processKeyUp: evt ].		RSMenuActivable new 		onElement: aView;		menuDo: [:menu | 			(menu 				add: 'Zoom in'				target: RSZoomMove in				selector: #onElement: 				argument: aView)				icon: (self iconNamed: #glamorousZoomIn).			(menu 				add: 'Zoom to fit'				target: RSZoomToFitView new				selector: #onElement: 				argument: aView)				icon: (self iconNamed: #glamorousZoomToFit).			(menu 				add: 'Zoom out'				target: RSZoomMove out				selector: #onElement: 				argument: aView)				icon: (self iconNamed: #glamorousZoomOut) ].	! !!RSControlsView methodsFor: 'hooks'!processKeyDown: evt	| action mult |	action := keyDownActions at: evt keyValue ifAbsent: [^ self ].	steps add: action.		mult := evt shiftKeyPressed ifTrue: [ 3 ] ifFalse: [ 1 ].	translationAnimation ifNil: [  		translationAnimation := evt canvas animation repeat			onStepDo: [ :t | | step |				step := steps inject: 0@0 into: [:p :s |p+s ].				evt canvas camera translateBy: step / (evt canvas camera scale / (speed*mult) ).				evt signalUpdate ] ].! !!RSControlsView methodsFor: 'hooks'!processKeyUp: evt	| action remove |	"Transcript show: evt keyValue; cr."	action := keyUpActions at: evt keyValue ifAbsent: [^ self ].	remove := [ 		(steps isEmpty and: [ translationAnimation notNil ]) ifTrue:  [ 			translationAnimation stop.			translationAnimation := nil ] ].	action isPoint ifFalse: [		steps removeAll.		remove value.		^ action onElement: evt canvas  ].	steps remove: action ifAbsent: [ ].	remove value.	! !!RSDraggableView class methodsFor: 'instance creation'!all	^ self new! !!RSDraggableView class methodsFor: 'instance creation'!left	^ self new left! !!RSDraggableView class methodsFor: 'instance creation'!middle	^ self new middle! !!RSDraggableView class methodsFor: 'instance creation'!right	^ self new right! !!RSDraggableView methodsFor: 'public - configuration'!all	"Any mouse button can be used to drag and drop the view"	mouse := TSMouseDragStart.! !!RSDraggableView methodsFor: 'initialization'!initialize	super initialize.		"Any button can be used to drag and drop"	self all.! !!RSDraggableView methodsFor: 'public - configuration'!left	"Only the left mouse button can be used to drag and drop the view	For example:		| v |	v := RTView new.	v @ RTDraggableView new left.	RTCPDiverging new viewOn: v.	^ v	"	mouse := TSMouseLeftDragStart! !!RSDraggableView methodsFor: 'public - configuration'!middle	"Only the middle mouse button can be used to drag and drop the view	For example:		| v |	v := RTView new.	v @ RTDraggableView new middle.	RTCPDiverging new viewOn: v.	^ v	"	mouse := TSMouseMiddleDragStart! !!RSDraggableView methodsFor: 'accessing'!mouse	"Return the class describing the mouse event for which the view can be dragged"	^ mouse! !!RSDraggableView methodsFor: 'hooks'!onElement: aView	"Configure the view provided as argument with call to properly handles the mouse interaction"	"also add key events for navigation"	| move lastStep camera |	move := false.	lastStep := nil.	camera := aView camera.	aView when: self mouse do: [ move := true].	aView when: TSMouseDragging do: [ :e |		move ifTrue: [ 			lastStep := e step negated / aView camera scale.			camera translateBy: lastStep.			e signalUpdate ]		].	aView when: TSMouseDragEnd do: [ 		move := false.		(lastStep isNotNil and: [ lastStep x abs > 2 or: [lastStep y abs > 2]  ]) ifTrue: [ 			aView animation 				easing: TSEasing cubicOut;				duration: 200 milliSeconds;				from: camera position;				to: camera position + (lastStep * 3);				on: camera set: #translateTo:		]	].	! !!RSDraggableView methodsFor: 'public - configuration'!right	"Only the right mouse button can be used to drag and drop the view	For example:		| v |	v := RTView new.	v @ RTDraggableView new right.	RTCPDiverging new viewOn: v.	^ v	"	mouse := TSMouseRightDragStart.! !!RSMaximizeView methodsFor: 'hooks'!onElement: aView	aView morph owner expandBoxHit.	! !!RSZoomMove class methodsFor: 'instance creation'!in	^ self new in! !!RSZoomMove class methodsFor: 'instance creation'!out	^ self new out! !!RSZoomMove methodsFor: 'modes'!in	delta := 1.5! !!RSZoomMove methodsFor: 'initialization'!initialize 	super initialize.	self in! !!RSZoomMove methodsFor: 'hooks'!onElement: anElement	| scale camera |	camera := anElement canvas camera.	scale := camera scale.	anElement animation 		easing: TSEasing backOut;		duration: 200 milliSeconds;		from: scale;		to: scale * delta;		on: anElement canvas camera set: #scale: ! !!RSZoomMove methodsFor: 'modes'!out	delta := 0.5! !!RSZoomToFitView methodsFor: 'hooks'!onElement: aView	| rect extent sc position scale camera |	camera := aView camera.	rect := aView encompassingRectangle.	extent := aView extent * 0.9.	sc := extent / (rect extent max: 1 @ 1).	sc := sc x min: sc y.	position := TSScale linear		from: camera position;		to: rect center.	scale := TSScale linear		from: camera scale;		to: sc.	camera scale < 1 ifTrue: [ 		aView animation			duration: 500 milliSeconds;			easing: TSEasing backOut;			onStepDo: [ :t | 				camera					position: (position scale: t);					scale: (scale scale: t).				aView signalUpdate ].		^ self ].	aView animation 		delay: 150 milliSeconds;		duration: 700 milliSeconds;		easing: TSEasing backOut;		onStepDo: [:t |			camera position: (position scale: t).			aView signalUpdate].	aView animation		duration: 300 milliSeconds;		easing: (TSEasing exp);		onStepDo: [ :t | 				camera scale: (scale scale: t).				aView signalUpdate]		! !!RSZoomableView class methodsFor: 'instance creation'!min: aMin max: aMax	^ self new		minZoom: aMin;		maxZoom: aMax;		yourself! !!RSZoomableView methodsFor: 'accessing'!maxZoom	^ maxZoom ifNil: [ 10 ]! !!RSZoomableView methodsFor: 'accessing'!maxZoom: aFloat	maxZoom := aFloat! !!RSZoomableView methodsFor: 'accessing'!minZoom	^ minZoom ifNil: [ 0.1 ]! !!RSZoomableView methodsFor: 'accessing'!minZoom: aFloat	minZoom := aFloat! !!RSZoomableView methodsFor: 'hooks'!onElement: aView	aView 		when: TSMouseWheelEvent				do: [ :e | self processEvent: e ]! !!RSZoomableView methodsFor: 'hooks'!processEvent: evt	| scale dist |	dist := evt position - evt canvas camera position.	scale := evt canvas camera scale.		evt isUp ifTrue: [  		scale * 1.25 <= self maxZoom ifTrue: [ 			scale := scale * 1.25.			dist := dist * 0.2 ]		ifFalse: [ ^ self ].		].	evt isDown ifTrue:  [		scale * 0.8 >= self minZoom ifTrue: [ 			scale := scale * 0.8.			dist := dist * -0.25 ]		ifFalse: [ ^ self ]	].	evt canvas camera		scale: scale;		translateBy: dist.	evt signalUpdate! !!RSDraggable methodsFor: 'hooks'!onElement: e	| d |	e when: TSMouseDragging do: [ :evt |		d := e parent camera distanceFromPixelToSpace: evt step. 		e translateBy: d.		e signalUpdate.		 ].! !!RSInteraction class methodsFor: 'instance creation'!onElement: element	^ self new onElement: element! !!RSInteraction methodsFor: 'hooks'!onElement: anElement	self subclassResponsibility 	! !!RSLabeled methodsFor: 'hooks'!createLabel: anElement	| label v color set |	label := shape elementOn: anElement model.	location stick: label on: anElement.	v := anElement view.	v add: label.	anElement attributes at: #RSLabeled put: label.	isHighlightable ifFalse: [ ^ self ].	color := label color.	label color: self lowColor.	set := [ :c | label pushFront; color: c; signalUpdate ].	anElement 		when: TSMouseEnter do: [ set value: color ];		when: TSMouseLeave do: [ set value: lowColor ].! !!RSLabeled methodsFor: 'public - configuration'!highlightable	isHighlightable := true! !!RSLabeled methodsFor: 'initialization'!initialize 	super initialize.	shape := RSShapeBuilder label.	location := RSLocate new above.! !!RSLabeled methodsFor: 'accessing'!location	^ location! !!RSLabeled methodsFor: 'accessing'!lowColor	^ lowColor ifNil: [ lowColor := Color veryVeryLightGray ].! !!RSLabeled methodsFor: 'accessing'!lowColor: aColor	lowColor := aColor! !!RSLabeled methodsFor: 'hooks'!onElement: anElement	| block |	block := [ self createLabel: anElement. ]. 	anElement isInACanvas 		ifTrue: block		ifFalse: [ anElement when: TSShapeAddedEvent do: block ].! !!RSLabeled methodsFor: 'accessing'!shape	^ shape! !!RSLabeled methodsFor: 'accessing'!shape: aShapeBuilder	shape := aShapeBuilder! !!RSMenuActivable methodsFor: 'enumerating'!menuDo: block	menuBlock := block! !!RSMenuActivable methodsFor: 'hooks'!onElement: anElement	anElement when: TSMouseRightClick do: [ :evt | 		| menu |		menu := MenuMorph new.		menuBlock value: menu.		menu popUpInWorld ].! !!RSPopup class methodsFor: 'accessing'!text: anObject	| inst |	inst := self new.	inst label text: anObject.	^ inst! !!RSPopup methodsFor: 'hooks'!createOrGetPopupOn: anElement	| textElement boxElement att g element |	att := anElement topParent view attributes.	att		at: #popup		ifPresent: [ :popup | ^ popup ].	g := TSGroup new.	textElement := label elementOn: anElement model.	boxElement := box elementOn: textElement.	g add: boxElement; add: textElement.	element := g asElement.	att at: #popup put: element.	element isFixed: true.	anElement topParent view add: element.	^ element	! !!RSPopup methodsFor: 'initialization'!initialize	super initialize.	label := RSShapeBuilder label.	box := RSShapeBuilder box		color: (Color colorFrom: 'efefef');		cornerRadius: 5;		border: (TSBorder new color: Color gray);		extent: [ :m | m extent + 5 ].! !!RSPopup methodsFor: 'accessing'!label	^ label! !!RSPopup methodsFor: 'hooks'!onElement: anElement	| remove |	remove := [ :evt | self removePopupOn: evt ].	anElement		when: TSMouseClick do: remove;		when: TSMouseEnter do: remove;		when: TSMouseLeave do: remove;		when: TSMouseDragging do: remove;		when: TSMouseMove do: [ :evt | | popup e p |			popup := self createOrGetPopupOn: anElement.			p := (anElement topParent camera 				fromSpaceToPixel: evt position).			e :=  (popup extent /2) + 5.			p x +  popup extent x > popup view extent x ifTrue: [ 				e := e x negated @ e y.				p x - popup extent x < 0					ifTrue: [ e := p x negated + (popup extent x /2) @ e y ].			].			popup translateTo: p + e.			popup signalUpdate. ]! !!RSPopup methodsFor: 'hooks'!removePopupOn: evt 	| att popup view |	view := evt canvas view.	view ifNil: [ ^ self ].	att := view attributes.	(att includesKey: #popup) ifFalse: [ ^ self ].	popup := att at: #popup.		popup remove.	att removeKey: #popup.	evt signalUpdate.! !!RSInteractionBuilder methodsFor: 'adding'!addExclusiveInteraction: anInteraction	"We only keep all the interaction that have a different class"	interactions := interactions select: [ :i | i class ~~ anInteraction class ].	self addInteraction: anInteraction! !!RSInteractionBuilder methodsFor: 'adding'!addInteraction: anInteraction	interactions add: anInteraction! !!RSInteractionBuilder methodsFor: 'interactions'!browseable	self addInteraction: [ :element | element when: TSMouseClick do: [ :evt | element model browse ] ].! !!RSInteractionBuilder methodsFor: 'interactions'!clear	interactions removeAll.! !!RSInteractionBuilder methodsFor: 'interactions'!draggable	| i |	self addExclusiveInteraction: (i := RSDraggable new).	^ i	! !!RSInteractionBuilder methodsFor: 'initialization'!initialize	super initialize.	interactions := OrderedCollection new.! !!RSInteractionBuilder methodsFor: 'interactions'!labeled	| i |	self addExclusiveInteraction: (i := RSLabeled new).	^ i	! !!RSInteractionBuilder methodsFor: 'interactions'!labeledHighlightable	| i |	i := self labeled.	i highlightable.	^ i! !!RSInteractionBuilder methodsFor: 'interactions'!popup	^ self popupText: #yourself! !!RSInteractionBuilder methodsFor: 'interactions'!popupText: anObject	| i |	self addExclusiveInteraction: (i := RSPopup new).	i label text: anObject.	^ i.! !!RSInteractionBuilder methodsFor: 'initialization'!setUpElement: elementOrGroup	"elements is an RTGroup, that contains RTElement or RTEdges"		interactions do: [ :int | elementOrGroup @ int ]! !!RSInteractionBuilder methodsFor: 'interactions'!when: event do: block	self addInteraction: [ :element | element when: event do: block ]! !!SequenceableCollection methodsFor: '*Roassal3'!asGroup	^ (TSGroup new: self size) addAll: self; yourself! !"Roassal3"!!RSAbstractElementHandling commentStamp: '' prior: 0!I am base class for RSAlignment and RSResize!!RSAlignment commentStamp: '' prior: 0!Define alignment of elements. For example, inspect the following:-=-=-=	objects := TSShape withAllSubclasses.	v := RSView new.	v showEncompassingRectangles.	n := TSScale category20c.	shape := RSShapeBuilder box color: n; size: [ : c | c numberOfMethods ].	es := shape elementsOn: objects.	v addAll: es.	RSHorizontalLineLayout new gapSize: 0; on: es.	RTAlignment new elements: es; bottom.	v @ RSControlsView.	v open-=-=-=!!RSResize commentStamp: '' prior: 0!Adjust the size of the Elements.[ [ [ 	values := #(35 26 5 18 17 60 36 13 16 28 29 3 8 0 3 2 14 12 13 17 1 9 3 3 4 1 1 1 2 1 1 61).	v := RSView new.	n := TSScale category20c.	shape := RSShapeBuilder box color: n; size: #yourself.	es := shape elementsOn: values.	v addAll: es.	RTResize new elements: es; sameSize.	RSHorizontalLineLayout new gapSize: 0; on: es.		v @ RSControlsView.	v open ] ] ]!!RSLocate commentStamp: '' prior: 0!I am iteratively buildable constraint for moving and positioning an element on top of another one.!!!! UsageThe order of configuration message sends is irrelevant, only the last of a group will be used.Here is an example:```Smalltalkv := RSView new.classes := Collection withAllSubclasses.boxes := RSShapeBuilder box				width: [ :cls | cls instVarNames size * 5 max: 5 ];				height: [ :cls | cls numberOfMethods max: 5 ];				elementsOn: classes.boxes @ RSDraggable.v addAll: boxes.RSEdgeBuilder orthoVertical	view: v;	attachPoint: RSVerticalAttachPoint new;	elements: boxes;	connectFrom: #superclass.boxes do: [ :b |	| t |	t := RSShapeBuilder label height: 2; text: #name; elementOn: b model.	v add: t.	RSLocate new		padding: 1;		fix: b;		movable: t;		above; center; stick.].RSTreeLayout on: boxes.v @ RSControlsView.v open```!!RSNormalizer commentStamp: '' prior: 0!A Metric normalizer is made to assign a color, or a particular shape computed from a group of elements. Consider the following example:!!RSAbstractElementHandling methodsFor: 'accessing'!elements	^ elements! !!RSAbstractElementHandling methodsFor: 'accessing'!elements: someElements	elements := someElements asGroup! !!RSAbstractElementHandling methodsFor: 'accessing'!fixedElement	^ fixedElement! !!RSAbstractElementHandling methodsFor: 'accessing'!fixedElement: anElement	"Designate a particular element for which all the other will be aligned against"	fixedElement := anElement! !!RSAbstractElementHandling methodsFor: 'private - configuration'!ifNoFixedElementThen: aBlock	fixedElement ifNil: [ aBlock value  ]! !!RSAlignment methodsFor: 'public'!alignFromBottomUsing: anElement	"The argument anElement is a fix point. It does not move"	| topY newY |	topY := anElement encompassingRectangle bottomCenter y.	elements do: [ :s |		newY := topY - (s encompassingRectangle height / 2).		s translateTo: s position x @ newY	]! !!RSAlignment methodsFor: 'public'!alignFromCenterUsing: anElement	| topX newX topY newY |		topX := anElement encompassingRectangle center x.	topY := anElement encompassingRectangle center y.		elements do: [ :s |		newX := topX + (s encompassingRectangle width / 2).		newY := topY + (s encompassingRectangle height / 2).				s translateTo: newX @ newY	]! !!RSAlignment methodsFor: 'public'!alignFromLeftUsing: anElement	| topX newX |	topX := anElement encompassingRectangle topLeft x.	elements do: [ :s |		newX := topX + (s encompassingRectangle width / 2).		s translateTo: newX @ s position y	]! !!RSAlignment methodsFor: 'public'!alignFromRightUsing: anElement	| topX newX |	topX := anElement encompassingRectangle topRight x.	elements do: [ :s |		newX := topX - (s encompassingRectangle width / 2).		s translateTo: newX @ s position y	]! !!RSAlignment methodsFor: 'public'!alignFromTopUsing: anElement	| topY newY |	topY := anElement encompassingRectangle topCenter y.	elements do: [ :s |		newY := topY + (s encompassingRectangle height / 2).		s translateTo: s position x @ newY	]! !!RSAlignment methodsFor: 'public'!bottom	self hasElement ifFalse: [ ^ self ].	self alignFromBottomUsing: self bottomMostElement ! !!RSAlignment methodsFor: 'accessing - computed'!bottomMostElement	fixedElement ifNotNil: [ ^ fixedElement ].	^ elements inject: elements first into: [ :maxS :s | 			maxS encompassingRectangle top <= s encompassingRectangle top					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSAlignment methodsFor: 'public'!center	self hasElement ifFalse: [ ^ self ].	self alignFromCenterUsing: self centerMostElement! !!RSAlignment methodsFor: 'public'!centerMostElement	fixedElement ifNotNil: [ ^ fixedElement ].	^ elements inject: elements first into: [ :maxS :s | 			maxS encompassingRectangle center <= s encompassingRectangle center					ifTrue: [ s ] ifFalse: [ maxS ] ]! !!RSAlignment methodsFor: 'testing'!hasElement	"Return true if some elements have been set"	^ (elements isNil or: [ elements isEmpty ]) not! !!RSAlignment methodsFor: 'public'!left	self hasElement ifFalse: [ ^ self ].	self alignFromLeftUsing: self leftMostElement ! !!RSAlignment methodsFor: 'accessing - computed'!leftMostElement	fixedElement ifNotNil: [ ^ fixedElement ].	^ elements inject: elements first into: [ :maxS :s | 			maxS encompassingRectangle left >= s encompassingRectangle left					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSAlignment methodsFor: 'public'!right	self hasElement ifFalse: [ ^ self ].	self alignFromRightUsing: self rightMostElement ! !!RSAlignment methodsFor: 'accessing - computed'!rightMostElement	fixedElement ifNotNil: [ ^ fixedElement ].	^ elements inject: elements first into: [ :maxS :s | 			maxS encompassingRectangle right <= s encompassingRectangle right					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSAlignment methodsFor: 'public'!top	self hasElement ifFalse: [ ^ self ].	self alignFromTopUsing: self topMostElement ! !!RSAlignment methodsFor: 'accessing - computed'!topMostElement	fixedElement ifNotNil: [ ^ fixedElement ].	^ elements inject: elements first into: [ :maxS :s | 			maxS encompassingRectangle top >= s encompassingRectangle top					ifTrue: [ s ] ifFalse: [ maxS ] ] ! !!RSResize methodsFor: 'accessing - computed'!biggestElement	^ elements inject: elements anyOne into: [ :biggestElement :e | 			biggestElement extent < e extent				ifTrue: [ e ] ifFalse: [ biggestElement ] ] ! !!RSResize methodsFor: 'accessing - computed'!biggestExtent	fixedElement ifNotNil: [ ^ fixedElement extent ].	^ elements inject: 0 @ 0 into: [ :maxExtent :e | 			maxExtent max: e extent ] ! !!RSResize methodsFor: 'accessing - computed'!highestElement	^ elements inject: elements anyOne into: [ :highestElement :e | 			highestElement extent y < e extent y				ifTrue: [ e ] ifFalse: [ highestElement ] ] ! !!RSResize methodsFor: 'public'!sameHeight	self ifNoFixedElementThen: [ self useHighestElement ].	elements do: [ :e | e height: self fixedElement height ]! !!RSResize methodsFor: 'public'!sameSize	self ifNoFixedElementThen: [ self useBiggestElement ].	elements do: [ :e | e extent: self fixedElement extent ]! !!RSResize methodsFor: 'public'!sameWidth	self ifNoFixedElementThen: [ self useWidestElement ].	elements do: [ :e | e width: self fixedElement width ]! !!RSResize methodsFor: 'public - configuration'!useBiggestElement	self fixedElement: self biggestElement! !!RSResize methodsFor: 'public - configuration'!useHighestElement	self fixedElement: self highestElement ! !!RSResize methodsFor: 'public - configuration'!useWidestElement	self fixedElement: self widestElement! !!RSResize methodsFor: 'accessing - computed'!widestElement	^ elements inject: elements anyOne into: [ :widestElement :e | 			widestElement extent x < e extent x				ifTrue: [ e ] ifFalse: [ widestElement ] ] ! !!RSLocate methodsFor: 'public - positioning shorcuts'!above 	self top; outer.! !!RSLocate methodsFor: 'public - positioning shorcuts'!below 	self bottom; outer! !!RSLocate methodsFor: 'public - modifiers'!border	orientation := 0! !!RSLocate methodsFor: 'public - positioning'!bottom	fixedY := #bottom.	direction := direction x@ -1.! !!RSLocate methodsFor: 'public - positioning'!center	fixedX := [:rec | rec rsCenter x].	direction := 0@ direction y! !!RSLocate methodsFor: 'private'!computePosition: movableElement on: fixedElement	^ movableElement extent / 2 * orientation * direction + (self parentPosition: fixedElement) + padding.! !!RSLocate methodsFor: 'initialization'!initialize	super initialize.	direction := 0@0.	self		padding: 0;		inner;		middle;		center! !!RSLocate methodsFor: 'public - modifiers'!inner	orientation := 1! !!RSLocate methodsFor: 'public - positioning'!left	fixedX := #left.	direction := 1@ direction y! !!RSLocate methodsFor: 'public - positioning'!middle	fixedY := [ :r | r rsCenter y ].	direction := direction x @ 0! !!RSLocate methodsFor: 'public - executing'!move: movableElement on: fixElement	movableElement translateTo: (self computePosition: movableElement on: fixElement).! !!RSLocate methodsFor: 'public - modifiers'!outer	orientation := -1! !!RSLocate methodsFor: 'public - modifiers'!padding	^ padding! !!RSLocate methodsFor: 'public - modifiers'!padding: aNumber	padding := aNumber asPoint! !!RSLocate methodsFor: 'private'!parentPosition: fixedElement	| rec |	rec := fixedElement encompassingRectangle.	^ (fixedX value: rec)@ (fixedY value: rec).! !!RSLocate methodsFor: 'public - positioning'!right	fixedX := #right.	direction := -1@direction y.! !!RSLocate methodsFor: 'public - executing'!stick: movableElement on: fixedElement	| block |	block := [ self move: movableElement on: fixedElement ].	block value.	fixedElement 		when: TSExtentChangedEvent do: block;		when: TSPositionChangedEvent do: block.! !!RSLocate methodsFor: 'public - positioning'!top	fixedY := #top.	direction := direction x @ 1! !!RSNormalizer class methodsFor: 'instance creation'!color 	| n |	n := self new.	n from: Color green.	n to: Color red.	n executeBlock: [ :rsElement :aOneArgBlockOrSymbol | rsElement color: (n scale scale: (aOneArgBlockOrSymbol rsValue: rsElement model)) ].	^ n! !!RSNormalizer class methodsFor: 'instance creation'!fontSize "Here is example-=-=-=-=-=-=-=v := RSView new.v @ RSControlsView.sb := RSShapeBuilder label.sb interactionDo: #draggable.sb text: #asString.elements := sb elementsOn: (Collection withAllSubclasses).elements do: [ :e | e translateTo: (Random new nextInt: 300) @ (Random new nextInt: 300) ].v addAll: elements.RSNormalizer fontSize	elements: elements;	to: 30;	normalize: #numberOfMethods.v zoomToFit.v open-=-=-=-=-=-=-="	| n |	n := self new.	n from: 5.	n to: 100.	n executeBlock: [ :rsElement :aOneArgBlockOrSymbol | rsElement fontSize: (n scale scale: (aOneArgBlockOrSymbol rsValue: rsElement model)) ].	^ n! !!RSNormalizer class methodsFor: 'instance creation'!size 	| n |	n := self new.	n from: 5 @ 5.	n to: 100 @ 100.	n executeBlock: [ :rsElement :aOneArgBlockOrSymbol | rsElement size: (n scale scale: (aOneArgBlockOrSymbol rsValue: rsElement model)) ].	^ n! !!RSNormalizer methodsFor: 'accessing'!elements	^ elements! !!RSNormalizer methodsFor: 'accessing'!elements: someRSElements	elements := someRSElements! !!RSNormalizer methodsFor: 'accessing'!executeBlock	^ executeBlock! !!RSNormalizer methodsFor: 'accessing'!executeBlock: anOneArgBlock	executeBlock := anOneArgBlock! !!RSNormalizer methodsFor: 'accessing'!from: aValue	scale from: aValue! !!RSNormalizer methodsFor: 'initialization'!initialize	super initialize.	scale := TSScale linear.	elements := #()! !!RSNormalizer methodsFor: 'normalizer'!normalize: anOneArgBlockOrSymbol 	| minAndMax |	minAndMax := elements inject: { SmallInteger maxVal . SmallInteger minVal } into: [ :res :anElement |		| tmp |		tmp := anOneArgBlockOrSymbol rsValue: anElement model.		{ res first min: tmp . res second max: tmp } ].	scale domain: minAndMax.	elements do: [ :anEl | executeBlock value: anEl value: anOneArgBlockOrSymbol ]! !!RSNormalizer methodsFor: 'accessing'!scale	^ scale! !!RSNormalizer methodsFor: 'accessing'!scale: aTSScale	scale := aTSScale! !!RSNormalizer methodsFor: 'accessing'!to: aValue	scale to: aValue! !"Roassal3-Utils"!!RSCell commentStamp: '' prior: 0!TODO!!RSCellMatrix commentStamp: '' prior: 0!TODO!!RSDummyNode commentStamp: '' prior: 0!A RODummyNode is used by the sugiyama layout!!RSIdentityMatrix commentStamp: '' prior: 0!TODO!!RSLayout commentStamp: '' prior: 0!TODO!!RSAbstractCircleLayout commentStamp: '' prior: 0!TODO!!RSCircleLayout commentStamp: '' prior: 0!TODO!!RSAbstractWeightedCircleLayout commentStamp: '' prior: 0!I am the abstract root class of weighted circle layout. Look at the class comments of my subclasses for more details.!!RSEquidistantCircleLayout commentStamp: '' prior: 0!RTEquidistantCircleLayout is a circle layout in which elements are equidistant from each other: the layout maintains the same distance between elements.Here is an example:-=-=-=-=-=-=-=-=-=-=-=-=v := RTView new.elements := (RTEllipse new size: 5; color: Color red; size: [:vv | vv * 4 ]) elementsOn: (1 to: 15).v addAll: elements.RTEquidistantCircleLayout on: elements.v-=-=-=-=-=-=-=-=-=-=-=-=!!RSWeightedCircleLayout commentStamp: '' prior: 0!RTWeightedCircleLayout is a circle layout that gives more space to big elements and fewer space to small elements.Here is an example:-=-=-=-=-=-=-=-=-=-=-=-=v := RTView new.elements := (RTEllipse new size: 5; color: Color red; size: [:vv | vv * 4 ]) elementsOn: (1 to: 15).v addAll: elements.RTWeightedCircleLayout on: elements.v-=-=-=-=-=-=-=-=-=-=-=-=!!RSAbstractFlowLayout commentStamp: '' prior: 0!TODO!!RSFlowLayout commentStamp: '' prior: 0!A RTFlowLayout arrange elements in a rectangle including space (gapSize) between them, ideally it give you a square if all elements have an equal height and width .!!RSHorizontalFlowLayout commentStamp: '' prior: 0!A RTHorizontalFlowLayout is a FlowLayout horizontaly arranged,  right queued at default.!!RSAbstractGridLayout commentStamp: '' prior: 0!A ROAbstractGridLayout is xxxxxxxxx.Instance Variables	gapSize:		<Object>	lineItemsCountBlock:		<Object>gapSize	- xxxxxlineItemsCountBlock	- xxxxx!!RSCellLayout commentStamp: '' prior: 0!A ROCellLayout is like ROGridLayout. Elements of each column are centered along the same vertical line. And elements of each row are centered along the same horizontal line.Instance Variables	inCellPosition:		<Object | Block>inCellPosition	- Object which computes position of each element inside a cell. The cell is the space allocated for an element. Its height is maximum of heights of elements on the row. Its width is maximum of widths of elements on the column. By default elements are in the middle of their cell.!!RSGridLayout commentStamp: '' prior: 0!A ROGridLayout places elements as a grid.!!RSAbstractLineLayout commentStamp: '' prior: 0!A ROAbstractLineLayout is the abstract superclass of the line layout.Instance Variables	alignment:		<Object>	gapSize:		<Object>	horizontalGap:		<Object>	horizontalOutGap:		<Object>	horizontallyStretchable:		<Object>	verticalGap:		<Object>	verticalOutGap:		<Object>	verticallyStretchable:		<Object>alignment	- xxxxxgapSize	- xxxxxhorizontalGap	- xxxxxhorizontalOutGap	- xxxxxhorizontallyStretchable	- xxxxxverticalGap	- xxxxxverticalOutGap	- xxxxxverticallyStretchable	- xxxxx!!RSHorizontalLineLayout commentStamp: '' prior: 0!A RTHorizontalLineLayout locates all the elements horizontally!!RSVerticalLineLayout commentStamp: '' prior: 0!A RTVerticalLineLayout locates all the elements vertically!!RSConditionalLayout commentStamp: '' prior: 0!TODO!!RSEdgeDrivenLayout commentStamp: '' prior: 0!TODO!!RSAbstractGraphLayout commentStamp: '' prior: 0!TODO!!RSAbstractCompactTree commentStamp: '' prior: 0!TODO!!RSRadialTreeLayout commentStamp: '' prior: 0!TODO!!RSAbstractRegularTreeLayout commentStamp: '' prior: 0!TODO!!RSAbstractHorizontalTreeLayout commentStamp: '' prior: 0!TODO!!RSHorizontalTreeLayout commentStamp: '' prior: 0!TODO!!RSAbstractVerticalTreeLayout commentStamp: '' prior: 0!TODO!!RSDominanceTreeLayout commentStamp: '' prior: 0!TODO!!RSTreeLayout commentStamp: '' prior: 0!TODO!!RSClusterLayout commentStamp: '' prior: 0!TODO!!RSSugiyamaLayout commentStamp: '' prior: 0!TODO!!RSForceBasedLayout commentStamp: '' prior: 0!A ROForceBasedLayout is inspired from the Code of D3. The original d3 version may be found on: http://bl.ocks.org/mbostock/4062045Layout algorithm inspired by Tim Dwyer and Thomas Jakobsen.!!RSOptimizedForceBasedLayout commentStamp: '' prior: 0!TODO!!RSGroupLayout commentStamp: '' prior: 0!RTGroupLayout is a simple class to order group of connected elements.Here is an example:-=-=-=-=-=-=-=-=-=-=-=-=v := RTView new.v addAll: (RTBox elementsOn: (1 to: 6)) @ RTPopup.RTEdgeBuilder new	view: v;	useAssociations: { 1 -> 2. 1 -> 3 . 4 -> 5 }.RTTreeLayout on: v elements.RTGroupLayout new grid; on: v elements.v-=-=-=-=-=-=-=-=-=-=-=-=Another example:-=-=-=-=-=-=-=-=-=-=-=-=clss := Collection allSubclasses.b := RTMondrian new.b nodes: clss.b edges connectFrom: #superclass.b layout tree.b build.RTGroupLayout new grid; on: b view elements.(RTGroupLayout new getGroupsFrom: b view elements) do: [ :g | 	c := Color random.	g do: [ :e | e color: c ] ].b view.-=-=-=-=-=-=-=-=-=-=-=-=The whole picture of Pharo-=-=-=-=-=-=-=-=-=-=-=-=classes := Smalltalk globals allClasses copyWithoutAll: { Object . TestCase . Model }.b := RTMondrian new.b shape box	width: [ :c | c numberOfVariables * 6 ];	height: #numberOfMethods.b nodes: classes.b edges connectFrom: #superclass.b layout tree."b normalizer normalizeSize: #numberOfMethods."b build.gl := RTGroupLayout new flow.gl on: b view elements.gl lonelyGroup do: #remove.(RTGroupLayout new getSortedGroupsFrom: b view elements) do: [ :g | 	c := Color random.	g do: [ :e | e color: c ] ].b view @ RTZoomableView.b view.-=-=-=-=-=-=-=-=-=-=-=-=!!RSNoLayout commentStamp: '' prior: 0!Here is an example:v := RTView new.es := (RTEllipse new color: Color blue trans; size: 20) elementsOn: (1 to: 30).v addAll: es.RTEdgeBuilder new	view: v;	elements: es;	connectFrom: [ :vv | vv // 2 ].v addMenu: 'Remember!!' callback: [ 	positions := es collect: #position.	 ].v addMenu: 'Recall!!' callback: [ 	positions with: es do: [ :p :e | e translateTo: p ].	v signalUpdate.	 ].v addMenu: 'Start layout!!' callback: [ 	force := RTForceBasedLayout new.	force initialLayout: RTNoLayout new.	animation := RTSpringLayoutStepping new.	animation layoutWithoutPreparing: force.	animation inView: v.].v addMenu: 'Stop layout!!' callback: [ 	animation stopAndRemove].v !!RSNullLayout commentStamp: '' prior: 0!TODO!!RSRectanglePackLayout commentStamp: '' prior: 0!A layout that packs rectangles in as amall space as possible (at least it tries to)Instance Variables	padding:	<Number>	freeSpace:	<Set of Rectamgles>	bounds:	<Point>gap	- gap between elements defined as "percentage" of average size. 0.2 means 20%freeSpace	- collection of spaces that can be used for next element insertion	bounds	- bounding box of all currently processed elements!!RSLayoutBuilder commentStamp: '' prior: 0!RTLayoutBuilder is a higher abstract to manage layout. Most builder use it as it significantly shorten the use of layouts.!!RSLayoutTranslator commentStamp: '' prior: 0!TODO!!RSDirectLayoutTranslator commentStamp: '' prior: 0!TODO!!RSMockEdge commentStamp: '' prior: 0!TODO!!RSMockElement commentStamp: '' prior: 0!TODO!!RSQuadTree commentStamp: '' prior: 0!TODO!!RSSortBlock commentStamp: '' prior: 0!TODO!!RSCell class methodsFor: 'public'!elements: aCollection columns: anInteger 		^ self new columns: anInteger; elements: aCollection; yourself! !!RSCell methodsFor: 'accessing'!column	^((number - 1) rem: columns) + 1! !!RSCell methodsFor: 'accessing'!columnWidthAt: index	"private"	^ columnWidths at: index! !!RSCell methodsFor: 'accessing'!columns	^ columns! !!RSCell methodsFor: 'accessing'!columns: anObject	columns := anObject! !!RSCell methodsFor: 'accessing'!computeColumnWidths	columnWidths := Array new: elements columnCount.	1 to: elements columnCount do: [ :columnIndex |		columnWidths at: columnIndex put: ((elements atColumn: columnIndex) select: #notNil thenCollect: #width) max	 ].! !!RSCell methodsFor: 'accessing'!computeRowHeights	rowHeights := Array new: elements rowCount.	1 to: elements rowCount do: [ :rowIndex |		rowHeights at: rowIndex put: ((elements atRow: rowIndex) select: #notNil thenCollect: #height) max	 ].! !!RSCell methodsFor: 'accessing'!element	^ element! !!RSCell methodsFor: 'accessing'!element: anObject	element := anObject! !!RSCell methodsFor: 'accessing'!elements: aCollection 	| rows  col |	rows := (aCollection size / columns) ceiling rounded.	col := Array new: rows * columns.	1 to: aCollection size do: [ :i | col at: i put: (aCollection at: i)].	elements := RSCellMatrix 						rows: rows						columns: columns 						contents: col.	self computeColumnWidths.	self computeRowHeights.! !!RSCell methodsFor: 'accessing'!extent	^ self width @ self height! !!RSCell methodsFor: 'accessing'!height	^ self rowHeightAt: self row! !!RSCell methodsFor: 'accessing'!number	^ number! !!RSCell methodsFor: 'accessing'!number: anObject	number := anObject! !!RSCell methodsFor: 'accessing'!row	^((number - 1) quo: columns) + 1! !!RSCell methodsFor: 'accessing'!rowHeightAt: index	"private"	^ rowHeights at: index! !!RSCell methodsFor: 'accessing'!width	^ self columnWidthAt: self column! !!RSCellMatrix class methodsFor: 'as yet unclassified'!rows: rows columns: columns contents: contents	^self new rows: rows columns: columns contents: contents! !!RSCellMatrix methodsFor: 'accessing rows/columns'!atColumn: column	| p |	p := (self indexForRow: 1 andColumn: column) - ncols.	^ (1 to: nrows) collect: [ :row | contents at: (p := p+ncols) ]! !!RSCellMatrix methodsFor: 'accessing rows/columns'!atRow: row	(row between: 1 and: nrows)		ifFalse: [ self error: '1st subscript out of range' ].	^ contents copyFrom: (row - 1) * ncols + 1 to: row * ncols! !!RSCellMatrix methodsFor: 'accessing'!columnCount	^ ncols! !!RSCellMatrix methodsFor: 'private'!indexForRow: row andColumn: column	(row between: 1 and: nrows)		ifFalse: [self error: '1st subscript out of range'].	(column between: 1 and: ncols)		ifFalse: [self error: '2nd subscript out of range'].	^ (row - 1) * ncols + column! !!RSCellMatrix methodsFor: 'accessing'!rowCount	^ nrows! !!RSCellMatrix methodsFor: 'private'!rows: rows columns: columns contents: anArray	(((rows isInteger and: [rows >= 0]) and: 		[columns isInteger and: [columns >= 0]]) and:			[ rows * columns = anArray size ]) ifFalse: [ self error: 'Wrong parameters' ].	nrows := rows.	ncols := columns.	contents := anArray! !!RSDummyNode class methodsFor: 'instance creation'!on: anEdge slot: anIndex		^(self new)		edge: anEdge;		slot: anIndex;		yourself! !!RSDummyNode methodsFor: 'accessing'!edge		^edge! !!RSDummyNode methodsFor: 'accessing'!edge: anEdge		edge := anEdge! !!RSDummyNode methodsFor: 'accessing'!extent	^ self height @ self width! !!RSDummyNode methodsFor: 'accessing'!height		^0! !!RSDummyNode methodsFor: 'accessing'!position	^ 0 @ 0! !!RSDummyNode methodsFor: 'accessing'!signalUpdate	"do nothing"! !!RSDummyNode methodsFor: 'accessing'!slot: anIndex	! !!RSDummyNode methodsFor: 'accessing'!translateBy: apoint	"do nothing"! !!RSDummyNode methodsFor: 'accessing'!translateTo: aPoint		"edge index: index point: aPoint"! !!RSDummyNode methodsFor: 'accessing'!view	^ RSView new! !!RSDummyNode methodsFor: 'accessing'!width		^0! !!RSIdentityMatrix methodsFor: 'accessing'!at: u		| row |	row := rows		at: u		ifAbsentPut: [IdentityDictionary new].	^row keys! !!RSIdentityMatrix methodsFor: 'accessing'!at: u at: v		| row |	row := rows		at: u		ifAbsentPut: [IdentityDictionary new].	^row		at: v		ifAbsent: [false]! !!RSIdentityMatrix methodsFor: 'accessing'!at: u at: v put: aBoolean		| row |	"u -> v"	row := rows		at: u		ifAbsentPut: [IdentityDictionary new].	row at: v put: aBoolean.	"v -> u"	row := rows		at: v		ifAbsentPut: [IdentityDictionary new].	row at: u put: aBoolean! !!RSIdentityMatrix methodsFor: 'initialize-release'!initialize		rows := IdentityDictionary new! !!RSAbstractCircleLayout class methodsFor: 'public'!isAbstract	^ self name = #RSAbstractCircleLayout! !!RSAbstractCircleLayout methodsFor: 'hook'!computeIncrementalAngleFor: elements	"Return the value _in radian_ of the incremental angle"		^ initialIncrementalAngle = 0		ifTrue: [ 2 * Float pi / elements size ]		ifFalse: [ initialIncrementalAngle ]! !!RSAbstractCircleLayout methodsFor: 'hook'!computeRadiusFor: elements	"Return the radius of the circle. If none has been set (i.e., initialRadius = 0), then it is computed as the scale factor times the number of elements"	^ initialRadius = 0 		ifTrue: [ elements size * self scaleFactor ]		ifFalse: [ initialRadius ]! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngle	"Return the initial angle, in radian"	^ initialAngle! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngle: aFloat	"aFloat is an angle in Radian."	initialAngle := aFloat! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngleInDegree 	"Return the initial angle in degree"	^ self initialAngle * 180 / Float pi! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialAngleInDegree: aNumber	"Set the initial angle in radian"	self initialAngle: aNumber * Float pi / 180! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialIncrementalAngle	"Return the initial incremental angle"	^ initialIncrementalAngle! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialIncrementalAngle: aNumberInRadian	initialIncrementalAngle := aNumberInRadian! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialIncrementalAngleInDegree: aNumberInDegree	self initialIncrementalAngle: aNumberInDegree * Float pi / 180! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialRadius	"Return the radius in pixels of the circle"	^ initialRadius! !!RSAbstractCircleLayout methodsFor: 'accessing'!initialRadius: aNumber	"Set the radius of the circle"	initialRadius := aNumber! !!RSAbstractCircleLayout methodsFor: 'initialize-release'!initialize	"Initialize a newly created instance. This method must answer the receiver."		super initialize.	self scaleBy: 11.		"Represent the initial angle to place the elements"	initialAngle := 0.		"Distance of the circle. If it is 0 when entering doExecute, then it is computed"	initialRadius := 0.		"0 means that it is computed, and not set by the user"	initialIncrementalAngle := 0.! !!RSAbstractCircleLayout methodsFor: 'accessing'!radius: aNumber	^ self initialRadius: aNumber! !!RSAbstractCircleLayout methodsFor: 'accessing'!scaleBy: aNumber		factor := aNumber! !!RSAbstractCircleLayout methodsFor: 'accessing'!scaleFactor	^ factor! !!RSAbstractWeightedCircleLayout methodsFor: 'hook'!doExecute: elements	"This method is used polymorphically"! !!RSAbstractWeightedCircleLayout methodsFor: 'hook'!weightSum: elements	"Computes the sum of all elements 'weight' or size"	| sum |	sum := 0.	elements		do: [ :each |			sum := sum + (each height)		].	^sum! !!RSEquidistantCircleLayout methodsFor: 'hook'!computeSeparationFor: elements"Compute the separation between each element, this separation will always be the same"	| sep |	sep := ((2 * Float pi * (self computeRadiusFor: elements)) - (self weightSum: elements))/	(elements size).	^sep! !!RSEquidistantCircleLayout methodsFor: 'hook'!doExecute: elements	| angle rad center angleIncrement |	rad := self computeRadiusFor: elements.	center := Point x: rad y: rad.	angle := self initialAngle.	elements		do: [ :each | 			| point |			"First, the angle is increased only by the angle given by the element radius (height/2),			then the point is set, and then it's increased by the rest of the total increment"			"This is to consider both last and next elements weights"			angle := angle + ((each height)/(2*rad)).			point := center + (Point r: rad theta: angle).			angleIncrement := (((each height)/2) + (self computeSeparationFor: elements))/rad.			angle := angle + angleIncrement.			translator translate: each to: point.		]! !!RSWeightedCircleLayout methodsFor: 'hook'!doExecute: elements	| angle rad center angleIncrement |	rad := self computeRadiusFor: elements.	center := Point x: rad y: rad.	angleIncrement := self computeIncrementalAngleFor: elements.	angle := self initialAngle.	elements		do: [ :each | 			| point fctr |			"The factor weighs the angleIncrement"			"The angle is increased by half of the total increment,			then the point is set, and then it's increased by the other half"			"This is to consider both last and next elements weights"			fctr := (elements size)*(each height)/(self weightSum: elements).			angle := angle + (angleIncrement*(fctr/2)).			point := center + (Point r: rad theta: angle).			angle := angle + (angleIncrement*(fctr/2)).			translator translate: each to: point. ]! !!RSCircleLayout class methodsFor: 'instance creation'!scaleBy: aNumber		^self new scaleBy: aNumber! !!RSCircleLayout methodsFor: 'hook'!doExecute: elements	| angleIncrement angle rad center |	rad := self computeRadiusFor: elements.	center := Point x: rad y: rad.	angleIncrement := self computeIncrementalAngleFor: elements.	angle := self initialAngle.	elements		do: [ :each | 			| point |			point := center + (Point r: rad theta: angle).			angle := angle + angleIncrement.			translator translateTopLeftOf: each to: point.			self step ]! !!RSAbstractFlowLayout class methodsFor: 'public'!isAbstract	^ self name = #RSAbstractFlowLayout! !!RSAbstractFlowLayout class methodsFor: 'instance creation'!withMaxWidth: anInteger		^(self new)		maxWidth: anInteger;		yourself! !!RSAbstractFlowLayout class methodsFor: 'instance creation'!withMaxWidth: anInteger withGap: anotherInteger		^(self new)		maxWidth: anInteger;		gapSize: anotherInteger;		yourself! !!RSAbstractFlowLayout methodsFor: 'alignment'!alignBottom	alignment := #bottom! !!RSAbstractFlowLayout methodsFor: 'alignment'!alignCenter	alignment := #center! !!RSAbstractFlowLayout methodsFor: 'alignment'!alignTop	alignment := #top! !!RSAbstractFlowLayout methodsFor: 'configuration'!defaultGapSize ^ 5! !!RSAbstractFlowLayout methodsFor: 'configuration'!defaultMaxWidth		^ [ :elements | 		(elements size < 4) ifTrue: [ (((elements collect: [ :each | each width * each height]) * 2) sum ) + (elements size * (gapSize squared)) ]			ifFalse: [			((((elements collect: [ :each | each width * each height]) * 2) sum) + (elements size * (gapSize squared))) sqrt ceiling truncated.			]		]! !!RSAbstractFlowLayout methodsFor: 'accessing'!gapSize		^gapSize! !!RSAbstractFlowLayout methodsFor: 'accessing'!gapSize: aSizeInPixels		gapSize := aSizeInPixels! !!RSAbstractFlowLayout methodsFor: 'initialize-release'!initialize		super initialize.	maxWidth := self defaultMaxWidth.	gapSize := self defaultGapSize.! !!RSAbstractFlowLayout methodsFor: 'testing'!isAlignBottom	^ alignment = #bottom! !!RSAbstractFlowLayout methodsFor: 'testing'!isAlignCenter	^ alignment = #center! !!RSAbstractFlowLayout methodsFor: 'testing'!isAlignTop	^ alignment = #top! !!RSAbstractFlowLayout methodsFor: 'private'!maxWidth		^maxWidth! !!RSAbstractFlowLayout methodsFor: 'accessing'!maxWidth: aSizeInPixels		maxWidth := aSizeInPixels! !!RSFlowLayout methodsFor: 'hook'!doExecute: elements 	| x y maxLastLineHeight maxNextLineHeight  nextElement |		x := self gapSize.	y := self gapSize.	maxLastLineHeight := 0.	maxNextLineHeight := 0.	nextElement := elements first.	 	elements do:		[ :anElement | 		(anElement = elements last) ifFalse:  [nextElement := (elements after: anElement)] ifTrue: [nextElement := anElement].			self isAlignBottom ifTrue: [ 			translator translateBottomLeftOf: anElement to: x @ y.			x := x + anElement width + (self gapSize).			((x > (self maxWidth rsValue: elements)) | ((x + nextElement width) > (self maxWidth rsValue: elements) )) ifTrue:				[ x := self gapSize.				maxNextLineHeight := self maxNextLineHeightFrom: nextElement for: elements.				y := y + (self gapSize) + maxNextLineHeight.				maxNextLineHeight := 0.				]			].				self isAlignCenter ifTrue: [ 			translator translateCenterLeftOf: anElement to: x @ y.								x := x + (anElement width) +(self gapSize).			maxLastLineHeight := maxLastLineHeight max: (anElement height).			((x > (self maxWidth rsValue: elements)) | ((x + nextElement width) > (self maxWidth rsValue: elements) )) ifTrue: 				[ x := self gapSize.				maxNextLineHeight := self maxNextLineHeightFrom: nextElement for: elements.				y := y + (self gapSize) + (maxNextLineHeight / 2) + (maxLastLineHeight / 2).				maxNextLineHeight := 0.				maxLastLineHeight := 0.				]			].				self isAlignTop ifTrue: [ 			translator translateTopLeftOf: anElement to: (x @ y).			x := x + anElement width + (self gapSize).			maxLastLineHeight := maxLastLineHeight max: (anElement height ).			( (x > (self maxWidth rsValue: elements)) | ((x + nextElement width) > (self maxWidth rsValue: elements) ))ifTrue: 				[ x := self gapSize.				y := y + (self gapSize) + maxLastLineHeight.				maxLastLineHeight := 0. 				]		] 	]! !!RSFlowLayout methodsFor: 'initialize-release'!initialize	super initialize.	self alignTop.! !!RSFlowLayout methodsFor: 'utility'!maxNextLineHeightFrom: ele for: elements	| nextLineX maxNextLineHeight anElement |	maxNextLineHeight := 0.	nextLineX := self gapSize.	anElement := ele.	[ nextLineX < (self maxWidth rsValue: elements) ] whileTrue: [		nextLineX := nextLineX + (self gapSize) + (anElement width).		maxNextLineHeight := maxNextLineHeight max: (anElement height).			(anElement = elements last) ifFalse:  [anElement := (elements after: anElement) ].		].	^ maxNextLineHeight				! !!RSHorizontalFlowLayout methodsFor: 'hook'!doExecute: elements 	| x y maxLastLineWidth nextElement maxNextLineWidth|	x := self gapSize.	y := self gapSize.	maxLastLineWidth := 0.	maxNextLineWidth := 0.		elements do:		[ :anElement | 				(anElement = elements last) ifFalse:  [nextElement := (elements after: anElement)] ifTrue: [nextElement := anElement].				self isAlignBottom ifTrue: [ 			translator translate: anElement to: ((x @ y) + ((anElement width / -2) @ (anElement height / 2))).				y := y + anElement height + (self gapSize).			((y > (self maxWidth rsValue: elements)) | ((y + nextElement height) > (self maxWidth rsValue: elements) ))ifTrue: 				[ y := self gapSize.				maxNextLineWidth := self maxNextLineWidthFrom: nextElement for: elements.				x := x + (1 * self gapSize) + maxNextLineWidth.				maxNextLineWidth := 0.				maxLastLineWidth := 0.				]		].		self isAlignCenter ifTrue: [ 		translator translate: anElement to: ((x @ y) + (0 @ (anElement width / 2))).			y := y + anElement height + (self gapSize).			maxLastLineWidth := maxLastLineWidth max: (anElement width).			((y > (self maxWidth rsValue: elements)) | ((y + nextElement height) > (self maxWidth rsValue: elements) ))ifTrue: 				[ y := self gapSize.				maxNextLineWidth := self maxNextLineWidthFrom: nextElement for: elements.				x := x + (self gapSize) + (maxNextLineWidth /2) + (maxLastLineWidth /2).				maxNextLineWidth := 0.				maxLastLineWidth := 0.				]			].						self isAlignTop ifTrue: [ 			translator translateTopLeftOf: anElement to: x @ y.			y := y + anElement height + (self gapSize).			maxLastLineWidth := maxLastLineWidth max: (anElement width ).			((y > (self maxWidth rsValue: elements)) | ((y + nextElement height) > (self maxWidth rsValue: elements) ))ifTrue: 				[ y := self gapSize.				x := x + (self gapSize) + maxLastLineWidth.				maxLastLineWidth := 0 ] 			].		].! !!RSHorizontalFlowLayout methodsFor: 'initialize-release'!initialize	super initialize.	self alignTop.! !!RSHorizontalFlowLayout methodsFor: 'utility'!maxNextLineWidthFrom: ele for: elements	| nextLineY maxNextLineWidth anElement |	anElement := ele.	maxNextLineWidth := 0.	nextLineY := self gapSize.	[ nextLineY < (self maxWidth rsValue: elements) ] whileTrue: [		nextLineY := nextLineY + (self gapSize) + (anElement height).		maxNextLineWidth := maxNextLineWidth max: (anElement width).			(anElement = elements last) ifFalse:  [anElement := (elements after: anElement)]		].	^ maxNextLineWidth! !!RSAbstractGridLayout class methodsFor: 'public'!isAbstract	^ self name = #RSAbstractGridLayout! !!RSAbstractGridLayout class methodsFor: 'public'!on: aCollectionOfElements withGap: anInteger withLineItemsCount: aBlock	"place the elements in a grid with (aBlock roValue: aCollectionOfElements) as the amount of elements horizontally"		| myLayout |	myLayout := self new gapSize: anInteger;  lineItemsCount: aBlock; yourself.	myLayout applyOn: aCollectionOfElements.	^ aCollectionOfElements! !!RSAbstractGridLayout class methodsFor: 'public'!on: aCollectionOfElements withLineItemsCount: aBlock	"place the elements in a grid with (aBlock roValue: aCollectionOfElements) as the amount of elements horizontally	For example:	self on: (ROElement forCollection: (1 to: 20)) withLineItemsCount: 5	=> place the 20 elements on a grid 5 x 4		self on: (ROElement forCollection: (1 to: 20)) withLineItemsCount: [ :elements | elements size // 3 ]	=> place the 20 elements on a grid 3 x 7	"			| myLayout |	myLayout := self new lineItemsCount: aBlock; yourself.	myLayout applyOn: aCollectionOfElements.	^ aCollectionOfElements! !!RSAbstractGridLayout class methodsFor: 'instance creation'!withGap: anInteger 	^ self new 			gapSize: anInteger; 			yourself! !!RSAbstractGridLayout class methodsFor: 'instance creation'!withGap: anInteger withLineItemsCount: aBlock		^self new		gapSize: anInteger;		lineItemsCount: aBlock;		yourself! !!RSAbstractGridLayout class methodsFor: 'instance creation'!withLineItemsCount: aBlock		^self new		lineItemsCount: aBlock;		yourself! !!RSAbstractGridLayout methodsFor: 'initialize-release'!defaultGapSize	^ 5! !!RSAbstractGridLayout methodsFor: 'accessing'!defaultLineItemsCount		^ [ :elements | 			| height width |			(elements size < 3 				ifTrue: [ (elements size max: 1) @ 1 ]				ifFalse: 					[ height := (elements size * 0.618034) sqrt ceiling truncated.					width := (elements size / height) ceiling truncated.					width @ height ]) x ]! !!RSAbstractGridLayout methodsFor: 'accessing'!gapSize		^ gapSize! !!RSAbstractGridLayout methodsFor: 'accessing'!gapSize: anInteger	gapSize := anInteger! !!RSAbstractGridLayout methodsFor: 'initialize-release'!initialize	super initialize.	gapSize := self defaultGapSize.	lineItemsCountBlock := self defaultLineItemsCount.! !!RSAbstractGridLayout methodsFor: 'accessing'!lineItemsCount: aNumberOrASymbolOrABlock	"The argument will be evaluated (using rtValue:) against the set of elements to perform the layout on. The result of this evaluation has to be a number, which indicates the number of elements per line"	lineItemsCountBlock := aNumberOrASymbolOrABlock! !!RSAbstractGridLayout methodsFor: 'accessing'!lineItemsCountBlock		^ lineItemsCountBlock! !!RSCellLayout methodsFor: 'accessing'!centered	align := #center.	translateElement := [ :aTranslator :anElement :newPos | translator translateCenterLeftOf: anElement to: newPos ].		self inCellPosition: [ :cell | cell extent x @ 0 ]! !!RSCellLayout methodsFor: 'hook'!doExecute: elements 		| lineItemSize pointer columnCount rowCount maxHeight columnsWidths rowHeights |	lineItemSize := self lineItemsCountBlock rsValue: elements.	"We compute the size of the grid"	columnCount := 1.	rowCount := 1.	maxHeight := 0.	columnsWidths := OrderedCollection new.	rowHeights := OrderedCollection new.	elements do: [ :e |		columnsWidths size < columnCount ifTrue: [ columnsWidths add: 0 ].		columnsWidths at: columnCount put: ((columnsWidths at: columnCount) max: e extent x).				maxHeight := maxHeight max: e extent y.		columnCount := columnCount + 1.				columnCount > lineItemSize			ifTrue: [ 				columnCount := 1. 				rowHeights add: maxHeight.				maxHeight := 0 ]	].	rowHeights add: maxHeight.	"We do the translation"	columnCount := 1.	rowCount := 1.	pointer := (((columnsWidths at: 1) / 2) @ ((rowHeights at: 1) / 2)).	elements do: [ :e | 		e translateTo: pointer.		pointer := pointer + (self gapSize * 2 @ 0) + (((columnsWidths at: columnCount) / 2) @ 0).		columnCount := columnCount + 1.		columnCount > lineItemSize			ifTrue: [ 				columnCount := 1.				pointer := (((columnsWidths at: 1) / 2) @ pointer y)  + (0 @ ((rowHeights at: rowCount) / 2)).				rowCount := rowCount + 1.				rowCount <= rowHeights size 					ifTrue: [ pointer := pointer + (0 @ ((rowHeights at: rowCount) / 2)) ].				 				 ]			ifFalse: [ pointer := pointer + (self gapSize * 2 @ 0) + (((columnsWidths at: columnCount ) / 2) @ 0) ].	]! !!RSCellLayout methodsFor: 'accessing'!inCellPosition: anObjectOrOneArgBlock	inCellPosition := anObjectOrOneArgBlock! !!RSCellLayout methodsFor: 'initialize-release'!initialize	super initialize.	self leftCentered! !!RSCellLayout methodsFor: 'accessing'!leftCentered	align := #left.	translateElement := [ :aTranslator :anElement :newPos | translator translateTopLeftOf: anElement to: newPos ].		"self inCellPosition: [ :cell | 0 @ ((cell extent y - cell element height) / 2) ]"	self inCellPosition: [ :cell | cell extent x @ 0 ]! !!RSGridLayout methodsFor: 'hook'!doExecute: elements	| pointer lineItemCount lineItemSize maxLastLineHeight originalGapLeft originalGapTop |	originalGapLeft := 0.	originalGapTop := 0.		pointer := originalGapLeft @ originalGapTop.	lineItemSize := self lineItemsCountBlock rsValue: elements.	lineItemCount := 0.	maxLastLineHeight := 0.	elements		do: [ :element | 			translator translateTopLeftOf: element to: pointer.			pointer := (pointer x + element width + self gapSize) @ pointer y.			lineItemCount := lineItemCount + 1.			maxLastLineHeight := maxLastLineHeight max: element height.			lineItemCount >= lineItemSize				ifTrue: [ 					pointer := originalGapLeft @ (pointer y + (self gapSize) + maxLastLineHeight).										maxLastLineHeight := 0.					lineItemCount := 0 ].			self step ].! !!RSAbstractLineLayout class methodsFor: 'testing'!isAbstract	^ self name = #RSAbstractLineLayout! !!RSAbstractLineLayout class methodsFor: 'instance creation'!withGap: anInteger		^(self new)		gapSize: anInteger;		yourself! !!RSAbstractLineLayout methodsFor: 'accessing'!alignBottom		alignment := #bottom! !!RSAbstractLineLayout methodsFor: 'accessing'!alignCenter	"Make the element centered"	alignment := #center! !!RSAbstractLineLayout methodsFor: 'accessing'!alignLeft		alignment := #left! !!RSAbstractLineLayout methodsFor: 'accessing'!alignRight		alignment := #right! !!RSAbstractLineLayout methodsFor: 'accessing'!alignTop		alignment := #top! !!RSAbstractLineLayout methodsFor: 'accessing'!alignment		^alignment! !!RSAbstractLineLayout methodsFor: 'accessing'!alignment: anObject		alignment := anObject! !!RSAbstractLineLayout methodsFor: 'configuration'!center	self alignment: #center! !!RSAbstractLineLayout methodsFor: 'hook'!deltaFor: aNodeFigure		^self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'hook'!doCenter: aGraph	self subclassResponsibility ! !!RSAbstractLineLayout methodsFor: 'hook'!doExecute: elements 	| pointer delta |	horizontallyStretchable ifTrue: 		[ self doStretchHorizontal: elements ].	verticallyStretchable ifTrue: 		[ self doStretchVertical: elements ].	pointer := self positionOriginalPointer: elements.	elements do: 		[ :element |		delta := self deltaFor: element.		translator translateTopLeftOf: element to: pointer - delta.		pointer := self 					movePointer: pointer					accordingToFigure: element.		self step ].! !!RSAbstractLineLayout methodsFor: 'hook'!doStretchHorizontal: aCollectionOfElements 	self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'hook'!doStretchVertical: aCollectionOfElements 	self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'accessing'!gapSize		^gapSize! !!RSAbstractLineLayout methodsFor: 'accessing'!gapSize: aNumber	gapSize := aNumber. " This value is never used actually "		verticalGap := 2 * aNumber.	horizontalGap := 2 * aNumber! !!RSAbstractLineLayout methodsFor: 'accessing'!horizontalGap		^horizontalGap! !!RSAbstractLineLayout methodsFor: 'accessing'!horizontalGap: anInteger		horizontalGap := anInteger! !!RSAbstractLineLayout methodsFor: 'testing'!horizontallyStretchable	^ horizontallyStretchable! !!RSAbstractLineLayout methodsFor: 'initialize-release'!initialize		super initialize.	verticalGap := 10.	horizontalGap := 10.	horizontallyStretchable := false.	verticallyStretchable := false! !!RSAbstractLineLayout methodsFor: 'hook'!movePointer: pointer accordingToFigure: aNodeFigure		self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'hook'!positionOriginalPointer: aGraph		^self subclassResponsibility! !!RSAbstractLineLayout methodsFor: 'configuration'!stretch	horizontallyStretchable := verticallyStretchable := true! !!RSAbstractLineLayout methodsFor: 'configuration'!stretchHorizontally	horizontallyStretchable := true! !!RSAbstractLineLayout methodsFor: 'configuration'!stretchVertically	verticallyStretchable := true! !!RSAbstractLineLayout methodsFor: 'accessing'!verticalGap		^verticalGap! !!RSAbstractLineLayout methodsFor: 'accessing'!verticalGap: anInteger		verticalGap := anInteger! !!RSAbstractLineLayout methodsFor: 'testing'!verticallyStretchable	^ verticallyStretchable! !!RSHorizontalLineLayout methodsFor: 'hook'!deltaFor: aNodeFigure		| delta |	delta := 0.	self alignment == #bottom ifTrue: [delta := aNodeFigure height].	self alignment == #center ifTrue: [delta := aNodeFigure height / 2.0].	^0 @ delta! !!RSHorizontalLineLayout methodsFor: 'hook'!doCenter: elements  	| midTallest step |	midTallest := 0.	midTallest := elements nodes 		inject: 0		into: [ :m :el | m max: (el bounds height )].	midTallest := midTallest / 2.	elements nodes do: [ :node | 		step := 0 @ (midTallest - (node bounds height / 2)) asInteger.		node bounds origin: (node bounds origin + step).		node bounds corner: (node bounds corner + step).	] ! !!RSHorizontalLineLayout methodsFor: 'hook'!doStretchHorizontal: aCollectionOfElements  	| parent parentBounds addedWidth parentBoundsWidth runningIndex newWidth |	aCollectionOfElements isEmpty ifTrue: [ ^ self "nothing to do" ].	parent := aCollectionOfElements anyOne parent.	parent isView ifTrue: [ ^ self "ROView does not have bounds" ].	parentBounds := parent bounds.	addedWidth := aCollectionOfElements		inject: 0		into: [ :m :el | m + el width ].	parentBoundsWidth := parentBounds width."	parentBoundsWidth := parentBoundsWidth - ((aCollectionOfElements size - 1) * horizontalGap) - (2 * horizontalOutGap)."			runningIndex := 0.	parentBounds width > addedWidth		ifTrue: [ aCollectionOfElements do: [ :element | 						newWidth := (element width * parentBoundsWidth / addedWidth) asInteger.						element width: newWidth.						runningIndex := runningIndex + newWidth + horizontalGap ] ]! !!RSHorizontalLineLayout methodsFor: 'hook'!doStretchVertical: aCollectionOfElements  	| parent parentBounds |	aCollectionOfElements isEmpty ifTrue: [ ^ self "nothing to do" ].	parent := aCollectionOfElements anyOne parent.	parent isView ifTrue: [ ^ self "ROView does not have bounds" ].	parentBounds := parent bounds.	aCollectionOfElements do: [ :element | 		element height: (parentBounds height) ]! !!RSHorizontalLineLayout methodsFor: 'initialize-release'!initialize		super initialize.	self alignTop! !!RSHorizontalLineLayout methodsFor: 'hook'!movePointer: pointer accordingToFigure: element		^ (pointer x + element width + self horizontalGap) @ pointer y! !!RSHorizontalLineLayout methodsFor: 'hook'!positionOriginalPointer: elements 	| maxHeight delta |	delta := 0.	self alignment == #bottom ifTrue: 		[ maxHeight := elements maxValue: #height.		delta := maxHeight ].	self alignment == #center ifTrue: 		[ maxHeight := elements maxValue: #height.		delta := maxHeight / 2.0 ].	^ (0) @ ((0) + delta)! !!RSVerticalLineLayout methodsFor: 'hook'!deltaFor: aNodeFigure		| delta |	delta := 0.	self alignment == #right ifTrue: [delta := aNodeFigure width].	self alignment == #center ifTrue: [delta := aNodeFigure width / 2.0].	^delta @ 0! !!RSVerticalLineLayout methodsFor: 'hook'!doCenter: aGraph  	| midWidest step |	midWidest := aGraph nodes 		inject: 0		into: [ :m :el | m max: (el bounds width )].	midWidest := midWidest / 2.	aGraph nodes do: [ :node | 		step := (midWidest - (node bounds width /2)) asInteger @ 0.		node bounds origin: (node bounds origin + step).		node bounds corner: (node bounds corner + step).	] ! !!RSVerticalLineLayout methodsFor: 'hook'!doStretchHorizontal: aCollectionOfElements 	 	| parent parentBounds |	aCollectionOfElements isNil ifTrue: [ ^ self "nothing to do" ].	parent := aCollectionOfElements anyOne parent.	parent isView ifTrue: [ ^ self "ROView does not have bounds" ].	parentBounds := parent bounds.	aCollectionOfElements do: [ :element | 		element width: parentBounds width ]! !!RSVerticalLineLayout methodsFor: 'hook'!doStretchVertical: aCollectionOfElements  	| parent parentBounds addedHeight parentBoundsHeight runningIndex newHeight |	aCollectionOfElements isEmpty ifTrue: [ ^ self "nothing to do" ].	parent := aCollectionOfElements anyOne parent.	parent isView ifTrue: [ ^ self "ROView does not have bounds" ].	parentBounds := parent bounds.	addedHeight := aCollectionOfElements 		inject: 0		into: [ :m :el | m + el height ].	parentBoundsHeight := parentBounds height.	"parentBoundsHeight := parentBoundsHeight - ((aCollectionOfElements size - 1) * verticalGap) - (2 * verticalOutGap)."		runningIndex := 0.	parentBounds height > addedHeight		ifTrue: [ aCollectionOfElements do: [ :element | 						newHeight := (element height * parentBoundsHeight / addedHeight) asInteger.						element height: newHeight.						runningIndex := runningIndex + newHeight + verticalGap ] ]! !!RSVerticalLineLayout methodsFor: 'initialize-release'!initialize		super initialize.	self alignLeft! !!RSVerticalLineLayout methodsFor: 'hook'!movePointer: pointer accordingToFigure: aNodeFigure		^ pointer x @ (pointer y + aNodeFigure height + self verticalGap)! !!RSVerticalLineLayout methodsFor: 'hook'!positionOriginalPointer: elements 	| maxWidth delta |	delta := 0.	self alignment == #right ifTrue: 		[ maxWidth := elements maxValue: #width.		delta := maxWidth ].	self alignment == #center ifTrue: 		[ maxWidth := elements maxValue: #width.		delta := maxWidth / 2.0 ].	^ ((0) + delta) @ (0)! !!RSConditionalLayout methodsFor: 'accessing'!condition	^ condition! !!RSConditionalLayout methodsFor: 'accessing'!condition: aBlockOrSymbolOrValue	"The argument will be evaluated for each Roassal elements.	elements that meet the condition will be evaluated using the thenLayout, else they will be given to the elseLayout	"	condition := aBlockOrSymbolOrValue! !!RSConditionalLayout methodsFor: 'as yet unclassified'!doExecute: elements	| thenElements elseElements |	thenElements := TSGroup new.	elseElements := TSGroup new.	elements do: [ :anElement | (condition rsValue: anElement) 											ifTrue: [ thenElements add: anElement ] 											ifFalse: [ elseElements add: anElement ] ].	thenLayout on: thenElements.	elseLayout on: elseElements.	overallLayout on: (TSGroup with: thenElements with: elseElements)! !!RSConditionalLayout methodsFor: 'accessing'!elseLayout	^ elseLayout! !!RSConditionalLayout methodsFor: 'accessing'!elseLayout: aLayout	elseLayout := aLayout! !!RSConditionalLayout methodsFor: 'as yet unclassified'!initialize	super initialize.	condition := true.	thenLayout := RSTreeLayout new.	elseLayout := RSGridLayout new.	overallLayout := RSHorizontalLineLayout new.! !!RSConditionalLayout methodsFor: 'accessing'!overallLayout	^ overallLayout! !!RSConditionalLayout methodsFor: 'accessing'!overallLayout: anObject	overallLayout := anObject! !!RSConditionalLayout methodsFor: 'accessing'!thenLayout	^ thenLayout! !!RSConditionalLayout methodsFor: 'accessing'!thenLayout: aLayout	thenLayout := aLayout! !!RSAbstractCompactTree class methodsFor: 'testing'!horizontalGap: anInt	| new |		new := self new.	new horizontalGap: anInt.		^ new ! !!RSAbstractCompactTree class methodsFor: 'testing'!horizontalGap: anInt verticalGap: another	| new |		new := self new.	new horizontalGap: anInt.	new verticalGap: another.			^ new ! !!RSAbstractCompactTree class methodsFor: 'testing'!isAbstract	^ self name = #RSAbstractCompactTree! !!RSAbstractCompactTree class methodsFor: 'testing'!verticalGap: anInt	| new |		new := self new.	new verticalGap: anInt.		^ new ! !!RSAbstractCompactTree methodsFor: 'private'!childrenFor: aNode 	sonsDictionary isEmpty ifTrue: [ ^ super childrenFor: aNode ] 							ifFalse: [ ^sonsDictionary at: aNode ifAbsent: [ ^ OrderedCollection new ] ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!compareContourOf: aNode with: another	"return the number of radians the subtree induced by aNode must be displaced to be separated by a predefined distance (horizontalGap) from the one induced by anotherNode"	| difference max nodeA nodeB |	nodeB := aNode.	"the right one"	nodeA := another.	"the left one"	max := aNode = another		ifTrue: [ 0 ]		ifFalse: [ horizontalGap / 2 - (nodeB x - (self getAbcissaOf: nodeA inSubtreeFromLayer: aNode layer - 1)) ].	nodeB := self followLeftContour: nodeB toLayer: nodeB layer + 1.	nodeA := self followRightContour: nodeA toLayer: nodeA layer + 1.	[ nodeB isNil not & nodeA isNil not ]		whileTrue: [ 			difference := horizontalGap				-					((self getAbcissaOf: nodeB inSubtreeFromLayer: aNode layer - 1)						- (self getAbcissaOf: nodeA inSubtreeFromLayer: aNode layer - 1)).			max := max max: difference.			nodeB := self followLeftContour: nodeB toLayer: nodeB layer + 1.			nodeA := self followRightContour: nodeA toLayer: nodeA layer + 1 ].	^ max! !!RSAbstractCompactTree methodsFor: 'algorithm'!computePosition: aNode"compute the position of the given node and of his sons recursively"	| children neighbor nodeA |		children := self childrenFor: aNode.	neighbor := self leftSiblingOf: aNode.		children isEmpty ifTrue: [ neighbor isNil ifTrue: [ aNode x: 0; mod: 0.]  											 ifFalse: [ aNode x: (neighbor x + (horizontalGap /2)); mod: (neighbor mod);													  pointer: (self followRightContour: neighbor toLayer: (aNode layer + 1)) ] ]					 					 ifFalse: [aNode leftContour: children first;									rightContour: children last.							  children do: [:e | self computePosition: e ].							      aNode x: (aNode leftContour x + aNode rightContour x + aNode rightContour mod ) /2;										mod: 0. 								neighbor isNil ifFalse: [ aNode mod: (self compareContourOf: aNode with: neighbor).																						  nodeA := (self followLeftContour: (aNode father) toLayer: (aNode layer)).													  [(self followLeftContour: nodeA toLayer: (nodeA layer + 1)) isNil ] whileFalse: [ nodeA := self followLeftContour: nodeA toLayer: (nodeA layer + 1) ].													 nodeA pointer: (self followLeftContour: aNode toLayer: (nodeA layer + 1)).																										 nodeA := self followRightContour: aNode toLayer: (aNode layer + 1).													 [(self followRightContour: nodeA toLayer: (nodeA layer +1)) isNil ] whileFalse: [ nodeA := self followRightContour: nodeA toLayer: (nodeA layer +1) ].													nodeA pointer: (self followRightContour: neighbor toLayer: (nodeA layer +1) ) ] ] ! !!RSAbstractCompactTree methodsFor: 'hook'!coordinate: aNode withMod: aFloat	self subclassResponsibility! !!RSAbstractCompactTree methodsFor: 'hook'!doExecute: nodeElements 	| rootNodes |		initialLayout isNil  ifFalse: [ initialLayout new executeOnElements: nodeElements. ].		rootNodes := self rootNodesFor: nodeElements."	root isNil ifTrue: [ rootNodes := self rootNodesFor: nodeElements. ]			 ifFalse: [ rootNodes := Array with: root.						self coveringTreeFor: nodeElements from: root ]."		rootNodes do: [:e | self initialize: e whoseFatherIs: nil ];		do: [:e | self computePosition:e].		rootNodes  do: [:e |					self draw:e withMod: 0  ]! !!RSAbstractCompactTree methodsFor: 'hook'!draw: aNode withMod: aFloat	self subclassResponsibility! !!RSAbstractCompactTree methodsFor: 'algorithm'!followLeftContour: aNode toLayer: anInteger	"return the last node in the left contour begining at anode"		((self layerOf: aNode) = anInteger ) ifTrue: [^ aNode  ].	((self layerOf: aNode) > anInteger ) ifTrue: [^ nil  ].		(self leftContourOf: aNode) isNil ifTrue: [ (self pointerOf: aNode)  isNil ifTrue: [ ^ nil ] 														 ifFalse: [ ^ ( self followLeftContour: (self pointerOf: aNode) toLayer: anInteger ) ] ]				  				ifFalse: [ ^ (self followLeftContour: (self leftContourOf: aNode) toLayer: anInteger ) ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!followRightContour: aNode toLayer: anInteger	"return the node in the right contour begining at anode in layer anInteger"	((self layerOf: aNode) = anInteger ) ifTrue: [^ aNode  ].	((self layerOf: aNode) > anInteger ) ifTrue: [^ nil  ].	(self rightContourOf: aNode) isNil ifTrue: [ (self pointerOf: aNode) isNil ifTrue: [ ^ nil ] 														 ifFalse: [ ^ ( self followRightContour: (self pointerOf: aNode) toLayer: anInteger ) ] ]				  				ifFalse: [ ^ (self followRightContour: (self rightContourOf: aNode) toLayer: anInteger ) ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!getAbcissaOf: aNode inSubtreeFromLayer: anInteger	| node x |		(anInteger < 0) ifTrue: [^ self getAbcissaOf: aNode inSubtreeFromLayer: 0 ].		((self layerOf: aNode) = anInteger ) ifTrue: [ ^ self xOf: aNode ].	((self layerOf: aNode) < anInteger ) ifTrue: [ ^ nil ].		x := (self xOf: aNode) + (self modOf: aNode).		node := self fatherOf: aNode.		[(self layerOf: node) = anInteger  ] whileFalse: [ x := x + (self modOf: node).									node := self fatherOf: node ].									^ x! !!RSAbstractCompactTree methodsFor: 'initialize-release'!greedyCycleRemoval: aGraph! !!RSAbstractCompactTree methodsFor: 'initialize-release'!initialLayout: aLayout	initialLayout := aLayout ! !!RSAbstractCompactTree methodsFor: 'initialize-release'!initialize 	super initialize.	verticalGap := 20.	horizontalGap := 30.	margin := 40. 	sonsDictionary := Dictionary new! !!RSAbstractCompactTree methodsFor: 'initialize-release'!initialize: aNode whoseFatherIs: another 	self fatherOf: aNode put: another.		another isNil ifTrue: [ self layerOf: aNode put: 0 ] ifFalse: [ self layerOf: aNode put: (self layerOf: another) + 1 ] .		( self childrenFor: aNode ) do: [ :e | self initialize: e whoseFatherIs: aNode ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!leftSiblingOf: aNode"return the left sibling of the given node "	| children |	(self fatherOf: aNode) isNil ifTrue: ["has no sibling" ^ nil]					    ifFalse: [ children := self childrenFor: (self fatherOf: aNode).								(children first) = aNode ifTrue: ["as no left sibling" ^ nil ]																    ifFalse: [^ children at: ((children indexOf: aNode) - 1) ] ]! !!RSAbstractCompactTree methodsFor: 'algorithm'!nodeAbcissaWithNeighbor: aNode	self subclassResponsibility ! !!RSAbstractCompactTree methodsFor: 'initialize-release'!root: aNode 	root := aNode ! !!RSRadialTreeLayout methodsFor: 'algorithm'!compareContourOf: aNode with: another	"return the number of radians the subtree induced by aNode must be displaced to be separated by a predefined distance (horizontalGap) from the one induced by anotherNode"	| difference max nodeA nodeB |	nodeB := aNode.	"the right one"	nodeA := another.	"the left one"	max := aNode = another		ifTrue: [ 0 ]		ifFalse: [ horizontalGap / (self layerOf: nodeB) / 2 - ((self xOf: nodeB) - (self getAbcissaOf: nodeA inSubtreeFromLayer: (self layerOf: aNode) - 1)) ].	nodeB := self followLeftContour: nodeB toLayer: (self layerOf: nodeB) + 1.	nodeA := self followRightContour: nodeA toLayer: (self layerOf: nodeA) + 1.	[ nodeB isNil not & nodeA isNil not ]		whileTrue: [ 			difference := horizontalGap / (self layerOf: nodeA)				-					((self getAbcissaOf: nodeB inSubtreeFromLayer: (self layerOf: aNode) - 1)						- (self getAbcissaOf: nodeA inSubtreeFromLayer: (self layerOf: aNode) - 1)).			max := max max: difference.			nodeB := self followLeftContour: nodeB toLayer: (self layerOf: nodeB) + 1.			nodeA := self followRightContour: nodeA toLayer: (self layerOf: nodeA) + 1 ].	^ max! !!RSRadialTreeLayout methodsFor: 'hook'!computeGap: aNode	" compute the vertical gap needed for drawing the radial tree "	| gap maxAbcissa i abc nodeL nodeR layer |		gap := 0.	maxAbcissa := 0.	layer := 1.		i := 1.	[ nodeL :=(self followLeftContour: aNode toLayer: i).	nodeR := (self followRightContour: aNode toLayer: i).	nodeL isNil not & nodeR isNil not ] whileTrue: [ abc := (((self getAbcissaOf: nodeR inSubtreeFromLayer: 0) - (self getAbcissaOf: nodeL inSubtreeFromLayer: 0 ) + (horizontalGap / layer/2)) / layer).																	(abc > maxAbcissa) ifTrue: [ maxAbcissa := abc. 																								layer := layer ].																	i := i + 1 ].		gap:= (maxAbcissa / 2 /Float pi ) floor +1.		((verticalGap isNil) or: [gap > verticalGap])  ifTrue: [ self verticalGap: gap ]! !!RSRadialTreeLayout methodsFor: 'algorithm'!computePosition: aNode"compute the position of the given node and of his sons recursively"	| children neighbor nodeA |		children :=self childrenFor: aNode.	neighbor := self leftSiblingOf: aNode.		children isEmpty ifTrue: [ neighbor isNil ifTrue: [ self xOf: aNode put: 0. self modOf: aNode put: 0. ]  													 ifFalse: [ self xOf: aNode put: ((self xOf: neighbor) + (horizontalGap /(self layerOf: aNode) /2)). self modOf: aNode put: ((self modOf: neighbor)).													 self pointerOf: aNode put: (self followRightContour: neighbor toLayer: ((self layerOf: aNode) + 1)) ] ]					 					 ifFalse: [ self leftContourOf: aNode put: children first.									self rightContourOf: aNode put: children last.							  children do: [:e | self computePosition: e ].							      self xOf: aNode put: ((self xOf: ( self leftContourOf: aNode ) ) + ( self xOf: ( self rightContourOf: aNode ) ) + (self modOf: ( self rightContourOf: aNode ) ) ) / 2. 										self modOf: aNode put: 0. 								neighbor isNil ifFalse: [ self modOf: aNode put: (self compareContourOf: aNode with: neighbor).																						  nodeA := (self followLeftContour: (self fatherOf: aNode) toLayer: (self layerOf: aNode)).													  [(self followLeftContour: nodeA toLayer: ((self layerOf: nodeA) + 1)) isNil ] whileFalse: [ nodeA := self followLeftContour: nodeA toLayer: ((self layerOf: nodeA) + 1) ].													 self pointerOf: nodeA put: (self followLeftContour: aNode toLayer: ((self layerOf: nodeA) + 1)).																										 nodeA := self followRightContour: aNode toLayer: ((self layerOf: aNode) + 1).													nodeA ifNil: [ ^ self ].													 [(self followRightContour: nodeA toLayer: ((self layerOf: nodeA) + 1)) isNil ] whileFalse: [ nodeA := self followRightContour: nodeA toLayer: ((self layerOf: nodeA) +1) ].													self pointerOf: nodeA put: (self followRightContour: neighbor toLayer: ((self layerOf: nodeA) + 1) ) ] ]. 											! !!RSRadialTreeLayout methodsFor: 'algorithm'!diameterOf: aNode	|diam|		(aNode shapes first isKindOf: RTEllipse) ifTrue: [ diam := aNode width max: aNode height ]										ifFalse: [ diam := (aNode width * aNode width + (aNode height * aNode height)) sqrt floor ].		^ diam! !!RSRadialTreeLayout methodsFor: 'hook'!doExecute: nodeElements	| rootNodes xOffset maximumRadius | 	initialLayout isNil		ifFalse: [ initialLayout new executeOnElements: nodeElements ].	rootNodes := self rootNodesFor: nodeElements.	rootNodes		do: [ :e | self initialize: e whoseFatherIs: nil ];		do: [ :e | self computePosition: e. self step];		do: [ :e | self computeGap: e ];		do: [ :e | self toRadialTree: e withMod: 0 ].	xOffset := 0.	rootNodes		do: [ :e | 			maximumRadius := self radialDraw: e.			"Shifting all the subgroups"			self shiftTree: e by:  (maximumRadius+xOffset)@maximumRadius.			xOffset := xOffset + (2 * maximumRadius) + 10.  ].! !!RSRadialTreeLayout methodsFor: 'private'!gap		^ self verticalGap! !!RSRadialTreeLayout methodsFor: 'algorithm'!halfDiameterOf: aNode	|diam|		(aNode shapes first isKindOf: RTEllipse) ifTrue: [ diam := aNode width max: aNode height ]										ifFalse: [ diam := (aNode width * aNode width + (aNode height * aNode height)) sqrt floor ].		^ diam / 2! !!RSRadialTreeLayout methodsFor: 'private'!layoutLayer: aCollection radius: oldRadius from: aFromAngle to: aToAngle		| delta childRadius maximumRadius myRadius fromAngle toAngle |	"Initialize with default value"	maximumRadius := oldRadius.	aCollection isEmpty		ifFalse:			[myRadius := oldRadius + self gap + (self maximumRadius: aCollection).			childRadius := oldRadius + self gap + (self maximumDiameter: aCollection).	"This is a purely optical tweak"			(aCollection size = 1 and: [aToAngle - aFromAngle = (2 * Float pi)])				ifTrue:					[delta := 0.4 * Float pi.					fromAngle := 0.8 * Float pi.					toAngle := fromAngle + delta]				ifFalse:					[delta := (aToAngle - aFromAngle) / aCollection size.					fromAngle := aFromAngle.					toAngle := aFromAngle + delta].			aCollection				do:					[:child | 					translator translateTopLeftOf: child to: (Point								r: myRadius								theta: toAngle - (delta / 2.0)).					"child						translateTo:							(Point								radius: myRadius								theta: toAngle - (delta / 2.0))."					maximumRadius := maximumRadius						max:							(self								layoutLayer: (self childrenFor: child)								radius: childRadius								from: fromAngle								to: toAngle).					fromAngle := toAngle.					toAngle := toAngle + delta]].	^maximumRadius! !!RSRadialTreeLayout methodsFor: 'private'!moveAllElementsToTopLeft: elements	| pos min |	pos := elements collect: #position.	min := pos inject: 0 @ 0 into: [ :minimum :p | minimum min: p ].	elements do: [ :e | e translateBy: min negated ] ! !!RSRadialTreeLayout methodsFor: 'algorithm'!nodeAbcissaWithNeighbor: aNode	^ aNode x + (horizontalGap / aNode layer /2) + ((self halfDiameterOf: aNode) / aNode layer)! !!RSRadialTreeLayout methodsFor: 'algorithm'!radialDraw: aNode	"draw the subtree induced by the given node"	| children r max |	r := (self rOf: aNode).	translator translateTopLeftOf: aNode to: (Point r: r theta: (self thetaOf: aNode)).	"aNode translateTo: (Point radius: (aNode r) theta: (aNode theta))."	children := self childrenFor: aNode.	max := 0.	children do: [ :e | max := max max: (self radialDraw: e) ].	^ r + max.! !!RSRadialTreeLayout methodsFor: 'hook'!rotateSubtreeFrom: aNode by: aFloat		aNode theta: aNode theta + aFloat.		(self childrenFor: aNode) do: [ :e | self rotateSubtreeFrom: e by: aFloat ]! !!RSRadialTreeLayout methodsFor: 'hook'!spreadNodes: nodeElements around: aNode	|nodeL nodeR i angle beta lay1 |		i := 1.	angle := 0.		[ nodeL :=(self followLeftContour: aNode toLayer: i).	nodeR := (self followRightContour: aNode toLayer: i).	nodeL isNil not & nodeR isNil not ] whileTrue: [ angle := angle max: ((nodeR theta - nodeL theta) + ((self halfDiameterOf: nodeR) + (self halfDiameterOf: nodeL) + horizontalGap  /i /verticalGap )).													i := i+1. ].	lay1 := nodeElements select: [ :e | e layer = 1 ].	beta := Float pi * 2 - angle / lay1 size.		lay1 do: [ :e | self rotateSubtreeFrom: e by: (lay1 indexOf: e) - 1 * beta ].! !!RSRadialTreeLayout methodsFor: 'algorithm'!toRadialTree: aNode withMod: aFloat	"compute polar coordinates of the subtree induced by anode from its cartesian coordinates "	| children |	self rOf: aNode put: ((self layerOf: aNode) * verticalGap ).	((self rOf: aNode) = 0) ifTrue: [ self thetaOf: aNode put: 0 ] 					ifFalse: [ self thetaOf: aNode put: ((self xOf: aNode)  + aFloat + (self modOf: aNode)) / verticalGap ].		children := self childrenFor: aNode.		children do: [ :e | self toRadialTree: e withMod: ( (self modOf: aNode) + aFloat) ]! !!RSAbstractGraphLayout class methodsFor: 'constants'!horizontalGap		^3.0! !!RSAbstractGraphLayout class methodsFor: 'testing'!isAbstract	^ self name = #RSAbstractGraphLayout! !!RSAbstractGraphLayout class methodsFor: 'public'!on: elements edges: edges	"Do the layout of the elements tacking into account the provided edges"	^ self new 		userDefinedEdges: edges;		applyOn: elements.! !!RSAbstractGraphLayout class methodsFor: 'constants'!verticalGap		^20.0! !!RSAbstractGraphLayout methodsFor: 'private'!cachedChildren		cachedChildren ifNil: [cachedChildren := IdentityDictionary new: 1000].	^cachedChildren! !!RSAbstractGraphLayout methodsFor: 'private'!cachedParents		cachedParents ifNil: [cachedParents := IdentityDictionary new: 1000].	^cachedParents! !!RSAbstractGraphLayout methodsFor: 'private'!cachedParentsWithHighestNestings		cachedParentsWithHighestNestings		ifNil: [cachedParentsWithHighestNestings := IdentityDictionary new: 1000].	^cachedParentsWithHighestNestings! !!RSAbstractGraphLayout methodsFor: 'private'!childrenFor: aNode		^self cachedChildren		at: aNode		ifAbsentPut:			[| nodes |			nodes := OrderedCollection new.			self edgesDo:					[:edge | 					(edge from == aNode and: [edge to ~= aNode])						ifTrue:							[(nodes includes: edge from) ifFalse: [nodes add: edge to]]].			nodes]! !!RSAbstractGraphLayout methodsFor: 'private'!childrenFor: aNode except: aNodeCollection		^(self childrenFor: aNode) 		reject: [:each | aNodeCollection includes: each]		"we are explicitly not using the default Collection>>difference: behavior here because we want to preserve the order of the collection"! !!RSAbstractGraphLayout methodsFor: 'private'!childrenWithHighestNestingLevelFor: aNode		^(self childrenFor: aNode)		select: [:eachChild | (self highestNestingParentFor: eachChild) == aNode]! !!RSAbstractGraphLayout methodsFor: 'private'!clear		cachedParents := nil.	cachedChildren := nil.	cachedParentsWithHighestNestings := nil! !!RSAbstractGraphLayout methodsFor: 'hook'!doInitialize: elements 	super doInitialize: elements.	self clear.	self greedyCycleRemoval: elements! !!RSAbstractGraphLayout methodsFor: 'battista'!greedyCycleRemoval: aCollection	"Di Battista Greedy-Cycle-Removal algorithm. Chapter 9.4, page 297. The last part is not like in the book. The original algorithm only takes	 local optimas into account. This will break ordinary trees sometimes. This version also takes global optimas into account."		| g sl sr s indeg outdeg degrees vertex | 	g := aCollection copy asOrderedCollection.	sl := OrderedCollection new.	sr := OrderedCollection new.	"While g contains a sink (aka leaf)"	g copy		do:			[:node | 			(self childrenFor: node) isEmpty				ifTrue:					[sr addFirst: node.					g remove: node]	"self edges detect: [:edge | edge fromFigure == node] ifNone: [sr addFirst: node. g remove: node]"].	"While g contains a source (aka root)"	g copy		do:			[:node | 			(self parentsFor: node) isEmpty				ifTrue:					[sl addLast: node.					g remove: node]	"self edges detect: [:edge | edge toFigure == node] ifNone: [sl addLast: node. g remove: node]"].	"Calculate deg for all remaining vertices"	degrees := IdentityDictionary new.	g		do:			[:node | 			indeg := (self parentsFor: node) size.			outdeg := (self childrenFor: node) size.	"indeg := self edges inject: 0 into: [:sum :edge | (edge toFigure == node) ifTrue: [sum + 1] ifFalse: [sum]].		outdeg := self edges inject: 0 into: [:sum :edge | (edge fromFigure == node) ifTrue: [sum + 1] ifFalse: [sum]]."			degrees				at: node				put: outdeg - indeg].	"While g not empty"	g := g asSortedCollection: [:a :b | (degrees at: a) >= (degrees at: b)].	[g isEmpty]		whileFalse:			[vertex := g				detect: [:v | (self parentsFor: v) anySatisfy: [:w | sl includes: w]]				ifNone: [g first].	"Corner case: Closed cycle with not root at all. Eg 1 -> 2 -> 3 -> 1"			sl addLast: vertex.			g remove: vertex].	"Remove all leftward edges"	s := sl , sr.	self edges notNil		ifTrue: 			[ self edges copy				do:					[:edge | 					(s indexOf: edge from) > (s indexOf: edge to)						ifTrue: [self edges remove: edge ] ] ].		"Reset the cache"	self clear! !!RSAbstractGraphLayout methodsFor: 'private'!highestNestingParentFor: aNodeFigure		| parents |	^self cachedParentsWithHighestNestings		at: aNodeFigure		ifAbsentPut:			[parents := self parentsFor: aNodeFigure.			parents isEmpty				ifTrue: [0]				ifFalse:					[parents detectMax: [:eachParent | self nestingLevelFor: eachParent]]]! !!RSAbstractGraphLayout methodsFor: 'accessing'!horizontalGap	"Return the horizontal space, in pixel, between two neighbors"	^ horizontalGap ifNil: [ self class horizontalGap ]! !!RSAbstractGraphLayout methodsFor: 'accessing'!horizontalGap: anInteger	"Set the horizontal space, in pixel, between two neighbors"	horizontalGap := anInteger! !!RSAbstractGraphLayout methodsFor: 'private'!maximumDiameter: aCollection		^aCollection		inject: 0		into: [:max :node | max max: (node radius * 2) ] ! !!RSAbstractGraphLayout methodsFor: 'private'!maximumRadius: aCollection		^aCollection		inject: 0		into: [:max :node | max max: node radius]! !!RSAbstractGraphLayout methodsFor: 'private'!nestingLevelFor: aNodeFigure		| parents parentsNesting |	parents := self parentsFor: aNodeFigure.	parentsNesting := parents		collect: [:eachParent | self nestingLevelFor: eachParent].	^parentsNesting isEmpty		ifTrue: [0]		ifFalse: [parentsNesting max + 1]! !!RSAbstractGraphLayout methodsFor: 'actions'!on: el edges: edgs	"Do the layout of the elements tacking into account the provided edges"	self userDefinedEdges ifNil: [ self userDefinedEdges: edgs ].	^ self applyOn: el.! !!RSAbstractGraphLayout methodsFor: 'private'!parentsFor: aNode	^ self cachedParents		at: aNode		ifAbsentPut:			[ | nodes |			nodes := OrderedCollection new.			self edgesDo:					[:edge | edge to == aNode ifTrue: [ nodes add: edge from ] ].			nodes ]! !!RSAbstractGraphLayout methodsFor: 'private'!rootNodesFor: aCollection	^ aCollection select: [:node | 		(self parentsFor: node) isEmpty ].	! !!RSAbstractGraphLayout methodsFor: 'private'!shiftTree: aNode by: aPoint		aNode translateBy: aPoint.	(self childrenFor: aNode) do: [:child | self shiftTree: child by: aPoint]! !!RSAbstractGraphLayout methodsFor: 'accessing'!verticalGap	"Return the vertical space, in pixel, between a layer and a children layer"	^ verticalGap ifNil: [ self class verticalGap ]! !!RSAbstractGraphLayout methodsFor: 'accessing'!verticalGap: anInteger	"Set the vertical space, in pixel, between a layer and a children layer"	verticalGap := anInteger! !!RSAbstractHorizontalTreeLayout class methodsFor: 'testing'!isAbstract	^ self = RSAbstractHorizontalTreeLayout! !!RSAbstractHorizontalTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	self subclassResponsibility! !!RSAbstractHorizontalTreeLayout methodsFor: 'default attach points'!defaultAttachPoint	^ RTHorizontalAttachPoint new! !!RSAbstractHorizontalTreeLayout methodsFor: 'reversing'!horizontallyReverse: elements	"Horizontally reverse the elements, as well as the attachpoints"	super horizontallyReverse: elements.	self inverseAttachPointIfNecessary! !!RSAbstractHorizontalTreeLayout methodsFor: 'initialize-release'!initialize	super initialize.	verticalGap := 3.	horizontalGap := 20! !!RSAbstractHorizontalTreeLayout methodsFor: 'reversing'!inverseAttachPoint	"Invert the attach point of all the considered edges. It is likely that all the attachpoint are the same, but we do not have a garanty"	| a |	a := RTShorterHorizontalDistanceAttachPoint new.	edges		do: [ :edge | 			edge shape attachPoint: a.			edge updateFromTo ]! !!RSAbstractHorizontalTreeLayout methodsFor: 'reversing'!inverseAttachPointIfNecessary	"Inverse the attach point if the user has not used #doNotAttachPoint"	self shouldSetDefaultAttachPoint		ifTrue: [ self inverseAttachPoint ]! !!RSAbstractHorizontalTreeLayout methodsFor: 'hook-private'!layout: aNodeCollection atPoint: aPoint atLayer: aNumber	| treeSize childrenPosition x y middleOfTree |	aNodeCollection isEmpty ifTrue: [ ^ 0 ].	x := aPoint x.	y := aPoint y.	alreadyLayoutedNodes addAll: aNodeCollection.	self atLayer: aNumber add: aNodeCollection.	aNodeCollection do: [ :each | 		childrenPosition := x + each width + self horizontalGap.		treeSize := each height			max: (self layout: (self computeChildrenFor: each) atPoint: childrenPosition @ y atLayer: aNumber + 1).		middleOfTree := y + (treeSize / 2.0) - (each height / 2.0).		translator translateTopLeftOf: each to: (x @ middleOfTree).		y := y + treeSize + self verticalGap.		self step ].	^ y - aPoint y - self verticalGap! !!RSAbstractHorizontalTreeLayout methodsFor: 'private'!rearrangeByLayers: aGraph	| cursor layerDepthSize |	cursor := self leftGap.	nodesByLayer do: [ :eachSetOfNodes |		layerDepthSize := eachSetOfNodes inject: 0 into: [ :max :eachNode | 			translator translateTopLeftOf: eachNode to: (cursor @ eachNode encompassingRectangle top).			max max: eachNode width ].		cursor := cursor + layerDepthSize + self horizontalGap ]! !!RSHorizontalDominanceTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenWithHighestNestingLevelFor: aNode! !!RSHorizontalTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenFor: aNode except: alreadyLayoutedNodes! !!RSAbstractRegularTreeLayout class methodsFor: 'testing'!isAbstract	^ self = RSAbstractRegularTreeLayout! !!RSAbstractRegularTreeLayout methodsFor: 'private'!atLayer: aNumber add: aNodeCollection	| collection |	collection := nodesByLayer at: aNumber ifAbsentPut: [OrderedCollection new].	collection addAll: aNodeCollection! !!RSAbstractRegularTreeLayout methodsFor: 'hook'!doExecute: elements	| rootNodes |	alreadyLayoutedNodes := OrderedCollection new.	rootNodes := self rootNodesFor: elements.	nodesByLayer := OrderedCollection new.	self		layout: rootNodes		atPoint: self leftGap @ self topGap		atLayer: 1.	self isLayered ifTrue: [		self rearrangeByLayers: elements ]! !!RSAbstractRegularTreeLayout methodsFor: 'hook'!doPost: elements	shouldBeHorizontallyReversed ifTrue: [ self horizontallyReverse: elements ].	shouldBeVerticallyReversed ifTrue: [ self verticallyReverse: elements ].! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!horizontallyReverse	shouldBeHorizontallyReversed := true! !!RSAbstractRegularTreeLayout methodsFor: 'reversing'!horizontallyReverse: elements	"Horizontally reverse the elements, as well as the attachpoints"	| g largeur |	g := elements asGroup.	largeur := g extent x.	elements		do: [ :el | el translateTo: (largeur - el position x) @ el position y ]! !!RSAbstractRegularTreeLayout methodsFor: 'initialize-release'!initialize	super initialize.	topGap := 5.	leftGap := 5.	isLayered := false.	shouldBeHorizontallyReversed := false.	shouldBeVerticallyReversed := false.	self doAttachPoint.! !!RSAbstractRegularTreeLayout methodsFor: 'reversing'!inverseAttachPoint	"Invert the attach point of all the considered edges. It is likely that all the attachpoint are the same, but we do not have a garanty"	self shouldSetDefaultAttachPoint ifFalse: [ ^ self ].	edges		do: [ :edge | 			edge shape attachPoint inverted: true.			edge updateFromTo ]! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!isLayered	"Is the layout layered"		^ isLayered! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!isLayered: boolean	"Is the layout layered"		isLayered := boolean! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!layered	self isLayered: true! !!RSAbstractRegularTreeLayout methodsFor: 'hook-private'!layout: aNodeCollection atPoint: aPoint atLayer: anObject	self subclassResponsibility! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!leftGap	^ leftGap! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!leftGap: anInteger	leftGap := anInteger! !!RSAbstractRegularTreeLayout methodsFor: 'private'!rearrangeByLayers: aGraph	self subclassResponsibility! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!shouldBeHorizontallyReversed	"Return if the layout is horizontally reversed"	^ shouldBeHorizontallyReversed ! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!shouldBeVerticallyReversed	"Return if the layout is vertically reversed"	^ shouldBeVerticallyReversed! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!topGap	^ topGap! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!topGap: anInteger	topGap := anInteger! !!RSAbstractRegularTreeLayout methodsFor: 'accessing'!verticallyReverse	"Reverse the edge extremities"	"Here is an example:| b |	b := RTMondrian new.b nodes: (1 to: 100).b edges connectFrom: [ :v | v // 2 ].b layout tree verticallyReverse.b"	shouldBeVerticallyReversed := true	! !!RSAbstractRegularTreeLayout methodsFor: 'reversing'!verticallyReverse: elements	"Vertically reverse the elements, as well as the attachpoints"	| g hauteur |	g := elements asGroup.	hauteur := g extent y.	elements		do: [ :el | el translateTo: el position x @ (hauteur - el position y) ]! !!RSAbstractVerticalTreeLayout class methodsFor: 'testing'!isAbstract	^ self = RSAbstractVerticalTreeLayout! !!RSAbstractVerticalTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	self subclassResponsibility! !!RSAbstractVerticalTreeLayout methodsFor: 'default attach points'!defaultAttachPoint	^ RTVerticalAttachPoint new! !!RSAbstractVerticalTreeLayout methodsFor: 'initialize-release'!initialize	super initialize.	verticalGap := 20.	horizontalGap := 3! !!RSAbstractVerticalTreeLayout methodsFor: 'reversing'!inverseAttachPoint	"Invert the attach point of all the considered edges. It is likely that all the attachpoint are the same, but we do not have a garanty"	| a |	a := RTShorterVerticalDistanceAttachPoint new.	edges		do: [ :edge | 			edge shape attachPoint: a.			edge updateFromTo ]! !!RSAbstractVerticalTreeLayout methodsFor: 'reversing'!inverseAttachPointIfNecessary	"Inverse the attach point if the user has not used #doNotAttachPoint"	self shouldSetDefaultAttachPoint		ifTrue: [ self inverseAttachPoint ]! !!RSAbstractVerticalTreeLayout methodsFor: 'hook-private'!layout: aNodeCollection atPoint: aPoint atLayer: aNumber	| treeSize childrenPosition x y middleOfTree |	aNodeCollection isEmpty ifTrue: [ ^ 0 ].	x := aPoint x.	y := aPoint y.	alreadyLayoutedNodes addAll: aNodeCollection.	self atLayer: aNumber add: aNodeCollection.	aNodeCollection do: [ :each | 		childrenPosition := y + each height + self verticalGap.		treeSize := each width			max: (self layout: (self computeChildrenFor: each) atPoint: x @ childrenPosition atLayer: aNumber + 1).		middleOfTree := x + (treeSize / 2.0) - (each width / 2.0).		translator translateTopLeftOf: each to: middleOfTree @ y.		x := x + treeSize + self horizontalGap.		self step ].	^ x - aPoint x - self horizontalGap! !!RSAbstractVerticalTreeLayout methodsFor: 'private'!rearrangeByLayers: aGraph	| cursor layerDepthSize |	cursor := self topGap.	nodesByLayer do: [:eachSetOfNodes |		layerDepthSize := eachSetOfNodes inject: 0 into: [ :max :eachNode | 			translator translateTopLeftOf: eachNode to: (eachNode position x @ cursor).			max max: eachNode height ].		cursor := cursor + layerDepthSize + self verticalGap ]! !!RSAbstractVerticalTreeLayout methodsFor: 'reversing'!verticallyReverse: elements	"Vertically reverse the elements, as well as the attachpoints"	super verticallyReverse: elements.	self inverseAttachPointIfNecessary! !!RSDominanceTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenWithHighestNestingLevelFor: aNode! !!RSTreeLayout methodsFor: 'hook-private'!computeChildrenFor: aNode	^ self childrenFor: aNode except: alreadyLayoutedNodes! !!RSClusterLayout methodsFor: 'algorithm'!computePosition: aNode	|children previous|		children := self childrenFor: aNode.		children do: [ :e | self computePosition: e ].													children isEmpty ifTrue: [ externalLayer first = aNode ifFalse: [ previous := externalLayer at: ( externalLayer indexOf: aNode) - 1.																											((self fatherOf: previous) = (self fatherOf: aNode)) ifTrue: [ self xOf: aNode put: (self xOf: previous) + (horizontalGap / 2) ] 																																			ifFalse: [ self xOf: aNode put: (self xOf: previous) + horizontalGap] ] ]																																																ifFalse: [ self xOf: aNode put: ((self xOf: (self leftContourOf: aNode)) + (self xOf: (self rightContourOf: aNode)) / 2 )]! !!RSClusterLayout methodsFor: 'hook'!doExecute: nodeElements 	| root gap |	"Not much to do if there is only one element"	nodeElements size = 1 ifTrue: [ ^ self ].		root := self rootNodesFor: nodeElements .	root do: [ :e | self initializeNode: e ].	root do: [ :e | self computePosition: e ].		maxLayer := (root collect: [ :e | self layerOf: e ]) max.		(root size > 1) ifTrue: [ maxLayer := maxLayer + 1 ].		maxAbcissa := (self xOf: externalLayer last) + horizontalGap .		gap := maxAbcissa "+ horizontalGap "/ 2 / Float pi / maxLayer.		verticalGap := verticalGap max: gap.		root do: [ :e | self draw: e. self step ].		! !!RSClusterLayout methodsFor: 'drawing-general'!draw: aNode	(self childrenFor: aNode) do: [ :e | self draw: e ].	translator translateTopLeftOf: aNode to: (Point r: maxLayer - (self layerOf: aNode) * verticalGap theta: (maxAbcissa - (self xOf: aNode) / maxAbcissa) * 2 * Float pi )! !!RSClusterLayout methodsFor: 'initialize-release'!initialize 	super initialize.	verticalGap := 30.	horizontalGap := 20.	externalLayer := OrderedCollection new! !!RSClusterLayout methodsFor: 'initialize-release'!initializeNode: aNode	|children|		children := self childrenFor: aNode.		children do: [ :e | self initializeNode: e.						self fatherOf: e put: aNode ].		children isEmpty ifTrue: [ self layerOf: aNode put: 0.							externalLayer add: aNode ] 					ifFalse: [ self layerOf: aNode put: ((children collect: [ :e | (self layerOf: e) ]) max + 1).							self leftContourOf: aNode put: children first.							self rightContourOf: aNode put: children last ].					! !!RSSugiyamaLayout class methodsFor: 'utils'!sortBlock		^ RSSortBlock new! !!RSSugiyamaLayout methodsFor: 'private'!addDummyNodes		| layer layerNr |	connections := RSIdentityMatrix new.	self edgesDo:			[:edge | 			| a b span fromNode toNode |			"edge hints removeAll."			a := layerNrs at: edge from.			b := layerNrs at: edge to.			span := (a - b) abs.			span = 1				ifTrue:					[connections						at: edge from						at: edge to						put: true].	"Normal case where nodes are in adjacent layers"			fromNode := edge from.			[span > 1]				whileTrue:					[span := span - 1.					layerNr := b + span.					layer := layers at: layerNr.					toNode := RSDummyNode						on: edge						slot: a - span.					layer add: toNode.					layerNrs at: toNode put: layerNr.					connections at: fromNode at: toNode put: true.					fromNode := toNode].			(a - b) abs > 1				ifTrue:					[connections						at: fromNode						at: edge to						put: true]]! !!RSSugiyamaLayout methodsFor: 'private'!assignLabels: aNodeCollection 	"Initialize label dictionary"	| label vertices parentLabels |	labels := IdentityDictionary new.	label := 1.	"Assign labels to the roots"	(self rootNodesFor: aNodeCollection) do: 		[ :node | 		labels 			at: node			put: label.		label := label + 1 ].	"Assign labels to the rest"	[ labels keys size < aNodeCollection size ] whileTrue: 		[ vertices := SortedCollection sortBlock: self sortBlock.		aNodeCollection do: 			[ :node | 			(labels includesKey: node) ifFalse: 				[ parentLabels := ((self parentsFor: node) collect: 					[ :pn | 					labels 						at: pn						ifAbsent: [ self maxFloat ] ]) asSortedCollection.				parentLabels last ~= self maxFloat ifTrue: [ vertices add: node -> parentLabels ] ] ].		labels 			at: vertices first key			put: label.		label := label + 1 ]! !!RSSugiyamaLayout methodsFor: 'private'!buildLayers: g		| w layerNr u vertices vertex layer done |	w := self maxFloat.	u := OrderedCollection new.	layers := IdentityDictionary new.	layerNrs := IdentityDictionary new.	"Assign all nodes to layers"	[g isEmpty]		whileFalse:			[vertices := g				select:					[:e | (self childrenFor: e) allSatisfy: [:node | u includes: node]].			vertex := vertices detectMax: [:e | labels at: e].			done := false.			layerNr := 1.			[done]				whileFalse:					[layer := layers						at: layerNr						ifAbsentPut: [OrderedCollection new].					(layer size >= w						or:							[(self childrenFor: vertex) anySatisfy: [:n | (layerNrs at: n) >= layerNr]])						ifTrue: [layerNr := layerNr + 1]						ifFalse: [done := true]].			layer add: vertex.			layerNrs at: vertex put: layerNr.			u add: vertex.			g remove: vertex]! !!RSSugiyamaLayout methodsFor: 'private'!cl: layer u: u v: v	"Calculates cuv. Di Battista, chapter 9.2.2, page 283"		| partnersOfU partnersOfV c partnersOfUIndex partnersOfVIndex layerNr |	layerNr := layerNrs at: u.	":= layerNrs at: v"	partnersOfU := (connections at: u)		select: [:each | (layerNrs at: each) = (layerNr - 1)].	partnersOfV := (connections at: v)		select: [:each | (layerNrs at: each) = (layerNr - 1)].	c := 0.	partnersOfUIndex := partnersOfU collect: [:node | layer indexOf: node].	partnersOfVIndex := partnersOfV collect: [:node | layer indexOf: node].	partnersOfUIndex		do:			[:uIndex | partnersOfVIndex do: [:vIndex | vIndex < uIndex ifTrue: [c := c + 1]]].	^c! !!RSSugiyamaLayout methodsFor: 'default attach points'!defaultAttachPoint	^ RTVerticalAttachPoint new! !!RSSugiyamaLayout methodsFor: 'hook'!doExecute: aNodeCollection 	"Coffman-Graham-Layering. Di Battista Book, page 275, chapter, 9.2.1"	self assignLabels: aNodeCollection.	self buildLayers: aNodeCollection copy.	self addDummyNodes.	self reduceCrossing.	self layoutAt: self verticalGap @ self horizontalGap! !!RSSugiyamaLayout methodsFor: 'private'!layoutAt: aPoint		| treeWidth layerKeys layer layerWidth horizontalPosition verticalPosition layerHeight |	treeWidth := layers values		inject: self maxFloat negated		into:			[:max :e | max max: (e sumNumbers: #width) + ((e size - 1) * self horizontalGap)].	verticalPosition := self horizontalGap.	"For visual reasons NOT: self class verticalGap"	layerKeys := layers keys asSortedCollection reverse.	layerKeys		do:			[:aKey | 			layer := layers at: aKey.			layerWidth := (layer sum: #width)				+ ((layer size - 1) * self horizontalGap).			layerHeight := (layer detectMax: #height) height.			horizontalPosition := treeWidth / 2.0 + aPoint x - (layerWidth / 2.0).			layer				do:					[:node | 					translator translateTopLeftOf: node to:  horizontalPosition @ verticalPosition.										horizontalPosition := horizontalPosition + node width						+ self horizontalGap ].			verticalPosition := verticalPosition + layerHeight + self verticalGap ]! !!RSSugiyamaLayout methodsFor: 'private'!maxFloat	^ 1e10! !!RSSugiyamaLayout methodsFor: 'private'!reduceCrossing	"Crossing reduction"		| layer2 u v c1 c2 layer1 done |	2		to: layers keys size		do:			[:index | 			layer1 := layers at: index - 1.			layer2 := layers at: index.			done := false.			[done]				whileFalse:					[done := true.					2						to: layer2 size						do:							[:i | 							u := layer2 at: i - 1.							v := layer2 at: i.							c1 := self cl: layer1 u: u v: v.							c2 := self cl: layer1 u: v v: u.							c1 > c2								ifTrue:									[layer2 rtSwapElement: u withElement: v.									done := false]]]]! !!RSSugiyamaLayout methodsFor: 'private'!sortBlock		sortBlock isNil ifTrue: [ sortBlock := self class sortBlock ].	^sortBlock! !!RSEdgeDrivenLayout class methodsFor: 'as yet unclassified'!isAbstract	^ self = RSEdgeDrivenLayout! !!RSEdgeDrivenLayout class methodsFor: 'public'!on: elements edges: edges	^ self new on: elements edges: edges! !!RSEdgeDrivenLayout class methodsFor: 'instance creation'!withEdges: aCollection		^self new initialize userDefinedEdges: aCollection! !!RSEdgeDrivenLayout methodsFor: 'default attach points'!addDefaultAttachPointToEdges	"TODO!!!!!!!!!!""	| a |	a := self defaultAttachPoint.	edges do: [ :e | e shape attachPoint: a ]"! !!RSEdgeDrivenLayout methodsFor: 'accessing'!affectedNodes		^affectedNodes! !!RSEdgeDrivenLayout methodsFor: 'accessing'!affectedNodes: anObject		affectedNodes := anObject! !!RSEdgeDrivenLayout methodsFor: 'accessing'!affectedNodesOf:  aNode 	^ affectedNodes ifNil: [ aNode nodes ]! !!RSEdgeDrivenLayout methodsFor: 'default attach points'!defaultAttachPoint	^ RTCenteredAttachPoint new! !!RSEdgeDrivenLayout methodsFor: 'default values'!defaultFromPositions	^ #()	! !!RSEdgeDrivenLayout methodsFor: 'default values'!defaultToPositions	^ #()! !!RSEdgeDrivenLayout methodsFor: 'default attach points'!doAttachPoint	"Change the attach point of edges when added"	shouldSetDefaultAttachPoint := true! !!RSEdgeDrivenLayout methodsFor: 'hook'!doExecute: elements		self subclassResponsibility! !!RSEdgeDrivenLayout methodsFor: 'hook'!doIncrementallyExecute: anElementNode	"called by refreshLayoutEvery: ms. It is used to convey a feeling of incremental execution."		self doExecute: anElementNode! !!RSEdgeDrivenLayout methodsFor: 'default attach points'!doNotAttachPoint	"Do not add an attach point to edges when doing the layout"	shouldSetDefaultAttachPoint := false! !!RSEdgeDrivenLayout methodsFor: 'private'!edges		^ edges! !!RSEdgeDrivenLayout methodsFor: 'accessing'!edges: aCollection	"Set the list of edges that should be considered for the layout.	If none is specified (i.e., if this method is not called), then the 	edges are infered."	edges := aCollection.	self shouldSetDefaultAttachPoint		ifTrue: [ self addDefaultAttachPointToEdges ]! !!RSEdgeDrivenLayout methodsFor: 'iterator'!edgesDo: aBlock	"Iterates over all the edges of the receiver."		edges ifNil: [ ^ self ].	edges do: aBlock! !!RSEdgeDrivenLayout methodsFor: 'hook'!executeOnElements: elements 	"Execute the layout, myself, on the elements"	self userDefinedEdges isNil 		ifTrue: [ self setEdgesFromElements: elements ]		ifFalse: 			[ | flat |			flat := OrderedCollection new.			self userDefinedEdges do: 				[ :each | 				each isCollection 					ifTrue: [ flat addAll: each ]					ifFalse: [ flat add: each ] ].			flat := flat select: #isUsedInLayout. 			self edges: flat ].			super executeOnElements: elements! !!RSEdgeDrivenLayout methodsFor: 'accessing'!fromPositions: anArray		fromPositions := anArray! !!RSEdgeDrivenLayout methodsFor: 'initialize-release'!initialize	"Initialization"	super initialize.	edges := nil.	shouldSetDefaultAttachPoint := false! !!RSEdgeDrivenLayout methodsFor: 'testing'!isEdgeDrivenLayout	^ true! !!RSEdgeDrivenLayout methodsFor: 'accessing'!setEdgesFromElements: elements 	elements isEmpty ifTrue: [ ^ self ].		^ self		edges:			((elements flatCollect: #incomingEdges)				select: [ :anEdge | anEdge isUsedInLayout and: (elements includes: anEdge from) ])"	view := elements anyOne view.	view ifNil: [ ^ self ].	self edges: (view edges select: [ :el | 		(el isUsedInLayout and: [ elements includes: el from ]) and: [ elements includes: el to ] ]).	"! !!RSEdgeDrivenLayout methodsFor: 'default attach points'!shouldSetDefaultAttachPoint	"Return true if an attach point has to be added to edges. False else"	^ shouldSetDefaultAttachPoint! !!RSEdgeDrivenLayout methodsFor: 'accessing'!toPositions: anArray		toPositions := anArray! !!RSEdgeDrivenLayout methodsFor: 'private'!userDefinedEdges		^userDefinedEdges! !!RSEdgeDrivenLayout methodsFor: 'initialize-release'!userDefinedEdges: aCollectionOfEdges	"useful to tell to the layout which edges have to be used for the layout"	userDefinedEdges := aCollectionOfEdges.	! !!RSForceBasedLayout methodsFor: 'algorithm'!accumulate: aQuad 	| cx cy k random |		cx := 0.	cy := 0.		aQuad charge: 0; cx: 0; cy: 0.		random := Random new.		aQuad leaf ifFalse: [ aQuad nodes do: [ :e | e isNil ifFalse: [ self accumulate: e.																aQuad charge: aQuad charge + e charge.																cx := cx + (e charge * e cx).																cy := cy + (e charge * e cy) ] ] ].													aQuad node isNil ifFalse: [ aQuad leaf ifFalse: [ aQuad node translateTo: aQuad node position + (random next - 0.5 @ ( random next - 0.5)) ].								k := alpha * (self chargeOf: aQuad node).								aQuad charge: aQuad charge + k.								cx := cx + (k * aQuad node position x). 								cy := cy + (k * aQuad node position y).].								aQuad charge = 0 ifTrue: [ ^ self ].					aQuad cx: cx / aQuad charge.	aQuad cy: cy / aQuad charge.! !!RSForceBasedLayout methodsFor: 'updating'!addEdge: anEdge	self addEdges: (Array with: anEdge)! !!RSForceBasedLayout methodsFor: 'updating'!addEdges: someEdges	someEdges		do: [ :e | 			| from to |			from := e from.			to := e to.			weights at: from put: (weights at: from) + 1.			weights at: to put: (weights at: to) + 1 ].	edges := edges, someEdges! !!RSForceBasedLayout methodsFor: 'updating'!addNodes: nodeElements	"Initialize the meta data associated to the nodes. At that stage, position of nodes is not modified"	nodes := nodes, nodeElements.	nodeElements		do: [ :e | 			weights add: (Association key: e value: 0).			oldPositions add: (Association key: e value: e position) ].! !!RSForceBasedLayout methodsFor: 'accessing'!charge: aFloat	"Typically a negative value. E.g., -300"	charge := aFloat! !!RSForceBasedLayout methodsFor: 'algorithm'!chargeOf: aNode 	^ charges at: aNode ifAbsent: [ ^ charge ] ! !!RSForceBasedLayout methodsFor: 'initialize-release'!defaultInitialLayout	^ RSGridLayout new! !!RSForceBasedLayout methodsFor: 'hook'!doExecute: nodeElements	self start: nodeElements.	self shouldRunLayoutWithProgressBar		ifTrue: [ self runLayoutInJob ]		ifFalse: [ self runLayoutSimply ].	alpha := 0.	nodes do: [ :e | translator translateTopLeftOf: e to: e position ]! !!RSForceBasedLayout methodsFor: 'configuration'!doNotUseProgressBar	shouldUseProgressBar := false	! !!RSForceBasedLayout methodsFor: 'algorithm'!fix: aNode at: aPoint	fixedNodes at: aNode put: aPoint  ! !!RSForceBasedLayout methodsFor: 'algorithm'!gravityAt: aPoint	center := aPoint ! !!RSForceBasedLayout methodsFor: 'accessing'!initialLayout: aLayout	"Set the initial layout to be used before stepping"	initialLayout := aLayout! !!RSForceBasedLayout methodsFor: 'hook'!initialPositionOfNodes: nodeElements	initialLayout executeOnElements: nodeElements! !!RSForceBasedLayout methodsFor: 'initialize-release'!initialize	super initialize.	nbIterations := 0.	edges := #().	nodes := #().	initialLayout := self defaultInitialLayout.	fixedNodes := Dictionary new.	strengths := Dictionary new.	lengths := Dictionary new.	charges := Dictionary new.	strength := 1.	length := 20.	charge := -30.	gravity := 0.1.	friction := 0.9.	theta := 0.8.	center := 200 @ 200.	alpha := 0.1.	self useProgressBar! !!RSForceBasedLayout methodsFor: 'testing'!isFixed: aNode	^ fixedNodes includesKey: aNode ! !!RSForceBasedLayout methodsFor: 'testing'!isJobInstalled	"Return true if the class Job exist. This is mainly useful to make a distinction between Pharo and VisualWorks"	^ Smalltalk includesKey: #Job! !!RSForceBasedLayout methodsFor: 'accessing'!length: aFloat	"Specifiy the length of the edges. E.g., 50"	length := aFloat! !!RSForceBasedLayout methodsFor: 'algorithm'!lengthOf: anEdge	^ lengths at: anEdge ifAbsent: [ ^ length ] ! !!RSForceBasedLayout methodsFor: 'accessing'!nbIterations	^ nbIterations! !!RSForceBasedLayout methodsFor: 'accessing'!nbIterations: anObject	nbIterations := anObject! !!RSForceBasedLayout methodsFor: 'accessing'!nodes	^ nodes! !!RSForceBasedLayout methodsFor: 'accessing'!nodes: elements	nodes := elements! !!RSForceBasedLayout methodsFor: 'hook'!on: elements edges: edgesCol	self nodes: elements.	self userDefinedEdges: edgesCol.	self applyOn: elements.! !!RSForceBasedLayout methodsFor: 'accessing'!prepareNodes: nodeElements	"Initialize the meta data associated to the nodes. At that stage, position of nodes is not modified"	weights := Dictionary new.	oldPositions := Dictionary new.	nodes := nodeElements.	nodes		do: [ :e | 			weights add: (Association key: e value: 0).			oldPositions add: (Association key: e value: e position) ].	edges		do: [ :e | 			| from to |			from := e from.			to := e to.			weights at: from put: (weights at: from) + 1.			weights at: to put: (weights at: to) + 1 ].	alpha := 0.1! !!RSForceBasedLayout methodsFor: 'updating'!removeAllEdges	edges := OrderedCollection new! !!RSForceBasedLayout methodsFor: 'updating'!removeEdge: ed	edges remove: ed! !!RSForceBasedLayout methodsFor: 'updating'!removeNode: node	nodes remove: node.	node connectedEdges do: [ :ed | self removeEdge: ed. ]! !!RSForceBasedLayout methodsFor: 'algorithm'!repulse: aNode from: aQuad	| dx dy dn k p |		dx := aQuad cx - aNode position x.	dy := aQuad cy - aNode position y.		((dx closeTo: 0) and: [ dy closeTo: 0 ] ) ifFalse: [ 		dn := 1 / ((dx * dx) + (dy * dy)) sqrt.		p := oldPositions at: aNode.	aQuad node ~= aNode ifTrue: [ aQuad corner x - aQuad origin x * dn < theta ifTrue: [ k := aQuad charge * dn * dn.																							oldPositions at: aNode put: p x - (dx * k) @ (p y - (dy * k) ).																							^ self].																					(aQuad node isNil not and: [ dn < 1e9 ]) ifTrue: [ k := (self chargeOf: aQuad node) * dn * dn * alpha.																					  oldPositions at: aNode put: p x - (dx * k) @ (p y - (dy * k) ) ] ]. ].																				(aQuad charge closeTo: 0) not ifTrue: [ aQuad nodes do: [ :e | e isNil ifFalse: [ self repulse: aNode from: e ] ] ]! !!RSForceBasedLayout methodsFor: 'hook'!runLayoutInJob	[ :job | 	job		title: 'Laying out elements';		min: 1 - alpha;		max: 1.	nbIterations = 0		ifTrue: [ 			[ 			alpha := alpha * 0.99.			alpha > 0.005 ]				whileTrue: [ 					self step.					job currentValue: 1 - alpha ] ]		ifFalse: [ 			nbIterations				timesRepeat: [ 					alpha := alpha * 0.99.					self step.					job currentValue: 1 - alpha ] ] ] asJob run! !!RSForceBasedLayout methodsFor: 'hook'!runLayoutSimply	nbIterations = 0		ifTrue: [ 			[ 			alpha := alpha * 0.99.			alpha > 0.005 ] whileTrue: [ self step ] ]		ifFalse: [ 			nbIterations				timesRepeat: [ 					alpha := alpha * 0.99.					self step ] ]! !!RSForceBasedLayout methodsFor: 'algorithm'!set: aNode charge: aFloat 	charges at: aNode put: aFloat! !!RSForceBasedLayout methodsFor: 'algorithm'!set: anEdge length: aFloat 	lengths at: anEdge put: aFloat! !!RSForceBasedLayout methodsFor: 'algorithm'!set: anEdge length: aFloat strength: another	lengths at: anEdge put: aFloat.	strengths at: anEdge put: another ! !!RSForceBasedLayout methodsFor: 'algorithm'!set: anEdge strength: aFloat 	strengths at: anEdge put: aFloat! !!RSForceBasedLayout methodsFor: 'updating'!shouldRunLayoutWithProgressBar	^ self isJobInstalled and: [ self shouldUseProgressBar ]! !!RSForceBasedLayout methodsFor: 'accessing'!shouldUseProgressBar	^ shouldUseProgressBar! !!RSForceBasedLayout methodsFor: 'accessing'!start: nodeElements	self initialPositionOfNodes: nodeElements.	self prepareNodes: nodeElements! !!RSForceBasedLayout methodsFor: 'events'!step 	"run a step of the force layout algorithm"	| from to fp tp x y len k quad old |				"If there is no nodes, then there is not much to do"	nodes ifEmpty: [ ^ self ].	super step.	edges do: [ :e | 					from := e from. 					fp := from position.					to := e to. 					tp := to position.					x := tp x - fp x.					y := tp y - fp y.					len := ((x * x) + (y * y)) sqrt.					((len closeTo: 0) not) ifTrue: [ 						len :=  alpha * (self strengthOf: e) * ( len - (self lengthOf: e) ) / len.						x := x * len.						y := y * len.						k := (weights at: from) / (( weights at: from) +( weights at: to )).						to translateTo: ( tp x - (x * k) )@( tp y - (y * k) ).						k := 1 -  k.						from translateTo: ( fp x + (x * k) )@( fp y + (y * k) ) ] ].					k := alpha * gravity.		((k closeTo: 0) not) ifTrue: [ 			x := center x.			y := center y.			nodes do: [ :ea | | pos |					pos := ea position.					ea translateTo: (pos x + ((x - pos x)* k)) @ (pos y + (( y - pos y )* k )) ] ].						quad := RSQuadTree withAll: nodes.		self accumulate: quad.		nodes do: [ :e | 			(self isFixed: e) 				ifFalse: [ self repulse: e from: quad ]				ifTrue: [ translator translateTopLeftOf: e to: (fixedNodes at: e) ] ].		nodes do: [ :e | 			old := e position.			e translateTo: 				(old x - (( (oldPositions at: e) x - old x ) * friction)) @ 				(old y - (( (oldPositions at: e) y - old y ) * friction)).			oldPositions at: e put: old.].! !!RSForceBasedLayout methodsFor: 'accessing'!strength: aFloat	"Set the force of attraction for the edges. A high value results in having nodes together.	The default value is 1.0"	strength := aFloat! !!RSForceBasedLayout methodsFor: 'algorithm'!strengthOf: anEdge	^ strengths at: anEdge ifAbsent: [ ^ strength ] ! !!RSForceBasedLayout methodsFor: 'configuration'!useProgressBar	shouldUseProgressBar := true	! !!RSForceBasedLayout methodsFor: 'public'!userDefinedEdges: aCollectionOfEdges	"useful to tell to the layout which edges have to be used for the layout"	userDefinedEdges := aCollectionOfEdges select: [ :e |		(nodes includes: e from) and: [ nodes includes: e to ] ]	! !!RSOptimizedForceBasedLayout methodsFor: 'updating'!addEdges: someEdges	"Probably something has to be done here"	super addEdges: someEdges! !!RSOptimizedForceBasedLayout methodsFor: 'hook'!executeOnElements: elements	"The argument is the set of Roassal elements"	mockElements := elements collect: [ :e | RSMockElement new realElement: e ].	super executeOnElements: mockElements.	mockElements do: #applyToRealElement! !!RSOptimizedForceBasedLayout methodsFor: 'accessing'!prepareNodes: nodeElements	"Probably something has to be done here"	super prepareNodes: nodeElements! !!RSOptimizedForceBasedLayout methodsFor: 'accessing'!setEdgesFromElements: elements 	| view realElements realEdges mockEdges |	elements isEmpty ifTrue: [ ^ self ].	view := elements anyOne view.	realElements := elements collect: #realElement.	view ifNil: [ ^ self ].		realEdges := view edges select: [ :el | 		(el isUsedInLayout and: [ realElements includes: el from ]) and: [ realElements includes: el to ] ].	mockEdges := realEdges collect: [ :e | 							RSMockEdge new 								from: (elements detect: [ :ee | ee realElement == e from ]);								to: (elements detect: [ :ee | ee realElement == e to ]) ].	self edges: mockEdges.	! !!RSGroupLayout methodsFor: 'hook'!doExecute: elements	layout on: (self getSortedGroupsFrom: elements)! !!RSGroupLayout methodsFor: 'public - configuration'!flow	layout := RSFlowLayout new! !!RSGroupLayout methodsFor: 'private - utils'!getGroupsFrom: elements	"Return a list of RTGroup, each being the set of connected elements"		| groups iterativeGroup |	lonelyGroup := RTGroup new.	groups := OrderedCollection new.	iterativeGroup := elements copy.	[ iterativeGroup notEmpty ] whileTrue: [ 		| els |		els := iterativeGroup first withAllConnectedElements.		els size > 1 			ifTrue: [ groups add: els asGroup ] 			ifFalse: [ lonelyGroup addAll: els ].		iterativeGroup removeAll: els.	].	RSGridLayout on: lonelyGroup.	groups add: lonelyGroup.	^ groups asArray! !!RSGroupLayout methodsFor: 'private - utils'!getSortedGroupsFrom: elements	| groups |	groups := self getGroupsFrom: elements.	^ groups sortedAs: sortBlock! !!RSGroupLayout methodsFor: 'public - configuration'!grid	layout := RSGridLayout new! !!RSGroupLayout methodsFor: 'initalize'!initialize	super initialize.	self sortRDecreasingSize.	self grid! !!RSGroupLayout methodsFor: 'accessing'!lonelyGroup	^ lonelyGroup! !!RSGroupLayout methodsFor: 'accessing'!lonelyGroup: anObject	lonelyGroup := anObject! !!RSGroupLayout methodsFor: 'public - configuration'!sortIncreaseSize	sortBlock := [ :g1 :g2 | g1 size < g2 size ]! !!RSGroupLayout methodsFor: 'public - configuration'!sortRDecreasingSize	sortBlock := [ :g1 :g2 | g1 size > g2 size ]! !!RSLayout class methodsFor: 'public'!isAbstract	^ self name = #RSLayout! !!RSLayout class methodsFor: 'public'!isNotAbstract	^ self isAbstract not! !!RSLayout class methodsFor: 'public'!on: aCollection	"main entry point of the class"		"If aCollection is empty, then there is not much to do"	aCollection isEmpty ifTrue: [ ^ aCollection ].	self new applyOn: aCollection.	^ aCollection! !!RSLayout class methodsFor: 'public'!on: elements edges: edges	"To make all the layout polymorphic"		^ self on: elements ! !!RSLayout class methodsFor: 'public'!onElement: aRoassalViewOrRoassalElement	^ self on: aRoassalViewOrRoassalElement elements! !!RSLayout class methodsFor: 'public'!onView: aRoassalView	^ self on: aRoassalView elements! !!RSLayout methodsFor: 'hook'!applyOn: elements	"Return quickly if there is nothing to do"	elements isEmpty ifTrue: [ ^ self ].	self executeOnElements: elements! !!RSLayout methodsFor: 'hook'!doExecute: elements	"Performs the layout"	self subclassResponsibility! !!RSLayout methodsFor: 'hook'!doInitialize: elements	"Method executed before beginning the layout. Useful when the graph to be ordered need to be prepared"	"self announce: (ROLayoutBegin new elements: elements)."! !!RSLayout methodsFor: 'hook'!doPost: elements	"Method executed after performing the layout"! !!RSLayout methodsFor: 'accessing'!executeOnElements: elements 	"Execute the layout, myself, on the elements"			self doInitialize: elements.	self doExecute: elements asOrderedCollection.	self doPost: elements.! !!RSLayout methodsFor: 'utils'!fatherOf: aNode	^ aNode attributes at: #father ifAbsent: [ nil ]! !!RSLayout methodsFor: 'utils'!fatherOf: aNode put: aValue	aNode attributes at: #father put: aValue! !!RSLayout methodsFor: 'initialize-release'!initialize	super initialize.	translator := RSLayoutTranslator default.! !!RSLayout methodsFor: 'testing'!isEdgeDrivenLayout	^ false! !!RSLayout methodsFor: 'utils'!layerOf: aNode	^ aNode attributes at: #layout! !!RSLayout methodsFor: 'utils'!layerOf: aNode put: aValue	aNode attributes at: #layout put: aValue! !!RSLayout methodsFor: 'utils'!leftContourOf: aNode	^ aNode attributes at: #leftContour ifAbsent: [ ^ nil ]! !!RSLayout methodsFor: 'utils'!leftContourOf: aNode put: aValue	aNode attributes at: #leftContour put: aValue! !!RSLayout methodsFor: 'utils'!modOf: aNode	^ aNode attributes at: #mod ifAbsent: [ ^ 0 ]! !!RSLayout methodsFor: 'utils'!modOf: aNode put: aFloat	aNode attributes at: #mod put: aFloat! !!RSLayout methodsFor: 'hook'!on: elements	self applyOn: elements! !!RSLayout methodsFor: 'hook'!on: elements edges: edges	self applyOn: elements! !!RSLayout methodsFor: 'utils'!pointerOf: aNode	^ aNode attributes at: #pointer ifAbsent: [ ^ nil ]! !!RSLayout methodsFor: 'utils'!pointerOf: aNode put: aValue	^ aNode attributes at: #pointer put: aValue! !!RSLayout methodsFor: 'utils'!rOf: aNode 	^ aNode attributes at: #r ifAbsent: [ 0 ]	! !!RSLayout methodsFor: 'utils'!rOf: aNode put: aValue	^ aNode attributes at: #r put: aValue! !!RSLayout methodsFor: 'utils'!rightContourOf: aNode	^ aNode attributes at: #rightContour ifAbsent: [ ^ nil ]! !!RSLayout methodsFor: 'utils'!rightContourOf: aNode put: aValue	aNode attributes at: #rightContour put: aValue! !!RSLayout methodsFor: 'events'!step"	currentIteraction := currentIteraction + 1.	(currentIteraction \\ self iterationsToSendEvent) = 0 		ifTrue: [ self announce: (ROLayoutStep new 											currentIteration: currentIteraction;											maxInterations: maxInterations) ].	"! !!RSLayout methodsFor: 'utils'!thetaOf: aNode	^ aNode attributes at: #theta ifAbsent: [ ^ 0 ]! !!RSLayout methodsFor: 'utils'!thetaOf: aNode put: aValue	^ aNode attributes at: #theta put: aValue! !!RSLayout methodsFor: 'accessing'!translator	^ translator! !!RSLayout methodsFor: 'accessing'!translator: t	translator := t! !!RSLayout methodsFor: 'hook'!userDefinedEdges: edges	"Do nothing"! !!RSLayout methodsFor: 'utils'!xOf: aNode 	^ aNode attributes at: #x ifAbsent: [ 0 ]! !!RSLayout methodsFor: 'utils'!xOf: aNode put: aValue	aNode attributes at: #x put: aValue! !!RSNoLayout methodsFor: 'hook'!doExecute: elements	"Do nothing"! !!RSNullLayout methodsFor: 'hook'!doExecute: elements	elements do: [ :e | e translateTo: 0 @ 0 ]! !!RSRectanglePackLayout methodsFor: 'space-calculation'!bestSpaceFor: anElement	| elementsPadedBox suitableSpaces |		elementsPadedBox := anElement encompassingRectangle extendBy: padding * 2.		suitableSpaces := freeSpace select: [ :space |		elementsPadedBox width <= space width and:			[ elementsPadedBox height <= space height ] ].		^ suitableSpaces		fold: [ :best :current |			| bestExt currentExt | 			((currentExt := self extentByInserting: elementsPadedBox into: current) <			(bestExt := self extentByInserting: elementsPadedBox  into: best) or: [ 				currentExt = bestExt and: [					current halfPerimeter < best halfPerimeter ] ])						ifTrue: [ current ]						ifFalse: [ best ] ]! !!RSRectanglePackLayout methodsFor: 'accessing'!boundingBox	^ bounds! !!RSRectanglePackLayout methodsFor: 'hook'!doExecute: elements	| sortedElements maxSpace |	bounds := 0@0.		maxSpace := elements inject: 0@0 into: [ :sum :el |			sum + el extent ].			padding := maxSpace / elements size * gap / 2.		maxSpace := 1 + gap * maxSpace.		freeSpace := Set new.	freeSpace add: (0@0 corner: maxSpace).		sortedElements := SortedCollection sortBlock:  [ :larger :smaller |		larger  encompassingRectangle halfPerimeter >		smaller encompassingRectangle halfPerimeter ].	sortedElements addAll: elements.		sortedElements size <= 2 ifTrue: [ 		RSHorizontalLineLayout on: sortedElements.		^ self	].	sortedElements		do: [ :element | self packIn: element ]		displayingProgress: 'Laying out elements'! !!RSRectanglePackLayout methodsFor: 'space-calculation'!extentByInserting: aRectangle into: aSpace	| futureCorner |	futureCorner := aSpace origin + aRectangle extent.		^	(((futureCorner x - bounds x) max: 0) +		((futureCorner y - bounds y) max: 0))		* "this is balancing magic"		(((futureCorner max: bounds) degrees - 45) abs / 45 + 1)! !!RSRectanglePackLayout methodsFor: 'accessing'!gap	"gap between elements defined as ''percentage'' of average size. 0.2 means 20%"	^ gap! !!RSRectanglePackLayout methodsFor: 'accessing'!gap: anObject	gap := anObject! !!RSRectanglePackLayout methodsFor: 'initialize-release'!initialize	super initialize.	gap := 0.2! !!RSRectanglePackLayout methodsFor: 'execution'!packIn: anElement	translator translateTopLeftOf: anElement to: (self bestSpaceFor: anElement) origin + padding.	bounds := bounds max: anElement encompassingRectangle bottomRight + padding.		self recalculateFreeSpacesWith: anElement! !!RSRectanglePackLayout methodsFor: 'deprecated'!padding	self deprecated: 'Use gap instead'.	^ self gap! !!RSRectanglePackLayout methodsFor: 'deprecated'!padding: anObject	self deprecated: 'Use gap: instead'.	self gap: anObject! !!RSRectanglePackLayout methodsFor: 'space-calculation'!recalculateFreeSpacesWith: anElement	freeSpace := freeSpace inject: Set new into: [ :set :space |		 set			addAll: (space areasOverlapingOutside:				(anElement encompassingRectangle expandBy: padding)); 			yourself ].			"remove subspaces"	freeSpace := freeSpace reject: [ :subspace | 		freeSpace anySatisfy: [ :space |			space ~~ subspace and: [ 				space containsRect: subspace ] ] ]	! !!RSLayoutBuilder methodsFor: 'public layout'!flow	^ layout := RSFlowLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!grid	^ layout := RSGridLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!horizontal	^ layout := RSHorizontalLineLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!horizontalTree	^ layout := RSHorizontalTreeLayout new.! !!RSLayoutBuilder methodsFor: 'initialization'!initialize	super initialize.	self flow.	! !!RSLayoutBuilder methodsFor: 'accessing'!layout	^ layout ! !!RSLayoutBuilder methodsFor: 'public layout'!on: elements	layout on: elements! !!RSLayoutBuilder methodsFor: 'public layout'!tree	^ layout := RSTreeLayout new.! !!RSLayoutBuilder methodsFor: 'public layout'!vertical	^ layout := RSVerticalLineLayout new.! !!RSDirectLayoutTranslator class methodsFor: 'testing'!isDefault	^ true! !!RSDirectLayoutTranslator methodsFor: 'hook'!translate: element to: newPosition	element translateTo: newPosition! !!RSLayoutTranslator class methodsFor: 'accessing'!default	"Return the default translator, the one used in the layouts"	defaultTranslator ifNotNil: [ ^ defaultTranslator ].	^ defaultTranslator := self defaultClass new! !!RSLayoutTranslator class methodsFor: 'accessing'!defaultClass	^ self allSubclasses detect: #isDefault! !!RSLayoutTranslator class methodsFor: 'as yet unclassified'!isDefault	^ false! !!RSLayoutTranslator methodsFor: 'accessing'!nbCycles: anInteger	"Do nothing"! !!RSLayoutTranslator methodsFor: 'hook'!translate: element by: deltaPosition	"Translate of the center of the element by a step"	self translate: element to: element position + deltaPosition! !!RSLayoutTranslator methodsFor: 'hook'!translate: element to: newPosition	"Translate of the center of the element"	self subclassResponsibility ! !!RSLayoutTranslator methodsFor: 'public - translating'!translate: element to: newPosition direction: aDirection	"Translate the bottom left corner of the element"	self translate: element to: newPosition + (element extent / 2 * aDirection)! !!RSLayoutTranslator methodsFor: 'public - translating'!translateBottomLeftOf: element to: newPosition	"Translate the bottom left corner of the element"	self translate: element to: newPosition direction: 1 @ -1.! !!RSLayoutTranslator methodsFor: 'public - translating'!translateBottomOf: element to: newPosition	"Translate the bottom side of the element"	self translate: element to: element position x @ newPosition direction: 0 @ -1! !!RSLayoutTranslator methodsFor: 'public - translating'!translateBottomRightOf: element to: newPosition	"Translate the bottom right corner of the element"	self translate: element to: newPosition direction: -1 @ -1! !!RSLayoutTranslator methodsFor: 'public - translating'!translateCenterLeftOf: element to: newPosition	"Translate the left center of the element to newPosition"	self translate: element to: newPosition direction: 1 @ 0! !!RSLayoutTranslator methodsFor: 'public - translating'!translateLeftOf: element to: newPosition	"Translate the left side of the element"	self translate: element to: newPosition @ element position y direction: 1 @ 0.! !!RSLayoutTranslator methodsFor: 'public - translating'!translateRightOf: element to: newPosition	"Translate the right side of the element"	self translate: element to: newPosition @ element position y direction: -1 @ 0.! !!RSLayoutTranslator methodsFor: 'public - translating'!translateTopLeftOf: element to: newPosition	"Translate the top right corner of the element"	self translate: element to: newPosition direction: 1 @ 1! !!RSLayoutTranslator methodsFor: 'public - translating'!translateTopOf: element to: newPosition	"Translate the top side of the element"	self translate: element to: element position x @ newPosition direction: 0 @ 1.! !!RSLayoutTranslator methodsFor: 'public - translating'!translateTopRightOf: element to: newPosition	"Translate the top right corner of the element"	self translate: element to: newPosition direction: -1 @ 1! !!RSLayoutTranslator methodsFor: 'accessing'!view	^ view! !!RSLayoutTranslator methodsFor: 'accessing'!view: aView	view := aView! !!RSMockEdge methodsFor: 'accessing'!from	^ from! !!RSMockEdge methodsFor: 'accessing'!from: aMockElement	from := aMockElement! !!RSMockEdge methodsFor: 'accessing'!to	^ to! !!RSMockEdge methodsFor: 'accessing'!to: aMockElement	to := aMockElement! !!RSMockElement methodsFor: 'action'!applyToRealElement	realElement translateTo: position! !!RSMockElement methodsFor: 'as yet unclassified'!extent	^ realElement extent! !!RSMockElement methodsFor: 'as yet unclassified'!height	^ realElement height! !!RSMockElement methodsFor: 'accessing'!position	^ position! !!RSMockElement methodsFor: 'accessing'!realElement	^ realElement! !!RSMockElement methodsFor: 'accessing'!realElement: rtElement	realElement := rtElement.	position := rtElement position! !!RSMockElement methodsFor: 'actions'!translateTo: aPosition	position := aPosition! !!RSMockElement methodsFor: 'as yet unclassified'!view	^ realElement view! !!RSMockElement methodsFor: 'as yet unclassified'!width	^ realElement width! !!RSQuadTree class methodsFor: 'public'!withAll: aNodeCollection	^ self withAll: aNodeCollection origin: (aNodeCollection collect: [:e | e position x]) min @ (aNodeCollection collect: [:e | e position y]) min corner: (aNodeCollection collect: [:e | e position x]) max @ (aNodeCollection collect: [:e | e position y]) max! !!RSQuadTree class methodsFor: 'public'!withAll: aNodeCollection origin: aPoint corner: anotherPoint	| dx dy root |	dx := anotherPoint x - aPoint x.	dy := anotherPoint y - aPoint y.	(dx closeTo: dy ) ifTrue: [ root := self new.										root origin: aPoint;											corner: anotherPoint.										aNodeCollection do: [ :e | root add: e ].										^ root ] .		dx > dy ifTrue: [ ^ self withAll: aNodeCollection origin: aPoint corner: anotherPoint x @ (aPoint y + dx) ].	dy > dx ifTrue: [ ^ self withAll: aNodeCollection origin: aPoint corner: (aPoint x + dy) @ anotherPoint y ] .! !!RSQuadTree methodsFor: 'adding'!add: aNode	|n|	leaf ifTrue: [ x isNil ifFalse: [ (x - aNode position x) abs + (y - aNode position y) abs < 0.01 ifTrue: [ self addChild: aNode ]																								   ifFalse: [ n := node.																											x := nil.																											y := nil.																											node := nil.																											self addChild: aNode;																												addChild: n ] ] 						ifTrue: [ x := aNode position x.								y := aNode position y.								node := aNode ] ] 		 ifFalse: [ self addChild: aNode ] ! !!RSQuadTree methodsFor: 'adding'!addChild: aNode	| sx sy new |		sx := (origin x + corner x) / 2.	sy := (origin y + corner y) / 2.		leaf := false.	aNode position x < sx ifTrue: [ aNode position y < sy ifTrue: [ (nodes at: 1) isNil ifTrue: [ new := RSQuadTree new.																								new origin: origin;																									corner: sx@sy.																								nodes at: 1 put: new ] .																	(nodes at: 1) add: aNode ]															ifFalse: [ (nodes at: 3) isNil ifTrue: [ new := RSQuadTree new.																								new origin: origin x @ sy;																									corner: sx @ corner y.																								nodes at: 3 put: new ] .																	(nodes at: 3) add: aNode ] ]	 						    ifFalse: [ aNode position y < sy ifTrue: [  (nodes at: 2) isNil ifTrue: [ new := RSQuadTree new.																								new origin: sx @ origin y;																									corner: corner x @ sy.																								nodes at: 2 put: new ] .																	(nodes at: 2) add: aNode ] 															ifFalse: [ (nodes at: 4) isNil ifTrue: [ new := RSQuadTree new.																								new origin: sx @ sy;																									corner: corner.																								nodes at: 4 put: new ] .																	(nodes at: 4) add: aNode ] ] ! !!RSQuadTree methodsFor: 'accessing'!charge	^ charge! !!RSQuadTree methodsFor: 'accessing'!charge: anObject	charge := anObject! !!RSQuadTree methodsFor: 'accessing'!corner	^ corner! !!RSQuadTree methodsFor: 'accessing'!corner: anObject	corner := anObject! !!RSQuadTree methodsFor: 'accessing'!cx	^ cx! !!RSQuadTree methodsFor: 'accessing'!cx: aFloat	cx := aFloat! !!RSQuadTree methodsFor: 'accessing'!cy	^ cy! !!RSQuadTree methodsFor: 'accessing'!cy: aFloat	cy := aFloat! !!RSQuadTree methodsFor: 'initialize-release'!initialize 	super initialize.		leaf := true.	nodes := Array new: 4.	! !!RSQuadTree methodsFor: 'accessing'!leaf	^ leaf! !!RSQuadTree methodsFor: 'accessing'!node	^ node! !!RSQuadTree methodsFor: 'accessing'!nodes	^ nodes! !!RSQuadTree methodsFor: 'accessing'!origin	^ origin! !!RSQuadTree methodsFor: 'accessing'!origin: anObject	origin := anObject! !!RSSortBlock methodsFor: 'accessing'!fixTemps! !!RSSortBlock methodsFor: 'accessing'!value: assocA value: assocB	"Return false if assocA is bigger than assocB.	Return true if assocA is smaller than assocB.	-> Inverted list with biggest elements first"		| a b offset |	offset := 0.	a := assocA value.	b := assocB value.	[(a size > offset)		and: [(b size > offset) and: [(a at: a size - offset) = (b at: b size - offset)]]]		whileTrue: [offset := offset + 1].	"Corner cases"	(a size = b size and: [b size = offset]) ifTrue: [ ^ true ].	"[3, 3], [3, 3]"	(a size > offset and: [b size = offset]) ifTrue: [ ^ true ].	"[3, 3, 6], [3, 3]"	(b size > offset and: [a size = offset]) ifTrue: [ ^ false ].	"[3, 3], [3, 3, 6]"	"Normal case"	^(a at: a size - offset) >= (b at: b size - offset)! !!Point class methodsFor: '*Roassal3-Layouts'!r: radius theta: angle	^ (radius * angle cos) @ (radius * angle sin)! !!Collection methodsFor: '*Roassal3-Layouts'!maxValue: aBlock	^ self inject: (aBlock value: self anyOne) into: [ :max :each | max max: (aBlock value: each) ]! !"Roassal3-Layouts"!!RSAnimationExamples commentStamp: '' prior: 0!I have examples for animation!!TSShapeExamples commentStamp: '' prior: 0!I have the basic examples for shapes!!RSLayoutExamples commentStamp: '' prior: 0!I use the RSShapeBuilder!!RSShapeExamples commentStamp: '' prior: 0!I use the RSShapeBuilder!!RSAnimationExamples methodsFor: 'data'!america	^ 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM19.158,23.269c-0.079,0.064-0.183,0.13-0.105,0.207c0.078,0.078-0.09,0.131-0.09,0.17s0.104,0.246,0.052,0.336c-0.052,0.092-0.091,0.223-0.13,0.301c-0.039,0.077-0.131,0.155-0.104,0.272c0.025,0.116-0.104,0.077-0.104,0.194c0,0.116,0.116,0.065,0.09,0.208c-0.025,0.144-0.09,0.183-0.09,0.285c0,0.104,0.064,0.247,0.064,0.286s-0.064,0.17-0.155,0.272c-0.092,0.104-0.155,0.17-0.144,0.233c0.014,0.065,0.104,0.144,0.091,0.184c-0.013,0.037-0.129,0.168-0.116,0.259c0.014,0.09,0.129,0.053,0.155,0.116c0.026,0.065-0.155,0.118-0.078,0.183c0.078,0.064,0.183,0.051,0.156,0.208c-0.019,0.112,0.064,0.163,0.126,0.198c-0.891,0.221-1.818,0.352-2.777,0.352C9.639,27.533,4.466,22.36,4.466,16c0-2.073,0.557-4.015,1.518-5.697c0.079-0.042,0.137-0.069,0.171-0.062c0.065,0.013,0.079,0.104,0.183,0.13c0.104,0.026,0.195-0.078,0.26-0.117c0.064-0.039,0.116-0.195,0.051-0.182c-0.065,0.013-0.234,0-0.234,0s0.183-0.104,0.183-0.169s0.025-0.169,0.129-0.208C6.83,9.655,6.83,9.681,6.765,9.837C6.7,9.993,6.896,9.928,6.973,9.863s0.13-0.013,0.272-0.104c0.143-0.091,0.143-0.143,0.221-0.143c0.078,0,0.221,0.143,0.299,0.091c0.077-0.052,0.299,0.065,0.429,0.065c0.129,0,0.545,0.169,0.624,0.169c0.078,0,0.312,0.09,0.325,0.259c0.013,0.169,0.09,0.156,0.168,0.156s0.26,0.065,0.26,0.13c0,0.065-0.052,0.325,0.078,0.39c0.129,0.064,0.247,0.169,0.299,0.143c0.052-0.026,0-0.233-0.064-0.26c-0.065-0.026-0.027-0.117-0.052-0.169c-0.026-0.051,0.078-0.051,0.117,0.039c0.039,0.091,0.143,0.26,0.208,0.26c0.064,0,0.208,0.156,0.168,0.247c-0.039,0.091,0.039,0.221,0.156,0.221c0.116,0,0.26,0.182,0.312,0.195c0.052,0.013,0.117,0.078,0.117,0.117c0,0.04,0.065,0.26,0.065,0.351c0,0.09-0.04,0.454-0.053,0.597s0.104,0.39,0.234,0.52c0.129,0.13,0.246,0.377,0.324,0.429c0.079,0.052,0.13,0.195,0.247,0.182c0.117-0.013,0.195,0.078,0.299,0.26c0.104,0.182,0.208,0.48,0.286,0.506c0.078,0.026,0.208,0.117,0.142,0.182c-0.064,0.064-0.168,0.208-0.051,0.208c0.117,0,0.156-0.065,0.247,0.053c0.09,0.116,0.208,0.181,0.194,0.26c-0.013,0.077,0.104,0.103,0.156,0.116c0.052,0.013,0.169,0.247,0.286,0.143c0.117-0.104-0.155-0.259-0.234-0.326c-0.078-0.064,0-0.207-0.182-0.35c-0.182-0.143-0.156-0.247-0.286-0.351c-0.13-0.104-0.233-0.195-0.104-0.286c0.13-0.091,0.143,0.091,0.195,0.208c0.052,0.116,0.324,0.351,0.441,0.454c0.117,0.104,0.326,0.468,0.39,0.468s0.247,0.208,0.247,0.208s0.103,0.168,0.064,0.22c-0.039,0.052,0.053,0.247,0.144,0.299c0.09,0.052,0.455,0.22,0.507,0.247c0.052,0.027,0.155,0.221,0.299,0.221c0.142,0,0.247,0.014,0.286,0.053c0.039,0.038,0.155,0.194,0.234,0.104c0.078-0.092,0.09-0.131,0.208-0.131c0.117,0,0.168,0.091,0.233,0.156c0.065,0.065,0.247,0.235,0.338,0.222c0.091-0.013,0.208,0.104,0.273,0.064s0.169,0.025,0.22,0.052c0.054,0.026,0.234,0.118,0.222,0.272c-0.013,0.157,0.103,0.195,0.182,0.234c0.078,0.039,0.182,0.13,0.248,0.195c0.064,0.063,0.206,0.077,0.246,0.116c0.039,0.039,0.065,0.117,0.182,0.052c0.116-0.064,0.092-0.181,0.092-0.181s0.129-0.026,0.194,0.026c0.064,0.05,0.104,0.22,0.144,0.246c0.038,0.026,0.115,0.221,0.063,0.362c-0.051,0.145-0.038,0.286-0.091,0.286c-0.052,0-0.116,0.17-0.195,0.209c-0.076,0.039-0.285,0.221-0.272,0.286c0.013,0.063,0.131,0.258,0.104,0.35c-0.025,0.091-0.194,0.195-0.154,0.338c0.038,0.144,0.312,0.183,0.323,0.312c0.014,0.131,0.209,0.417,0.235,0.546c0.025,0.13,0.246,0.272,0.246,0.453c0,0.184,0.312,0.3,0.377,0.312c0.063,0.013,0.182,0.131,0.272,0.17s0.169,0.116,0.233,0.221s0.053,0.261,0.053,0.299c0,0.039-0.039,0.44-0.078,0.674C19.145,23.021,19.235,23.203,19.158,23.269zM10.766,11.188c0.039,0.013,0.117,0.091,0.156,0.091c0.04,0,0.234,0.156,0.286,0.208c0.053,0.052,0.053,0.195-0.013,0.208s-0.104-0.143-0.117-0.208c-0.013-0.065-0.143-0.065-0.208-0.104C10.805,11.344,10.66,11.152,10.766,11.188zM27.51,16.41c-0.144,0.182-0.13,0.272-0.195,0.286c-0.064,0.013,0.065,0.065,0.09,0.194c0.022,0.112-0.065,0.224,0.063,0.327c-0.486,4.619-3.71,8.434-8.016,9.787c-0.007-0.011-0.019-0.025-0.021-0.034c-0.027-0.078-0.027-0.233,0.064-0.285c0.091-0.053,0.312-0.233,0.363-0.272c0.052-0.04,0.13-0.221,0.091-0.247c-0.038-0.026-0.232,0-0.26-0.039c-0.026-0.039-0.026-0.092,0.104-0.182c0.13-0.091,0.195-0.222,0.247-0.26c0.052-0.039,0.155-0.117,0.195-0.209c0.038-0.09-0.041-0.039-0.118-0.039s-0.117-0.142-0.117-0.207s0.195,0.026,0.339,0.052c0.143,0.024,0.077-0.065,0.064-0.142c-0.013-0.078,0.026-0.209,0.105-0.17c0.076,0.039,0.479-0.013,0.531-0.026c0.052-0.013,0.194-0.246,0.246-0.312c0.053-0.065,0.064-0.129,0-0.168c-0.065-0.04-0.143-0.184-0.168-0.221c-0.026-0.041-0.039-0.274-0.013-0.34c0.025-0.063,0,0.377,0.181,0.43c0.183,0.052,0.286,0.078,0.455-0.078c0.169-0.155,0.298-0.26,0.312-0.363c0.013-0.104,0.052-0.209,0.117-0.246c0.065-0.039,0.104,0.103,0.182-0.065c0.078-0.17,0.156-0.157,0.234-0.299c0.077-0.144-0.13-0.325,0.024-0.43c0.157-0.103,0.43-0.233,0.43-0.233s0.078-0.039,0.234-0.078c0.155-0.038,0.324-0.014,0.376-0.09c0.052-0.079,0.104-0.247,0.182-0.338c0.079-0.092,0.169-0.234,0.13-0.299c-0.039-0.065,0.104-0.352,0.091-0.429c-0.013-0.078-0.13-0.261,0.065-0.416s0.402-0.391,0.416-0.454c0.012-0.065,0.169-0.338,0.154-0.469c-0.012-0.129-0.154-0.285-0.245-0.325c-0.092-0.037-0.286-0.05-0.364-0.154s-0.299-0.208-0.377-0.182c-0.077,0.026-0.208,0.051-0.312-0.015c-0.104-0.063-0.272-0.143-0.337-0.194c-0.066-0.051-0.234-0.09-0.312-0.09s-0.065-0.053-0.182,0.103c-0.117,0.157,0,0.209-0.208,0.182c-0.209-0.024,0.025-0.038,0.144-0.194c0.115-0.155-0.014-0.247-0.144-0.207c-0.13,0.039-0.039,0.117-0.247,0.156c-0.207,0.038-0.207-0.092-0.077-0.117c0.13-0.026,0.363-0.143,0.363-0.194c0-0.053-0.026-0.196-0.13-0.196s-0.078-0.129-0.233-0.297c-0.156-0.17-0.351-0.274-0.508-0.249c-0.154,0.026-0.272,0.065-0.35-0.076c-0.078-0.144-0.169-0.17-0.222-0.247c-0.051-0.078-0.182,0-0.221-0.039s-0.039-0.039-0.039-0.039s-0.169,0.039-0.077-0.078c0.09-0.117,0.129-0.338,0.09-0.325c-0.038,0.013-0.104,0.196-0.168,0.183c-0.064-0.013-0.014-0.04-0.144-0.117c-0.13-0.078-0.337-0.013-0.337,0.052c0,0.065-0.065,0.117-0.065,0.117s-0.039-0.038-0.078-0.117c-0.039-0.078-0.221-0.091-0.312-0.013c-0.09,0.078-0.142-0.196-0.207-0.196s-0.194,0.065-0.26,0.184c-0.064,0.116-0.038,0.285-0.092,0.272c-0.05-0.013-0.063-0.233-0.05-0.312c0.012-0.079,0.155-0.208,0.05-0.234c-0.103-0.026-0.259,0.13-0.323,0.143c-0.065,0.013-0.195,0.104-0.273,0.209c-0.077,0.103-0.116,0.168-0.195,0.207c-0.077,0.039-0.193,0-0.167-0.039c0.025-0.039-0.222-0.181-0.261-0.13c-0.04,0.052-0.155,0.091-0.272,0.144c-0.117,0.052-0.222-0.065-0.247-0.117s-0.079-0.064-0.091-0.234c-0.013-0.168,0.027-0.351,0.065-0.454c0.038-0.104-0.195-0.312-0.286-0.3c-0.091,0.015-0.182,0.105-0.272,0.091c-0.092-0.012-0.052-0.038-0.195-0.038c-0.143,0-0.026-0.025,0-0.143c0.025-0.116-0.052-0.273,0.092-0.377c0.142-0.104,0.091-0.351,0-0.363c-0.092-0.014-0.261,0.039-0.377,0.026c-0.116-0.014-0.208,0.091-0.169,0.207c0.039,0.117-0.065,0.195-0.104,0.183c-0.039-0.013-0.09-0.078-0.234,0.026c-0.142,0.103-0.194,0.064-0.337-0.052c-0.143-0.118-0.299-0.234-0.325-0.416c-0.026-0.182-0.04-0.364,0.013-0.468c0.051-0.104,0.051-0.285-0.026-0.312c-0.078-0.025,0.09-0.155,0.181-0.181c0.092-0.026,0.234-0.143,0.26-0.195c0.026-0.052,0.156-0.04,0.298-0.04c0.143,0,0.169,0,0.312,0.078c0.143,0.078,0.169-0.039,0.169-0.078c0-0.039,0.052-0.117,0.208-0.104c0.156,0.013,0.376-0.052,0.416-0.013s0.116,0.195,0.194,0.143c0.079-0.051,0.104-0.143,0.131,0.014c0.025,0.155,0.09,0.39,0.208,0.429c0.116,0.039,0.052,0.194,0.168,0.207c0.115,0.013,0.17-0.246,0.131-0.337c-0.04-0.09-0.118-0.363-0.183-0.428c-0.064-0.065-0.064-0.234,0.064-0.286c0.13-0.052,0.442-0.312,0.532-0.389c0.092-0.079,0.338-0.144,0.261-0.248c-0.078-0.104-0.104-0.168-0.104-0.247s0.078-0.052,0.117,0s0.194-0.078,0.155-0.143c-0.038-0.064-0.026-0.155,0.065-0.143c0.091,0.013,0.116-0.065,0.078-0.117c-0.039-0.052,0.091-0.117,0.182-0.091c0.092,0.026,0.325-0.013,0.364-0.065c0.038-0.052-0.078-0.104-0.078-0.208c0-0.104,0.155-0.195,0.247-0.208c0.091-0.013,0.207,0,0.221-0.039c0.012-0.039,0.143-0.143,0.155-0.052c0.014,0.091,0,0.247,0.104,0.247c0.104,0,0.232-0.117,0.272-0.129c0.038-0.013,0.286-0.065,0.338-0.078c0.052-0.013,0.363-0.039,0.325-0.13c-0.039-0.09-0.078-0.181-0.118-0.22c-0.039-0.039-0.077,0.013-0.13,0.078c-0.051,0.065-0.143,0.065-0.168,0.013c-0.026-0.051,0.012-0.207-0.078-0.156c-0.092,0.052-0.104,0.104-0.157,0.078c-0.052-0.026-0.103-0.117-0.103-0.117s0.129-0.064,0.038-0.182c-0.09-0.117-0.221-0.091-0.35-0.025c-0.13,0.064-0.118,0.051-0.273,0.09s-0.234,0.078-0.234,0.078s0.209-0.129,0.299-0.208c0.091-0.078,0.209-0.117,0.286-0.195c0.078-0.078,0.285,0.039,0.285,0.039s0.105-0.104,0.105-0.039s-0.027,0.234,0.051,0.234c0.079,0,0.299-0.104,0.21-0.131c-0.093-0.026,0.129,0,0.219-0.065c0.092-0.065,0.194-0.065,0.247-0.09c0.052-0.026,0.092-0.143,0.182-0.143c0.092,0,0.13,0.117,0,0.195s-0.143,0.273-0.208,0.325c-0.064,0.052-0.026,0.117,0.078,0.104c0.104-0.013,0.194,0.013,0.286-0.013s0.143,0.026,0.168,0.065c0.026,0.039,0.104-0.039,0.104-0.039s0.169-0.039,0.221,0.026c0.053,0.064,0.092-0.039,0.053-0.104c-0.039-0.064-0.092-0.129-0.13-0.208c-0.039-0.078-0.091-0.104-0.194-0.078c-0.104,0.026-0.13-0.026-0.195-0.064c-0.065-0.04-0.118,0.052-0.065-0.04c0.053-0.09,0.078-0.117,0.117-0.195c0.039-0.078,0.209-0.221,0.039-0.259c-0.169-0.04-0.222-0.065-0.247-0.143c-0.026-0.078-0.221-0.221-0.272-0.221c-0.053,0-0.233,0-0.247-0.065c-0.013-0.065-0.143-0.208-0.208-0.273c-0.064-0.065-0.312-0.351-0.351-0.377c-0.039-0.026-0.091-0.013-0.208,0.143c-0.116,0.157-0.22,0.183-0.312,0.144c-0.091-0.039-0.104-0.026-0.193-0.13c-0.093-0.104,0.09-0.117,0.051-0.182c-0.04-0.064-0.247-0.091-0.377-0.104c-0.13-0.013-0.221-0.156-0.416-0.169c-0.194-0.013-0.428,0.026-0.493,0.026c-0.064,0-0.064,0.091-0.09,0.234c-0.027,0.143,0.09,0.182-0.027,0.208c-0.116,0.026-0.169,0.039-0.052,0.091c0.117,0.052,0.273,0.26,0.273,0.26s0,0.117-0.092,0.182c-0.09,0.065-0.182,0.13-0.233,0.053c-0.053-0.079-0.195-0.065-0.155,0.013c0.038,0.078,0.116,0.117,0.116,0.195c0,0.077,0.117,0.272,0.039,0.337c-0.078,0.065-0.168,0.014-0.233,0.026s-0.131-0.104-0.078-0.13c0.051-0.026-0.014-0.221-0.014-0.221s-0.155,0.221-0.143,0.104c0.014-0.117-0.064-0.13-0.064-0.221c0-0.091-0.079-0.13-0.194-0.104c-0.118,0.026-0.26-0.04-0.482-0.079c-0.22-0.039-0.311-0.064-0.493-0.156c-0.182-0.091-0.247-0.026-0.338-0.013c-0.091,0.013-0.052-0.182-0.169-0.207c-0.116-0.027-0.181,0.025-0.207-0.144c-0.026-0.168,0.039-0.208,0.324-0.39c0.286-0.182,0.247-0.26,0.468-0.286c0.22-0.026,0.325,0.026,0.325-0.039s0.052-0.325,0.052-0.195S16.95,9.109,16.832,9.2c-0.116,0.091-0.052,0.104,0.04,0.104c0.091,0,0.259-0.091,0.259-0.091s0.208-0.091,0.26-0.013c0.053,0.078,0.053,0.156,0.144,0.156s0.285-0.104,0.116-0.195c-0.168-0.091-0.272-0.078-0.376-0.182s-0.078-0.065-0.195-0.039c-0.116,0.026-0.116-0.039-0.156-0.039s-0.104,0.026-0.13-0.026c-0.025-0.052,0.014-0.065,0.145-0.065c0.129,0,0.285,0.039,0.285,0.039s0.155-0.052,0.194-0.065c0.039-0.013,0.247-0.039,0.208-0.155c-0.04-0.117-0.169-0.117-0.208-0.156s0.078-0.09,0.143-0.117c0.065-0.026,0.247,0,0.247,0s0.117,0.013,0.117-0.039S17.897,8.2,17.976,8.239s0,0.156,0.117,0.13c0.116-0.026,0.143,0,0.207,0.039c0.065,0.039-0.013,0.195-0.077,0.221c-0.065,0.025-0.169,0.077-0.026,0.09c0.144,0.014,0.246,0.014,0.246,0.014s0.092-0.091,0.131-0.169c0.038-0.078,0.104-0.026,0.155,0c0.052,0.025,0.247,0.065,0.065,0.117c-0.183,0.052-0.221,0.117-0.26,0.182c-0.038,0.065-0.053,0.104-0.221,0.065c-0.17-0.039-0.26-0.026-0.299,0.039c-0.039,0.064-0.013,0.273,0.053,0.247c0.063-0.026,0.129-0.026,0.207-0.052c0.078-0.026,0.39,0.026,0.467,0.013c0.078-0.013,0.209,0.13,0.248,0.104c0.039-0.026,0.117,0.052,0.194,0.104c0.078,0.052,0.052-0.117,0.194-0.013c0.144,0.104,0.065,0.104,0.144,0.104c0.076,0,0.246,0.013,0.246,0.013s0.014-0.129,0.144-0.104c0.13,0.026,0.245,0.169,0.232,0.064c-0.012-0.103,0.013-0.181-0.09-0.259c-0.104-0.078-0.272-0.13-0.299-0.169c-0.026-0.039-0.052-0.091-0.013-0.117c0.039-0.025,0.221,0.013,0.324,0.079c0.104,0.065,0.195,0.13,0.273,0.078c0.077-0.052,0.17-0.078,0.208-0.117c0.038-0.04,0.13-0.156,0.13-0.156s-0.391-0.051-0.441-0.117c-0.053-0.065-0.235-0.156-0.287-0.156s-0.194,0.091-0.246-0.039s-0.052-0.286-0.105-0.299c-0.05-0.013-0.597-0.091-0.674-0.13c-0.078-0.039-0.39-0.13-0.507-0.195s-0.286-0.156-0.389-0.156c-0.104,0-0.533,0.052-0.611,0.039c-0.078-0.013-0.312,0.026-0.403,0.039c-0.091,0.013,0.117,0.182-0.077,0.221c-0.195,0.039-0.169,0.065-0.13-0.13c0.038-0.195-0.131-0.247-0.299-0.169c-0.169,0.078-0.442,0.13-0.377,0.221c0.065,0.091-0.012,0.157,0.117,0.247c0.13,0.091,0.183,0.117,0.35,0.104c0.17-0.013,0.339,0.025,0.339,0.025s0,0.157-0.064,0.182c-0.065,0.026-0.169,0.026-0.196,0.104c-0.025,0.078-0.155,0.117-0.155,0.078s0.065-0.169-0.026-0.234c-0.09-0.065-0.117-0.078-0.221-0.013c-0.104,0.065-0.116,0.091-0.169-0.013C16.053,8.291,15.897,8.2,15.897,8.2s-0.104-0.129-0.182-0.194c-0.077-0.065-0.22-0.052-0.234,0.013c-0.013,0.064,0.026,0.129,0.078,0.247c0.052,0.117,0.104,0.337,0.013,0.351c-0.091,0.013-0.104,0.026-0.195,0.052c-0.091,0.026-0.13-0.039-0.13-0.143s-0.04-0.195-0.013-0.234c0.026-0.039-0.104,0.027-0.234,0c-0.13-0.025-0.233,0.052-0.104,0.092c0.13,0.039,0.157,0.194,0.039,0.233c-0.117,0.039-0.559,0-0.702,0s-0.35,0.039-0.39-0.039c-0.039-0.078,0.118-0.129,0.208-0.129c0.091,0,0.363,0.012,0.467-0.13c0.104-0.143-0.13-0.169-0.233-0.169c-0.104,0-0.183-0.039-0.299-0.155c-0.118-0.117,0.078-0.195,0.052-0.247c-0.026-0.052-0.156-0.014-0.272-0.014c-0.117,0-0.299-0.09-0.299,0.014c0,0.104,0.143,0.402,0.052,0.337c-0.091-0.064-0.078-0.156-0.143-0.234c-0.065-0.078-0.168-0.065-0.299-0.052c-0.129,0.013-0.35,0.052-0.415,0.039c-0.064-0.013-0.013-0.013-0.156-0.078c-0.142-0.065-0.208-0.052-0.312-0.117C12.091,7.576,12.182,7.551,12,7.538c-0.181-0.013-0.168,0.09-0.35,0.065c-0.182-0.026-0.234,0.013-0.416,0c-0.182-0.013-0.272-0.026-0.299,0.065c-0.025,0.091-0.078,0.247-0.156,0.247c-0.077,0-0.169,0.091,0.078,0.104c0.247,0.013,0.105,0.129,0.325,0.117c0.221-0.013,0.416-0.013,0.468-0.117c0.052-0.104,0.091-0.104,0.117-0.065c0.025,0.039,0.22,0.272,0.22,0.272s0.131,0.104,0.183,0.13c0.051,0.026-0.052,0.143-0.156,0.078c-0.104-0.065-0.299-0.051-0.377-0.116c-0.078-0.065-0.429-0.065-0.52-0.052c-0.09,0.013-0.247-0.039-0.299-0.039c-0.051,0-0.221,0.13-0.221,0.13S10.532,8.252,10.494,8.2c-0.039-0.052-0.104,0.052-0.156,0.065c-0.052,0.013-0.208-0.104-0.364-0.052C9.818,8.265,9.87,8.317,9.649,8.304s-0.272-0.052-0.35-0.039C9.22,8.278,9.22,8.278,9.22,8.278S9.233,8.33,9.143,8.382C9.052,8.434,8.986,8.499,8.921,8.421C8.857,8.343,8.818,8.343,8.779,8.33c-0.04-0.013-0.118-0.078-0.286-0.04C8.324,8.33,8.064,8.239,8.013,8.239c-0.04,0-0.313-0.015-0.491-0.033c2.109-2.292,5.124-3.74,8.478-3.74c2.128,0,4.117,0.589,5.83,1.598c-0.117,0.072-0.319,0.06-0.388,0.023c-0.078-0.043-0.158-0.078-0.475-0.061c-0.317,0.018-0.665,0.122-0.595,0.226c0.072,0.104-0.142,0.165-0.197,0.113c-0.055-0.052-0.309,0.06-0.293,0.165c0.016,0.104-0.039,0.225-0.175,0.199c-0.134-0.027-0.229,0.06-0.237,0.146c-0.007,0.087-0.309,0.147-0.332,0.147c-0.024,0-0.412-0.008-0.27,0.095c0.097,0.069,0.15,0.027,0.27,0.052c0.119,0.026,0.214,0.217,0.277,0.243c0.062,0.026,0.15,0,0.189-0.052c0.04-0.052,0.095-0.234,0.095-0.234s0,0.173,0.097,0.208c0.095,0.035,0.331-0.026,0.395-0.017c0.064,0.008,0.437,0.061,0.538,0.112c0.104,0.052,0.356,0.087,0.428,0.199c0.071,0.113,0.08,0.503,0.119,0.546c0.04,0.043,0.174-0.139,0.205-0.182c0.031-0.044,0.198-0.018,0.254,0.042c0.056,0.061,0.182,0.208,0.175,0.269C21.9,8.365,21.877,8.459,21.83,8.425c-0.048-0.034-0.127-0.025-0.096-0.095c0.032-0.069,0.048-0.217-0.015-0.217c-0.064,0-0.119,0-0.119,0s-0.12-0.035-0.199,0.095s-0.015,0.26,0.04,0.26s0.184,0,0.184,0.034c0,0.035-0.136,0.139-0.128,0.2c0.009,0.061,0.11,0.268,0.144,0.312c0.031,0.043,0.197,0.086,0.244,0.096c0.049,0.008-0.111,0.017-0.07,0.077c0.04,0.061,0.102,0.208,0.189,0.243c0.087,0.035,0.333,0.19,0.363,0.26c0.032,0.069,0.222-0.052,0.262-0.061c0.04-0.008,0.032,0.182,0.143,0.191c0.11,0.008,0.15-0.018,0.245-0.096s0.072-0.182,0.079-0.26c0.009-0.078,0-0.138,0.104-0.113c0.104,0.026,0.158-0.018,0.15-0.104c-0.008-0.087-0.095-0.191,0.07-0.217c0.167-0.026,0.254-0.138,0.357-0.138c0.103,0,0.389,0.043,0.419,0c0.032-0.043,0.167-0.243,0.254-0.251c0.067-0.007,0.224-0.021,0.385-0.042c1.582,1.885,2.561,4.284,2.673,6.905c-0.118,0.159-0.012,0.305,0.021,0.408c0.001,0.03,0.005,0.058,0.005,0.088c0,0.136-0.016,0.269-0.021,0.404C27.512,16.406,27.512,16.408,27.51,16.41zM17.794,12.084c-0.064,0.013-0.169-0.052-0.169-0.143s-0.091,0.169-0.04,0.247c0.053,0.078-0.104,0.169-0.155,0.169s-0.091-0.116-0.078-0.233c0.014-0.117-0.077-0.221-0.221-0.208c-0.143,0.014-0.208,0.13-0.259,0.169c-0.053,0.039-0.053,0.259-0.04,0.312s0.013,0.235-0.116,0.221c-0.118-0.013-0.092-0.233-0.079-0.312c0.014-0.078-0.039-0.273,0.014-0.376c0.053-0.104,0.207-0.143,0.312-0.156s0.324,0.065,0.363,0.052c0.04-0.014,0.222-0.014,0.312,0C17.729,11.837,17.858,12.071,17.794,12.084zM18.027,12.123c0.04,0.026,0.311-0.039,0.364,0.026c0.051,0.065-0.054,0.078-0.183,0.13c-0.129,0.052-0.169,0.039-0.221,0.104s-0.221,0.09-0.299,0.168c-0.078,0.079-0.217,0.125-0.246,0.065c-0.04-0.078,0.013-0.039,0.025-0.078c0.013-0.039,0.245-0.129,0.245-0.129S17.988,12.097,18.027,12.123zM16.988,11.668c-0.038,0.013-0.182-0.026-0.3-0.026c-0.116,0-0.091-0.078-0.143-0.064c-0.051,0.013-0.168,0.039-0.247,0.078c-0.078,0.039-0.208,0.03-0.208-0.04c0-0.104,0.052-0.078,0.221-0.143c0.169-0.065,0.352-0.247,0.429-0.169c0.078,0.078,0.221,0.169,0.312,0.182C17.144,11.5,17.026,11.655,16.988,11.668zM15.659,7.637c-0.079,0.026-0.347,0.139-0.321,0.199c0.01,0.023,0.078,0.069,0.19,0.052c0.113-0.018,0.276-0.035,0.355-0.043c0.078-0.009,0.095-0.139,0.009-0.147C15.805,7.689,15.736,7.611,15.659,7.637zM14.698,7.741c-0.061,0.026-0.243-0.043-0.338,0.018c-0.061,0.038-0.026,0.164,0.07,0.172c0.095,0.009,0.259-0.06,0.276-0.008c0.018,0.052,0.078,0.286,0.234,0.208c0.156-0.078,0.147-0.147,0.19-0.156c0.043-0.009-0.008-0.199-0.078-0.243C14.983,7.689,14.758,7.715,14.698,7.741zM14.385,7.005c0.017,0.044-0.008,0.078,0.113,0.095c0.121,0.018,0.173,0.035,0.243,0.035c0.069,0,0.042-0.113-0.018-0.19c-0.061-0.078-0.043-0.069-0.199-0.113c-0.156-0.043-0.312-0.043-0.416-0.035c-0.104,0.009-0.217-0.017-0.243,0.104c-0.013,0.062,0.07,0.112,0.174,0.112S14.368,6.962,14.385,7.005zM14.611,7.481c0.043,0.095,0.043,0.051,0.165,0.061C14.896,7.551,14.991,7.421,15,7.378c0.009-0.044-0.061-0.13-0.225-0.113c-0.165,0.017-0.667-0.026-0.736,0.034c-0.066,0.058,0,0.233-0.026,0.251c-0.026,0.017,0.009,0.095,0.077,0.078c0.069-0.017,0.104-0.182,0.157-0.182C14.299,7.447,14.568,7.386,14.611,7.481zM12.982,7.126c0.052,0.043,0.183,0.008,0.173-0.035c-0.008-0.043,0.053-0.217-0.051-0.225C13,6.858,12.854,6.962,12.697,7.014c-0.101,0.033-0.078,0.13-0.009,0.13S12.931,7.083,12.982,7.126zM13.72,7.282c-0.087,0.043-0.114,0.069-0.191,0.052c-0.078-0.017-0.078-0.156-0.217-0.13c-0.138,0.026-0.164,0.104-0.207,0.139s-0.139,0.061-0.173,0.043c-0.034-0.017-0.234-0.129-0.234-0.129s-0.416-0.018-0.433-0.07c-0.017-0.052-0.086-0.138-0.277-0.121s-0.52,0.13-0.572,0.13c-0.052,0,0.062,0.104-0.009,0.104c-0.069,0-0.155-0.008-0.181,0.069c-0.018,0.053,0.078,0.052,0.189,0.052c0.112,0,0.295,0,0.347-0.026c0.052-0.026,0.312-0.087,0.303-0.009c-0.009,0.079,0.104,0.199,0.164,0.182c0.061-0.017,0.183-0.13,0.243-0.086c0.061,0.043,0.07,0.146,0.13,0.173c0.061,0.025,0.226,0.025,0.304,0c0.077-0.027,0.294-0.027,0.389-0.009c0.095,0.018,0.373,0.069,0.399,0.018c0.026-0.053,0.104-0.061,0.112-0.113s0.051-0.216,0.051-0.216S13.806,7.239,13.72,7.282zM18.105,16.239c-0.119,0.021-0.091,0.252,0.052,0.21C18.3,16.407,18.223,16.217,18.105,16.239zM19.235,15.929c-0.104-0.026-0.221,0-0.299,0.013c-0.078,0.013-0.299,0.208-0.299,0.208s0.143,0.026,0.233,0.026c0.092,0,0.144,0.051,0.221,0.09c0.078,0.04,0.221-0.052,0.272-0.052c0.053,0,0.118,0.156,0.131-0.013C19.508,16.032,19.339,15.955,19.235,15.929zM15.616,7.507c-0.043-0.104-0.259-0.139-0.304-0.035C15.274,7.563,15.659,7.611,15.616,7.507zM18.093,15.292c0.143-0.026,0.064-0.144-0.053-0.13C17.922,15.175,17.949,15.318,18.093,15.292zM19.82,16.095c-0.119,0.022-0.092,0.253,0.051,0.211C20.015,16.264,19.937,16.074,19.82,16.095zM18.247,15.708c-0.09,0.013-0.285-0.09-0.389-0.182c-0.104-0.091-0.299-0.091-0.377-0.091c-0.077,0-0.39,0.091-0.39,0.091c-0.013,0.13,0.117,0.091,0.273,0.091s0.429-0.026,0.479,0.039c0.053,0.064,0.286,0.168,0.352,0.221c0.064,0.052,0.272,0.065,0.285,0.013S18.338,15.695,18.247,15.708zM16.698,7.412c-0.13-0.009-0.295-0.009-0.399,0c-0.104,0.008-0.182-0.069-0.26-0.113c-0.077-0.043-0.251-0.182-0.354-0.199c-0.104-0.017-0.086-0.017-0.303-0.069c-0.11-0.027-0.294-0.061-0.294-0.086c0-0.026-0.052,0.121,0.043,0.165c0.095,0.043,0.251,0.121,0.363,0.164c0.114,0.043,0.329,0.052,0.399,0.139c0.069,0.086,0.303,0.156,0.303,0.156l0.277,0.026c0,0,0.191-0.043,0.39-0.026c0.199,0.017,0.493,0.043,0.659,0.035c0.163-0.008,0.189-0.061,0.208-0.095c0.016-0.035-0.304-0.104-0.383-0.095C17.271,7.42,16.827,7.42,16.698,7.412zM17.182,9.404c-0.034,0.039,0.157,0.095,0.191,0.043C17.407,9.396,17.271,9.309,17.182,9.404zM17.764,9.585c0.086-0.035,0.043-0.139-0.079-0.104C17.547,9.521,17.676,9.62,17.764,9.585z'! !!RSAnimationExamples methodsFor: 'examples'!example01Basic	<script: 'self new example01Basic'>	| c b |	c := TSCanvas new.	b := TSBox new		extent: 100@100;		border: TSBorder new.	c addShape: b.		c animation 		easing: TSEasing bounce;		from: -100@ -100;		to: 100@100;		on: b set: #position:.	c animation 		from: Color red;		to: Color blue;		on: b set: #color:.	c animation 		from: 0;		to: 10;		on: b border set: 'width:'.	c 		when:TSMouseClick		do: [ c animations do: #pause ];		when: TSMouseDoubleClick 		do: [ c animations do: #continue ].	c clearBackground: false.	c open.! !!RSAnimationExamples methodsFor: 'examples'!example02Sequential	<script: 'self new example02Sequential'>	| c b animation |	c := TSCanvas new.	b := TSBox new		extent: 100@100;		border: TSBorder new.	c addShape: b.		animation := c animationFrom: { 		(c tAnimation			from: -100@ -200;			to: 100@130;			on: b set: #position:).		(c tAnimation			from: Color red;			to: Color blue;			on: b set: #color:).		(c tAnimation 			from: 0;			to: 10;			on: b border set: 'width:')	}.	animation		loops: 2.		c 		when:TSMouseClick		do: [ c animations do: #pause ];		when: TSMouseDoubleClick 		do: [ c animations do: #continue ].	c open.! !!RSAnimationExamples methodsFor: 'examples'!example03Ramp	<script: 'self new example03Ramp'>	| c b |	c := TSCanvas new.	b := TSBox new		extent: 100@100;		border: TSBorder new.	c addShape: b.		c animation		ramp: { 		 	0 -> (0@0).			0.25 -> (200@180).			0.75 -> (-200@ -80).			1 -> (200@0)};		on: b set: #position:.		c 		when:TSMouseClick		do: [ c animations do: #pause ];		when: TSMouseDoubleClick 		do: [ c animations do: #continue ].	c open.! !!RSAnimationExamples methodsFor: 'examples'!example04BoxWindmill	<script: 'self new example04BoxWindmill'>	| v elements extent points frameCount |	v := RSView new.	v color: Color black.	extent := 1920@1080.	points := (0 to: extent x by: 50) flatCollect: [ :x |		(0 to: extent y by: 50) collect: [ :y | (x@y)- (extent/2) ] ].	elements := RSShapeBuilder box		extent: 140@40;		color: Color white;		border: (TSBorder new			color: (Color gray alpha: 0.5) ) ;		elementsOn: points.	v addAll: elements.	frameCount := 0.	v animation repeat;		onStepDo: [ :t |			elements do: [ :e | 				e matrix 					loadIdentity;					translateBy: e model;					rotateByRadians: (e model x + e model y + frameCount) degreesToRadians * 1.95  ].			frameCount := frameCount + 1. ].	v open.! !!RSAnimationExamples methodsFor: 'examples'!example05BoxesLineCircles	<script: 'self new example05BoxesLineCircles'>	| v extent r  elements position shape alpha update updateLine lineX line |	v := RSView new.	r := SharedRandom globalGenerator.	shape := RSShapeBuilder box		noPaint;		border: (TSBorder new			width: 4).			elements := shape elementsOn: ((1 to: 12) collect: [:i | r next ]).	v addAll: elements.		RSNormalizer size		from: 30;		to: 100;		elements: elements;		normalize: #yourself.		lineX := 0.	line := RSEdgeBuilder line		color: Color red;		width: 8;		from: 1@0; to: 0@0; edge.	v add: line. 	position := nil.	updateLine := [		line 			from: lineX@position from y;			to: lineX@position to y;			update. ].	v when: TSMouseMove do: [ :ev | 		lineX := ev position x.		updateLine value ].	update := [ 		extent := v extent.		position := TSScale linear			range: { extent / 2 negated. extent /2 }.		updateLine value.		elements do: [ :e | e translateTo: (position scale: r next@ r next) ].	].	update value.	v when: TSExtentChangedEvent do: update.		"shadow"	alpha := TSScale linear domain: #(1 4); range: #(0.4 0.05).	elements do: [ :e | | ant |		ant := e.		1 to: 4 do: [:i | | s |			s := shape				position: e position;				extent: e extent;				border: (TSBorder new					width: 5;					color: (e border color alpha: (alpha scale: i)));				elementOn: i.			ant when: TSPositionChangedEvent do: [ :evt | 				s translateTo: evt oldPosition ].			ant := s.			v add: s			] ] .	"animation"	v animation repeat; 		onStepDo: [ :t | 			elements do: [ :e |				| delta newX |				delta := e attributes at: #delta ifAbsentPut: [ 5 ].				newX := e position x + delta.				(newX 					between: position from x 					and: position to x) ifFalse: [ 					delta := delta negated.					newX := e position x + delta.					 ].				e translateTo: newX@e position y.				e attributes at: #delta put: delta				].			v elements do: [ :e | | cls |				cls := e position x > lineX 					ifTrue: [ TSEllipse ]					ifFalse: [ TSBox ].				e trachelShape: cls new.				 ].	].	v open.	"87 lines of code"! !!RSAnimationExamples methodsFor: 'examples'!example05b	<script: 'self new example05b'>	| v extent r elements position alpha update updateLine lineX line |	v := RSView new.	r := SharedRandom globalGenerator.	elements := (1 to: 12) collect: [ :i | | e | 		e := RSElement new			model: r next;			trachelShape: TSBox new;			noPaint;			border: (TSBorder new width: 4);			yourself.		e.].	v addAll: elements.	RSNormalizer size		from: 30;		to: 100;		elements: elements;		normalize: #yourself.	lineX := 0.	line := RSEdgeBuilder line		color: Color red;		width: 8;		from: 1@0; to: 0@0; edge.	v add: line. 	position := nil.	updateLine := [		line 			from: lineX@position from y;			to: lineX@position to y;			update. ].	v when: TSMouseMove do: [ :ev | 		lineX := ev position x.		updateLine value ].	update := [ 		extent := v extent.		position := TSScale linear			range: { extent / 2 negated. extent /2 }.		updateLine value.		elements do: [ :e | e translateTo: (position scale: r next@ r next) ].	].	update value.	v when: TSExtentChangedEvent do: update.		"shadow"	alpha := TSScale linear domain: #(1 4); range: #(0.4 0.05).	elements do: [ :e | | ant |		ant := e.		1 to: 4 do: [:i | | s |			s := RSElement new 				trachelShape: TSBox new;				noPaint;				position: e position;				extent: e extent;				border: (TSBorder new					width: 6;					color: (e border color alpha: (alpha scale: i)));				yourself.			ant when: TSPositionChangedEvent do: [ :evt | 				s translateTo: evt oldPosition ].			ant := s.			v add: s			] ] .	v animation repeat; 		onStepDo: [ :t | 			elements do: [ :e |				| delta newX |				delta := e attributes at: #delta ifAbsentPut: [ 5 ].				newX := e position x + delta.				(newX 					between: position from x 					and: position to x) ifFalse: [ 					delta := delta negated.					newX := e position x + delta.					 ].				e translateTo: newX@e position y.				e attributes at: #delta put: delta				].			v elements do: [ :e | | cls |				cls := e position x > lineX 					ifTrue: [ TSEllipse ]					ifFalse: [ TSBox ].				e trachelShape: cls new.				 ].	].	v open.	"87 lines of code"! !!RSAnimationExamples methodsFor: 'examples'!example06Atom	<script: 'self new example06Atom'>	| elements v border extent speed frame |	v := RSView new.	border := TSBorder new width: 4.	extent := 450@110.	elements := RSShapeBuilder ellipse		border: border;		extent: #yourself;		color: nil;		onElement;		matrixDo: [ :e | [ :m | m rotateByRadians: e index * Float pi/4 ] ];		if: [ :e | e index = 1 ] 			actions: [ :s | s color: Color black ];		elementsOn: { 40@40. extent. extent. extent. extent}.	v addAll: elements.	elements := RSShapeBuilder ellipse		border: border;		color: Color black;		extent: 20@20;		elementsOn: (1 to: 4).	v addAll: elements.	frame := 0.		v animation repeat onStepDo: [ :t |		frame := frame +1.		speed := frame/50.		elements do: [ :e | | ang |			ang := speed + (e index * 90).			e matrix				loadIdentity;				rotateByRadians: e index * Float pi /4;				translateBy: (extent/2)* (ang cos @ ang sin)			 ]	].			v when: TSExtentChangedEvent do: [ :evt | 		v zoomToFit ].	v open.	! !!RSAnimationExamples methodsFor: 'examples'!example07Psycho	<script: 'self new example07Psycho'>	| shape v theta slices unit color sc1 sc2 |	v := RSView new.	slices := 50.	unit := Float pi * 2 / slices.	"domain: aBoolean, range: aColor"	color := TSScale ordinal rangeFrom: { '480D4A'. 'BB1C60' }.	"input: a number between {-1 1} ouput: a number between 100 and 350"	sc1 := TSScale linear domain: #(-1 1);range: { 100. 350 }.	sc2 := TSScale linear domain: #(-1 1);range: { 350. 100 }.	"for zoom to fit"	v add: (RSShapeBuilder box extent: 800@800; noPaint; element).	theta := 0.		shape := RSEdgeBuilder linePath 		onElement; 		onMyselfDo: [ 			[: e| e attributes at: #zn				put: (e model even 						ifTrue: [ sc1 scale: (e model *unit + theta) sin ]						ifFalse: [ sc2 scale: (e model*unit - theta) sin ]).] ];		svgPath: [ :e |			"e is an instance of RSEdge, been created by shape"			[ :a :b |			"a and b are points, the vertices from this edge"			"this block returns a block to use complex operations of Athens Canvas"			"in this part you can also return a string, the svg path"				[ :canvas | | angle sz |				angle := e model* unit.				sz := e attributes at: #zn. 				canvas  					moveTo: a + (sz * (angle cos@ angle sin));					arcCenterX: a x						centerY: a y 						radius: sz						startAngle: e model* unit						endAngle: (e model+1)*unit 				  ] ] ];		width: [ :e | (e attributes at: #zn) /2 ];		onModel;"change context, now the bock argument recives the model, a number between [1 50]"		color: [ :m | color scale: m even ];		from: [ :m | m even			ifTrue: [-25@ -25 ]			ifFalse: [ 25@25 ] ];		to: 0@0.	v addAll: (shape edgesOn: (1 to: slices)).		v animation repeat onStepDo: [ :t |		v edges do: [ :ed | shape updateElement: ed ].		theta := theta + 0.0523 ].	v when: TSExtentChangedEvent do: [ :evt | 		v zoomToFit ].	v open.	"53 lines of code"! !!RSAnimationExamples methodsFor: 'examples'!example07b	<script: 'self new example07b'>	| update v theta slices unit color sc1 sc2 |	v := RSView new.	slices := 50.	unit := Float pi * 2 / slices.	"domain: aBoolean, range: aColor"	color := TSScale ordinal rangeFrom: { '480D4A'. 'BB1C60' }.	"input: a number between {-1 1} ouput: a number between 100 and 350"	sc1 := TSScale linear domain: #(-1 1);range: { 100. 350 }.	sc2 := TSScale linear domain: #(-1 1);range: { 350. 100 }.	"for zoom to fit"	v add: (RSShapeBuilder box extent: 800@800; noPaint; element).	theta := 0.	update := [ 		v edges copy do: #remove.		1 to: slices do: [ :i | | e sz  |			"e is an instance of RSEdge, not been created by shape"			e := RSEdge new				model: i;				trachelShape: TSSVGPathLine new.			sz := i even				ifTrue: [ sc1 scale: (i *unit + theta) sin ]				ifFalse: [ sc2 scale: (e model*unit - theta) sin ].			e 				width:  sz /2;				color: (color scale: i even);				from: (i even					ifTrue: [-25@ -25 ]					ifFalse: [ 25@25 ]);				to: 0@0.			e svgPath: [ :a :b |				"a and b are points, the vertices from this edge"				"this block returns a block to use complex operations of Athens Canvas"				"in this part you can also return a string, the svg path"				[ :canvas | | angle |					angle := i * unit.					canvas  						moveTo: a + (sz * (angle cos@ angle sin));						arcCenterX: a x							centerY: a y 							radius: sz							startAngle: e model* unit							endAngle: (e model+1)*unit 					 ] ].			v add: e.		].		].		v animation repeat onStepDo: [ :t |		update value.		theta := theta + 0.0523 ].	v when: TSExtentChangedEvent do: [ :evt | 		v zoomToFit ].	v open.	"56 lines of code without RSShapeBuilder"! !!RSAnimationExamples methodsFor: 'examples'!example08ElasticEllipses	<script: 'self new example08ElasticEllipses'>	| v r mouseClick |	v := RSView new.	r := SharedRandom globalGenerator.		mouseClick := [ | c1 c2 color  |		v elements copy do: #remove.		c1 := Color r: r next g: r next b: r next.		c2 := Color r: r next g: r next b: r next.		color := TSScale linear range: { c1. c2 }.		1 to: 10000 do: [ :i | | e shape radius ang overlapped |			e := RSElement new.			shape := TSEllipse new.			e trachelShape: shape.			"old days, without RSShapeBuilder"						e radius: r next * 30 + 2.			radius := r next * 250.			ang := r next * Float pi * 2.			e position: radius * (ang cos @ ang sin).			overlapped := v elements anySatisfy: [ :other |				(other position dist: e position) < 					((e radius + other radius) * 1.4)  ].			overlapped ifFalse: [ 				v add: e.				e attributes at: #radius put: e radius.				e color: (color scale: (e position dist: 0@0)/250 ) ].		].		v animation			easing: TSEasing elasticOut;			onStepDo: [ :t |				v elements do: [ :e | | scale |					scale := TSScale linear range: { 1. e attributes at: #radius }.					e radius: (scale scale: t)					 ].				]	].	mouseClick value.		v 		when: TSExtentChangedEvent do: [ :evt | v zoomToFit ];		when: TSMouseClick do: mouseClick;		open! !!RSAnimationExamples methodsFor: 'examples'!example09LinePatterns	<script: 'self new example09LinePatterns'>	| v step frame border dot bar radius data update |	v := RSView new.	step := 0.	frame := 0.	bar := 200.	radius := 150.	data := (1 to: 360 by: 3) collect: #degreesToRadians.	v add: (RSShapeBuilder box noPaint; size: 640; element).	border := TSBorder new		color: (Color colorFrom: '00004A');		width: 2.	dot := RSShapeBuilder ellipse		size: 5;		border: border.	update := [ 		v elements copy do: #remove.		v addAll: (data collect: [ :radian | | matrix e d1 d2 |			"edges do not handle matrix"			matrix := AthensAffineTransform new.			matrix translateBy: radius * (radian cos @ radian sin);				rotateByRadians: radian + (radian * step * 5) + (frame *0.02).			d1 := dot element.			d2 := dot element.			d1 position: (matrix transform: bar/2@0).			d2 position: (matrix transform: bar/ -2 * radian cos @ 0 ).			d2 size: 6* radian cos.			v add: d1; add: d2.			e := RSEdge new				trachelShape: TSLine new.			e border: border.			e from: d1.			e to: d2.			e ]).	].	v animation repeat onStepDo: [ :t | 		frame := frame + 1.		update value.	].	v 		when: TSExtentChangedEvent do: [ :evt | v zoomToFit ];		when: TSMouseClick do: [ 			step := step +1.			step > 20 ifTrue: [ step := 0 ] ];		open! !!RSAnimationExamples methodsFor: 'examples'!example10CircleParty	<script: 'self new example10CircleParty'>	| v x x2 speed speed2 r shape color |	v := RSView new.	x := 1. x2 := 2.	speed := 5. speed2 := 10.	r := SharedRandom globalGenerator.	color := TSScale ordinal rangeFrom: { 		(Color colorFrom: 'B4FA05') alpha: 0.7. 		'FF7C7C'.		(Color colorFrom: 'EA323E') alpha: 0.5.		'BDEA5C'.		(Color colorFrom: 'CB1D34') alpha: 0.3.		'E0CC14'}.	v color: Color black.	shape := RSShapeBuilder circle		borderDo: [ [:b |			b width: 25;			color: (Color 				r: (r rsNext: 0 and: 40)				g: (r rsNext: 100 and: 200)				b: (r rsNext: 100 and: 255)				range: 255)] ];		color: [ :m | color scale: m ];		position: #key;		size: #value.	v animation repeat onStepDo: [:t | 		v elements copy do: #remove.		color dictionary keysAndValuesRemove: [:a :b| true ].		(x between: 0 and: 1000) ifFalse: [ speed := speed negated ].		x2 >= x ifTrue: [ 			speed2 := speed2 negated.			x2 > 20 ifTrue: [ x2 := x2 - 20 ] ].		x2 <= 0 ifTrue: [ speed2 := speed2 negated ].		x := x + speed.		x2 := x2 + speed2.		v add: (shape elementOn: 0@0 -> x).		v add: (shape elementOn: 0@0 -> x2).		v add: (shape elementOn: -300 asPoint -> x).		v add: (shape elementOn: -300 asPoint -> x2).		v add: (shape elementOn: 300 asPoint -> x).		v add: (shape elementOn: 300 asPoint -> x2).		].	v camera scale: 0.5.	v open! !!RSAnimationExamples methodsFor: 'examples'!example11ArcTree	<script: 'self new example11ArcTree'>	| v shape newArc alpha beta |	v := RSView new.	shape := RSShapeBuilder arc.	shape 		color: Color black;		innerRadius: [:m | m * 0.9];		externalRadius: #yourself.	newArc := nil.	newArc := [ :point :size :iteration | | e |		e := shape elementOn: size index: iteration. 		e position: point.		v add: e.		iteration > 1 ifTrue: [ 			newArc 				value: point + (0 - size@ (size/2 - (size* 0.01) ) ) 				value: size/2				value: iteration - 1.			newArc 				value: point + (size@ (size/2 - (size* 0.01) ) ) 				value: size/2				value: iteration - 1.			 ]		].	newArc value: 0@0 value: 100 value: 5.	alpha := TSScale linear range: #(90 0).	beta := TSScale linear range: #(90 180).	v showEncompassingRectangles.	v animationFrom: ((1 to: 5) reverse collect: [ :i| | elements |		elements := v elements select: [ :e | e index = i ].		v tAnimation 			duration: 1 seconds;			easing: TSEasing bounceOut;			onStepDo: [ :t |			elements do: [ :e |				e 					alphaAngle: (alpha scale: t);					betaAngle: (beta scale: t);					resetPath.				 ]			 ]		 ]).	v when: TSExtentChangedEvent do: [ v zoomToFit; signalUpdate ].	v open	! !!RSAnimationExamples methodsFor: 'examples'!example12PerlinParticles	<script: 'self new example12PerlinParticles'>	| v label particle r frame perlin color |	v := RSView new.	r := SharedRandom globalGenerator.	frame := 0.	perlin := TSPerlinNoise new.		label := TSLabel new		color: Color black;		text: 'Drag to draw. type ''c'' to clear the view'.	v addShape: label.		v animation delay: 2 seconds;		from: Color black; 		to: Color transparent; 		on: label set: #color:;		when: TSAnimationEndEvent do: [ 			v clearBackground: false.			label remove. ].	color := TSGradientPalette fabledSunset asScale.	color domain: color domain reverse.	particle := RSShapeBuilder ellipse		onMyselfDo: [ :m | [ :e | 			| ang vel att lifeSpan decay passedLife weightRange update |			att := e attributes.						ang := r next * Float pi * 2.			vel := r next * 5 * (ang cos @ ang sin).			lifeSpan := r rsNext: 30 and: 90.						decay := r rsNext: 0.75 and: 0.9.			passedLife := 0.			weightRange := r rsNext: 3 and: 50.			att at: #dead put: false.			"in this case use a class"			update := [ | radius rn acc mag pos dir rand alpha |				att at: #dead put: (passedLife >= lifeSpan).				passedLife := passedLife + 1.				acc := (lifeSpan - passedLife)/lifeSpan.				alpha := acc max: 0.4.				e border color: (Color black alpha: alpha).				e color: (color scale: acc asFloat).				radius := acc * weightRange.				pos := e position.				rn := 4*Float pi*((perlin 					noise: 0.02					and:0.02) - 0.5).				mag := (perlin noise: (pos y + frame) * 0.01 and: (pos x + frame)* 0.01) abs.				dir := rn cos @ rn sin.				ang :=  r next * Float pi * 2.				rand := (ang cos @ ang sin) * 0.5.				acc := (dir * mag) + rand.				vel := (vel + acc)* decay.				vel := vel normalized * 3.					e size: radius.				e translateBy: vel.				 ].			att at: #update put: update.  			 ] ];		border: TSBorder new;		position: #key.	v animation repeat; onStepDo: [ :t| 		frame := frame + 30.		v elements copy do: [ :e| 			(e attributes at: #update) value.			(e attributes at: #dead) ifTrue: [ e remove ] ].		v signalUpdate ].		v when: TSMouseDragging do: [ :evt | 		1 to: 10 do: [ :i | | p |			p := (particle elementOn: evt position-> (i+v elements size) ).			v add: p ].		v signalUpdate ];		when: TSKeyUp do: [:evt | 			evt keyValue = 8 ifTrue: [ 				v clearBackground: true.				v elements do: #remove.				v signalUpdate.				v animation duration: 200 milliSeconds;				when: TSAnimationEndEvent do: [ v clearBackground: false ] ] ].	v open setLabel: 'Particles!!!!!! :V'	! !!RSAnimationExamples methodsFor: 'examples'!example12b	<script: 'self new example12b'>	| v label particle r frame perlin changeHue hIndex hExtent h |	v := RSView new.	v color: Color black.	r := SharedRandom globalGenerator.	frame := 0.	perlin := TSPerlinNoise new.		label := TSLabel new		color: Color white;		text: 'Drag to draw. type ''c'' to clear the view.'.	v addShape: label.		v animation delay: 2 seconds;		from: Color black; 		to: Color transparent; 		on: label set: #color:;		when: TSAnimationEndEvent do: [ 			v clearBackground: false.			label remove. ].			hIndex := 4.	changeHue := [		hIndex := hIndex + 1.		hIndex > 4 ifTrue: [ hIndex := 0 ].		hExtent := TSScale linear			domain: #(0 1 2 3 4);			range: { 220@100. 55@0. 100@20. 180@110. 255@150 };			scale: hIndex.		hExtent := hExtent * 360 / 255.		h := hExtent y ].	changeHue value.	particle := RSShapeBuilder ellipse		onMyselfDo: [ :m | [ :e | 			| ang vel att lifeSpan decay passedLife update sizeMult |			att := e attributes.						ang := r next * Float pi * 2.			vel := r next * 5 * (ang cos @ ang sin).			lifeSpan := r rsNext: 30 and: 90.						decay := r rsNext: 0.75 and: 0.9.			passedLife := 0.			h := h + 0.5.			h > hExtent x ifTrue: [ h := hExtent y + h - hExtent x ].			e color: ((Color h: h s: 1 v: 1) alpha: 0.2).			sizeMult := ((frame * 0.02) sin max: 0.05) min: 0.5.			att at: #dead put: false.			"in this case use a class"			update := [ | radius rn acc mag pos dir rand |				att at: #dead put: (passedLife >= lifeSpan).				passedLife := passedLife + 1.				acc := lifeSpan - passedLife.								radius := acc * sizeMult.				pos := e position.				rn := 4*Float pi*((perlin 					noise: 0.02					and:0.02) - 0.5).				mag := (perlin noise: (pos y + frame) * 0.01 and: (pos x + frame)* 0.01) abs.				dir := rn cos @ rn sin.				ang :=  r next * Float pi * 2.				rand := (ang cos @ ang sin) * 0.5.				acc := (dir * mag) + rand.				vel := (vel + acc)* decay.				vel := vel normalized * 3.					e size: radius.				e translateBy: vel.				 ].			att at: #update put: update.  			 ] ];		position: #key.	v animation repeat; onStepDo: [ :t| 		frame := frame + 30.		v elements copy do: [ :e| 			(e attributes at: #update) value.			(e attributes at: #dead) ifTrue: [ e remove ] ].		v signalUpdate ].		v when: TSMouseDragging do: [ :evt | 		1 to: 10 do: [ :i | | p |			p := (particle elementOn: evt position-> (i+v elements size) ).			v add: p ].		v signalUpdate ];		when: TSKeyUp do: [:evt | 			evt keyValue = 8 ifTrue: [ 				v clearBackground: true.				v elements do: #remove.				v signalUpdate.				v animation duration: 200 milliSeconds;				when: TSAnimationEndEvent do: [ v clearBackground: false ] ]			ifFalse: changeHue ].	v open setLabel: 'Particles!!!!!! :V'	! !!RSAnimationExamples methodsFor: 'examples'!example13Arcs	<script: 'self new example13Arcs'>	| view beta shape theta step size |	theta := 0.	step := 12.	size := 21.	view := RSView new.	view color: Color black.	beta := TSScale linear		domain: #(-1 1);		range: #(180 360).	shape := RSShapeBuilder arc		color: [:m | Color h: theta * 2 + (m * 10) s: 1 l: 0.5];		innerRadius: [ :m | m * step ];		externalRadius: [ :m | m * step + 5 ];		alphaAngle: 180;		betaAngle: [ :m | | offset |			offset := Float pi * 2 / size * m.			beta scale: (theta + offset) sin ].			view addAll: (shape elementsOn: (1 to: size)).	view animation repeat onStepDo: [ :t |		theta := theta + 0.0523.		view elements do: [ :e |			shape 				updateElement: e withCommand: #betaAngle:;				updateElement: e withCommand: #color:			 ] ].	view when: TSExtentChangedEvent do: [ | s sc e |		s := (size * step + 5) * 2.		e := view extent.		sc := e x / s.		view camera			scale: sc.		view animation 			from: 0@0; 			to: 0@ (e y/sc "+ (s/2)"  )/2;			on: view camera set: #translateTo:.  ].	view open setLabel: 'Arc animation'.	! !!RSAnimationExamples methodsFor: 'lines'!example13DashAnimation	<script: 'self new example13DashAnimation'>	| c box paint form border animation |	c := TSCanvas new.	form := self iconNamed: #eyedropper.	paint := (AthensCairoPatternSurfacePaint 		createForSurface: (AthensCairoSurface 			fromForm: form)).	paint origin: (form extent / 2) negated.	border := TSBorder new		color: Color purple;		dashArray: #(4).	box := TSBox new		paint: paint;		extent: form extent;		border: border;		scaleBy: 3.		c addShape: box.		animation := c animation		repeat;		from: 0;		to: 8;		on: border set: #dashOffset:.	box when: TSMouseClick do: [ :a |		animation isPaused 			ifTrue: [ animation continue ]			ifFalse: [ animation pause ] ].	c open.	! !!RSAnimationExamples methodsFor: 'examples'!example14C	<script: 'self new example14C'>	| view shape step theta |	view := RSView new.	view color: Color black.	step := 15.	theta := 0.	shape := RSShapeBuilder arc		innerRadius: [ :m | m * step + 7];		externalRadius: [ :m | m * step + 10 ].	view addAll: (shape elementsOn: (1 to: 16) ).	view animation repeat onStepDo: [ :t |		theta := theta + 0.2.		view elements do: [ :e |			e 				alphaAngle: 30 + (theta * e model);				betaAngle: 300 + (theta * e model);				color: (Color h: theta * e model s: 1 l: 0.5) ] ].	view when: TSExtentChangedEvent do: [ view zoomToFit ].	view open setLabel: 'C!!!!!!'! !!RSAnimationExamples methodsFor: 'examples'!example15Sky	<script: 'self new example15Sky'>	| view client image ext shape dots r frame box colors |	view := RSView new.	r := SharedRandom globalGenerator.	ext := 2200 @ 2200.	box := TSBox new		extent: ext;		position: 0 @ ext y / 2 negated;		paint:			(LinearGradientPaint new				colorRamp:					{(0 -> Color black).					(1 -> Color blue muchDarker)};				start: ext / 2 negated;				stop: ext / 2).	view addShape: box.	colors := TSScale linear		domain: #(5 15);		range: {'6A6569' . 'white'}.	shape := RSShapeBuilder ellipse		attributesDo: [ [ :a | 			a				at: #a put: (r rsNext: 0 and: 350);				at: #r put: (r rsNext: 3500 and: 6000) ] ];		size: [ r rsNext: 5 and: 15 ];		onElement;		color: [ :e | (colors scale: e width) alpha: (r rsNext: 0.1 and: 0.8) ].	dots := shape elementsOn: (1 to: 800).	view addAll: dots.	frame := 0.	view clearBackground: false.	(view animation duration: 5 seconds;onStepDo: [ :t| ])		when: TSAnimationEndEvent do: [ box remove ].	view animation repeat		onStepDo: [ :t | 			frame := frame + 0.1.			dots				do: [ :e | 					| ang radius |					ang := ((e attributes at: #a) + frame) degreesToRadians.					radius := e attributes at: #r.					e position: ang cos @ ang sin negated * radius + (2500 @ 3000) ] ].	(client := ZnEasy client)		url:			'http://www.transparentpng.com/download/mountain/68IzPF-mountain-clipart-png-photos.png';		accept: ZnMimeType imagePng;		signalProgress: true;		get.	image := ImageReadWriter formFromStream: client entity readStream.	view addShape: (TSBitmap new form: image).	view		when: TSExtentChangedEvent		do: [ | e s |			e := view extent.			s := e x / 2200.			"2200 x 800 = image extent"			view camera				scale: s;				translateTo: 0 @ (e y / s - 800) / 2 negated ].	view open setLabel: 'Star trails'! !!RSAnimationExamples methodsFor: 'examples'!example16ArcNoise	<script: 'self new example16ArcNoise'>	| frame view perlin radius shape line points yscale |	frame := 0.	view := RSView new.	view color: Color black.	perlin := TSPerlinNoise new.	radius := TSScale linear domain: #(1 20); range: #(50 250).	shape := RSShapeBuilder arc 		color: Color white;		externalRadius: [ :m | radius scale: m ];		alphaAngle: 0;		onElement;		betaAngle: [ :e | | t |			t := (frame * 0.025) + (e externalRadius * 0.0005).			360 * (perlin noise: t and: 0.01) abs ];		innerRadius: [ :e | e externalRadius - 5 ].	view addAll: (shape elementsOn: (1 to: 20) ).	view addShape: (TSBox new 		color: (Color white alpha: 0.4);		cornerRadius: 7;		extent: 140@80;		position: 70@40;		isFixed: true ).			points := OrderedCollection new.	yscale := TSScale linear domain: #(0 360); range: #(80 5).		line := TSPolyline new		border: (TSBorder new  width: 2; paint: (LinearGradientPaint new			colorRamp:				{(0 -> Color red).				(0.5 -> Color yellow).				(1 -> Color green)};			start: 0@0;			stop: 0@80));		isFixed: true.	view addShape: line.			view animation repeat; onStepDo: [ :t| | last | 		frame := frame + 0.2.		view elements do: [ :e | 			shape updateElement: e withCommand: #betaAngle:.			e color: (Color h: e betaAngle s: 0.5 v: 1).						 ].		last := view elements last.		points add: (yscale scale: last betaAngle).		points size > 140 ifTrue: [ points removeFirst ].		line controlPoints: (points collectWithIndex: [:y :x | x@ y]).		 ].		view when: TSExtentChangedEvent do: [ view zoomToFit ].	view open setLabel: 'Arcs with Perlin noise'! !!RSAnimationExamples methodsFor: 'examples'!example17Retina	<script: 'self new example17Retina'>	| r view perlin side angle circleSize ringSize label minR updateValues offset rad val radius shape |	view := RSView new.	view color: Color black.	minR := 0.08.	side := 900.	perlin := TSPerlinNoise new.	circleSize := ringSize := 100.	r := SharedRandom globalGenerator.	angle := TSScale linear domain: { 1. circleSize }; range: {0. 360}.	label := TSLabel new 		fontName: 'Source Sans Pro'; 		text: 'Now begin!!'; 		color: Color white;		fontSize: 40.	view addShape: label.	(view animation 		delay: 2 seconds; 		from: 40; 		to: 12; 		on: label set:#fontSize: ).	(view animation 		delay: 2 seconds;		from: Color white; to: Color transparent;		on: label set: #color:) when: TSAnimationEndEvent do: [			label remove.			view clearBackground: false].	updateValues := [ 		offset := r rsNext: 90.		rad := r rsNext: minR*side and: 1/ 2 sqrt*side.		val := rad / side * 100.		radius := ((rad / (side /2))-minR)*((perlin noise: val and: 0) abs) * side / 6.	].	updateValues value.	shape := RSShapeBuilder circle		size: [ radius ];		noPaint;		borderDo: [ :m | [ :b | | theta |			theta := angle scale: m.			b color: (Color h: theta + offset s: 1 v: 1 alpha: 0.7) ] ];		position: [:m | | theta |			theta := (angle scale: m) degreesToRadians.			((theta cos @ theta sin) * rad).			].	view addAll: (shape elementsOn: (1 to: circleSize)).	view animation 		delay: 4 seconds;		loops: ringSize; 		duration: 200 milliSeconds; 	 	when: TSAnimationLoopEvent do: [ :evt | 			updateValues value.			view elements do: [ :e | shape updateElement: e ]		].			view when: TSExtentChangedEvent do: [ 		view camera zoomToFit: view extent extent: side@side ].	view open setLabel: 'Retina (~˘.˘)~'.! !!RSAnimationExamples methodsFor: 'examples'!example18SpaceDandy	<script: 'self new example18SpaceDandy'>	| random extent diagonal rotation init drawDist view shape elements |	random := SharedRandom globalGenerator.	extent := 800@600.	diagonal := ((extent x * extent x)+ (extent y* extent y)) sqrt / 2.	rotation := 0.	init := [ :e | | n |		e attributes 			at: #l put: 1;			at: #n put: (n := random rsNext: 1 and: extent x/2);			at: #r put: (random rsNext: Float pi * 2);			at: #off put: (random rsNext: 90);			at: #o put: (random rsNext: 1 and: (random rsNext: 1 and: extent x / n ))  ].	drawDist := [ :att | | n o |		n := att at: #n.		o := att at: #o.		(n / o) arcTan * extent x / (Float pi / 2)].	view := RSView new.	view color: Color black.	shape := RSShapeBuilder ellipse		color: Color white.		elements := shape elementsOn: (1 to: 500).	elements do: [ :e | init value: e ].	view addAll: elements.		view addShape: (TSLabel new 		paint: (LinearGradientPaint new			colorRamp:				{(0 -> Color yellow).				(0.35 -> Color orange).				(0.25 -> Color white darker).				(0.35 -> Color orange).				(1 -> Color white)};			start: 0@ -150;			stop: 0@130);		fontSize: 150;		"fontName: 'Source Sans Pro';"		fontName: 'Brushcrazy DEMO';		border: (TSBorder new color: Color black);		bold;		text: 'Pharo').	view animation 		repeat;		duration: 5 seconds; 		when: TSAnimationLoopEvent do: [ :e| view clearBackground: e animation currentLoop odd  ].	view animation repeat onStepDo: [ :t|		rotation := rotation - 0.002.		elements do: [ :e | | l o r d off | 			l := (e attributes at: #l)+1.			e attributes at: #l put: l.			r := (e attributes at: #r) + rotation.			o := e attributes at: #o.			off := e attributes at: #off.			d := drawDist value: e attributes.						"e color: (Color white alpha: d/ diagonal)."			e color: ((Color h: (e attributes at: #r) radiansToDegrees+off s: 1 v: 0.5) 				alpha: d / diagonal).			e size: extent x/o/8.			e position: (r cos @ r sin) * d.			e attributes at: #o put: o - 0.07.			(drawDist value: e attributes) > diagonal ifTrue: [ init value: e ].			].		 ].	view when: TSExtentChangedEvent do: [ 		view camera			zoomToFit: view extent 			extent: extent ].	view open setLabel: 'Space :D'.! !!RSAnimationExamples methodsFor: 'examples'!example19Gris	<script: 'self new example19Gris'>	| v label shape border r mini animation |	v := RSView new.	r := SharedRandom globalGenerator.	border := TSBorder new.	label := TSLabel new		fontName: 'Marker Felt';		text: 'Roassal';		noPaint;		border: border;		fontSize: 30.	v addShape: label.	shape := RSShapeBuilder circle		noPaint;		radius: [ :m | m * label width ];		border: border;		onElement;		if: [ :e | e index = 5 ] actions: [ :s| s border: (TSBorder new width: 1.5) ];		if: [ :e | e index = 4 ] actions: [ :s | s border: (TSBorder new dashArray: #(4)) ].			v addAll: (shape elementsOn: { 0.6. 0.64. 1.05. 1.20. 1.7 }).		v animation repeat from: 0; to: 8; duration: 200 milliSeconds;		on: v elements fourth border set: #dashOffset:.			mini := RSShapeBuilder circle		noPaint;		border: (TSBorder new width: 0.5);		radius: [ :m | m * 5 ];		if: [ :m | m = 1 ] actions: [ :s | s paint: Color black ];		if: [ :m | m = 2 ] actions: [ :s | s radius: [ :m | m * 6 ] ].			animation := [ :e :seconds :target :dir | |  ang |		ang := r next * Float pi * 2.		v animation repeat duration: seconds asSeconds;				from: ang; to: ang + (Float pi * 2* dir);				onStepDo: [ :t | e translateTo: (t cos@ t sin)* target radius ] ].				shape := RSShapeBuilder composite 		shapes: [:m | mini elementsOn: (1 to: m value) ];		onMyselfDo: [:m | [ :e | 			animation value: e value: m key * 6 value: (v elements at: m key) value: 1			 ] ].	v addAll: (shape elementsOn: {3-> 3. 4->2}).		shape := RSShapeBuilder composite 		shapes: [:m | | g |			g := mini elementsOn: (1 to: 4).			g first radius: 10.			g second radius: 15.			g third radius: 18.			g fourth radius: 25.			g add: ((mini elementOn: 1) radius: 3).			g ];		onMyselfDo: [:m | [ :e |			animation value: e value: 30 value: v elements fifth value: -1.			animation value: e shapes fifth value: 10 value: e shapes fourth value: 1.			] ].	v add: shape element.	v when: TSExtentChangedEvent do: [ v zoomToFit ].	v open setLabel: 'Roassal :V'.	! !!RSAnimationExamples methodsFor: 'examples'!example20Flor	<script: 'self new example20Flor'>	| v shape frame angleSp alphaS hueS dia1 dia2 |	v := RSView new.	frame := 0.	angleSp := 0.	hueS := TSScale linear domain: #(50 200); range: #(250 360).	alphaS := TSScale linear domain: #(50 200); range: #(0.3 1).	dia1 := TSScale linear domain: #(50 180); range: #(90 1).	dia2 := TSScale linear domain: #(-1 1); range: #(5 20).	shape := RSShapeBuilder circle		attributesDo: [ :m | [ :att |			att at: #angle 				put: (m key + (angleSp sin * m value)) degreesToRadians ] ];		color: [ :m |			Color 				h: (hueS scale: m value)				s: 0.8 				v: 1 				alpha: (alphaS scale: m value) ];		onElement;		position: [ :e | | angle | 			angle := e attributes at: #angle.			e model value * (angle cos @ angle sin). ];		extent: [:e | | dist diameter |			dist := e position dist: 0@0.			diameter := dia2 scale: (dia1 scale: dist) sin.			diameter asPoint.			].	(0 to: 350 by: 60) do: [ :i | 		v addAll: (shape elementsOn: ((50 to: 170 by: 10) 			collect: [:radius| i-> radius ]) ).		 ].	shape removeCommandsBySelectors: {#size:. #extent:. #color:}.	v animation repeat onStepDo: [ :t | 		frame := frame + 1.		angleSp := frame / 250.0 * (Float pi * 2).		shape updateElements: v elements.		].	v when: TSExtentChangedEvent do: [ 		v camera zoomToFit: v extent extent: 500 asPoint ].	v open setLabel: 'Animation test'.	! !!RSAnimationExamples methodsFor: 'examples'!example21Rainbow	<script: 'self new example21Rainbow'>	| v r shape mode color frame |	v := RSView new.	v clearBackground: false.	v color: Color black.	r := SharedRandom globalGenerator.	shape := RSShapeBuilder circle		onElement;		attributesDo: [ [ :att | 			| xs ys |			xs := r rsNext: -3 and: 3.			ys := (xs between: -1 and: 1)				ifTrue: [ r next > 0.5					ifTrue: [ r rsNext: 1 and: 3 ]					ifFalse: [ r rsNext: -3 and: -1 ] ]				ifFalse: [ r rsNext: 3 and: -3 ].			att				at: #s put: 0;				at: #t put: 0;				at: #degX put: r next;				at: #degY put: r next;				at: #xs put: xs;				at: #ys put: ys;				at: #hue put: r next * 360;				at: #hue2 put: 4 ] ];		border: [ TSBorder new width: 0.5 ].	mode := 1.	frame := 0.	color := TSScale ordinal		domain: #(0 1 2);		range:			{[ Color black ].			[ :e | Color h: (e attributes at: #hue) s: 0.7 v: 1 ].			[ :e | 			frame even				ifTrue: [ Color black ]				ifFalse: [ Color h: (e attributes at: #hue) s: 1 v: 1 ] ]}.	v animation repeat		onStepDo: [ :k | 			| elements |			v add: shape element.			frame := frame + 1.			elements := v elements copy.			elements do: [ :e | | att t s degX degY xs ys hue hue2|				"From Milton: please Milton use a class for this work next time"				att := e attributes.				t := att at: #t.				s := att at: #s.				degX := att at: #degX.				degY := att at: #degY.				xs := att at: #xs.				ys := att at: #ys.				hue := att at: #hue.				hue2 := att at: #hue2.								e color: ((color scale: mode) rsValue: e).				e border color: (Color h: 360 - (att at: #hue) s: 1 v: 1).				e size: s.								t := t + 0.02.				s := s + 0.2.				e translateBy: ((xs @ ys )+(degX cos@ degY cos)) * t.				degX := degX +  (r rsNext: 0.1 and: 0.8).				degY := degY + (r rsNext: 0.1 and: 0.8).				hue := hue + hue2.				(hue > 360 or: [hue < 0])					ifTrue: [ hue2 := hue2 negated ].				att					at: #t put: t;					at: #s put: s;					at: #degX put: degX;					at: #degY put: degY;					at: #hue put: hue;					at: #hue2 put: hue2.				((Rectangle center: 0@0 extent: v extent + 200) 					containsPoint: e position)					ifFalse: [ e remove ]  ] ].	v		when: TSExtentChangedEvent		do: [ v camera zoomToFit: v extent extent: v extent ];		when: TSMouseClick do: [ 			mode := mode +1.			mode > 2 ifTrue: [mode := 0] ].	v open setLabel: 'Worms'! !!RSAnimationExamples methodsFor: 'examples'!example22Stars	<script: 'self new example22Stars'>	| v color shape r stars |	v := RSView new.	r := SharedRandom globalGenerator.	color := TSScale linear domain: #(0 10); range: #('black' 'blue').	shape := RSShapeBuilder box		size: 39;		color: [ :m | color scale: m-1 // 10 ].	v addAll: (shape elementsOn: (1 to: 100)).	RSGridLayout new lineItemsCount: 10; gapSize: 1; on: v elements. 	shape := RSShapeBuilder star 		size: [ r rsNext: 10 and: 100 ];		position: [ (r rsNext: 50 and: 300)@ (r rsNext: 50 and: 300) ];		color: Color white.	stars := shape elementsOn: (1 to: 5).	v addAll: stars.	v animation repeat to: 360; onStepDo: [ :t |		stars do: [ :star | | position |			position := star position.			star matrix loadIdentity.			star translateTo: position.			star rotateByDegrees: t ] ].	v when: TSExtentChangedEvent do: [ v zoomToFit ].	v open setLabel: 'Stars'.! !!RSAnimationExamples methodsFor: 'examples'!example23CircleWaves	<script: 'self new example23CircleWaves'>	| v shape elements frame |	v := RSView new.	frame := 0.		shape := RSShapeBuilder polygon		color: nil;		border: [:m | TSBorder new 			color: ((Color colorFrom: m) alpha: 0.5);			width: 10 ];		onElement;		privatePoints: [ :e | | points |			points := TSPolygon				generateUnitNgonPoints: 150				rotation: 0 				angle: [ :a :i | a ]				radius: [ :a :i | | t |					t := frame.					200 + (((a * 8) - ((e index * 2 * Float pi) / 3) + t ) cos * 				(((1 + (a - t) cos) / 2) raisedTo: 3) * 32 ) ].			e resetPath.			points			 ].			elements := shape elementsOn: #('15c108' '8d0402' '0002ab').	v addAll: elements.		v animation repeat onStepDo: [ :t | 		frame := frame + 0.02.		elements do: [ :e | 			shape				updateElement: e				withCommand: #privatePoints: ] ].	"at this point: elements encompassingRectangle = zero"	v when: TSExtentChangedEvent do: [ v camera zoomToFit: v extent extent: 500@500 ].	v open setLabel: 'Waves'.! !!RSAnimationExamples methodsFor: 'examples'!example24Lines	<script: 'self new example24Lines'>	| v frame radius hueOffset shape line angleSp elements soffset size mult  |	v := RSView new.	v color: Color black.	frame := 0.	radius := 200.	hueOffset := 0.	angleSp := 0.	"<globals>"	soffset := nil. size := nil. mult := 0.	"</globals>"	line := RSSingleEdgeBuilder line		width: 1.5;		color: [ :m | Color h: m + hueOffset s: 0.6 v: 1 ].	shape := RSShapeBuilder composite 		onMyselfDo: [ :i | [:e | | ed pos offset ang a soff|			ang := i degreesToRadians.			a := Float halfPi + ang.			soff := soffset.			offset := a * size.			pos := 0.			ed := line from: 0@0; to: 0@pos; edgeOn: i+soff.						e attributes at:#update put: [				pos := (angleSp negated + offset) cos * 30.				line updateElement: ed withCommand: #color:.				ed to: 0@pos.				ed update.				 ].			e add: ed trachelShape.			e translateTo: ang cos @ ang sin * radius * mult.			e matrix rotateByRadians: a. ] ].		soffset := 0. size := 12. mult := 1.	elements := shape elementsOn: (0 to: 359 by: 12).	v addAll: elements.		soffset := 180. size := 8. mult := 0.5.	elements := shape elementsOn: (0 to: 359 by: 5).	v addAll: elements.		"soffset := 120. size := 4. mult := 0.5@0.75.	elements := shape elementsOn: (0 to: 359 by: 5).	v addAll: elements."		"soffset := 240. size := 4. mult := 0.75@0.5.	elements := shape elementsOn: (0 to: 359 by: 5).	v addAll: elements."	elements := v elements.	v addShape: (TSLabel new 		text: 'Roassal';		fontSize: 30;		border: (TSBorder new color: Color white);		color: nil).	v animation repeat onStepDo: [ :t |		frame := frame + 1. 		angleSp := frame / 300 * Float twoPi.		hueOffset := hueOffset + 1.		elements do: [ :e | (e attributes at: #update) value ].		 ].	v when: TSExtentChangedEvent do: [ v camera zoomToFit: v extent extent: 500 asPoint ].	v open setLabel: '.=.= Lines =.=.'.! !!RSAnimationExamples methodsFor: 'examples'!example25Lines	<script: 'self new example25Lines'>	| v radius bar step line shape frame label |	v := RSView new.	v color: (Color colorFrom: 'EEEEEE').	radius := 200.	bar := 180.	step := 1.	frame := 0.	line := RSSingleEdgeBuilder line		color: Color lightGray;		from: bar negated /2 @0;		to: bar / 2 @ 0.	shape := RSShapeBuilder composite add: [line edge trachelShape ].	v addAll: (shape elementsOn: (0 to: 360 by: 0.5) ).	v animation repeat onStepDo: [ :t | 		frame := frame + 4.		v elements do: [ :e | | radian |			radian := e model degreesToRadians.			e matrix 				loadIdentity;				translation: radius * (radian cos@radian sin);				rotateByRadians: radian + (frame * (radian * step * 0.5) sin * 0.05) ]		].	label := TSLabel new 		text: 'Pharo';		fontName: 'Brushcrazy DEMO';		fontSize: 50;		noPaint;		bold;		border: (TSBorder new paint: Color black; dashArray: #(4)).	v addShape: label.	v animation repeat from: 0; to: 8; on: label border set: #dashOffset:.		v when: TSMouseClick do: [		step := step + 0.5.		step > 11 ifTrue: [ step := 1 ] ].	v when: TSExtentChangedEvent do: [ v camera zoomToFit: v extent extent: 640@640 ].	v open setLabel: 'Line patterns'.	! !!RSAnimationExamples methodsFor: 'examples'!example26PerlinNoise	<script: 'self new example26PerlinNoise'>	"inpired by wangyasai Twitter: @yasai_wang"	| v r s c1 c2 c3 size perlin noiseScale rec |	v := RSView new.	rec := Rectangle rsCenter: 0@0 extent: World extent.	r := SharedRandom globalGenerator.	size := 200.	noiseScale := 300.	v clearBackground: false.	perlin := TSPerlinNoise2 new.	v color: (Color colorFrom: '150832').	c1 := '45217C'. c2 := '0799F2'. c3 := 'white'.		s := RSShapeBuilder composite onMyselfDo: [ :m | [ :e| | a b c newcircle |		newcircle := [ :col | TSEllipse new			position: (r next* rec width)@(r next * rec height) + rec origin;			size: 0.1 + (e index /size);			color: ((Color colorFrom: col) alpha: e index*(250 / 255)/ size);			yourself ].		a := newcircle value: c1.		b := newcircle value: c2.		c := newcircle value: c3.		e add: a; add: b; add: c.		] ].	v addAll: (s elementsOn: (1 to: size)).	v animation repeat onStepDo: [ :t | | speed |		speed := 0.4.		v elements do: [ :c |			c shapes do: [ :e |				| angle p dir vel pval |				p := e position.				pval := perlin 					noise: p x / noiseScale					and: p y / noiseScale.				pval := (pval + 1) / 2.				angle := Float twoPi * noiseScale * pval.				dir := angle cos @ angle sin.				vel := dir * speed.				p := p + vel.				(rec containsPoint: p) ifFalse: [ 					p := (r next * rec width )@(r next * rec height) + rec origin ].				e translateTo: p.				].			].		].	v open setLabel: 'Perlin Noise'.	! !!RSAnimationExamples methodsFor: 'examples'!example27RoassalPerlinNoise	<script: 'self new example27RoassalPerlinNoise'>	| v density rect maxLife size shape perlin r color noiseScale sc1 sc2 |	v := RSView new.	v color: Color black.	v clearBackground: false.	r := SharedRandom globalGenerator.	perlin := TSPerlinNoise2 new.	density := 800. maxLife := 10. noiseScale := 800.	rect := Rectangle rsCenter: 0@0 extent: World extent.	size := rect width * rect height / density.	color := TSScale ordinal rangeFrom: { '6E39CC'. '0799F2'. 'white'}.	sc1 := TSScale linear domain: {1. size}; range: #(5 1).	sc2 := TSScale linear domain: {1. size}; range: #(1 2).	shape := RSShapeBuilder ellipse		onMyselfDo: [ :m | [ :e | 			e size: (sc2 scale: e index).			e attributes				at: #flip put: (r next* 2) asInteger * 2 - 1;				at: #life put: r next * maxLife;				at: #color put: (color scale: (r next * 3) asInteger) ] ];		position: [ (r next * rect width)@ (r next * rect height )+ rect origin ].	v addAll: (shape elementsOn: (1 to: size)).		v animation repeat onStepDo: [ :t |		v elements do: [ :e | 			| life att p flip iterations respawn case fadeRatio colorCase c |			att := e attributes.			flip := att at: #flip.			life := att at: #life.			c := att at: #color.			life := life - 0.06667.			respawn := [				shape updateElement: e withCommand: #position:.				life := maxLife. ].			life < 0 ifTrue: respawn.			att at: #life put: life.			p := e position-rect origin.			iterations := sc1 scale: e index.			1 to: iterations do: [ :i| | angle dir |				angle := Float twoPi * noiseScale * flip * (perlin 					snoise: p x / noiseScale  					and: p y / noiseScale).				dir := angle cos @ angle sin * 1.2.				p := p + dir.				].			case := p / rect extent.			case := ((case x + case y)/2 *3 )asInteger.			p := p + rect origin.			e position: p.			(rect containsPoint: p) ifFalse: respawn.			fadeRatio := (life * 5) min: 1.			fadeRatio := fadeRatio min: (maxLife - life)*5 / maxLife .			colorCase := TSScale ordinal domain: #(0 1 2); range: { 				[ Color gray: life / maxLife ].				[ c ].				[ (Color 					r: (c blue * 255) + 10					g: (c green * 255)- 20					b: (c red * 255) - 5 range: 255) ]			}.			c := (colorCase scale: case) value.			e color: (c setAlpha: fadeRatio).			 ]. ].	v when: TSExtentChangedEvent do: [ v camera zoomToFit: v extent rectangle: rect ].	v open extent: 800@500; setLabel: 'Roassal'.	"morph := v canvas morph.	morph extent: 800@500.	v2 := RSView new.	v2 color: Color black.		v2 addShape: (TSLabel new		text: 'Roassal3';		fontName: 'Impact';		fontSize: 150;		border: (TSBorder new color: Color white trans)).		v2 animation repeat onStepDo: [ :t| | paint |		morph drawOnMockCanvas.		paint := AthensCairoPatternSurfacePaint createForSurface: morph surface.		paint origin: ( -100@ -300) .		v2 shapes first paint: paint.		v2 signalUpdate ].	v2 when: TSExtentChangedEvent do: [ v zoomToFit ].	v2 open extent: 800@500; setLabel: 'Roassal'.	"! !!RSAnimationExamples methodsFor: 'examples'!example28AnimationCircle	<script: 'self new example28AnimationCircle'>	| v radius line shape elements update points lines sc1 sc2 |	v := RSView new.	radius := 50.	lines := 1.	v addShape: (TSEllipse new		color: Color black;		radius: radius).	shape := RSShapeBuilder circle		color: Color white;		onElement;		if: [ :e | e index = 1 ] actions: [ :s | s color: Color red ];		if: [ :e | e index = 2 ] actions: [ :s | s color: Color green ].	line := RSSingleEdgeBuilder line		width: 0.1;		color: Color white.	elements := shape elementsOn: (1 to: 10).		points := [ :r :i |		| a b slice |		slice := Float twoPi / (lines * 2).		a := (i-1) * slice + Float halfPi.		b := a + Float pi.		a := (a cos @ a sin ) * r.		b := (b cos @ b sin) * r.		a -> b ].	update := [ 		lines := lines + 1.		lines > 10 ifTrue: [ lines := 2 ].		v elements copy do: #remove.		v edges copy do: #remove.		elements do: [ :e | e model: (e index - 1) / (lines*2) ].		1 to: lines do: [ :i| | ab |			ab := points value: radius value: i.			v add: (line from: ab key; to: ab value; edge).			v add: (elements at: i).		].	].	update value.	sc1 := TSScale linear range: {0. Float twoPi}.	sc2 := TSScale linear domain: #(-1 1).	elements do: [ :e | | animation |		animation := v animation repeat 			"easing: TSEasing bounceOut;"			duration: 3 seconds; onStepDo: [ :t | 			| val |			val := (e model + t)%1.			val := (sc1 scale: val) cos.			v edges size >= e index ifTrue: [ | ab |				ab := points value: radius - 2.5 value: e index.				e position: (sc2 range: { ab key. ab value. };					scale: val).			] ].		e index = 1 ifTrue:[ animation when: TSAnimationLoopEvent do: update ] ].		v @ RSControlsView.	v open setLabel: 'Animation Test'.	! !!RSAnimationExamples methodsFor: 'examples'!example29Bezier	<script: 'self new example29Bezier'>	| v size theta s bezier sc |	v := RSView new.	size := 50.	theta := 0.	v color: Color black.	sc := TSScale linear domain: #(-1 1); range: #(0 80).	bezier := RSSingleEdgeBuilder bezier		color: Color white;		width: 2;		controlPoints: [ :m | 			| x1 |			x1 := sc scale: (theta + (m * 5)) sin.			Array				with: x1 @ 0				with: 100 @ -100				with: 100 @ 50				with: 200 @ -120 ];		onElement;		paint: [ :e| (Color h: 360 / size * e index s: 1 v: 1 alpha: 0.4) ];		markerEnd: [ :e | 			(RSShapeBuilder triangle				extent: 10@20;				color: e paint;				border: (TSBorder new color: Color white);				element) trachelShape asMarker offset: -10 ] .	s := RSShapeBuilder composite onMyselfDo: [ :m | [ :e | 		| offset b |		offset := Float twoPi / size * e index.		e matrix rotateByRadians: offset.		b := bezier edgeOn: offset index: e index.		"b paint:  Variable or expression expected ->."		e add: b trachelShape.		e attributes			at: #update			put: [ bezier updateElement: b withCommand: #controlPoints: ] ] ].	v addAll: (s elementsOn: (1 to: size)).	v animation repeat onStepDo: [ :t | 		theta := theta + 0.0523.		v elements do: [ :e | (e attributes at: #update) value ] ].	v		when: TSExtentChangedEvent		do: [ v camera zoomToFit: v extent extent: 500 @ 500 ].	v open setLabel: 'Bezier Test'! !!RSAnimationExamples methodsFor: 'examples'!example30SVGIcons	<script: 'self new example30SVGIcons'>	| v elements s color r theta |	v := RSView new.	r := SharedRandom globalGenerator.	color := TSGradientPalette gradient21.	color range at: 1 put: TSGradientPalette trueSunset.	theta := (1 to: 3) collect: [:i | r next * Float twoPi ].	s := RSShapeBuilder svgPath		draggable;		svgPath: [ :m | self perform: m ];		position: [ (r next * 50)@ (r next * 50) - 25 ];		color: [:m | | grad |			grad := color scale: m.			grad start: -20 asPoint; stop: 20 asPoint.			grad ].	elements := s elementsOn: #(america puzzlePiece supermarketCart).	v addAll: elements.	v animation repeat onStepDo: [:t | 		elements do: [:e | | p ang ext block | 			p := e position.			ext := e extent / 2.			ang := theta at: e index.			block := [ 				ang := Float pi / 4 + ang.				p := (ang cos@ ang sin) * 1.5 + e position. ].			p := (ang cos@ ang sin) * 1.5 + p.			(p x + ext x) > 50 ifTrue: block.			(p y + ext y)  > 50 ifTrue: block.			(p x - ext x) < -50 ifTrue: block.			(p y - ext y) < -50 ifTrue: block.			theta at: e index put: ang.			e position: p.			 ] ].	v addShape: (TSBox new		extent: 100@100;		noPaint;		border: TSBorder new).	v when: TSExtentChangedEvent do: [ v camera zoomToFit: v extent extent: 100 asPoint ].	"v showEncompassingRectangles."	v open setLabel: 'Icons'.	! !!RSAnimationExamples methodsFor: 'examples'!example31Miku	<script: 'self new example31Miku'>	| r v lines svg easing |	r := SharedRandom globalGenerator.	v := RSView new.	lines := RSAnimationExamples new miku lines.	lines := (0 to: lines size / 2 - 1)		collect: [ :i | (lines at: i * 2 + 1) -> (lines at: i * 2 + 2) ].	svg := RSShapeBuilder svgPath		draggable;		svgPath: #key;		color: #value.	v addAll: (svg elementsOn: lines).	v @ RSControlsView.	easing := TSEasing elasticOut.	v elements do: [ :e | | position |		position := (r next * 1000) @ (r next * 1000) - 100.		v animation			easing: easing;			delay: (e index * 50) milliSeconds;			from: position;			to: e position;			duration: 5 seconds;			on: e trachelShape set: #position:.			e position: position ].	v addShape: (TSLabel new		text: 'Roassal';		fontName: 'Marker Felt';		noPaint;		border: (TSBorder new color: Color transparent; width: 1.5);		fontSize: 100;		position: 320 @ 630).	v animation		delay: 6 seconds;		duration: 3 seconds;		from: Color transparent;		to: Color black;		on: v shapes last border set: #color:.	"v showEncompassingRectangles."	v open setLabel: 'Miku'! !!RSAnimationExamples methodsFor: 'examples'!example32RSLocate	<script: 'self new example32RSLocate'>	| v box fixedElement movableElement buttonShape buttons locate labelShape label grad1 grad2 |	v := RSView new.	locate := RSLocate new.	box := RSShapeBuilder box		onElement;		size: 200;		color: TSColorPalette qualitative paired3.	labelShape  := RSShapeBuilder label		text: [ :m | 'Padding:', 			(m padding x printShowingDecimalPlaces: 1),'@',			(m padding y printShowingDecimalPlaces: 1) ].	label := labelShape elementOn: locate.	fixedElement := box elementOn: 'padding'.	movableElement := box element.	movableElement size: 40.	fixedElement when: TSMouseClick do: [ 		v animation			scale: (TSScale linear 				domain: #(0 0.5 1); 				range: { 0@0. 20@20. 0@0});			onStepDo: [ :t | 				locate padding: t.				locate move: movableElement on: fixedElement.				labelShape updateElement: label.				label signalUpdate.				 ]  ].		v add: fixedElement; add: movableElement; add: label.	grad2 := (TSGradientPalette linearGradient: 		{0->'white'.		0.25->'black'.		1 ->'lightGray'})		start: 0@ -15;		stop: 0@ 15.	grad1 := (TSGradientPalette linearGradient: 		{0->'lightGray'.		0.25->'black'.		1 ->'gray'})		start: 0@ -15;		stop: 0@ 15.	buttonShape := RSShapeBuilder box		cornerRadius: 5;		extent: 60@30;		paint: grad1;		interactionDo: [ :i| | lbl |			lbl := i labeled.			lbl shape color: Color white.			lbl location middle];		border: (TSBorder new color: Color lightGray);		onElement;		when: TSMouseEnter do: [:e | [ e paint: grad2; signalUpdate ] ]; 		when: TSMouseLeave do: [:e | [ e paint: grad1; signalUpdate ] ];		when: TSMouseClick do: [:e | [ | p |			e model value: locate. "= locate perform: e model"			p := movableElement position.			locate move: movableElement on: fixedElement.			v animation				from: p;				duration: 500 milliSeconds;				to: movableElement position;				on: movableElement trachelShape set: #position: ] ].	buttons := buttonShape elementsOn: #(outer border inner left center right top middle bottom).	RSGridLayout new lineItemsCount: 3; on: buttons.	RSVerticalLineLayout new center; gapSize: 30; on: (TSGroup with: v elements with: buttons).	v addAll: buttons.	v when: TSExtentChangedEvent do: [ 		v camera zoomToFit: v extent * 0.7.		v signalUpdate ].	 	v open setLabel: 'RSLocate methods'! !!RSAnimationExamples methodsFor: 'examples'!example33AlteredWorld	<script: 'self new example33AlteredWorld'>	"base on Gerard Ferrandez source code"	"https://codepen.io/ge1doot/details/GQobbq/"	| v extent px perlin path r period length |	v := RSView new.	r := Random new.	extent := 500@500.	period := 0.01.	length := 400.	v clearBackground: false.	v color: Color black.	px := 0.	perlin := TSPerlinNoise3 new octaves: 5.	path := RSSingleEdgeBuilder polyline		width: 0.5.	v addAll: (path edgesOn: (1 to: extent y /6)).	v animation		loops: extent x;		duration: 50 milliSeconds;		when: TSAnimationLoopEvent do: [			v edges do: [ :e | | x y n points m |				x := px.				y := extent y * r next.				n := perlin noise: x * period and: y * period.				e color: ((Color h: -210 + (n * 600) s: 1 l: 8 * n * n * n) alpha: 0.05).								points := OrderedCollection new.				points add: x@y.				m := 0.				[ m < length and:  [y >= 0 and: [ y <= extent y ] ]] whileTrue: [ 					n := perlin noise: x * period and: y * period.					x := x + (n * 14) cos.					y := y + (n * 14) sin.					points add: x@y.					m := m + 1 ].				e trachelShape controlPoints: points.				].			v signalUpdate.			px := px + 1			].	v when: TSExtentChangedEvent do: [ v camera 		zoomToFit: v extent 		rectangle: (Rectangle rsCenter: extent / 2 extent: extent) ].	v open setLabel: 'Altered World :V'	! !!RSAnimationExamples methodsFor: 'examples'!example34Tick	<script: 'self new example34Tick'>	| v shape labelShape slice animation |	v := RSView new.	v color: Color black.	slice := Float twoPi / 16.	labelShape := RSShapeBuilder label		color: Color lightGray.	shape := RSShapeBuilder composite shapes: [ | g |		g := labelShape elementsOn:((1 to: 16) collect: [:i |			i even				ifTrue: [ 'I' ]				ifFalse: [ 'O' ] ] ).		g do: [ :e | | ang | 			ang := e index * slice.			e matrix rotateByRadians: ang + Float halfPi.			e position: (ang cos @ ang sin) * 30.			 ].		g ].		v add: shape element.	labelShape		color: Color white;		onElement;		position: [ :e | 0@( -60 + (e index * 15)) ].		v addAll: (labelShape elementsOn: 'TICK').	(v elements at: 3) remove.	animation := [:a :b :k | v tAnimation 		duration: 700 milliSeconds;		easing: TSEasing bounceOut;		from: a;		to: b;		onStepDo: [ :t | | s |			v elements first matrix				loadIdentity;				rotateByRadians: t.			s := v elements first shapes.			(s at: k key) color: Color lightGray.			(s at: k value) color: Color white. ]].	(v animationFrom: { 		(animation value: 0 value: slice value: 10->11).		(animation value: slice value: slice * 2 value: 11->10)}) repeat.		v when: TSExtentChangedEvent do: [ v camera zoomToFit: v extent extent: 120 asPoint ].	v open setLabel: 'Can you hear it?'.	! !!RSAnimationExamples methodsFor: 'examples'!example35Perlin	<script: 'self new example35Perlin'>	| v r s frame scIterations scRadius rect extent maxLife perlin noiseScale |	r := Random new.	v := RSView new.	v clearBackground: false.	extent := 500@500.	rect := Rectangle rsCenter: extent/2 extent: extent.	maxLife := 10.	perlin := TSPerlinNoise2 new.	noiseScale := 160.	v color: Color black.	scIterations := TSScale linear domain: #(0 100); range: #(5 1).	scRadius := TSScale linear domain: #(0 100); range: #(1 3).		s := RSShapeBuilder circle onMyselfDo: [:i | [:e |		| iterations life flip c1 c2 respawnTop color |		iterations := scIterations scale: i.		e size: (scRadius scale: i).		flip := (r next * 2 ) asInteger * 2 - 1. 		c1 := c2 :=  Color white.				respawnTop := [			life := r next * maxLife.			e position: r next @ 0 * extent ].		respawnTop value.		(r next * 3) asInteger = 1 ifTrue: [ 			c1 := Color purple.			c2 := Color cyan ].				e attributes at: #update put: [ | p vel heading alpha |			(life := life - 0.01666) < 0 ifTrue: respawnTop.			p := e position.			vel := 0@0.			1 to: iterations do: [ :k | 				| transition angle |				transition := p x / extent x.				angle := (perlin					snoise: p x / noiseScale					and: p y / noiseScale) * transition * Float twoPi * noiseScale.				vel := angle cos @ angle sin * 0.2.				p := p + vel. ].			(rect containsPoint: p) ifFalse: respawnTop.			e position: p.			heading := vel angle / Float twoPi.			heading < 0 ifTrue: [ heading := heading negated ].			color := TSScale linear range: { c1. c2 }; scale: heading.			alpha := life * 5 / maxLife min: 1.			alpha := (maxLife - life * 5 )/ maxLife min: alpha.			color setAlpha: alpha.			e color: color.			].		 ] ].	frame := 0.		v addAll: (s elementsOn: (1 to: 100)).	v animation repeat onStepDo: [ :t |		frame := frame + 1.		v elements do: [ :e |			(e attributes at:#update) value ]. ].	v when: TSExtentChangedEvent do: [ v camera 		zoomToFit: v extent		rectangle: rect ].	v open setLabel: 'Perlin :V'.	! !!RSAnimationExamples methodsFor: 'examples'!example36RoundRectagles	"example inspired in paper.js"	<script: 'self new example36RoundRectagles'>	| v mouse extent s frame scale |	v := RSView new.	extent := 500@500.	mouse := 0@0.	scale := [ :i | (1- (i / 25)) * 10 ].	s := RSShapeBuilder box		size: [:i | 25 * (scale value: i) ];		cornerRadius: [:i | 6 * (scale value: i) ];		color: TSColorPalette sequential blues9.	v addAll: (s elementsOn: (1 to: 25) ).	v when: TSExtentChangedEvent do: [ 		v camera zoomToFit: v extent extent: extent ].	v when: TSMouseMove do: [ :evt | mouse := evt position. ].	frame := 0.	v animation repeat onStepDo: [ :t |		frame := frame + 1.		v elements do: [ :e | | pos angle |			pos := e position + ((mouse - e position) / (e index + 5)).			angle := e attributes at: #angle ifAbsentPut: [ 0 ].			angle := angle +(((frame + e index) / 10) sin * 7).			e attributes at: #angle put: angle.			e matrix 				loadIdentity;				translation: pos;				rotateByDegrees: angle.			]].	v open setLabel: 'Round Rectangles'! !!RSAnimationExamples methodsFor: 'data'!miku	^ 'm 148.25647,236.39122 -3.89508,14.84999 -14.11966,51.12292 -10.10286,26.9004 -15.70204,33.35162 -14.849996,32.37785 -10.589748,26.90039 -6.207783,20.20573 -5.477456,18.25819 -3.408195,26.77867 0.365164,20.69261 2.556146,18.62335 6.329504,21.42294 1.095491,-13.38934 2.434425,-21.7881 3.89508,-24.34425 7.546717,-21.1795 5.477456,19.84057 7.303275,27.63072 11.92868,23.97908 17.04097,22.8836 9.61598,9.25081 5.84262,-16.43237 6.81639,-24.1008 3.28648,-15.21516 2.3127,-20.57089 2.55615,-15.70204 0.48688,-21.7881 0.60861,-26.90039 3.85187,-84.73722 3.09851,-18.41896 3.09852,-17.73041 7.57415,23.58316 2.23782,-5.85275 8.95127,-21.51748 5.1642,-11.18909 6.71345,27.54237 8.60699,21.34534 3.27066,-26.85381 4.13136,15.83686 4.64777,18.24682 6.88559,16.86971 4.64778,5.33633 -0.17214,-11.87765 0.34428,-15.49258 228.94597,2.23782 2.06568,14.45974 0.8607,18.5911 1.03284,24.616 0.51642,34.08369 0.17214,32.53443 1.54926,22.55031 5.33633,26.3374 2.92638,17.38612 8.43485,32.70657 4.13136,-2.23782 17.55826,-19.62394 15.83687,-20.3125 12.22192,-17.7304 12.22193,-21.34534 9.12341,-22.72246 7.74629,-25.64883 5.68062,17.7304 8.09057,30.12447 4.81992,22.20604 2.40995,18.93538 0.51642,9.29555 2.75424,-7.22987 4.13136,-14.80403 2.58209,-14.80403 -0.86069,-19.10752 -2.75424,-16.52542 -3.4428,-16.18114 -4.99205,-13.25477 -8.26272,-17.55826 -6.19703,-12.73835 -10.84481,-20.82892 -14.63188,-25.4767 -9.4677,-19.96822 -7.05773,-16.35328 -6.36917,-14.97617 -3.95922,-11.18908 -21.87474,-45.37302 -14.3631,-37.73359 -37.73359,15.33688 0.73033,17.28442 -4.86885,6.08606 -0.24344,-23.12704 -60.86062,13.63278 -74.4934,10.22459 -67.92046,-2.19099 -54.77455,-7.30327 z#299ca3m 267.67744,453.58845 2.58209,-2.92637 10.50053,-6.19704 9.98411,-7.22987 7.7463,-7.57415 0.57862,-2.65433 -0.85205,-6.20779 3.28648,-2.55614 3.28647,-7.18156 2.06926,-9.98114 1.94754,-8.64221 1.46066,-12.53729 -0.36517,-11.07663 -0.12172,-9.37253 10.95491,-0.73033 16.67581,-3.4082 10.83319,-2.43442 6.45123,0.60861 22.27499,28.60449 0.48688,21.90982 0.48689,11.19835 4.74712,1.0955 -0.97377,6.69466 -0.48688,3.77336 4.13852,5.7209 11.56352,7.425 5.84262,5.7209 -4.09974,22.93458 -32.36229,29.95233 -38.9036,-3.09852 -40.96928,-9.29555 -17.90254,-22.0339 z#ffffffm 266.81674,454.44915 8.09057,9.29555 8.77913,9.81197 10.15625,9.63983 5.33634,-1.54925 9.63983,-4.99206 11.87764,-7.57415 5.33634,-3.27066 5.68061,6.88559 7.57416,9.29556 10.15625,7.91843 4.99205,1.37712 6.54132,-3.78708 6.74264,-6.5708 9.37254,-5.59918 4.86885,-4.13852 6.93811,-5.59918 -1.94754,-8.76393 5.35573,2.43442 4.0168,-0.36516 4.62541,-8.27704 2.67787,-4.0168 10.71147,3.89507 -1.21722,6.32951 -10.3463,20.57089 c 0,0 -12.65901,15.94548 -12.29385,15.82376 0.36517,-0.12172 -11.68524,8.39877 -11.68524,8.39877 l -6.81639,2.79958 -17.04097,4.86885 -15.58032,2.67787 -9.12909,0.85205 -12.78073,-0.73033 -11.80696,-2.55614 -8.15533,-2.43443 -11.68523,-3.65164 -9.85942,-5.84261 -9.00738,-6.32951 -8.27704,-6.69467 2.92131,-4.0168 -7.05983,-6.93811 -6.32951,-10.58975 9.37254,-5.11229 z#808791m 241.86011,504.54312 5.59917,6.20778 11.32008,4.62541 9.85942,2.79959 -10.58975,13.38933 -17.52786,20.93606 -12.53728,15.33687 -5.1123,5.59918 -7.30327,3.65164 -11.56352,0.12172 -9.85942,-2.06926 -5.47746,-1.21722 1.94754,-6.69466 17.04098,-23.61393 10.71147,-13.63277 10.3463,-11.19836 9.25082,-10.22458 z#808791m 254.27567,493.5882 8.76393,7.05984 13.38934,8.76393 -7.18155,9.37253 -9.61598,-2.92131 -10.58975,-4.13852 -7.18155,-6.81639 z#fdf4ebm 408.73993,485.79804 6.45123,-2.06926 8.39876,-4.99057 0.85205,11.80696 -4.74713,15.94549 -6.3295,17.52785 -7.54672,14.48483 -0.12172,6.45123 2.55614,10.3463 1.21722,9.00738 -2.31271,5.72089 -6.57294,2.79959 -9.25082,0.12172 -5.47745,-0.85204 -7.18156,-1.94754 -4.86885,-4.62541 -1.21721,-7.425 2.3127,-13.26761 6.45123,-15.09344 4.86885,-9.85942 4.86885,-11.56352 0.97377,-6.3295 6.93811,-5.96434 6.57295,-7.91188 1.70409,-2.43443 z#808792m 247.79529,463.48649 3.87314,6.97167 9.7259,11.4473 -2.15174,2.49602 7.83236,6.97167 11.53337,7.1438 7.74629,4.81991 17.12791,5.33634 13.94333,3.09852 14.71795,0.60249 10.84481,-0.94677 13.08263,-2.92638 12.82442,-3.18459 11.27516,-5.33633 8.34878,-6.19704 7.66022,-8.60699 7.57415,-11.10302 4.21743,-6.97166 4.13136,-9.12341 1.80746,-6.88559 3.52887,1.46318 1.80747,3.70101 -1.11891,7.66022 -5.07813,13.68512 -4.30349,6.54131 -8.26271,9.46769 -8.34879,8.52093 -6.54131,5.16419 -11.79158,5.93882 -10.15625,3.4428 -7.48808,1.7214 -9.38162,2.66817 -12.308,2.15174 -6.02489,-0.77462 -11.70551,-0.68856 -8.43485,-2.32389 -7.40202,-0.43035 -2.15174,-2.15175 -4.47564,-0.60249 -7.40201,-1.97961 -8.77913,-3.61493 -4.99206,-3.78708 -7.66022,-3.87315 -6.62738,-5.4224 -4.21743,-4.3035 -1.63533,-2.15174 1.97961,-3.01245 -6.45524,-8.26271 -4.90599,-7.14381 -1.63533,-3.95921 3.35673,-3.27066 z#93d3d5m 416.16493,468.75707 4.86885,4.26024 1.94754,5.96435 -5.47746,3.16475 -7.425,2.67786 2.31271,-6.81638 z#fdf4ebm 319.27482,371.98868 5.23401,-4.6254 4.13852,0.6086 5.7209,3.65164 0.24344,2.55615 -3.52991,5.23401 3.40819,11.19835 3.65164,13.02418 -1.7041,6.81639 -7.30327,8.39876 -7.05983,5.59918 -3.65164,-2.79959 -4.50369,-9.12909 -4.38196,-9.61598 2.43442,-5.11229 4.62541,-8.27705 4.62541,-10.83319 z#93d3d5m 284.58426,368.94565 8.39877,-2.3127 9.85942,-4.50369 4.50369,-2.55614 -9.49426,-0.85205 -10.95491,-0.97377 -3.28648,-2.67787 26.65696,-0.73033 21.42293,-1.21721 14.72827,-0.48688 -7.91188,2.92131 -4.99057,1.70409 -5.59917,10.10287 -2.79959,0.6086 -3.04303,-4.26024 -2.31271,-4.99057 -10.10286,1.09549 0.12172,17.52786 -6.93811,4.13852 -10.58975,5.7209 -4.86885,-11.68524 z#fdf4ebm 354.08709,353.24361 32.86474,0 -2.92131,4.50369 -7.425,7.30327 -1.94754,17.1627 -3.65164,8.27704 -5.59917,2.31271 -4.13852,-0.60861 -4.01681,-5.23401 -3.16475,-12.90246 -0.48688,-13.02417 z#fdf4ebm 201.4036,388.5196 24.96028,-7.57416 19.62394,-4.99205 28.05879,-8.77913 12.39407,30.29661 -9.81197,8.26271 -18.82312,14.33499 -27.75244,20.08401 -11.6077,-21.76672 z#808791m 190.90307,392.30667 9.89804,-3.87314 11.53337,20.3125 17.98861,32.01801 -11.18909,7.31594 -10.58659,-19.53787 -11.4473,-22.63639 z#93d3d5m 274.30482,367.43247 7.31594,-1.89354 3.87315,6.2831 6.11096,11.70551 2.32389,7.74629 -7.66022,5.50848 -5.07813,-11.27516 -6.19703,-13.59905 z#93d3d5m 178.56506,409.23538 2.06926,-6.93811 4.26025,-4.13852 8.27704,0.12172 14.60655,29.69999 -5.35573,7.30327 -7.66844,4.13852 -4.13853,1.82582 -8.76392,4.13852 -6.32951,0.24345 -6.20778,-2.79959 -5.11229,-8.88565 -3.52992,-8.88565 -3.77336,-10.34631 1.21721,-4.50369 5.35574,-7.42499 2.43442,8.88565 6.20779,-0.97377 z#fdf4ebm 177.99259,446.70286 6.36917,14.45975 6.71345,10.50053 5.50848,0.51641 5.59454,-4.5617 0.94677,-3.27066 -3.35673,-9.12341 -6.36917,-15.23437 -3.4428,1.89353 -5.25026,2.66817 -6.79952,1.03284 z#ffffffm 150.10593,227.74099 2.75424,-17.90254 -10.50053,7.22988 0.17214,-10.50053 2.40996,-12.73835 7.05773,-6.71346 7.22987,-7.74629 2.17303,-8.34279 3.89508,-6.57294 5.47745,-4.26025 10.71147,0.73033 5.59918,-2.55615 11.56352,-17.04097 -8.15533,-7.05983 -7.91188,-6.93811 -6.20778,-8.15533 -3.16475,-6.08606 12.17212,6.81639 19.84056,8.64221 12.90246,2.79959 15.94548,1.82582 6.3295,-1.46066 14.60655,-4.0168 25.43974,-4.26024 22.88359,-1.94754 59.54143,-10.9726 53.01907,28.91949 5.50848,16.69756 7.83236,15.57866 25.033,2.60391 42.11555,37.97702 -78.87536,23.37048 -62.80816,15.09344 -61.10407,4.86885 -73.76307,-4.62541 -68.65078,-14.11966 z#93d3d5m 72.667581,151.91668 6.694669,1.94754 9.737699,6.57295 5.599177,4.86885 9.250814,9.85942 8.0336,10.71147 7.79016,11.92868 0.48689,-9.85942 1.82582,-13.26762 3.52991,-15.58032 6.32951,-16.0672 5.23401,-11.32008 4.92159,-9.06132 6.19703,-7.74629 5.50848,-2.66817 6.88559,-0.34428 8.17664,3.27066 5.85276,4.21742 1.7214,6.62738 -0.77463,8.43486 -5.76669,11.27516 -6.97166,9.98411 -4.38957,7.40201 -6.62738,11.70551 -3.61494,10.24232 -3.35672,9.55376 -1.54926,8.34878 -0.97863,6.41624 -0.36516,17.1627 0.85205,17.1627 2.3127,15.58031 3.16475,18.37991 3.4082,16.91925 -20.57089,8.27705 -5.47746,-22.76187 -3.89508,-17.1627 -4.99057,-18.62335 -4.62541,-13.63278 -5.59917,-9.49425 -6.938113,-10.22459 -9.615978,-9.61598 -6.451226,-7.30327 -6.675989,-5.36698 -8.305746,-5.20723 -4.647776,-4.30349 -1.204979,-9.29555 2.496028,-9.63983 3.959216,-6.41221 z#5fc5c9m 166.37315,411.41419 6.54131,-0.77462 6.02489,-1.7214 1.80747,-6.62739 -4.64777,-11.53337 -4.99206,-21.34533 -5.68061,-20.82892 -5.50848,-22.20604 -8.26271,-34.25583 c -6.20014,3.16792 -11.49776,7.01271 -21.1732,7.57415 l 7.57415,33.05085 8.77914,29.43591 7.57415,18.50503 7.74629,18.59111 z#ffffffm 74.966896,158.45471 1.979608,2.79727 0.25821,4.1744 -0.860699,4.30349 -1.850503,3.78708 -1.506224,2.45299 -2.108713,1.97961 -2.237817,-0.0861 -1.721399,-1.67836 c -0.758778,-9.75855 3.696766,-18.27448 8.047537,-17.73038 z#299da4m 152.90321,117.61454 c 7.03567,-1.57483 15.78503,3.49999 17.62825,9.8666 l -0.27387,1.46065 -1.61281,2.03883 -2.79959,1.36937 -2.37356,-0.18258 -4.89928,-1.88668 -5.17315,-3.95594 -1.94754,-2.58658 -0.79119,-2.58658 0.27387,-1.94754 0.88248,-1.09549 z#299da4m 448.25212,176.09905 21.34534,-22.20604 -12.39407,-13.25477 -5.86103,-6.73631 -14.60654,-13.99794 -11.03402,-10.25092 -11.96372,-9.46769 -9.20948,-7.660223 -5.33633,-10.07018 -3.70101,-11.877648 -3.35673,-14.804025 -1.72139,-12.049789 -0.43035,-11.016949 -3.09852,-4.733845 -9.20948,-4.905985 -6.36917,0.08607 -6.97167,2.582097 -2.8403,5.422405 -0.60249,15.320445 1.29104,15.750794 2.23782,10.41446 4.90599,10.930879 0.90373,3.657971 -5.2933,1.075875 -16.43935,1.118908 -19.71001,3.442797 -13.85726,3.442797 -8.0045,3.356726 -3.18459,3.70101 -0.94677,9.55376 1.20498,9.29555 3.18459,7.05773 2.06568,0.60249 11.96371,-3.18459 19.96822,-3.52886 22.8946,-0.25821 15.49259,2.49603 16.18114,9.81197 14.97617,9.63983 14.11546,11.79157 z#5fc5c9m 431.98491,162.84428 15.92293,13.85725 -3.01245,11.27516 -2.92637,8.34879 1.63532,13.68511 8.17665,28.57521 -8.52093,9.03735 -6.88559,-13.68512 -9.29555,-17.30005 -4.5617,-13.08263 0.60248,-8.09057 4.04529,-13.85726 3.01245,-11.70551 z#808791m 247.36494,201.05932 17.21398,49.57627 10.67267,23.06674 12.39407,21.34534 13.08262,15.32044 13.77119,13.59905 -0.68856,-12.91049 -1.54926,-38.73146 5.1642,-36.49364 8.26271,-42.3464 36.66578,57.4947 13.59905,35.97723 -1.05197,13.58121 -1.15635,23.12704 -0.79119,9.61598 -36.1512,9.37253 -54.65284,3.89508 -22.39671,-5.59917 -24.58769,3.52991 -6.45123,-6.69467 -1.33893,-11.44179 -0.85205,-18.86679 -0.24344,-12.78073 -1.58238,-21.05778 13.99795,-49.90571 z#fdf4ebm 480.0625,208.28125 c -10.91988,4.12393 -21.98027,8.0309 -33.15625,11.6875 l 3.3125,12.625 c 3.80711,-1.2643 7.63016,-2.57732 11.46875,-3.9375 l 1.53125,-1.6875 L 467.375,223 l 3.53125,2.3125 c 3.08442,-1.14879 6.17882,-2.31867 9.28125,-3.53125 l 1.34375,-3.15625 4.125,-4.5 -5.59375,-5.84375 z m -49.25,16.75 c -6.10399,1.83639 -12.23387,3.58742 -18.40625,5.25 l 4.125,12.4375 c 6.93741,-1.85936 13.9349,-3.88821 21,-6.0625 l -6.71875,-11.625 z m -280.59375,4.0625 -3.125,12.25 c 18.02488,7.60993 44.65417,14.50638 77.75,18.09375 l 2.71875,-13.375 c -25.52993,-3.0698 -51.33015,-8.56718 -77.34375,-16.96875 z M 405.96875,232 c -15.43506,3.98249 -31.08297,7.36842 -46.90625,10.0625 l 4.625,12.21875 c 13.911,-2.3659 28.2087,-5.32857 42.8125,-8.96875 L 405.96875,232 z M 311.875,247.8125 c -15.10479,1.11216 -30.35409,1.5248 -45.71875,1.09375 L 270.25,262 c 13.20733,0.10471 27.07798,-0.31428 41.53125,-1.375 l 0.0937,-12.8125 z#ffffffm 187.69415,157.69844 2.43443,-9.79856 2.0084,-5.17316 5.11229,-1.82581 4.74713,2.0084 7.18155,4.86885 -5.59917,2.19098 -9.25082,4.50368 z#7f8791m 198.64907,141.57037 c -1.88612,4.4324 -2.97264,8.465 -3.89508,12.41557 l 3.65163,-0.60861 c 0.86888,-4.04055 1.97288,-7.84596 3.16476,-11.56351 z#fb9ae7m 440.50583,170.5045 3.01244,2.5821 c -3.10015,10.35019 -10.10675,24.24455 -9.46769,26.5956 0.9743,3.58438 3.14331,6.66171 4.13136,10.24232 5.43376,19.69146 7.99932,25.03314 11.87765,29.86626 l -2.84031,3.09852 c -2.56504,-5.67442 -7.68573,-16.66677 -10.5866,-25.21849 -1.76587,-5.20575 -0.84787,-7.95931 -2.8403,-13.08262 -0.39089,-1.00512 -2.1206,-4.09214 -2.23782,-5.1642 -0.45037,-4.11903 3.0183,-11.72928 8.95127,-28.91949 z#fb9ae7m 405.21716,281.53469 6.11097,-5.4224 1.63532,2.66816 0.17214,7.48809 -8.26271,10.50053 z#fb9ae7m 404.78681,281.96504 4.99206,-4.13135 2.40996,-1.7214 1.72139,9.12341 12.22193,-16.18115 -4.38956,-5.50847 -1.54926,-8.34878 -2.92638,-9.46769 -3.18459,-12.04979 -4.30349,-9.81197 -4.21743,-8.17664 -0.0861,14.97616 1.46319,16.69757 -1.29105,25.90704 z#808791m 478.24276,230.18344 1.46065,-8.88565 3.52992,-5.96434 4.86885,-2.67787 6.81639,1.33893 3.16475,3.04303 4.38197,-4.38196 3.16475,-6.57295 1.21721,-4.99057 -3.40819,-2.67787 -0.12173,-1.94754 4.38197,-1.15635 6.99897,3.7125 12.11126,10.10286 6.57295,7.97274 4.99057,10.28545 -1.09549,6.45122 -2.79959,6.75553 -4.3211,8.03361 -5.53832,4.0168 -3.83422,0.6086 -1.64323,4.32111 -4.13853,2.617 -6.45122,1.15635 -5.35574,0.36517 -7.48585,-11.1375 -9.55512,-11.62437 -6.3295,-5.7209 z#fdf4ebm 467.22699,223.00188 -8.27705,8.39877 6.26865,4.26024 8.45962,6.69467 8.94651,10.28545 5.29488,7.66843 5.17315,10.10287 5.35574,12.47642 6.14692,23.30962 3.22561,0.54775 4.74713,-3.65164 5.96434,-6.08606 -3.10389,-10.65061 -10.52889,-21.11864 -5.23401,-7.54671 -8.0336,-12.65901 -8.76393,-10.10286 -9.61598,-8.27705 z#93d3d4m 381.47437,333.52477 10.22982,-0.4342 12.39406,-1.03284 20.74285,-1.97961 13.51298,-0.43035 17.12791,-1.54925 9.46769,-0.51642 8.69306,-4.47564 11.87765,-9.38162 11.18909,-7.05773 6.62739,-0.60249 6.62738,1.80747 4.90598,7.83236 1.03284,7.40201 -2.58209,5.59455 -7.66023,4.90598 -10.50053,4.38957 -11.79157,3.44279 -7.83237,1.11891 13.51298,5.68062 20.91499,8.77913 20.05429,9.7259 16.78363,9.03734 8.8652,7.74629 2.40996,6.62739 -2.15175,9.38162 -3.25366,5.11167 -3.80407,4.52816 -7.31594,5.16419 -5.1642,0.60249 -9.20948,-3.61494 -11.79158,-10.07018 -11.79157,-11.10301 -11.70551,-10.24232 -12.91049,-9.72591 -9.63983,-7.22987 -10.41446,-4.81991 -9.46769,-3.61494 -10.50053,-0.34428 -17.12791,-0.60249 -24.01351,-0.0861 -17.64433,-0.34428 z#5fc5c9m 378.27728,328.87315 -3.35673,4.13135 6.45525,0.0861 z#93d3d4m 385.73462,353.42619 12.71987,0.0609 5.29487,5.05144 -6.69467,5.05143 -5.78176,-3.52992 -4.92971,-5.05143 z#93d3d4m 458.92479,232.13056 4.99205,2.66817 9.29556,7.1438 10.15625,10.67267 6.2831,10.15625 5.68061,11.87765 3.70101,10.07018 3.70101,11.36123 2.23781,9.89804 -5.25026,0.0861 -4.64778,1.80747 -6.54131,4.30349 -11.10302,8.09057 -8.77913,5.68062 -5.25027,2.5821 -10.93087,0.17214 -11.83865,0.7461 -11.68524,0.48688 -12.35471,1.21722 -13.57192,1.03463 -5.41659,0.6086 -15.1543,0.42603 -4.13852,-8.88565 6.57295,-5.59918 4.92971,13.57192 7.91188,-0.60861 3.46905,-12.53729 1.94754,-11.19835 1.27808,-10.22458 4.74712,-6.81639 7.60758,-9.25082 8.06757,-10.8095 8.95127,-12.04979 12.39407,-14.63188 11.96372,-12.39407 z#808791m 399.62262,353.66128 12.99655,0.25821 -9.12341,4.90599 z#808791m 236.17585,344.27966 2.23782,-5.33633 7.31594,-4.13136 12.99656,-0.60249 15.40651,-0.0861 2.49603,5.1642 5.76668,1.63532 6.62739,-1.63532 3.95921,-3.35673 7.31595,3.95921 7.57415,1.11891 6.71345,-1.63532 6.45524,-5.93883 6.62739,-0.8607 17.55826,0.43035 16.43935,0.8607 18.41897,-0.17214 3.701,-0.17214 c -1.46829,4.78103 -1.9166,11.60199 -1.54925,20.05429 l -14.63189,-0.25821 -21.86176,-0.43035 -18.16075,1.03284 -17.47219,0.60249 -20.91499,0.43035 -18.50504,0.17214 -13.4269,0.17214 -8.34878,-0.51642 -8.26272,-1.37712 -4.38956,-3.52887 z#ffffffm 552.371,389.75998 c -2.49095,9.6659 -6.94355,16.46199 -13.81537,19.71885 l -3.10389,-1.33894 -0.18258,-3.7125 1.21721,-4.80798 2.67787,-5.59918 3.52992,-3.65164 3.52991,-2.19098 3.83422,-1.21721 1.71442,0.87064 z#299ca3m 538.12961,234.20024 7.18155,12.53729 4.50369,12.29384 0.12172,6.93811 -2.67787,4.74713 -3.65163,2.92131 -2.67787,0.54775 -3.46906,-3.52992 -6.51208,-8.09446 -6.81639,-9.7377 5.78176,-4.50369 4.07766,-5.96434 2.67787,-7.18155 z#ffffffm 485.60646,214.40016 5.25027,-0.51642 7.91843,2.84031 3.61494,-4.13136 3.52886,-6.79952 0.51642,-5.07813 -7.40201,-9.12341 -7.523,-10.46185 -9.61597,-12.29385 -14.60656,-18.01474 c -7.65585,12.01479 -15.38301,18.65231 -23.00531,22.64015 l 20.08401,18.37991 16.18892,16.0672 z#ffffffm 223.78178,263.71822 1.54926,19.10752 c 7.42354,-28.43554 16.28337,-50.63582 22.20604,-74.19227 4.3298,19.47745 11.43985,39.4604 25.82097,60.76536 l -8.43485,-22.37817 -6.02489,-22.55032 -3.78708,-16.35329 -1.7214,-20.3125 -0.68856,-19.10752 -3.95921,6.71346 -4.99206,16.52542 -4.13136,12.04979 -7.05773,24.61599 z#f8bba6m 317.25371,165.9428 5.68061,6.36917 8.09057,12.39407 9.63984,18.5911 13.59904,29.43591 9.63983,23.7553 c -14.91707,-17.72028 -27.14191,-35.93006 -37.01006,-54.56833 -3.97848,18.72673 -8.76077,47.90307 -14.11547,84.52066 l -1.20498,-23.7553 1.7214,-27.37023 0.8607,-25.13242 1.54926,-22.72246 z#f8bba6m 155.125,209.125 -3.34375,2.125 c -1.19191,7.58216 -2.51216,15.4045 -4.25,23.03125 -1.13172,5.29018 -2.40529,10.6577 -3.75,16.0625 l 1.25,6.75 c 1.82232,-7.15843 3.55969,-14.32927 5.25,-21.5625 2.08211,-9.04014 3.55542,-17.99909 4.84375,-26.40625 z m -25.59375,89.40625 c -1.22344,3.54891 -2.43061,7.01443 -3.65625,10.3125 -23.29503,63.59916 -64.03125,122.16517 -64.03125,189.25 0,18.6086 4.187985,36.84136 8.919678,48.90884 1.230121,3.13724 2.285052,4.28124 3.091048,4.05766 0.805996,-0.22358 1.092635,-1.9105 1.320275,-4.86445 1.82224,-23.64618 3.983515,-47.09643 10.436204,-68.13804 0.773996,-2.52393 1.76968,-5.57549 2.514045,-5.57047 0.744365,0.005 0.894453,2.99632 1.385426,5.41439 7.300589,35.95584 21.141314,67.85441 45.611034,91.28735 1.58142,1.51441 3.34127,2.77095 4.57424,2.54929 1.23297,-0.22166 1.76376,-1.84855 2.45611,-3.6903 20.19014,-53.70883 19.44685,-92.93263 20.72319,-133.73552 0.36982,-5.23993 -1.45168,-7.94582 -3.8125,-10 1.79353,45.24895 -1.58002,91.22691 -18.30123,139.00221 -0.5714,1.63257 -0.76411,3.38147 -2.06557,3.56511 -1.30146,0.18364 -2.51798,-1.36983 -3.86206,-2.73881 -28.3933,-28.91926 -37.112825,-62.12083 -43.700293,-95.76591 -0.523738,-2.67496 -0.57079,-3.49989 -1.969947,-3.81392 -1.399156,-0.31404 -2.099286,1.07435 -3.238228,3.70467 -6.029559,13.92491 -9.798966,28.86851 -12.766938,65.63269 -0.21294,2.63768 -0.02193,5.03411 -0.885194,5.15919 -0.863258,0.12509 -1.968502,-2.68814 -2.563441,-5.03455 C 67.643566,525.87487 65.25,512.88476 65.25,498.59375 c 0,-67.11566 42.17483,-128.50301 63.3125,-188.21875 0.90203,-2.37718 1.78085,-4.73456 2.625,-7.09375 z#000000m 176.61752,446.84725 1.47057,-1.48444 1.93763,1.60616 c 0,0 7.49134,23.7965 12.90245,23.7965 3.26872,0 8.94651,-3.35424 8.94651,-5.29487 0,-5.48726 -9.92028,-23.4922 -9.92028,-23.4922 l 1.21721,-2.06926 2.3127,1.33893 c 0,0 8.88565,18.77162 8.88565,24.46597 0,3.77364 -6.82795,7.72929 -11.38093,7.72929 -6.56381,0 -11.26047,-14.49902 -16.37151,-26.59608 z#000000m 171.84375,298.625 c -2.85759,15.3187 -5.72399,30.49037 -7.96875,45.8125 l 2.59375,10.53125 c 1.06462,-12.78171 2.8288,-25.43522 6.46875,-43.5625 L 171.84375,298.625 z M 159.6875,393.25 c -0.006,0.46079 -0.0279,0.91337 -0.0312,1.375 l -0.0937,11.71875 4.5,-2 c 0.012,-0.27879 0.0194,-0.44244 0.0312,-0.71875 l -4.4063,-10.375 z#000000m 160.34825,404.87288 c 0,0 -4.99205,5.25958 -4.99205,8.43485 0,3.9951 4.72479,11.3353 6.36917,17.4722 1.54529,5.76709 3.90438,16.61149 16.52542,16.61149 7.15488,0 12.34049,-5.72226 16.00901,-5.93883 7.28991,-0.43035 14.63188,-11.36122 14.63188,-11.36122 l -1.80746,-3.35673 c 0,0 -5.09149,10.62263 -13.25477,11.27516 -2.82496,0.22581 -6.6816,6.02489 -15.40652,6.02489 -8.55579,0 -9.49679,-3.94525 -11.72228,-8.47034 -1.21925,-2.47909 -2.99567,-3.87558 -3.68423,-7.36652 -1.13118,-5.73501 -4.38957,-11.55254 -4.38957,-14.97617 0,-3.4319 6.0249,-8.34878 6.0249,-8.34878 z#000000m 156.97065,110.82851 c 8.65658,0 20.67766,5.08911 20.67766,16.78975 0,15.33809 -12.60506,24.23485 -21.52895,42.80853 -7.36801,15.33537 -12.89902,32.61104 -12.89902,49.74005 0,33.63945 8.23568,65.12984 16.45638,98.02644 5.91996,23.68975 10.12224,43.99383 18.14373,72.04772 0.68607,2.39944 3.87314,11.79158 3.87314,11.79158 l -2.15175,3.27065 c 0,0 -2.0746,-8.0815 -4.5617,-15.06223 -7.44753,-20.90356 -12.77937,-49.25654 -18.21055,-70.95563 -8.43911,-33.71657 -16.30349,-66.01529 -16.30349,-100.49565 0,-18.78214 5.77733,-38.4196 12.64807,-49.83623 9.27198,-15.4066 22.43892,-33.05931 22.43892,-41.03271 0,-7.84344 -10.37384,-14.65277 -18.21728,-14.65277 -13.82406,0 -28.70684,34.2996 -33.63582,60.23358 -2.96922,15.62256 -1.51073,28.33236 -3.37425,28.33236 -1.88463,0 -6.01878,-10.5924 -13.70697,-20.41117 -10.808656,-13.80397 -26.50237,-28.21833 -34.147901,-28.21833 -2.395694,0 -8.606992,12.48112 -8.606992,19.62394 0,8.1786 4.870582,7.89565 11.189089,12.73835 15.196452,11.64703 35.820634,35.72632 38.731464,44.41207 15.01519,44.80452 22.37051,111.06298 50.04551,170.22387 2.79816,5.98163 3.09093,9.87194 4.40662,9.40276 4.10047,-1.46225 11.61115,-1.9828 11.61115,-1.9828 l -0.79209,2.92855 c 0,0 -11.23008,3.74551 -14.12802,2.38587 -1.92184,-0.90168 -0.43804,-5.7025 -3.02712,-10.97517 -15.9584,-32.49931 -29.01209,-79.67101 -36.80362,-117.7329 -6.11416,-29.86787 -9.5759,-36.33093 -14.63107,-53.22495 -2.30271,-7.6955 -21.526955,-31.68977 -36.602028,-42.93248 -5.283146,-3.94007 -12.640953,-5.43559 -12.640953,-15.26866 0,-8.36137 6.333661,-22.58162 10.921671,-22.58162 7.777044,0 27.347107,14.53391 36.69931,28.21354 5.42501,7.93525 9.61266,15.57192 9.93912,15.57192 0.32646,0 -0.40762,-10.08087 2.057,-21.69525 5.25342,-24.7564 20.39861,-61.48298 36.13074,-61.48298 z#000000m 177.3901,411.93061 c 0,-7.33191 3.68905,-15.39503 9.89804,-15.49258 1.98952,-0.0313 5.93882,0.60249 5.93882,0.60249 l 0.94677,3.01245 c 0,0 -4.9212,-0.77463 -7.40201,-0.77463 -3.13916,0 -6.36918,5.29918 -6.36918,12.39406 0,5.58091 2.56211,11.01695 5.07813,11.01695 3.41181,0 -0.13347,-9.96061 3.44279,-9.7259 2.66396,0.17483 0.89486,5.60549 1.63533,8.34878 0.95054,3.52157 3.2769,5.90082 4.04529,12.22193 0.25358,2.08608 -0.60249,5.85276 -0.60249,5.85276 l -3.95922,2.75423 c 0,0 -1.41666,-1.43564 1.09646,-2.88659 0.88691,-0.51206 1.03464,-3.9322 0.964,-5.52827 -0.12627,-2.85321 -2.3763,-10.28752 -3.53409,-10.28752 -1.40229,0 -1.21575,2.09089 -3.43235,2.09089 -4.35615,0 -7.74629,-7.69387 -7.74629,-13.59905 z#000000m 221.30562,445.05505 c 22.92826,-16.76309 46.24633,-33.0145 69.63218,-53.41572 1.19842,-0.80536 1.11432,-1.33 0.77871,-2.49147 -1.8367,-6.03689 -5.60053,-13.03734 -9.40221,-20.05672 -0.76082,-1.77284 -1.12393,-1.88943 -2.75308,-1.39997 -28.73356,8.59439 -73.20649,18.7757 -86.31977,25.55523 -0.66624,0.26024 -0.8572,0.74362 -0.45046,1.60277 8.47649,17.88549 17.35796,35.36554 26.33071,49.77353 0.74287,1.49646 1.04381,1.26638 2.18392,0.43235 z m 16.10114,-68.49451 c 8.06997,-2.30699 29.93795,-8.63547 42.36507,-12.53403 1.97258,-0.91595 2.29603,-0.19009 3.2265,1.37333 4.93685,8.346 8.90828,16.37019 11.82532,24.04292 0.81101,1.63884 0.64777,2.08506 -0.57039,3.13816 -21.5295,18.56984 -46.79294,36.91613 -71.77744,55.27912 -0.52818,0.3882 -1.70176,1.37889 -2.77318,1.21709 -1.07143,-0.16179 -2.03138,-1.34058 -2.25756,-1.74155 -14.13892,-25.06442 -19.81454,-37.68038 -27.70129,-53.48098 -0.22439,-0.44954 -0.23539,-1.33202 -0.003,-2.00773 0.23214,-0.67571 0.90296,-1.31228 1.43393,-1.51277 15.77351,-5.95615 22.05873,-6.86297 46.23229,-13.77356 z#000000m 199.25767,389.2731 3.04303,-1.09549 c 9.95284,17.24177 19.54344,34.20423 28.84794,51.12292 l -2.19098,1.82582 c -9.04577,-16.77188 -19.03223,-34.10817 -29.69999,-51.85325 z#000000m 273.02075,368.45877 2.55614,-0.97377 c 3.95594,10.62501 7.54672,20.72127 11.50266,28.78707 l -1.82582,2.13012 c -4.01098,-8.64762 -8.06074,-18.07062 -12.23298,-29.94342 z#000000m 283.25609,368.12103 c 8.56571,-2.6387 16.47429,-5.56945 22.98067,-9.12341 l 4.3035,0.94676 c -6.12149,3.70101 -15.31864,7.40201 -26.25133,11.10302 z#000000m 292.29343,386.28178 c 5.82083,-3.31186 11.68231,-6.82698 17.73041,-11.27516 l 0.17214,3.35673 c -5.31773,3.83366 -11.10221,7.30908 -16.69757,10.15625 z#000000m 223.99569,212.88476 c 2.44838,-1.79166 8.70933,19.39485 40.31025,30.77305 l 0.61726,3.53499 c -32.75735,-12.12348 -43.3759,-32.51638 -40.92751,-34.30804 z#000000m 335.5437,244.03878 c -1.54327,-2.01708 6.22883,-3.82083 19.63888,-14.46395 17.3319,-13.75577 21.14919,-19.59885 22.76187,-17.89303 1.61268,1.70582 -4.65072,6.71639 -20.98647,20.22662 -14.26057,11.79398 -19.87101,14.14744 -21.41428,12.13036 z#000000m 249.93839,294.34539 c -1.08843,-13.81741 -3.39074,-33.66454 0.74762,-34.40202 4.08713,-0.72834 3.95335,12.49575 4.74862,28.0415 0.44725,8.74294 0.58322,17.65725 -1.01196,18.25189 -2.84295,1.05978 -4.0511,-6.39217 -4.48428,-11.89137 z#000000m 344.59284,252.58014 c 3.62536,-0.15165 3.87607,20.20414 3.89508,30.43031 0.0122,6.58257 -0.003,19.31888 -2.43443,19.59712 -3.44964,0.3948 -4.96536,-26.99989 -4.74713,-38.22047 0.0794,-4.0845 0.17705,-11.67689 3.28648,-11.80696 z#000000m 72.556939,157.85222 c 0,0 4.133465,0.19322 4.131356,6.8856 -0.0012,3.75088 -4.19954,12.82441 -6.713454,12.82441 -2.427261,0 -3.873146,-3.44279 -3.873146,-3.44279 0,0 0.529439,4.5617 3.959216,4.5617 2.605358,0 7.574153,-7.87294 7.574153,-14.20153 0,-8.03334 -5.078125,-6.62739 -5.078125,-6.62739 z#000000m 154.28167,117.1044 c 0,0 -3.16475,0.87752 -3.16475,3.95594 0,4.54214 10.56257,11.08555 13.69364,10.83319 6.06022,-0.48844 5.84262,-6.39036 5.84262,-6.39036 0,0 1.46619,7.54672 -6.14692,7.54672 -3.86668,0 -14.405,-6.47409 -14.48483,-12.11127 -0.0555,-3.91575 4.26024,-3.83422 4.26024,-3.83422 z#000000m 206.83841,181.53767 c -0.55762,3.3853 -1.13144,6.68726 -1.87662,9.86612 -11.62549,49.59324 -17.74277,83.92057 3.47477,143.5815 1.63208,4.57631 1.34631,4.36292 1.86668,0.0572 8.20046,-67.80527 23.10991,-126.32341 40.15006,-167.08876 2.1378,-5.11428 3.06825,-3.64589 3.33805,0.41178 3.52836,53.06509 10.08558,105.62102 57.43218,150.99979 1.66327,1.36913 1.55393,0.56499 1.6168,-0.80847 -4.29057,-49.68136 -1.45931,-98.85411 2.21538,-147.96644 0.34474,-4.60751 0.3183,-6.61391 1.07675,-6.97744 0.47421,-0.22729 1.1255,-0.42398 2.7666,1.67499 14.92912,19.09443 28.39621,46.21862 40.28098,74.71218 13.65128,32.72874 25.09124,67.15274 31.78859,92.79428 l 5.55487,-0.8877 c 2.30722,-12.21832 6.6699,-28.2312 6.6699,-37.44042 0,-46.25986 10.20351,-88.72236 -19.4832,-131.6081 -1.32743,-1.91762 -1.88853,-4.1705 -2.35358,-6.43102 -0.40798,-1.72104 -0.24844,-2.47305 0.0625,-2.53716 0.54773,-0.11291 0.70573,0.65634 1.65951,2.15099 27.58001,43.24245 27.16452,60.29308 23.00328,138.75357 -0.62975,11.87402 -3.35545,24.58775 -6.37325,37.86562 l -12.13586,1.29105 C 376.0696,286.06075 352.97625,221.9036 321.249,173.21897 c -1.53034,-2.51656 -2.07113,-2.41823 -2.45849,-2.43498 -0.53981,-0.0233 -0.58101,0.81914 -0.80743,3.71091 -3.51167,44.87584 -5.85773,91.69438 -2.46498,148.07758 0.42155,2.9416 -0.67752,3.00703 -2.58358,1.61488 -39.00648,-29.36009 -61.66245,-93.97244 -61.29921,-146.70942 0.0932,-5.04388 0.25069,-4.88949 -1.31821,-0.54853 -18.90316,52.32828 -29.72011,109.2985 -38.23456,165.11326 -0.55582,5.55752 -0.96017,6.09042 -3.4041,0.95416 -28.47729,-62.02075 -17.5003,-116.54305 -2.97072,-163.54086 2.4702,-8.06614 2.76034,-7.83153 1.13066,2.0817 z#000000m 196.21464,295.06086 -1.94754,-5.84262 c -5.26961,12.00005 -9.80287,24.42087 -14.28363,36.87169 0,0 -0.68006,2.6445 -1.37538,2.54257 -0.69531,-0.10193 -0.73501,-1.51861 -1.04676,-2.82489 -7.67983,-32.17914 -1.74447,-59.21869 0.45811,-74.54092 0.31701,-2.2053 0.81436,-4.47309 0.15092,-4.74919 -0.66344,-0.27611 -2.11038,2.03085 -3.42262,3.60866 -8.48495,10.20215 -16.86838,20.6581 -23.8134,34.71011 -2.75754,-34.01406 14.14817,-63.9577 29.30139,-90.83717 1.07749,-1.91129 2.0947,-3.3903 1.56285,-3.96637 -0.53185,-0.57607 -1.95183,0.56538 -3.71353,1.67274 -10.74858,6.75627 -20.96688,12.89053 -35.42775,23.38453 l 1.46065,-13.7545 c 6.74826,-16.25273 28.23339,-33.04462 61.59095,-50.27087 l 3.43446,-1.22659 c 0,0 2.04168,-0.83434 2.19388,-1.50844 0.1522,-0.6741 -0.0556,-1.6479 -1.0555,-2.22496 -11.73883,-6.77463 -23.48722,-14.42682 -30.95212,-25.26941 -0.97985,-1.4232 -2.53488,-2.88836 -1.79919,-3.6091 0.73569,-0.72074 1.89644,0.92996 3.28064,1.75512 21.53222,12.83591 39.64489,15.21867 48.8665,15.24479 0.34729,9.8e-4 0.68917,-0.0721 0.7898,0.19308 0.10398,0.27396 -0.0365,0.89007 0.13294,1.12647 0.19996,0.27894 0.83467,0.32118 1.14294,0.22971 25.58212,-7.59111 48.88731,-11.54314 72.25569,-12.69532 l -0.34428,-2.75424 c -19.41767,0.73051 -41.96076,1.92651 -70.23305,12.91049 -0.68646,0.2667 -0.11878,-0.58647 -0.42835,-1.03028 -0.35953,-0.51542 -1.58388,-0.65914 -2.32589,-0.69112 -19.58094,-0.84397 -39.54973,-8.83242 -55.36771,-19.40231 -1.80202,-1.20415 -2.98842,-2.41164 -3.77709,-1.94124 -0.78866,0.4704 -0.18828,2.17262 0.68821,4.23996 3.97976,9.38687 11.9573,20.13945 33.39907,32.41141 0.70626,0.40421 0.89018,0.61107 0.8934,0.74422 0.003,0.13314 -0.0737,0.2943 -0.99366,0.4492 -10.85517,1.82774 -43.63068,25.48341 -58.33003,40.47704 l -4.13136,14.28761 -0.89024,16.89058 c 11.69268,-8.10748 20.27882,-14.23962 29.0903,-19.73733 1.20131,-0.74953 2.25725,-1.8424 2.80727,-1.31288 0.55001,0.52953 -0.36056,1.16778 -1.4107,2.87156 -6.71505,10.89473 -24.49878,39.45812 -24.60458,75.3082 l 3.27066,15.49258 c 5.59093,-13.29105 12.8929,-22.51523 19.78182,-31.85638 1.04969,-1.42335 2.15152,-3.55629 2.68243,-3.17407 0.53091,0.38221 -0.18615,2.31975 -0.48545,4.13645 -3.38887,20.56955 -5.71761,49.02927 3.05694,70.72303 0.55994,1.38437 1.14537,3.39693 2.20538,3.37807 1.06002,-0.0189 1.45188,-1.87586 2.12232,-3.498 5.12328,-12.39585 9.82394,-25.37302 15.54029,-36.94167 z#000000m 174.5625,158.4375 c -9.52407,-0.0682 -14.23155,9.03951 -17.46875,22.5 l 3.59375,-2.65625 c 2.9046,-10.50801 7.13459,-17.04175 15.1875,-16.75 2.17976,0.079 6.46875,1.09375 6.46875,1.09375 l 4.25,-2.6875 c -2.93853,-0.80821 -5.22297,-0.65099 -9.71875,-1.3125 -0.79289,-0.11667 -1.5781,-0.18224 -2.3125,-0.1875 z#000000m 201.23146,142.87606 c -10.4521,0.4076 -8.11711,-0.27116 -12.56621,14.54581 l -3.52886,2.84031 c 5.45094,-20.10126 5.08028,-20.68404 13.77118,-19.62394 z#000000m 215.32488,312.58872 c 4.01949,17.21093 6.72949,36.63324 14.99368,52.72691 1.00237,1.95203 1.68133,3.4007 2.50375,3.08227 0.82242,-0.31842 0.5746,-1.74035 0.48966,-3.63951 -0.37556,-8.39707 -0.61608,-13.65583 -0.33751,-22.46969 l 2.79959,1.33894 c 0.18688,7.67134 -0.15201,17.44248 0.11225,25.92976 0.0998,3.20457 -0.37149,4.18459 -1.20775,4.50054 -0.83625,0.31596 -2.45959,-0.0118 -4.32214,-2.93166 -9.71228,-15.22566 -14.459,-41.7398 -16.0053,-51.11257 z#000000m 225.34375,260.78125 -2.4375,7.0625 c 0,0 2.78125,27.08184 2.78125,48.8125 0,17.99661 -0.87282,22.15173 9.28125,29 0.43866,0.29585 0.94257,0.60904 1.4375,0.90625 l 0.0937,-3.125 c -0.12494,-0.0701 -0.25359,-0.14865 -0.375,-0.21875 -9.54454,-5.51054 -6.46106,-11.31452 -7.28125,-27 -1.13139,-21.63678 -3.5,-55.4375 -3.5,-55.4375 z m 146.56906,65.70195 c -0.12425,1.45943 -0.43519,5.15968 -1.81906,6.92305 l 3.1875,1 c 0.33806,-0.52515 0.59375,-0.96875 0.59375,-0.96875 2.03407,-15.13437 1.9791,-29.01533 2.50432,-43.24439 l -2.66542,-7.56086 c 0,0 -0.56645,29.34887 -1.80109,43.85095 z M 348.8125,353.5 l -9.125,0.15625 c -7.67299,2.49629 -16.88255,4.15625 -27.84375,4.15625 -12.44914,0 -24.81462,-1.13264 -36.03125,-2.9375 l -14.78125,0.4375 c 13.1811,2.9707 30.31289,5.0625 51.09375,5.0625 15.559,0 27.5729,-2.94471 36.6875,-6.875 z#000000m 274.37489,329.17323 c 0.32235,0.14256 0.40567,0.39236 0.53068,0.99568 0.65915,3.18125 1.26783,9.62883 8.23281,9.62883 3.70201,0 7.10418,-4.94015 10.03156,-4.94015 2.74751,0 4.28911,5.02622 13.93275,5.02622 7.65622,0 10.7677,-4.71828 13.17625,-8.80835 0.67297,-1.14279 1.29872,-1.71773 1.59379,-1.61537 1.07361,0.37242 1.29071,1.74297 0.70492,3.0012 -2.75652,5.92074 -7.34358,9.94048 -15.80447,9.94048 -9.86891,0 -11.81474,-4.25159 -13.66843,-4.25159 -1.78964,0 -6.29696,4.74713 -9.98114,4.74713 -10.30018,0 -10.82804,-9.23667 -9.60946,-12.77325 0.26678,-0.77426 0.53839,-1.09338 0.86074,-0.95083 z#000000m 253.3019,492.12755 2.19099,2.19098 c -32.59003,27.22711 -65.54689,75.39477 -65.54689,77.96246 1e-5,2.67704 9.81672,3.04736 15.93504,3.04736 14.56582,0 16.50197,-1.29475 25.3311,-13.35737 4.62675,-6.32122 10.01003,-12.74794 15.45777,-19.27648 10.13827,-12.14964 20.71182,-24.22788 28.54182,-33.6477 l 2.06926,1.46066 c -7.99137,9.55323 -18.64267,21.93678 -28.78451,34.35699 -5.23006,6.40499 -10.76689,12.44065 -14.80563,18.89833 -9.6377,15.41007 -17.64989,14.40945 -28.05771,14.40945 -7.20728,0 -18.8519,-0.66098 -18.8519,-5.83039 0,-4.20001 19.8118,-29.73004 30.8444,-43.45238 9.93086,-12.352 18.81217,-21.03832 35.67626,-36.76191 z#000000m 243.00058,504.19323 c 7.03354,8.41444 17.16608,9.85614 26.65647,12.74268 l -1.7214,2.40996 c -8.98747,-3.02714 -18.14715,-3.75808 -26.68168,-12.82442 z#000000m 416.28665,467.53986 c 0,0 9.25081,3.92497 9.25081,18.13646 0,20.25713 -18.86679,51.13311 -18.86679,57.57415 0,7.96006 4.62541,10.17706 4.62541,20.81433 0,4.63567 -5.15041,10.34631 -19.59712,10.34631 -8.12387,0 -20.5709,-3.19442 -20.5709,-13.51106 0,-19.19642 17.13795,-45.88375 19.59713,-57.81759 l 3.28647,-2.79959 c 0.57798,13.56246 -20.08401,39.5991 -20.08401,60.1303 0,9.38345 13.46684,11.68524 18.25819,11.68524 7.59642,0 16.0672,-3.64083 16.0672,-7.79016 0,-8.73591 -4.13852,-12.81591 -4.13852,-21.05778 0,-10.02895 18.62335,-36.41339 18.62335,-57.45243 0,-12.20369 -7.91188,-15.33687 -7.91188,-15.33687 z#000000m 408.92251,483.8505 c 5.29105,-1.01969 9.47253,-3.5928 13.1459,-6.87725 l 1.39979,3.34734 c -6.66033,4.37135 -11.85711,6.12924 -16.24979,6.45122 z#000000m 395.43666,461.64682 c -2.34308,0 -5.00609,-4.00871 -6.2852,-3.14745 -1.1364,0.76517 0.86428,4.03705 0.86428,7.07818 0,2.49628 -9.11773,7.50567 -16.56997,13.1261 -6.06389,4.57335 -15.94347,14.03251 -20.08901,14.03251 -3.64102,0 -11.44703,-6.35837 -16.02402,-10.75523 -8.17382,-7.85215 -10.62371,-14.355 -12.144,-14.355 -1.7452,0 -7.39486,5.53003 -14.44969,9.42373 -6.78107,3.74261 -14.62665,7.57487 -16.7466,7.70943 -3.00201,0.19054 -8.73045,-7.55741 -15.26022,-14.69449 -6.59756,-7.21119 -12.77132,-11.92133 -12.77132,-16.0358 0,-2.13932 5.33773,-3.74931 11.93838,-8.98264 8.08967,-6.41389 19.2132,-14.428 19.95259,-17.18743 0.65521,-2.44529 -1.96637,-5.27359 -0.85205,-7.54671 0.48088,-0.98095 2.20014,-0.79077 2.79959,-1.7041 3.11177,-4.74117 5.49193,-15.94257 6.78125,-23.29122 3.28305,-18.71224 1.49579,-36.47391 1.49579,-36.47391 l 2.67787,0.24344 c 0,0 2.03081,17.72313 -1.47846,36.70232 -1.43142,7.74157 -3.68313,20.05531 -7.52891,24.64519 -0.41201,0.49173 -1.48438,0.0655 -1.82582,0.6086 -1.19727,1.90448 1.66593,4.5975 0.85205,6.69467 -1.60539,4.13671 -3.59063,5.96753 -8.03041,9.78138 -3.67694,3.15855 -9.61093,8.44192 -13.25457,10.65182 -5.57082,3.37874 -10.1191,4.44037 -10.1191,6.22375 0,2.24946 6.26658,7.88387 11.55209,13.90118 5.83778,6.64607 10.83836,13.60783 12.91388,13.60783 2.87126,0 8.65993,-3.36779 14.82404,-6.99333 7.6389,-4.49296 14.89636,-10.53454 17.18864,-10.53454 2.36648,0 6.59244,9.40259 13.37025,15.57456 6.23747,5.67994 10.87813,9.81477 14.26659,9.81477 2.43878,0 9.19684,-7.00762 17.11727,-12.24913 5.63247,-3.7274 16.70673,-10.60962 16.5221,-12.50459 -0.48425,-4.96987 -3.70299,-11.75918 -0.50345,-12.61649 2.71613,-0.72779 4.37245,5.80875 7.99362,5.80875 1.18239,0 6.33952,-9.71894 6.33952,-12.22871 0,-2.60891 -21.79199,-13.49454 -21.79199,-18.66327 0,-6.12202 1.94754,-6.41527 1.94754,-9.31168 0,-1.36529 -4.94425,-0.026 -5.23402,-3.65163 -0.27854,-3.48506 -0.38027,-10.20923 -0.49324,-15.08765 -0.23863,-10.30468 -0.11536,-19.11602 -0.11536,-19.11602 l 1.21721,-14.24139 2.06926,-2.55614 c 0,0 -0.53564,47.6682 0.73033,50.27087 0.97465,2.00377 4.99057,-0.52414 4.99057,3.40819 0,5.2266 -2.13012,4.82096 -2.13012,9.49427 0,4.23753 22.64015,15.15835 22.64015,18.86678 0,2.6438 -7.46836,16.26023 -9.34733,16.26023 z#000000m 386.76924,457.98474 c 15.81572,17.23035 20.18336,27.75245 22.82274,27.75245 2.40946,0 10.58975,-21.38961 10.58975,-29.15224 0,-6.73096 -16.55409,-11.56352 -16.55409,-11.56352 l -1.09549,3.28647 c 0,0 15.32211,2.59339 15.32211,8.61268 0,3.39833 -6.67324,24.00862 -8.62745,24.00862 -1.94438,0 -4.86162,-6.90788 -20.084,-24.52683 z#000000m 374.57627,475.88056 2.15175,-0.8607 c 2.49478,4.77176 9.14483,27.62844 11.87765,27.62844 1.25338,0 14.59718,-11.89315 18.33289,-20.57071 l 3.09852,2.23782 c -5.43655,7.9806 -18.53249,22.72246 -22.20604,22.72246 -2.77576,0 -10.31268,-20.17816 -13.25477,-31.15731 z#000000m 356.7598,489.90996 c 0.34657,14.52929 0.32652,26.50953 2.84031,26.50953 5.67248,0 17.24265,-5.20727 27.71451,-11.70551 l 1.29105,1.63533 c -7.84202,6.53879 -25.29893,12.91049 -29.43591,12.91049 -4.40149,0 -4.14006,-7.87148 -4.73385,-27.71451 z#000000m 333.60699,476.39698 2.40996,3.09852 c -0.89076,14.23072 -5.09809,42.54169 -2.66817,42.69068 2.81889,0.17284 15.55655,-2.6595 24.09958,-5.1642 l 1.89354,1.89354 c -9.7276,3.359 -19.52336,5.74272 -27.54238,5.59454 -4.63846,-0.0857 1.18375,-32.03505 1.80747,-48.11308 z#000000m 310.87605,475.8169 c -1.83066,6.8258 -4.79068,16.72841 -7.08528,24.61912 -2.3308,8.01524 -3.71954,13.80982 -3.15407,15.92017 0.77141,2.87893 6.85145,1.21757 15.03685,3.61525 4.41194,1.29234 11.26186,1.508 15.89511,1.97781 l 0.32952,1.87624 c -3.3601,-0.46868 -10.60298,0.79963 -17.07868,-1.58311 -6.97743,-2.56736 -14.00915,-0.10939 -15.87213,-3.33616 -1.55579,-2.69471 -0.0705,-10.0921 2.44293,-19.39624 1.97195,-7.29978 4.60983,-16.13727 6.68616,-22.35414 z#000000m 288.47934,479.46854 1.82582,1.94754 c -4.97799,9.4234 -14.87087,21.84428 -14.87087,24.3799 0,3.34758 13.36518,9.5897 23.51308,9.94549 l 0.85205,3.04303 c -10.30463,-0.25821 -27.40816,-8.36791 -27.40816,-11.89303 0,-5.12364 9.58371,-16.20795 16.08808,-27.42293 z#000000m 275.5098,464.6054 c -8.73865,9.31072 -23.84137,24.56481 -23.84137,26.68168 0,4.2216 16.32964,14.81612 22.46425,17.55826 l -0.0861,-2.92638 c -6.2113,-2.66339 -19.27966,-12.09541 -19.27966,-14.37367 0,-1.96621 14.48042,-15.38985 22.29211,-24.78814 z#000000m 267.84958,453.41631 c -5.46019,-0.68666 -27.88666,11.70691 -27.88666,16.00901 0,1.47385 7.03221,10.49689 14.63189,19.96822 l 1.63533,-1.97961 c -5.26976,-6.98611 -12.82442,-15.51329 -12.82442,-18.07468 0,-2.25422 18.37097,-13.07324 24.01351,-13.51298 z#000000m 249.08634,463.05614 c 4.05476,6.32627 8.2092,12.50302 13.16869,17.4722 l -2.23782,2.66816 c -5.03287,-6.11096 -9.27964,-12.22193 -13.16869,-18.33289 z#000000m 259.93114,483.71292 c 5.66754,5.07559 11.80693,9.20747 18.16076,12.91049 l -1.11891,2.32389 c -7.25838,-3.88144 -13.75255,-8.16205 -19.02145,-13.08263 z#000000m 278.78046,497.82839 c 6.34256,4.32241 14.22041,6.72571 22.37817,8.77913 l -1.1189,2.92638 c -7.86915,-2.79432 -16.31443,-4.86848 -22.46425,-9.81197 z#000000m 301.50291,506.60752 c 10.17086,3.9213 20.18229,4.81319 30.12447,4.38957 l -0.34428,3.35672 c -9.02847,-0.74075 -16.87813,-0.24654 -30.46875,-5.76668 z#000000m 332.22987,511.42744 c 7.91843,-0.52074 15.83687,-2.16096 23.7553,-4.04529 l 0.51642,2.92638 c -8.3883,1.55305 -16.71431,2.91922 -24.87421,3.78707 z#000000m 356.32945,507.21001 c 11.48527,-2.07751 19.04528,-6.45127 26.07918,-11.36123 l 1.7214,3.09852 c -7.85107,4.82714 -16.25257,9.14316 -27.28416,11.01695 z#000000m 383.69968,495.76271 c 8.14024,-5.69978 13.40544,-13.19646 17.90255,-21.1732 l 2.06567,2.5821 c -3.73941,7.74308 -10.29315,14.95009 -18.84931,21.77569 z#000000m 402.54899,474.50344 c 4.88229,-8.95376 9.84974,-17.95011 9.81198,-24.44385 l 2.75423,1.11891 c -1.24312,9.11387 -6.01102,17.34655 -10.84481,25.56276 z#000000m 306.92532,424.66896 c 8.20172,5.33995 20.21973,7.89823 31.60422,10.05541 -9.10736,0.36189 -29.24628,-4.98873 -31.60422,-10.05541 z#000000m 385.61289,354.09566 4.16194,0.20272 c -5.70226,6.04504 -11.83037,9.86498 -11.83037,11.96941 0,5.25206 -1.31838,28.23932 -13.26762,28.23932 -9.53857,0 -13.71275,-18.24618 -12.90245,-41.99382 l 2.79959,0.85204 c -0.51522,23.24137 4.11444,38.25951 10.10286,38.22047 9.35915,-0.061 10.08198,-20.04026 10.08198,-25.4102 0,-4.21862 5.75756,-5.17792 10.85407,-12.07994 z#000000m 501.9375,304.71875 c -3.05781,0.12604 -6.50239,0.79133 -10.34375,3.375 -10.57046,7.10961 -23.88725,18.8125 -28.03125,18.8125 -13.61104,0 -52.62424,4.1046 -79,4.96875 -17.5059,0.57353 -34.0581,-0.16453 -51.46875,-0.0312 -3.87007,0.0296 -7.78008,0.0632 -11.6875,0.125 l -0.6875,2.15625 c 4.24337,-0.0873 8.49287,-0.15898 12.71875,-0.1875 16.62106,-0.11217 32.89072,1.16992 49.5,0.5625 27.38661,-1.00156 65.81102,-4.84375 80.65625,-4.84375 7.92199,0 27.83509,-22.34375 39.3125,-22.34375 6.31336,0 11.71875,6.8724 11.71875,14.28125 0,9.74198 -28.72611,19.58365 -46,20.6875 21.84959,7.56508 43.09162,17.00065 59.875,25.5625 16.14148,8.23439 28.25,15.58879 28.25,22.875 0,8.26997 -8.95374,22.40625 -19,22.40625 -10.1627,0 -20.67914,-12.90357 -34.46875,-25.03125 -15.60494,-13.72424 -36.21314,-30.05522 -50.46875,-33.875 -3.81308,-1.02171 -27.32501,-1.34571 -52.21875,-1.71875 -16.78702,-0.25155 -33.86702,-0.78923 -47.21875,-0.5625 -28.54836,0.48477 -58.07714,2.03125 -81.09375,2.03125 -7.85551,0 -35.03125,2.73369 -35.03125,-7.75 0.3672,-8.68555 9.85842,-10.75 22.75,-10.75 4.8326,0 9.6764,-0.0689 14.53125,-0.15625 l -0.59375,-2.46875 c -4.57092,0.055 -9.12432,0.125 -13.65625,0.125 -7.6447,0 -25.46875,-1.09178 -25.46875,13.40625 0,12.11891 13.79243,9.96875 37.375,9.96875 21.26912,0 48.92668,-1.26109 75.8125,-1.46875 48.7184,-0.3763 95.70662,0.45364 103.34375,2.5 17.74073,4.75362 35.0506,20.04945 50.5625,34.03125 13.99231,12.6121 24.62924,25 36.03125,25 9.9157,0 21.8125,-15.2755 21.8125,-27.21875 0,-15.66649 -58.03462,-36.16161 -77.40625,-46.46875 10.9255,-2.60648 34.96875,-8.35896 34.96875,-20.65625 0,-10.73215 -6.28291,-17.34375 -14.09375,-17.34375 -0.42168,0 -0.84442,-0.018 -1.28125,0 z#000000m 541.17264,409.72227 c -3.91602,-1.17614 -5.11229,-1.13155 -5.11229,-4.86885 0,-5.67922 7.0103,-16.91925 14.11966,-16.91925 1.98945,0 1.76361,1.56905 1.52152,3.71249 2.26925,-2.09021 0.66324,-4.99057 -1.52151,-4.99057 -8.5754,0 -15.58033,12.29569 -15.58033,18.92766 0,3.75229 1.24986,5.04116 6.57295,4.13852 z#000000m 364.29091,395.6634 c 0,0 1.49582,7.15552 1.49582,9.54983 0,3.38733 -1.88313,9.59628 -1.88313,12.82835 0,3.51628 4.1987,8.03431 8.79976,15.48157 1.66791,2.69966 5.59294,8.46603 6.34855,11.45831 -3.20494,-5.00454 -4.86974,-7.62579 -6.727,-10.24882 -6.02894,-8.51474 -9.10987,-12.37188 -9.10987,-16.51892 0,-4.9997 1.70053,-8.03659 1.70053,-12.69599 0,-3.36296 -0.62466,-9.85433 -0.62466,-9.85433 z#000000m 357.23318,422.21597 c 4.02135,-1.98682 7.88398,-4.21173 11.4473,-6.88559 -4.10703,1.65441 -7.91404,3.96888 -11.4473,6.88559 z#000000m 321.64327,359.3419 c 0.48795,1.82107 2.68424,7.18683 4.47564,7.18683 1.53816,0 4.09259,-5.95169 5.33633,-8.9943 l 4.64778,-0.94677 c -2.21722,2.677 -6.67042,8.32336 -6.67042,10.28536 0,0.89002 3.5043,2.45423 5.25657,3.73022 2.54006,1.84966 4.34758,3.88696 5.33003,3.88696 0.98164,0 2.2534,-4.31602 4.13334,-9.58706 1.31767,-3.69454 3.24063,-8.01152 4.25848,-10.98365 l 3.52886,0.17214 c -1.47289,3.54324 -3.62271,7.76813 -5.24469,11.84516 -2.48763,6.25293 -4.43199,11.86711 -6.24564,11.86711 -2.0822,0 -4.36915,-2.51591 -7.01376,-4.83315 -2.58543,-2.26539 -5.3596,-3.85992 -7.14474,-3.85992 -1.21208,0 -3.7344,1.90914 -5.87485,4.28793 -2.05946,2.28877 -3.73344,5.05066 -5.1421,5.05066 -2.18229,0 -2.58,-8.90647 -2.92638,-19.4518 l 2.92638,0.086 c -0.0196,4.69846 -0.36226,14.15849 1.11891,14.15849 1.07961,0 2.65136,-1.96047 3.61424,-2.92336 1.35205,-1.35204 2.62583,-2.44071 2.62583,-3.35973 0,-1.23985 -3.43413,-4.84577 -4.00225,-8.13361 z#000000m 322.62748,370.41358 c 0,0 -1.27893,5.47389 -0.19481,6.67349 0.71687,0.79323 8.40016,0.93177 8.9365,0.15734 0.66776,-0.96419 1.7214,-5.59455 1.7214,-5.59455 l 3.09852,2.32389 c 0,0 -2.37238,4.01136 -3.55229,5.41017 -0.83978,0.99558 -11.09275,1.32169 -11.90032,0.23911 -1.46067,-1.95806 -1.33102,-6.59605 -1.33102,-6.59605 z#000000m 321.95268,379.17024 c -2.15913,9.07663 -10.94565,20.82022 -11.07663,24.34425 -0.0535,1.43972 3.84563,8.31009 7.00952,13.4994 1.77715,2.91482 2.96884,5.71167 3.96016,5.71167 1.34498,0 4.26183,-3.54904 7.72709,-6.82886 3.33321,-3.15482 6.98641,-6.31475 6.98641,-9.94779 0,-7.28864 -6.28639,-19.52688 -6.57294,-26.77867 l 2.3127,-0.73033 c 0.9004,7.79336 6.81639,22.13484 6.81639,27.38728 0,5.2109 -4.39329,8.57395 -8.19883,12.36483 -4.16933,4.15327 -7.87859,7.8763 -9.69419,7.59745 -2.06523,-0.31719 -3.12014,-3.49845 -5.57253,-7.28407 -3.7335,-5.76321 -8.18668,-12.85195 -7.69509,-14.99091 0.70832,-3.08195 9.44823,-18.15186 12.53729,-26.41351 z#000000m 467.0666,221.9616 c -0.77903,0.27169 -1.46375,0.84304 -2.11759,1.47176 -34.6979,33.36534 -44.2692,51.87533 -60.60526,71.97289 l 0,4.65625 c 17.60239,-20.94232 26.44104,-39.06574 61.08947,-73.34455 0.72946,-0.72168 1.34009,-1.65158 2.35213,-1.75635 1.01205,-0.10478 1.45525,0.73609 2.23733,1.3406 21.80627,16.85514 38.33746,44.56702 46.15003,68.52657 0.29902,0.91701 0.69398,1.61573 0.5573,2.43249 -0.13669,0.81675 -0.72725,1.29151 -1.2605,1.78134 -2.72674,2.50471 -5.78557,4.92052 -9.18826,7.30115 L 508.625,307.75 c 3.40565,-2.4744 6.52178,-4.98767 9.31608,-7.52979 0.66289,-0.60308 1.36443,-1.18359 1.63268,-2.1152 0.26824,-0.93162 -0.0247,-1.81814 -0.23291,-2.88422 -6.11373,-31.30601 -37.71273,-65.93071 -49.85755,-72.62806 -0.98438,-0.54285 -1.63766,-0.90282 -2.4167,-0.63113 z m -82.1916,94.38215 c -2.28395,2.16204 -4.70596,4.3899 -7.31585,6.69191 -0.79355,0.69993 -1.32615,1.16266 -1.61649,2.07756 -0.29033,0.91489 -0.0686,1.51619 0.32235,2.24816 1.12844,2.11282 2.34646,4.20019 3.64124,6.26362 l 4.1875,-0.6875 c -0.98197,-1.49323 -1.9951,-3.07401 -3.12004,-4.84133 -0.51709,-0.81236 -0.92454,-1.58377 -0.8123,-2.60795 0.11225,-1.02419 0.6533,-1.2715 1.36702,-1.92133 1.50781,-1.37281 2.95274,-2.72172 4.34657,-4.03564 z m 11.28125,37.4375 c 1.81311,1.74941 3.64828,3.37814 5.4912,4.86938 0.75197,0.60848 1.58195,1.0638 2.60308,1.1101 1.02113,0.0463 1.67938,-0.32783 2.74139,-0.82723 2.65751,-1.24967 5.51566,-2.55189 8.50808,-3.90225 l -5.71875,-0.375 c -0.74492,0.35727 -1.48286,0.70962 -2.22313,1.06339 -1.00723,0.48135 -1.67712,0.91656 -2.71384,0.82234 -1.03672,-0.0942 -1.5952,-0.61044 -2.17301,-1.19508 -0.4049,-0.40969 -0.80098,-0.81213 -1.20252,-1.2219 z#000000m 459.98457,231.1572 c 33.73254,18.64689 41.01287,55.04132 46.25407,75.34545 l -2.79959,-0.6086 c -7.30842,-26.05981 -15.27965,-54.99767 -45.40202,-73.39791 z#000000m 375.14487,333.88994 3.89508,-4.13853 -1.58238,-2.79959 -4.86885,4.74713 1.33893,2.31271 z#000000m 388.04732,354.70427 c 0,0 6.01666,6.84429 8.27704,6.93811 1.80665,0.075 6.20779,-4.38197 6.20779,-4.38197 l 2.79959,1.94754 c 0,0 -6.40548,5.59918 -9.1291,5.59918 -2.19478,0 -10.58975,-7.79016 -10.58975,-7.79016 z#000000m 479.40943,231.35593 c 0,0 -0.25085,-16.18114 10.50053,-16.18114 5.57059,0 11.98931,5.47632 12.56621,11.01695 0.17827,1.71214 -1.49884,3.88791 -3.22024,3.88791 -1.70564,0 -3.85848,-1.21162 -5.80611,-2.33608 -2.51514,-1.45212 -3.25244,-2.92899 -4.25795,-1.76394 -1.00552,1.16504 0.85937,2.32236 3.08658,3.9799 2.03554,1.5149 5.17355,2.9752 7.25046,2.9752 2.9253,0 5.35721,-3.93911 5.35721,-6.91513 0,-5.72163 -7.90239,-14.14501 -15.0057,-14.14501 -12.77567,0 -12.88095,18.62064 -12.88095,18.62064 z#000000m 495.52718,231.15721 c -0.49402,0.67385 -0.60861,1.22719 -0.60861,2.3127 0,3.72979 3.69524,6.98326 6.64898,8.65644 6.86789,3.8904 12.87102,9.84519 19.76453,9.84519 7.60137,0 15.82376,-17.19737 15.82376,-23.4922 0,-5.84691 -16.43963,-27.62455 -30.55203,-31.28236 -1.28853,-0.33398 -1.80329,0.31556 -2.67787,1.46066 l -2.37356,-2.13012 c 1.10243,-0.86887 2.73098,-1.82582 4.86885,-1.82582 9.84379,0 33.04731,22.09042 33.04731,33.77764 0,6.37402 -7.47405,26.04834 -18.19732,26.04834 -7.46103,0 -18.53724,-8.49031 -25.38401,-13.23411 -2.86653,-1.98608 -3.40307,-6.20853 -3.40307,-7.94538 0,-1.34457 0.44011,-2.51557 1.21722,-3.77336 z#000000m 503.89758,196.87217 c 0,0 3.91492,1.64217 3.91492,4.96178 0,6.35165 -8.0045,16.52542 -8.0045,16.52542 l -2.23782,-1.9796 c 0,0 6.84876,-6.72191 7.22987,-14.20154 0.0324,-0.6362 -0.90247,-5.30606 -0.90247,-5.30606 z#000000m 519.38454,253.43219 c -2.27354,7.09841 -9.65136,6.94336 -16.06721,8.15533 l 1.7311,2.40489 c 8.23646,-1.25602 15.52973,-3.29212 16.84184,-10.27501 z#000000m 484.96875,215.25 3.71875,-1.28125 c -6.90455,-7.10093 -14.22188,-14.6095 -22.71875,-23.125 -13.52559,-13.55524 -35.70202,-33.66951 -55.82105,-48.5732 -5.81406,-4.30692 -11.80057,-7.31799 -17.01257,-10.47058 -6.24648,-3.77833 -11.5307,-7.38435 -16.09636,-8.60771 -12.14844,-3.25517 -31.41762,-2.25815 -43.09292,-0.6685 -15.26367,2.07822 -21.69874,5.53556 -24.28701,5.53556 -3.31206,0 -4.99058,-5.02549 -4.99058,-14.11967 0,-3.98884 -1.53725,-8.9323 1.46066,-11.56352 7.38337,-6.480281 38.52463,-10.55366 58.30448,-12.537285 1.66103,-0.166576 3.42501,0.006 5.14658,0.153639 1.79347,0.153764 3.21068,-0.645223 3.48571,-1.193864 0.27503,-0.548638 -0.41122,-1.930704 -1.32461,-3.437316 -5.96764,-9.843532 -9.37694,-19.340353 -9.37694,-43.845795 0,-4.665275 0.66403,-11.881744 2.77259,-14.220501 2.45797,-2.726307 5.57753,-2.642216 9.24827,-2.642216 5.33562,0 14.37176,6.429958 14.37176,10.533213 0,21.799923 8.68648,55.007465 16.57027,60.732701 8.25342,5.993654 16.07313,11.852364 23.61047,18.737544 13.80312,12.60883 27.25467,27.22562 39.71875,41.1875 13.0445,14.61206 23.74922,31.67537 36.25,45.59375 0.2388,0.26588 0.47852,0.51853 0.71875,0.78125 l -0.84375,-4.40625 -0.5,-1.84375 0.28125,0.21875 c -11.79708,-13.62956 -20.94393,-28.24199 -34.5,-43.46875 -12.97394,-14.57288 -26.2676,-28.74464 -40.75,-41.65625 -7.15931,-6.38279 -14.63742,-12.366647 -22.28034,-17.644489 -6.08019,-4.198692 -15.71314,-37.367064 -15.71314,-58.558984 0,-6.603653 -9.1006,-13.236041 -16.62897,-13.276267 -4.72691,-0.02526 -8.67993,1.453788 -12.4451,4.311712 -2.30627,1.750552 -2.44308,11.712201 -2.44308,16.4079 0,12.422854 0.32808,27.521265 7.14416,40.228853 0.71223,1.327839 1.61893,2.864535 1.28035,3.426038 -0.33859,0.561504 -1.04628,0.670318 -2.38524,0.635184 -0.67443,-0.0177 -1.41703,-0.04008 -2.25979,-0.04008 -9.64506,0 -52.70292,6.397525 -59.27824,13.511063 -3.34605,3.61993 -2.67788,8.61196 -2.67788,14.60655 0,6.71052 3.47659,16.76281 6.32951,16.79753 1.64247,0.02 11.62392,-2.99997 27.39302,-4.96116 12.61418,-1.56881 30.29559,-2.5841 40.28718,0.0931 4.14207,1.10987 8.50333,4.50234 14.71456,8.35537 4.99438,3.09818 11.54991,6.25077 17.37482,10.60359 26.63498,19.90373 59.58886,50.50578 77.24443,69.69156 z m 52.6875,16.3125 -1,4.03125 c 0.68459,1.09639 1.35033,2.21431 1.96875,3.375 4.21044,7.90236 10.34375,15.71231 10.34375,24.6875 0,2.81677 -4.92786,9.125 -8.15625,9.125 -1.83008,0 -4.99756,-9.03753 -15.5625,-20.84375 l -3.34375,1.125 c 9.06668,11.04246 15.68874,22.28125 18.78125,22.28125 5.29017,0 10.46875,-6.6455 10.46875,-11.9375 0,-9.87256 -6.2175,-18.58637 -10.75,-27.25 -0.83453,-1.59516 -1.77593,-3.10599 -2.75,-4.59375 z#000000m 421.57045,154.92585 c 2.869,4.5768 5.73799,8.38791 8.60699,16.009 0,0 -1.42034,3.39697 -1.7214,2.75424 -1.02435,-2.18686 -14.38086,-25.34767 -14.28761,-24.78814 z#000000m 448.5964,177.47616 c -1.09549,10.17976 -5.2404,16.90451 -5.24414,19.20837 -0.01,5.97441 6.20883,27.09179 9.54764,40.35202 l -2.06568,2.92637 c -5.00553,-13.72498 -10.63578,-37.97576 -10.84481,-43.72351 -0.0705,-1.93898 4.24241,-11.04458 6.36917,-20.14036 z#000000m 432.84074,163.4802 c -1.34328,11.27206 -9.1291,31.83126 -9.1291,37.97702 0,6.49839 13.66599,29.67395 20.57089,45.40203 l -2.43442,2.19098 c -7.75457,-18.30577 -21.16183,-37.76897 -21.05778,-47.59301 0.11448,-10.80892 5.54043,-16.03603 9.49426,-39.07251 z#000000m 437.75159,238.06938 c -0.0268,7.11051 -0.61824,13.88224 -2.92638,19.62395 l 4.13136,-4.3035 c 1.47051,-4.10932 1.79801,-7.7798 1.89354,-11.36123 z#000000m 405.21001,209.24738 c 9.7274,22.56975 16.55409,39.77396 16.55409,50.75776 0,2.57256 2.5809,6.26099 5.23402,8.27705 l -1.94754,2.43442 c -3.03688,-2.87042 -6.27493,-7.36443 -6.45123,-10.83319 -0.48512,-9.54464 -7.09419,-28.7342 -12.41557,-41.50694 z#000000m 406.79239,249.41539 c 4.33296,-0.18016 8.60026,0.13203 12.29385,4.74713 l -0.73033,-4.38196 c -2.62571,-1.77365 -4.70938,-3.95383 -11.07664,-2.92131 z#000000m 406.54895,262.56129 c 4.20465,-0.6642 8.27192,-1.46578 14.3631,-0.24344 l 1.33894,2.55614 c -4.93459,-0.65807 -10.00205,-0.91589 -15.58032,0.36516 z#000000m 405.45346,284.59283 c 0,0 4.80798,-6.45123 5.90347,-6.08606 1.0955,0.36516 0.42603,8.64221 0.42603,8.64221 l 3.16475,-3.52992 c 0,0 0.0812,-7.89928 -2.0084,-8.88565 -2.08961,-0.98636 -7.24241,5.59918 -7.24241,5.59918 z#000000m 466.15466,362.01006 c 3.19923,26.33245 3.71863,64.39733 2.7468,78.73861 -2.79763,41.28461 11.46608,104.38145 16.61197,122.86304 0.80181,2.87972 1.09227,4.28624 2.06831,4.28624 0.97605,0 1.85005,-1.48736 2.96453,-2.65183 43.54284,-45.49597 63.22587,-85.68975 72.23254,-123.51101 0.68923,-2.89424 1.33028,-3.07654 2.06861,-3.04318 0.73833,0.0334 1.54144,0.24766 2.38019,3.13729 10.01082,34.48884 17.72566,65.50146 20.0174,83.44393 0.3633,2.84428 0.43409,5.53642 1.15547,5.74433 0.72139,0.20792 1.09714,-2.8716 1.84102,-5.55099 2.30784,-8.31262 4.15734,-18.77878 4.15734,-29.87592 0,-69.16011 -53.45009,-119.81074 -78.4225,-195.66086 l 2.67787,-2.3127 c 27.11887,78.73308 78.5102,129.91128 78.5102,198.04046 0,14.85947 -3.42589,31.0045 -8.22618,43.99853 -1.35617,3.67106 -2.66532,7.96757 -3.68189,7.60247 -1.01658,-0.36509 -0.39333,-4.61478 -0.4714,-8.32858 -0.55347,-26.32961 -8.15539,-56.84425 -18.67951,-89.09393 -0.48941,-1.49973 -0.79073,-2.6151 -1.21291,-2.59311 -0.42217,0.022 -0.8003,1.06267 -1.10511,2.55776 -7.83243,38.4178 -33.91467,79.11684 -73.56067,121.51135 -1.38154,1.47731 -2.31983,2.36791 -3.46349,2.36882 -1.14367,9.1e-4 -1.86415,-1.05219 -2.47775,-2.853 -7.42803,-21.79997 -18.97634,-66.92927 -18.62374,-130.81056 0.11887,-21.53784 1.38221,-45.10044 -2.0892,-79.21214 z#000000'! !!RSAnimationExamples methodsFor: 'data'!puzzlePiece	^ 'M3.739,13.619c0,0,3.516-4.669,5.592-3.642c2.077,1.027-0.414,2.795,1.598,3.719c2.011,0.924,5.048-0.229,4.376-2.899c-0.672-2.67-1.866-0.776-2.798-2.208c-0.934-1.432,4.586-4.59,4.586-4.59s3.361,6.651,4.316,4.911c1.157-2.105,3.193-4.265,5.305-1.025c0,0,1.814,2.412,0.246,3.434s-2.917,0.443-3.506,1.553c-0.586,1.112,3.784,4.093,3.784,4.093s-2.987,4.81-4.926,3.548c-1.939-1.262,0.356-3.364-2.599-3.989c-1.288-0.23-3.438,0.538-3.818,2.34c-0.13,2.709,1.604,2.016,2.797,3.475c1.191,1.457-4.484,4.522-4.484,4.522s-1.584-3.923-3.811-4.657c-2.227-0.735-0.893,2.135-2.917,2.531c-2.024,0.396-4.816-2.399-3.46-4.789c1.358-2.391,3.275-0.044,3.441-1.951C7.629,16.087,3.739,13.619,3.739,13.619z'! !!RSAnimationExamples methodsFor: 'data'!supermarketCart	^ 'M29.02,11.754L8.416,9.473L7.16,4.716C7.071,4.389,6.772,4.158,6.433,4.158H3.341C3.114,3.866,2.775,3.667,2.377,3.667c-0.686,0-1.242,0.556-1.242,1.242c0,0.686,0.556,1.242,1.242,1.242c0.399,0,0.738-0.201,0.965-0.493h2.512l5.23,19.8c-0.548,0.589-0.891,1.373-0.891,2.242c0,1.821,1.473,3.293,3.293,3.293c1.82,0,3.294-1.472,3.297-3.293c0-0.257-0.036-0.504-0.093-0.743h5.533c-0.056,0.239-0.092,0.486-0.092,0.743c0,1.821,1.475,3.293,3.295,3.293s3.295-1.472,3.295-3.293c0-1.82-1.473-3.295-3.295-3.297c-0.951,0.001-1.801,0.409-2.402,1.053h-7.136c-0.601-0.644-1.451-1.052-2.402-1.053c-0.379,0-0.738,0.078-1.077,0.196l-0.181-0.685H26.81c1.157-0.027,2.138-0.83,2.391-1.959l1.574-7.799c0.028-0.145,0.041-0.282,0.039-0.414C30.823,12.733,30.051,11.86,29.02,11.754zM25.428,27.994c-0.163,0-0.295-0.132-0.297-0.295c0.002-0.165,0.134-0.297,0.297-0.297s0.295,0.132,0.297,0.297C25.723,27.862,25.591,27.994,25.428,27.994zM27.208,20.499l0.948-0.948l-0.318,1.578L27.208,20.499zM12.755,11.463l1.036,1.036l-1.292,1.292l-1.292-1.292l1.087-1.087L12.755,11.463zM17.253,11.961l0.538,0.538l-1.292,1.292l-1.292-1.292l0.688-0.688L17.253,11.961zM9.631,14.075l0.868-0.868l1.292,1.292l-1.292,1.292l-0.564-0.564L9.631,14.075zM9.335,12.956l-0.328-1.24L9.792,12.5L9.335,12.956zM21.791,16.499l-1.292,1.292l-1.292-1.292l1.292-1.292L21.791,16.499zM21.207,14.5l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,14.5zM18.5,15.791l-1.293-1.292l1.292-1.292l1.292,1.292L18.5,15.791zM17.791,16.499L16.5,17.791l-1.292-1.292l1.292-1.292L17.791,16.499zM14.499,15.791l-1.292-1.292l1.292-1.292l1.292,1.292L14.499,15.791zM13.791,16.499l-1.292,1.291l-1.292-1.291l1.292-1.292L13.791,16.499zM10.499,17.207l1.292,1.292l-0.785,0.784l-0.54-2.044L10.499,17.207zM11.302,20.404l1.197-1.197l1.292,1.292L12.5,21.791l-1.131-1.13L11.302,20.404zM13.208,18.499l1.291-1.292l1.292,1.292L14.5,19.791L13.208,18.499zM16.5,19.207l1.292,1.292L16.5,21.79l-1.292-1.291L16.5,19.207zM17.208,18.499l1.292-1.292l1.291,1.292L18.5,19.79L17.208,18.499zM20.499,19.207l1.292,1.292L20.5,21.79l-1.292-1.292L20.499,19.207zM21.207,18.499l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,18.499zM23.207,16.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,16.499zM25.207,14.499l1.292-1.292L27.79,14.5l-1.291,1.292L25.207,14.499zM24.499,13.792l-1.156-1.156l2.082,0.23L24.499,13.792zM21.791,12.5l-1.292,1.292L19.207,12.5l0.29-0.29l2.253,0.25L21.791,12.5zM14.5,11.791l-0.152-0.152l0.273,0.03L14.5,11.791zM10.5,11.792l-0.65-0.65l1.171,0.129L10.5,11.792zM14.5,21.207l1.205,1.205h-2.409L14.5,21.207zM18.499,21.207l1.206,1.206h-2.412L18.499,21.207zM22.499,21.207l1.208,1.207l-2.414-0.001L22.499,21.207zM23.207,20.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,20.499zM25.207,18.499l1.292-1.291l1.291,1.291l-1.291,1.292L25.207,18.499zM28.499,17.791l-1.291-1.292l1.291-1.291l0.444,0.444l-0.429,2.124L28.499,17.791zM29.001,13.289l-0.502,0.502l-0.658-0.658l1.016,0.112C28.911,13.253,28.956,13.271,29.001,13.289zM13.487,27.994c-0.161,0-0.295-0.132-0.295-0.295c0-0.165,0.134-0.297,0.295-0.297c0.163,0,0.296,0.132,0.296,0.297C13.783,27.862,13.651,27.994,13.487,27.994zM26.81,22.414h-1.517l1.207-1.207l0.93,0.93C27.243,22.306,27.007,22.428,26.81,22.414z'! !!TSShapeExamples methodsFor: 'box and ellipses'!example01BasicBoxes	<script: 'self new example01BasicBoxes'>	| c |	c := TSCanvas new.	c addShape: (TSBox new		extent: 100@100;		yourself).	c addShape: (TSBox new		position: 100@100;		color: Color red;		extent: 100@100;		yourself).	c open! !!TSShapeExamples methodsFor: 'box and ellipses'!example02BasicEllipses	<script: 'self new example02BasicEllipses'>	| c |	c := TSCanvas new.	c addShape: (TSEllipse new		extent: 100@100;		yourself).	c addShape: (TSEllipse new		position: 100@100;		color: Color red;		extent: 100@100;		yourself).	c open! !!TSShapeExamples methodsFor: 'box and ellipses'!example03BasicComposite	<script: 'self new example03BasicComposite'>	| c com |	c := TSCanvas new.	com := TSComposite new.	com add: (TSBox new		color: (Color gray alpha: 0.4);		extent: 100@100;		yourself).	com add: (TSBox new		position: 100@100;		color: (Color red alpha: 0.4);		extent: 100@100;		yourself).			c addShape: com.		c addShape: (TSEllipse new		color: (Color gray alpha: 0.4);		extent: 100@100;		yourself).	c addShape: (TSEllipse new		position: 100@100;		color: (Color red alpha: 0.4);		extent: 100@100;		yourself).	c open! !!TSShapeExamples methodsFor: 'box and ellipses'!example04BasicComposite	<script: 'self new example04BasicComposite'>	| c com |	c := TSCanvas new.	com := TSComposite new.	com add: (TSBox new		color: (Color yellow alpha: 0.5);		position: -50 @ 0;		extent: 50@100;		yourself).	com add: (TSBox new		position: 0 @ 0;		color: (Color red alpha: 0.5);		extent: 50@100;		yourself).			com position: 100@100.		c addShape: com.		c addShape: (TSEllipse new		color: (Color gray alpha: 0.5);		extent: 100@100;		yourself).	c addShape: (TSEllipse new		color: (Color gray alpha: 0.5);		extent: 20@20;		yourself).	c open! !!TSShapeExamples methodsFor: 'box and ellipses'!example05BasicGroup	<script: 'self new example05BasicGroup'>	| c |	c := TSCanvas new.	c addShape: (TSBox new		color: (Color yellow alpha: 0.5);		position: -50 @ 0;		extent: 50@100;		yourself).	c addShape: (TSBox new		position: 0 @ 0;		color: (Color red alpha: 0.5);		extent: 50@100;		yourself).					c addShape: (TSEllipse new		color: (Color gray alpha: 0.5);		extent: 100@100;		yourself).	c addShape: (TSEllipse new		color: (Color gray alpha: 0.5);		extent: 20@20;		yourself).	c open! !!TSShapeExamples methodsFor: 'labels'!example06BasicLabels	<script: 'self new example06BasicLabels'>	| c label |	c := TSCanvas new.	1 to: 12 do: [ :m | 		| angle theta p|		angle := (m * 360 / 12) degreesToRadians.		theta := angle cos @ angle sin.		p := theta * 100.		label := TSLabel new			color: (Color purple alpha: 0.5);			fontName: 'Source Sans Pro';			fontSize: 20;			text: (Month nameOfMonth: m);			yourself.		angle := angle radiansToDegrees.		angle := angle + ((angle between: 90 and: 270) 			ifTrue: [ 180 ]			ifFalse: [ 0 ] ).				label rotateByDegrees: angle..		label position: p + ((label textWidth/2) * theta).		m even			ifTrue: [ label bold ]			ifFalse: [ label italic ].		c addShape: label.		].	c addShape: (TSEllipse new		color: nil;		border: TSBorder new;		radius: 90).	c open	! !!TSShapeExamples methodsFor: 'events'!example07EventsMouseMoveDrag	<script: 'self new example07EventsMouseMoveDrag'>	| c ellipse a b update anim |	c := TSCanvas new.	ellipse := TSEllipse new		radius: 40;		border: TSBorder new.	c addShape: ellipse.	a := Color colorFrom: '12A288'.	b := Color colorFrom: 'AB2567'.	update := [ :evt :color |		ellipse 			color: color;			position: evt position;			signalUpdate].	anim := nil.	c		when: TSMouseDragging do: [ :evt | update value: evt value: a ];		when: TSMouseMove do: [ :evt | update value: evt value: b  ].	c clearBackground: false.		c open.	! !!TSShapeExamples methodsFor: 'box and ellipses'!example08EllipseBorder	<script: 'self new example08EllipseBorder'>	| c y r |	c := TSCanvas new.	r := SharedRandom globalGenerator.	c color: (Color colorFrom: '325A64').	1 to: 500 do: [ :x|		y := 255 + (x sin * 255).		c addShape: (TSEllipse new			color: Color transparent;			border: (TSBorder new				width: x/ 50;				color: (Color 					r: r next * 255 					g: r next * 200					b: 255					range: y) );			position: (x*2@y)-250;			extent: (y/10)@( x * 75/ 499 ) ).		 ].	"m := c morph.	PolymorphSystemSettings setDesktopLogoWith: m.	m position: 0@World menubar height.	m extent: World extent- (0@World menubar height)."	c open! !!TSShapeExamples methodsFor: 'events'!example09MouseStep	<script: 'self new example09MouseStep'>	|  c e prev dif |	c := TSCanvas new.	c color: Color black.	e := TSEllipse new		border: (TSBorder new color: Color white);		radius: 0.	c addShape: e.	prev := 0.	c when: TSMouseMove do: [ :evt | 		dif := (evt position x - prev) abs.		prev := evt position x.		e 			color: (Color r: 0 g: dif b: 0 range: 255);			position: evt position;			size: dif.		c signalUpdate.		 ].	c clearBackground: false.	c open.! !!TSShapeExamples methodsFor: 'events'!example10EllipseMouseMove	<script: 'self new example10EllipseMouseMove'>	| c border circleResolution angle a b radius |	c := TSCanvas new.	c color: Color white.	border := TSBorder new color: (Color colorFrom: '002800').	b := 1.	radius := 200.	c when: TSMouseMove do: [ :evt | 		circleResolution := b.		circleResolution isZero ifTrue: [ circleResolution := 1 ].		angle := Float twoPi / circleResolution.		a := 175 * evt position x / c extent x.		b := 200 * evt position y / c extent y.		c shapes copy do: #remove.		0 to: circleResolution do: [ :i |			c addShape: (TSEllipse new 				color: Color transparent;				rotateByDegrees: 45;				border: border;				extent: ((angle * i) cos @ (angle * i) sin) * radius + a			)].				c signalUpdate.		 ].	c open.! !!TSShapeExamples methodsFor: 'events'!example11ScaleMouseDistance	<script: 'self new example11ScaleMouseDistance'>	| c easing canvasExtent boxSize zindex maxDist scale border |	c := TSCanvas new.	c color: Color white.	easing := 0@0.	boxSize := 50.	canvasExtent := 500 asPoint.	maxDist := 0@0 dist: canvasExtent.	scale := TSScale linear 		domain: { 0. maxDist}; 		rangeRound: #(80 0).	border := TSBorder new.	c when: TSExtentChangedEvent do: [ 		c shapes copy do: #remove.		canvasExtent := c extent.		maxDist := 0@0 dist: canvasExtent.		scale := TSScale linear 			domain: { 0. maxDist}; 			rangeRound: #(80 0).		0 to: canvasExtent y/boxSize do: [ :y|			0 to: canvasExtent x/boxSize do: [ :x| 				c addShape: (TSBox new 					color: Color white;					position: ((x@y)*boxSize) - (canvasExtent/2);					extent: 10@10;					border: border )				] ]		].	c when: TSMouseMove do: [ :evt | 		easing := easing + ((evt position - easing)* 0.1).		c shapes copy do: [ :s |			zindex := scale scale: (easing dist: s position).			s extent: boxSize * (zindex /100) asPoint ].		c signalUpdate.	].	c clearBackground: false.	c open.! !!TSShapeExamples methodsFor: 'lines'!example12BasicLine	<script: 'self new example12BasicLine'>	| c |	c := TSCanvas new.	c addShape: TSLine new.	c open.! !!TSShapeExamples methodsFor: 'bitmap'!example14BasicBitmap	<script: 'self new example14BasicBitmap'>	| c |	c := TSCanvas new.	c addShape: (TSBitmap new		form: (self iconNamed: #eyedropper);		extent: 200@350).			c open! !!TSShapeExamples methodsFor: 'box and ellipses'!example15BasicRoundBoxses	<script: 'self new example15BasicRoundBoxses'>	| c |	c := TSCanvas new.	c addShape: (TSBox new		cornerRadius: 5;		extent: 100@50).			c addShape: (TSBox new		cornerRadius: (TSCornerRadius new top: 20);		position: 100@100;		extent: 100@50;		border: TSBorder new).			c open! !!TSShapeExamples methodsFor: 'lines'!example16BasicLinePath	<script: 'self new example16BasicLinePath'>	| c b1 b2 translate l arrowWidth arrowHeight middle |	c := TSCanvas new.	b1 := TSBox new size: 100@100.	b2 := TSBox new size: 100@100; color: Color blue; position: 100@100.	c addShape: b1.	c addShape: b2.		l := TSSVGPathLine new		svgPath: [ :a :b |			[ :canvas | | vector u unit left right left1 right1 |			arrowWidth := 50.			arrowHeight := 30.			vector := a-b.			u := vector normal.			unit := vector / (vector r max: 1).			middle := b + (unit* arrowHeight).			left := middle - (u * arrowWidth / 4).			right := middle + (u * arrowWidth / 4).			left1 := middle - (u * arrowWidth / 2).			right1 := middle + (u * arrowWidth / 2).						canvas				absolute;				moveTo: a;				lineTo: left;				lineTo: left1;				lineTo: b;				lineTo: right1;				lineTo: right;				close.			 ]			 ];		width: 5;		paint: Color yellow;		dashArray: { 10. 2 };		joinMiter;		startPoint: 0@0;		endPoint: 100@100.	c addShape: l.		translate := [ :evt |		l 			startPoint: b1 position;			endPoint: b2 position.		evt shape translateBy: evt step.		evt signalUpdate ].	b1 when: TSMouseDragging do: translate.	b2 when: TSMouseDragging do: translate.	c open! !!TSShapeExamples methodsFor: 'border'!example17Borders	<script: 'self new example17Borders'>	| c border border2 a b ce d |	c := TSCanvas new.	border := [ :position :inner :outer :text |		c addShape: (TSBox new			color: Color lightGray;			position: position;			border: (TSBorder new				capSquare;				joinMiter;				color: inner);"brighter"			size: 100).		c addShape: (TSBox new			color: nil;			position: position;			border: (TSBorder new				capSquare;				dashArray: #(98 196);				color: outer);"darker"			size: 98).		c addShape: (TSBox new			color: nil;			position: position;			border: (TSBorder new				capSquare;				dashArray: #(0 102 102 0 102 0);				color: outer);"darker"			size: 102).		c addShape: (TSLabel new			text: text;			position: position;			color: Color black).		 ].	border2 := [ :position :text |				c addShape: (TSBox new			color: Color lightGray;			position: position;			size: 100).		c addShape: (TSLine new			startPoint: position - 50;			endPoint: position + (50 @ -50);			color: a).		c addShape: (TSLine new			startPoint: position - 50;			endPoint: position + (-50 @ 50);			color: a).		c addShape: (TSLine new			startPoint: position - 49;			endPoint: position + (49 @ -49);			color: b).		c addShape: (TSLine new			startPoint: position - 49;			endPoint: position + (-49 @ 49);			color: b).					c addShape: (TSLine new			startPoint: position + (-49@49);			endPoint: position + 49;			color: ce ).		c addShape: (TSLine new			startPoint: position + (49@ -49) ;			endPoint: position + (49 @ 49);			color: ce).					c addShape: (TSLine new			startPoint: position + (-50@50);			endPoint: position + 50;			color: d).		c addShape: (TSLine new			startPoint: position + (50@ -50);			endPoint: position + (50 @ 50);			color: d).		c addShape: (TSLabel new			text: text;			position: position;			color: Color black).		 ].		"line border"	c addShape: (TSBox new		color: Color lightGray;		border: TSBorder new;		size: 100).	c addShape: (TSLabel new		text: 'Line border';		color: Color black).	"raised etched"	border 		value: 120@0		value: (Color lightGray adjustBrightness: 0.08)		value: (Color lightGray adjustBrightness: -0.08)		value: 'Raised etched'.		"lowered etched"	border 		value: -120@0		value: (Color lightGray adjustBrightness: -0.08)		value: (Color lightGray adjustBrightness: 0.08)		value: 'Lowered etch'.	"Raised bevel"	b := Color lightGray adjustBrightness: 0.08.	a := b adjustBrightness: 0.08.	ce := Color lightGray adjustBrightness: -0.08.	d := ce adjustBrightness: -0.08.	border2		value: 0@ -120		value: 'Raised bevel'.	"Lowered bevel"	b := Color lightGray adjustBrightness: -0.08.	a := b adjustBrightness: -0.08.	ce := Color lightGray adjustBrightness: 0.08.	d := ce adjustBrightness: 0.08.	border2 		value: 0@ 120		value: 'Lowered bevel'.	RSDraggableView new onElement: c.	RSZoomableView new onElement: c.	c open.! !!TSShapeExamples methodsFor: 'arcs'!example18BasicPieSlice	<script: 'self new example18BasicPieSlice'>	| c |	c := TSCanvas new.	"empty"	c addShape: TSPieSlice new.	"circle"	c addShape: (TSPieSlice new		innerRadius: 0;		externalRadius: 100;		alphaAngle: 0;		betaAngle: 360).	c open.! !!TSShapeExamples methodsFor: 'arcs'!example19PieSlice	<script: 'self new example19PieSlice'>	| c |	c := TSCanvas new.	"slice"	c addShape: (TSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 30;		betaAngle: 90;		segmentSpacing: 5).	c open.! !!TSShapeExamples methodsFor: 'arcs'!example20Donut	<script: 'self new example20Donut'>	| c |	c := TSCanvas new.	"donut"	c addShape: (TSPieSlice new		border: TSBorder new;		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 360).	c open.! !!TSShapeExamples methodsFor: 'arcs'!example21CornerRadii	<script: 'self new example21CornerRadii'>	| c |	c := TSCanvas new.	"corner radii"	c addShape: (TSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 45;		cornerRadii: 20).	c open.! !!TSShapeExamples methodsFor: 'arcs'!example22BasicPieSlice	<script: 'self new example22BasicPieSlice'>	| c |	c := TSCanvas new.	"slice"	c addShape: (TSPieSlice new		externalRadius: 100;		alphaAngle: 30;		betaAngle: 90).	c open.! !!TSShapeExamples methodsFor: 'box and ellipses'!example23FixedShape	<script: 'self new example23FixedShape'>	| c box |	c := TSCanvas new.	box := TSBox new		extent: 100@100;		position: 200 asPoint;		color: Color blue;		yourself.	box isFixed: true.	c addShape: box.		box := TSBox new		extent: 100@100;		yourself.	c addShape: box.	box setAsFixed.	c open.! !!TSShapeExamples methodsFor: 'lines'!example24Polyline	<script: 'self new example24Polyline'>	| c |	c := TSCanvas new.	c addShape: (TSPolyline new		controlPoints: { 5@30. 15@30. 15@20. 25@20. 25@10. 35@10}).	c open.! !!TSShapeExamples methodsFor: 'labels'!example25LabelWithBorder	<script: 'self new example25LabelWithBorder'>	| c |	c := TSCanvas new.	c addShape: (TSLabel new		fontSize: 60;		fontName: 'Source Sans Pro';		"fontName: 'Brushcrazy DEMO';"		border: (TSBorder new 			color: Color red;			dashArray: #(4) );		text: 'Roassal Pharo').	c open.! !!TSShapeExamples methodsFor: 'box and ellipses'!example26Polygon	<script: 'self new example26Polygon'>	| c |	c := TSCanvas new.	c addShape: (TSPolygon new		points: { 100@10. 40@198. 190@78. 10@78. 160@198 };		yourself).	c shapes first translateTo: 0@0.	c showEncompassingRectangles.	c shapes first when: TSMouseDragging do: [:evt |		evt shape translateBy: evt step; signalUpdate].	c open.! !!TSShapeExamples methodsFor: 'lines'!example27Markers	<script: 'self new example27Markers'>	| c arrow axes circle dataLine |	c := TSCanvas new.	arrow := TSPolygon new 		points: { -10@0. 0@ -10. 10@0 };		color: Color black;		size: 10.	circle := TSEllipse new		radius: 2.5;		color: Color red.	axes := TSPolyline new		controlPoints: { 10@10. 10@90. 90@90 }.	dataLine := TSPolyline new 		controlPoints: { 15@80. 29@50. 43@60. 57@30. 71@40. 85@15 }.	axes markerEnd: (axes markerStart: arrow).	dataLine marker: circle.	c addShape: axes.	c addShape: dataLine.	c camera zoomToFit: 250@250.	c open.! !!TSShapeExamples methodsFor: 'svg'!example28SVGShape	<script: 'self new example28SVGShape'>	| c |	c := TSCanvas new.	c addShape: (TSSVGPath new		paint: nil;		border: TSBorder new;		svgPath: 'M 100 350 q 150 -300 300 0';		yourself).	c addShape: (TSSVGPath new		paint: nil;		border: (TSBorder new color: Color red);		svgPath: 'M 100 350 l 150 -300';		yourself).	c addShape: (TSSVGPath new		paint: nil;		border: (TSBorder new color: Color red);		svgPath: 'M 250 50 l 150 300';		yourself).	c addShape: (TSSVGPath new		paint: nil;		border: (TSBorder new color: Color green);		svgPath: 'M 175 200 l 150 0';		yourself).	c showEncompassingRectangles.	c zoomToFit.	c open! !!TSShapeExamples methodsFor: 'lines'!example29PolylineRadius	<script: 'self new example29PolylineRadius'>	| c |	c := TSCanvas new.	c addShape: (TSPolyline new		border: (TSBorder new width: 10);		cornerRadii: 50;		controlPoints: { 5@30. 15@30. 15@20. 25@20. 25@10. 35@10} * 50).	c zoomToFit.	c open! !!TSShapeExamples methodsFor: 'box and ellipses'!example30PolygonWithRadius	<script: 'self new example30PolygonWithRadius'>	| c |	c := TSCanvas new.	c addShape: (TSPolygon new		cornerRadii: 10;		points: { 100@10. 40@198. 190@78. 10@78. 160@198 };		yourself).	c shapes first translateTo: 0@0.	c showEncompassingRectangles.	c shapes first when: TSMouseDragging do: [:evt |		evt shape translateBy: evt step; signalUpdate].	c open.! !!RSLayoutExamples methodsFor: 'layouts'!example01LayoutBasic	<script: 'self new example01LayoutBasic'>	| v elements |	v := RSView new.	elements := RSShapeBuilder box		size: #yourself;		position: [:m | (1 to: m) sum asPoint -150 ];		interactionDo: #draggable;		onElement;		color: [ :e | e index even 			ifTrue: [ Color red alpha: 0.5 ]			ifFalse: [ Color blue alpha: 0.5 ] ];		elementsOn: (1 to: 20).	v addAll: elements.	RSGridLayout on: elements.	v open	! !!RSLayoutExamples methodsFor: 'layouts'!example02Grid	<script: 'self new example02Grid'>	| v elements |	v := RSView new.	elements := RSShapeBuilder box		size: #numberOfMethods;		interactionDo: #draggable;		elementsOn: (Collection withAllSubclasses).	v addAll: elements.	RSGridLayout on: elements.	v open	! !!RSLayoutExamples methodsFor: 'layouts'!example03LayoutColorFadingBasic	<script: 'self new example03LayoutColorFadingBasic'>	| v elements color |	v := RSView new.	color := TSScale linear		domain: #(1 20);		range: {Color red. Color green}.			elements := RSShapeBuilder box		size: #yourself;		position: [:m | (1 to: m) sum asPoint -150 ];		interactionDo: #draggable;		onElement;		color: [ :e | color scale: e index ];		elementsOn: (1 to: 20).	v addAll: elements.	RSGridLayout on: elements.	v open	! !!RSLayoutExamples methodsFor: 'layouts'!example04LayoutColorFadingBasic2	<script: 'self new example04LayoutColorFadingBasic2'>	| v elements color |	v := RSView new.	color := TSScale linear		domain: #(1 10 20);		range: { Color red. Color green. Color blue }";		interpolate: TSColorHSVAInterpolator".					elements := RSShapeBuilder box		size: #yourself;		position: [:m | (1 to: m) sum asPoint -150 ];		interactionDo: #draggable;		color: [ :m |color scale: m ];		elementsOn: (1 to: 20).	v addAll: elements.	RSGridLayout on: elements.	v open	! !!RSLayoutExamples methodsFor: 'layouts'!example05LayoutBasicWithColorFading	<script: 'self new example05LayoutBasicWithColorFading'>	| v elements minAndMax color |	v := RSView new.	minAndMax := Collection withAllSubclasses inject: { 10000 . 0 } into: [ :res :cls | {res first min: cls numberOfMethods . res second max: cls numberOfMethods}].	color := TSScale linear		domain: minAndMax;		range: { Color green . Color red }.	elements := RSShapeBuilder box		size: #numberOfMethods;		interactionDo: #draggable;		color: [ :cls | color scale: cls numberOfMethods ];		elementsOn: (Collection withAllSubclasses).	v addAll: elements.	RSGridLayout on: elements.	v @ RSDraggableView .	v open	! !!RSLayoutExamples methodsFor: 'layouts'!example05TreeLayout	<script: 'self new example05TreeLayout'>	| v elements eb |	v := RSView new.	elements := RSShapeBuilder circle		interactionDo: #draggable;		elementsOn: Collection withAllSubclasses.	v addAll: elements.	RSNormalizer color		from: (Color gray alpha: 0.5);		to: (Color red alpha: 0.5);		elements: elements;		normalize: #numberOfMethods.	RSNormalizer size		elements: elements;		normalize: #numberOfMethods.	eb := RSEdgeBuilder line.	eb view: v.	eb connectFrom: #superclass.	RSTreeLayout on: elements.	elements do: [ :e | e translateBy: 0 @ 0 ].	v @ RSDraggableView.	v open! !!RSLayoutExamples methodsFor: 'layouts'!example06Cluster	<script: 'self new example06Cluster'>	| v sb eb |	v := RSView new.	sb := RSShapeBuilder circle.	v addAll: (sb elementsOn: GLMBrickedMorph withAllSubclasses).	eb := RSEdgeBuilder line		view: v;		color: Color blue trans;		connectFrom: #superclass.	RSNormalizer size		scale:			(TSScale log				base: 2.7;				range: {1 . 30});		elements: v elements;		normalize: #numberOfMethods.	RSNormalizer color		scale:			(TSScale log				base: 2.7;				range:					{Color blue.					Color red});		elements: v elements;		normalize: #numberOfMethods.	RSClusterLayout on: v elements.	v open! !!RSLayoutExamples methodsFor: 'lines'!example07ForceBasedLayout	<script: 'self new example07ForceBasedLayout'>	| v sb eb |	v := RSView new.	sb := RSShapeBuilder circle		interactionDo: [ :i | 			i				draggable;				popup ].	v addAll: (sb elementsOn: TSShape withAllSubclasses).	RSNormalizer size		elements: v elements;		normalize: #numberOfMethods.	RSNormalizer color		from: (Color green alpha: 0.5);		to: (Color red alpha: 0.5);		elements: v elements;		normalize: #numberOfMethods.	eb := RSEdgeBuilder line.	eb		view: v;		moveBehind;		connectFrom: #superclass.	RSForceBasedLayout new		charge: -350;		on: v elements.	v @ RSControlsView.	v zoomToFit.	v open! !!RSLayoutExamples methodsFor: 'lines'!example08HorizontalTree	<script: 'self new example08HorizontalTree'>	| v sb label box |	v := RSView new.	label := RSShapeBuilder label.	box := RSShapeBuilder box		border: TSBorder new;		cornerRadius: (TSCornerRadius new right: 10);		extent: [ :lb | lb extent + 5 ].	sb := RSShapeBuilder composite		interactionDo: #draggable;		shapes: [ :m | | l |			l := label elementOn: m.			TSGroup with: (box elementOn: l) with: l].	v addAll: (sb elementsOn: String withAllSubclasses).	v @ RSControlsView.	RSEdgeBuilder orthoHorizontal		markerEnd: (TSMarker new 			offset: 2;			shape: (RSShapeBuilder triangle 				color: Color black;				size: 5;				element));		attachPoint: RSHorizontalAttachPoint new; 		view: v;		elements: v elements;		connectFrom: #superclass.	RSHorizontalTreeLayout new on: v elements.	v open setLabel: 'Horizontal Tree'! !!RSLayoutExamples methodsFor: 'lines'!example09BorderAttachPoint	<script: 'self new example09BorderAttachPoint'>	| v sb |	v := RSView new.	sb := RSShapeBuilder square 		interactionDo: #draggable;		size: 30.	v addAll: (sb elementsOn: (TSShape withAllSubclasses) ).	RSEdgeBuilder arrowedLine 		withBorderAttachPoint;		view: v;		connectFrom: #superclass.	RSForceBasedLayout new 		charge: -500; 		on: v elements.	v @ RSControlsView.	v open setLabel: 'TSShape withAllSubclasses'! !!RSLayoutExamples methodsFor: 'lines'!example10Locate	<script: 'self new example10Locate'>	| v shape e1 e2 |	v := RSView new.	shape := RSShapeBuilder box		@ RSDraggable;		onElement;		color: TSColorPalette sequential blues3;		size: 100.	e1 := shape element.	"e1 @ RSDraggable."	e2 := shape element.	e2 size: 20.	RSLocate new		padding: 1@ -1;		inner;		bottom;		left;		stick: e2 on: e1.	v addAll:{e1. e2}.	v @ RSControlsView.	v open! !!RSShapeExamples methodsFor: 'shapes'!example01BasicShape	<script: 'self new example01BasicShape'>	| v elements |	v := RSView new.	elements := RSShapeBuilder box		size: #yourself;		position: [:m | (1 to: m) sum asPoint -150 ];		onElement;		color: [ :e | e index even 			ifTrue: [ Color red ]			ifFalse: [ Color blue ] ];		elementsOn: (1 to: 20).	v addAll: elements.	v open! !!RSShapeExamples methodsFor: 'lines'!example02BasicEdge	<script: 'self new example02BasicEdge'>	| v box box1 line |	v := RSView new.	box := RSShapeBuilder box		size: 100;		interactionDo: [ :i | i draggable ].	box1 := box element.	box1 translateBy: 150@150.	v add: box1.	line := RSSingleEdgeBuilder line 		color: Color red.	v add: (line from: box1; to: 0@0; edge).	v open	! !!RSShapeExamples methodsFor: 'lines'!example03LinePath	<script: 'self new example03LinePath'>	| v elements form paint line path |	v := RSView new.	form := self iconNamed: #remote.	paint := (AthensCairoPatternSurfacePaint 		createForSurface: (AthensCairoSurface 			fromForm: form)).	paint origin: (form extent / 2) negated.	elements := RSShapeBuilder box		size: form extent x;		paint: paint;		position: [:m | m * 50 asPoint ];		interactionDo: #draggable;		elementsOn: {-1. 1}.			path := [ :a :b | String streamContents: [ :s|		| point number vector u unit middle middle2 l r |		number := [ :n | 			s nextPutAll: n asFloat asString ].		point := [ :p | 			number value: p x.			s space.			number value: p y.			s space. ].		vector := a - b.		u := vector normal.		unit := vector / vector r.			1 to: 3 do: [ :i |			middle := a - (unit * (i+1)* 5).			middle2 := a - (unit * (i*2)*5).			l := middle - (u * ((i-1) * 7)).			r := middle + (u * ((i-0.9) * 7)).						s nextPutAll: 'M'.			point value: l. 			s nextPutAll: 'Q '.			point value: middle2.			point value: r.			].		 ] ].	line := RSEdgeBuilder linePath		color: [:m | m alpha: 0.4];		svgPath: [path];		width: 4;		capRound.	v add: (line 		from: elements first;		to: elements second;		edgeOn: Color red).	v add: (line 		from: elements second;		to: elements first;		edgeOn: Color blue).	v addAll: elements.	v camera scale: 1.	v open	! !!RSShapeExamples methodsFor: 'lines'!example04LineDashes	<script: 'self new example04LineDashes'>	| v line |	v := RSView new.	line := RSEdgeBuilder line		width: 1.	"no dashes no gaps"	v add: (line from: -15@ 1; to: 15@ 1; edge).	"Dashes and gaps of the same size"	line dashArray: { 4 }.	v add: (line from: -15@ 3; to: 15@ 3; edge).	"Dashes and gaps of different sizes"	line dashArray: { 4. 1 }.	v add: (line from: -15@ 5; to: 15@ 5; edge).	"Dashes and gaps of various sizes with an odd number of values"	line dashArray: { 4. 1. 2 }.	v add: (line from: -15@ 7; to: 15@ 7; edge).	"Dashes and gaps of various sizes with an even number of values"	line dashArray: { 4. 1. 2. 3 }.	v add: (line from: -15@ 9; to: 15@ 9; edge).	v camera 		scale: 10;		position: 0@5.	v open	! !!RSShapeExamples methodsFor: 'lines'!example05CapStyles	<script: 'self new example05CapStyles'>	| v line dot d1 d2 ed styles |	v := RSView new.	line := RSEdgeBuilder line		color: Color lightGray;		width: 20.	dot := RSShapeBuilder circle		interactionDo: #draggable;		color: Color darkGray;		position: #yourself;		radius: 5.	styles := #('capButt' 'capRound' 'capSquare').	styles doWithIndex: [ :style :i|		d1 := dot elementOn: -100@(i*30).		d2 := dot elementOn: 100@(i*30).		line perform: style asSymbol.		ed := line from: d1; to: d2; edge.		v add: ed; add: d1; add: d2.		 ].		v open	! !!RSShapeExamples methodsFor: 'lines'!example06JoinStyles	<script: 'self new example06JoinStyles'>	| v line path styles |	v := RSView new.	path := [ :a :b| String streamContents: [ :s| 		| mid number point |		number := [ :n | 			s nextPutAll: n asFloat asString ].		point := [ :p | 			number value: p x.			s space.			number value: p y.			s space. ].				mid := (a + b)/2 + (0@ -50).		s nextPutAll: 'M'.		point value: a.		s nextPutAll: 'L'.		point value: mid.		s nextPutAll: 'L'.		point value: b.		 ] ].		line := RSEdgeBuilder linePath		svgPath: [ path ];		color: Color lightGray;		width: 25.	styles := #('joinMiter' 'joinRound' 'joinBevel').	styles doWithIndex: [ :style :i|		line perform: style asSymbol.		v add: (line			from: ((i-2) * 80)@0;			to: (((i-2) * 80) + 50)@0;			edge).	].		v open	! !!RSShapeExamples methodsFor: 'normalizer'!example07NormalizeColor	<script: 'self new example07NormalizeColor'>	| v elements |	v := RSView new.	elements := RSShapeBuilder box		size: #numberOfMethods;		interactionDo: #draggable;		elementsOn: (Collection withAllSubclasses).	RSNormalizer color		elements: elements;		normalize: #numberOfMethods.	v addAll: elements.	RSGridLayout on: elements.	v camera position: v elements encompassingRectangle center.	v when: TSExtentChangedEvent do: [ v zoomToFit; signalUpdate ].	v @ RSControlsView.	v open	! !!RSShapeExamples methodsFor: 'shapes'!example08Labels	<script: 'self new example08Labels'>	| v sb elements |	v := RSView new.	v @ RSControlsView.	sb := RSShapeBuilder label.	sb interactionDo: #draggable.	sb text: #asString.	elements := sb elementsOn: Collection withAllSubclasses.	elements		do:			[ :e | e translateTo: (Random new nextInt: 300) @ (Random new nextInt: 300) ].	v addAll: elements.	RSNormalizer fontSize		elements: elements;		to: 30;		normalize: #numberOfMethods.	RSNormalizer color		elements: elements;		normalize: #numberOfMethods.	v zoomToFit.	v open! !!RSShapeExamples methodsFor: 'lines'!example09Polyline	<script: 'self new example09Polyline'>	| v box box1 line box2 |	v := RSView new.	box := RSShapeBuilder box		size: 100;		interactionDo: #draggable.	box1 := box element.	box1 translateBy: 150@150.	box2 := box element.	box2 translateBy: -200@200.	v add: box1; add: box2.	line := RSSingleEdgeBuilder polyline 		color: Color red;		controlPoints: { box1. 0@0. [ box1 position x@ box2 position y ]. box2 }.	v add: (line edge).	v open	! !!RSShapeExamples methodsFor: 'shapes'!example10Donut	<script: 'self new example10Donut'>	| data shape radius color view border |	"1800 ellipses"	data := 0 to: 358 by: 2.	view := RSView new.	radius := TSScale linear		domain: #(1 10);		range: #(180 240).	color := TSScale linear		domain: #(1 7 10);		range: #('brown' '4682b4' 'brown').	border := TSBorder new.	1 to: 10 do: [ :i |		shape := RSShapeBuilder circle			radius: 4.5;			color: (color scale: i);			border: border;			position: [ :a | | d |				d := a degreesToRadians.				(radius scale: i) * (d cos @ d sin)				 ].		view addAll: (shape elementsOn: data).		 ].	view @ RSControlsView.	view zoomToFit.	view open.! !!RSShapeExamples methodsFor: 'shapes'!example11ClassTree	<script: 'self new example11ClassTree'>	| v shape label shapeWithTitle elements |	v := RSView new.	"v showEncompassingRectangles."	shape := RSShapeBuilder composite		color: (Color lightGray alpha: 0.4);		shapes: [ :cls | 			| group |			group := RSShapeBuilder box				interactionDo: [ :i | i popupText: #selector ];				size: #linesOfCode;				elementsOn: cls methods.			RSGridLayout on: group.			group ];		onElement;		extent: [ :anElement | anElement extent + (10 @ 10) ].	label := RSShapeBuilder label.	shapeWithTitle := RSShapeBuilder composite		interactionDo: [ :i | 			i				draggable;				popup ];		shapes: [ :cls | 			| group lb s |			group := TSGroup new.			s := shape elementOn: cls.			lb := label elementOn: cls.			group add: lb.			group add: s.			RSVerticalLineLayout new alignCenter on: group.			group ].	elements := shapeWithTitle elementsOn: Collection withAllSubclasses.	v addAll: elements.	RSEdgeBuilder line		view: v;		objects: Collection withAllSubclasses;		connectFrom: #superclass.	v edges pushBack.	RSTreeLayout on: elements.	v @ RSControlsView.	v when: TSExtentChangedEvent do: [ v zoomToFit ].	v open setLabel: 'Collection withAllSubclasses'! !!RSShapeExamples methodsFor: 'shapes'!example12Polygons	<script: 'self new example12Polygons'>	| view color border |	view := RSView new.	color:= TSGradientPalette gradient21.	border := TSBorder new paint: Color black; width: 2.	#('diamond' 'square' 'heptagon' 'hexagon' 	'octagon' 'pentagon' 'rhomboid' 'star'	'triangle' 'vee' 'cross' 'arrow'	"not polygons" 'box' 'circle') do: [ :selector| 		| shape |		shape := (RSShapeBuilder perform: selector asSymbol)			size: 100;			interactionDo: #popup;			color: [:e | | grad |				grad := color scale: e.				grad start: -50 asPoint; stop: 50 asPoint.				grad];			border: border.		view add: (shape elementOn: selector)		 ].	"view showEncompassingRectangles.	view animation repeat;		scale: (TSScale linear domain: {0. 0.5. 1}; range:{ 100. 150. 100} );		onStepDo: [ :t | 			view elements do: [ :e | e size: t ] ]."	RSGridLayout new gapSize: 50; on: view elements.	view when: TSExtentChangedEvent do: [ view zoomToFit ].	view @ RSControlsView.	view open setLabel: 'Polygon shapes'.! !!RSShapeExamples methodsFor: 'shapes'!example13Arrow	<script: 'self new example13Arrow'>	| view triangle box label labels paint |	view := RSView new.	   	paint := LinearGradientPaint new		colorRamp:			{(0 -> (Color colorFrom: 'CC2A49')).			(0.25 -> (Color colorFrom: 'F99E4C')).			(0.50 -> (Color colorFrom: 'F36F38')).			(0.75 -> (Color colorFrom: 'EF4648')).			(1 -> (Color colorFrom: '582841'))};		start: -100 asPoint;		stop: 100 asPoint.	triangle := RSShapeBuilder triangle		color: paint;		border: (TSBorder new width: 20; joinRound; paint: paint);		extent: 200@100.	view add: triangle element.	box := RSShapeBuilder box		color: paint;		extent: 120@200;		cornerRadius: (TSCornerRadius new bottom: 20).	view add: box element.	view elements second pushBack.		RSVerticalLineLayout new alignCenter; gapSize: -1; on: view elements.	label := RSShapeBuilder label		fontSize: 20;		text: #asUppercase;		onElement;		if: [ :e | e index = 3 ] actions: [ :s | s fontSize: 10 ].	labels := label elementsOn: #('Keep' 'calm' 'and' 'roassal' 'on').	view addAll: labels.	RSVerticalLineLayout new alignCenter on: labels.	labels translateBy: 50@50.	view when: TSExtentChangedEvent do: [ view zoomToFit ].	view @ RSControlsView.	view open setLabel: 'You can do it'.! !!RSShapeExamples methodsFor: 'shapes'!example14Marker	<script: 'self new example14Marker'>	| view  elements line arrow |	view := RSView new.	elements := RSShapeBuilder ellipse 		interactionDo: #draggable;		size: 100; elementsOn: (1 to: 2).		arrow := RSShapeBuilder triangle 		color: Color white;		border: (TSBorder new color: Color red; width: 3);		size: 20; element.	line := RSSingleEdgeBuilder line		markerEnd: (TSMarker new shape: arrow; offsetRatio: 0.5; offset: 10); 		from: elements first;		to: elements second;		edge.	view addAll: elements.	view add: line.	RSFlowLayout on: elements.	view open! !!RSShapeExamples methodsFor: 'shapes'!example15BimetricLine	<script: 'self new example15BimetricLine'>	| view e1 e2 box l |	view := RSView new.	box := RSShapeBuilder box 		size: 100;		draggable.	e1 := box element.	e1 color: Color blue.	e2 := box element.	e2 translateTo: 400@0.	l := RSSingleEdgeBuilder bimetricLine		widthFrom: 50;		widthTo: 10;		paint: Color red;		border: nil;		withBorderAttachPoint;		from: e1;		to: e2;		edge.	view addAll: { e1. e2. l}.	view @ RSControlsView. 	view open! !!RSShapeExamples methodsFor: 'shapes'!example16Bezier	<script: 'self new example16Bezier'>	| v box e1 e2 l |	v := RSView new.	v addShape: (TSBezier new		color: Color red;		controlPoints:			{(0 @ 0).			(100 @ 100).			(200 @ 0).			(300 @ 100)}).	box := RSShapeBuilder box draggable size: 100.	e1 := box element.	e1 color: Color blue.	e1 translateTo: 100 @ -200.	e2 := box element.	v		add: e1;		add: e2.	l := RSSingleEdgeBuilder bezier		withVerticalAttachPoint;		"paint: Color red trans;"		from: e1;		to: e2;		controlPoints: [ :m | 			[ :a :b | 			| mid |			mid := (a + b) / 2.			Array				with: a				with: a x @ mid y				with: b x @ mid y				with: b ] ];		edge.	v add: l.	v open! !!RSShapeExamples methodsFor: 'shapes'!example17Labeled	<script: 'self new example17Labeled'>	| v e1 e2 s l |	v := RSView new.	s := RSShapeBuilder ellipse		border: TSBorder new;		interactionDo: [:i | i draggable; labeled ];		size: 20.	e1 := s elementOn: 'hello'.	e2 := s elementOn: 'world'.	e2 translateTo: 60@80.	l := RSSingleEdgeBuilder arrowedLine 		interactionDo: [ :i | | label |			label := i labeled.			label location  				inner;				middle.			label shape text: 'lining up!!' ];		color: Color red;		from: e1;		to: e2;		edge.	v add: e1; add: e2; add: l.	v @ RSControlsView.	v open.! !!RSShapeExamples methodsFor: 'shapes'!example18ExampleFromMondrian	<script: 'self new example18ExampleFromMondrian'>	| v shape composite legend |	v := RSView new.	shape := RSShapeBuilder circle		draggable;		popup;		color: Color red trans.	v addAll: (shape elementsOn: Collection withAllSubclasses).	RSNormalizer size		from: 5;		to: 50;		elements: v elements;		normalize: #numberOfMethods.	RSEdgeBuilder line		color: Color lightGray;		elements: v elements;		view: v;		connectFrom: #superclass.	RSForceBasedLayout on: v elements.	RSEdgeBuilder multiBezier		color: (Color blue alpha: 0.1);		elements: v elements;		view: v;		tension: 0.7;		following: #superclass;		connectToAll: #dependentClasses.		composite := RSShapeBuilder composite 		border: (TSBorder new);		shapes: [ | labels |			labels := RSShapeBuilder label				elementsOn: { 'Circle = classes, size = number of methods; gray links = inheritance;'.				'blue links = dependencies; layout = force based layout on the inheritance links' }.			RSVerticalLineLayout on: labels.			labels. ];		padding: 10.	legend := composite element.	RSLocate new		below;		padding: 10;		move: legend on: v elements.	v add: legend.	v @ RSControlsView.	v open.! !!RSShapeExamples methodsFor: 'shapes'!example19Bitmap	<script: 'self new example19Bitmap'>	| v elements |	v := RSView new.	elements := RSShapeBuilder bitmap		form: #value;		interactionDo: [ :i | i popupText: #key ];		elementsOn: Smalltalk ui icons icons associations.	v addAll: elements.	RSGridLayout on: elements.	v @ RSControlsView.	v open! !!RSShapeExamples methodsFor: 'shapes'!example20Highlightable	<script: 'self new example20Highlightable'>	| v es s |	v := RSView new.	s := RSShapeBuilder ellipse		color: Color blue;		interactionDo: [:i | i draggable; labeledHighlightable];		size: 20.	es := s elementsOn: #('Hello' 'World').	v addAll: es.	RSHorizontalLineLayout on: es.	v @ RSControlsView.	v open.! !"Roassal3-Examples"!!TSTest commentStamp: '' prior: 0!I am the top class for tests!!RSCompositeElementTest commentStamp: '' prior: 0!I have tests for TSGroup asElement!!RSDraggableViewTest commentStamp: '' prior: 0!For drag view tests!!RSEdgeBuilderTest commentStamp: '' prior: 0!I have tests for RSEdgeBuilder!!RSEdgeTest commentStamp: '' prior: 0!I have tests for RSEdge!!RSRoassalTest commentStamp: '' prior: 0!I have test of global uses of roassal!!RSViewTest commentStamp: '' prior: 0!I have tests for RSView!!RSZoomableViewViewTest commentStamp: '' prior: 0!for zoom with the wheel!!TSAnimationTest commentStamp: '' prior: 0!base of animation tests!!TSSequentialAnimationTest commentStamp: '' prior: 0!I have test for sequential animation!!TSTransitionAnimationTest commentStamp: '' prior: 0!I have test for animation in trachel!!TSAthensRendererTest commentStamp: '' prior: 0!I am the test class for TSAthensRenderer !!TSCanvasTest commentStamp: '' prior: 0!I have common tests for shapes and canvas!!TSBoundingTest commentStamp: '' prior: 0!Test for all shapes with a matrix an one encompassing rectangle!!TSLabelTest commentStamp: '' prior: 0!A TSLabelTest is a test class for testing the behavior of TSLabel!!TSLinesTest commentStamp: '' prior: 0!Test for all the lines of trachel!!TSGroupTest commentStamp: '' prior: 0!A TSGroupTest is a test class for testing the behavior of TSGroup!!TSNormalizerTest commentStamp: '' prior: 0!I am test for RSNormalizer!!TSScaleTest commentStamp: '' prior: 0!A TSScaleTest is a test class for testing the behavior of TSScale!!RSAlignmentTest methodsFor: 'running'!setUp	super setUp.	align := RSAlignment new.! !!RSAlignmentTest methodsFor: 'tests'!testFromBottom	| es |	es := (RSShapeBuilder box size: #yourself) elementsOn: (10 to: 100 by: 10).	align elements: es.	RSHorizontalLineLayout on: es.	es second translateBy: 0 @ 150.	self assert: (es collect: [ :e | e encompassingRectangle bottom ]) asArray equals: #(10.0 170.0 30.0 40.0 50.0 60.0 70.0 80.0 90.0 100.0).	self assert: align bottomMostElement equals: es second.	align bottom.	self assert: (es collect: [ :e | e encompassingRectangle bottom ]) asArray equals: #(170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0)	"		RSView new addAll: es; yourself.	"! !!RSAlignmentTest methodsFor: 'tests'!testFromLeft	| es |	es := (RSShapeBuilder box size: #yourself) elementsOn: (10 to: 100 by: 10).	align elements: es.	RSVerticalLineLayout on: es.	es second translateBy: -150 @ 0.	self assert: (es collect: [ :e | e encompassingRectangle left ]) asArray equals: #(0.0 -150.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align leftMostElement equals: es second.	align left.	self assert: (es collect: [ :e | e encompassingRectangle left ]) asArray equals: #(-150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0 -150.0)"		RSView new addAll: es; inspect.	"! !!RSAlignmentTest methodsFor: 'tests'!testFromRight	| es |	es := (RSShapeBuilder box size: #yourself) elementsOn: (10 to: 100 by: 10).	align elements: es.	RSVerticalLineLayout on: es.	es second translateBy: 150 @ 0.	self assert: (es collect: [ :e | e encompassingRectangle right ]) asArray equals: #(10.0 170.0 30.0 40.0 50.0 60.0 70.0 80.0 90.0 100.0).	self assert: align rightMostElement equals: es second.	align right.	self assert: (es collect: [ :e | e encompassingRectangle right ]) asArray equals: #(170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0 170.0)"		RTView new addAll: es; inspect.	"! !!RSAlignmentTest methodsFor: 'tests'!testFromTop	| es |	es := (RSShapeBuilder box size: #yourself) elementsOn: (10 to: 100 by: 10).	align elements: es.	RSHorizontalLineLayout on: es.	es second translateBy: 0 @ -50.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(0.0 -50.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0).	self assert: align topMostElement equals: es second.	align top.	self assert: (es collect: [ :e | e encompassingRectangle top ]) asArray equals: #(-50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0 -50.0).! !!RSAlignmentTest methodsFor: 'tests'!testHasElement	self deny: align hasElement.	align elements: (Array with: RSElement new).	self assert: align hasElement.	align elements: #().	self deny: align hasElement.! !!RSAlignmentTest methodsFor: 'tests'!testNoErrorOnDefault	RSAlignment new left; right; top; bottom! !!RSResizeTest methodsFor: 'running'!setUp	super setUp.	elements := (RSShapeBuilder box height: #yourself; width: [ :o | o + 1 ]) elementsOn: (1 to: 3).	resize := RSResize new.	resize elements: elements.! !!RSResizeTest methodsFor: 'tests'!testBiggestElement	self assert: resize biggestElement equals: elements last.	resize useBiggestElement.	self assert: resize fixedElement equals: elements last.! !!RSResizeTest methodsFor: 'tests'!testBiggestExtent	self assert: resize biggestExtent equals: 4 @ 3! !!RSResizeTest methodsFor: 'tests'!testHighestElement	self assert: resize highestElement equals: elements last.! !!RSResizeTest methodsFor: 'tests'!testSameHeight	resize fixedElement: elements second.	resize sameHeight.	self assert: (elements collect: #extent) sorted asArray equals: (Array with: (2.0@2.0) with: (3.0@2.0) with: (4.0@2.0))! !!RSResizeTest methodsFor: 'tests'!testSameSize	resize fixedElement: elements second.	resize sameSize.	self assert: (elements collect: #extent) asSet asArray equals: (Array with: (3.0@2.0))! !!RSResizeTest methodsFor: 'tests'!testSameSizeWithoutFixedElement	resize sameSize.	self assert: (elements collect: #extent) asSet asArray equals: (Array with: (4.0 @ 3.0))! !!RSResizeTest methodsFor: 'tests'!testSameWidth	resize fixedElement: elements second.	resize sameWidth.	self assert: (elements collect: #extent) sorted asArray equals: (Array with: (3.0@1.0) with:(3.0@2.0) with: (3.0@3.0))! !!RSResizeTest methodsFor: 'tests'!testWidestElement	self assert: resize widestElement equals: elements last.! !!RSCompositeElementTest methodsFor: 'running'!setUp	view := RSView new! !!RSCompositeElementTest methodsFor: 'tests'!testAddOnceInCanvas	| elements |	elements := RSShapeBuilder box 		elementsOn: (1 to: 10).	view addAll: elements.	self assert: view elements size equals: 10.	view add: elements asElement.	self assert: view elements size equals: 1.! !!RSCompositeElementTest methodsFor: 'tests'!testAsElement	| elements |	elements := RSShapeBuilder box 		elementsOn: (1 to: 10).	view add: elements asElement.	self assert: view elements size equals: 1.! !!RSCompositeElementTest methodsFor: 'tests'!testCreateComposite	| elements |	elements := RSShapeBuilder composite		shapes: [ :m | 			RSShapeBuilder box				size: m;				elementsOn: (1 to: m).			];		elementsOn: (1 to: 10).	self assert: elements size equals: 10.	self assert: elements first shapes size equals: 1.	self assert: elements last shapes size equals: 10.		self assert: elements first encompassingRectangle extent equals: 1@1.	self assert: elements last encompassingRectangle extent equals: 10@10.! !!RSDraggableViewTest methodsFor: 'running'!setUp	view := RSView new.	view add: (RSShapeBuilder ellipse width: 40; height: 20) element.	! !!RSDraggableViewTest methodsFor: 'tests'!testDefault	self assert: view canvas camera position equals: 0@0.! !!RSDraggableViewTest methodsFor: 'tests'!testDraggingModeLeft	view @ RSDraggableView left.	view canvas announce: (TSMouseDragging step: 10 @ 5).	self assert: (view canvas camera position closeTo: (0 @ 0)).		view removeInteractionIfPresent: RSDraggableView.		view @ RSDraggableView left.	view canvas announce: (TSMouseDragStart new).	view canvas announce: (TSMouseDragging step: 10 @ 5).	view canvas announce: (TSMouseDragEnd new).	self assert: (view canvas camera position closeTo: (0 @ 0)).		view canvas announce: (TSMouseLeftDragStart new).	view canvas announce: (TSMouseDragging step: 10 @ 5).	view canvas announce: (TSMouseDragEnd new).	self assert: (view canvas camera position closeTo: (-10 @ -5)).! !!RSDraggableViewTest methodsFor: 'tests'!testDraggingModeMiddle	view @ RSDraggableView middle.	view canvas announce: (TSMouseDragging step: 10 @ 5).	self assert: (view canvas camera position closeTo: (0 @ 0)).		view removeInteractionIfPresent: RSDraggableView.		view @ RSDraggableView middle.	view canvas announce: (TSMouseDragStart new).	view canvas announce: (TSMouseDragging step: 10 @ 5).	view canvas announce: (TSMouseDragEnd new).	self assert: (view canvas camera position closeTo: (0 @ 0)).		view canvas announce: (TSMouseMiddleDragStart new).	view canvas announce: (TSMouseDragging step: 10 @ 5).	view canvas announce: (TSMouseDragEnd new).	self assert: (view canvas camera position closeTo: (-10 @ -5)).! !!RSDraggableViewTest methodsFor: 'tests'!testDraggingModeRight	view @ RSDraggableView right.	view canvas announce: (TSMouseDragging step: 10 @ 5).	self assert: (view canvas camera position closeTo: (0 @ 0)).		view removeInteractionIfPresent: RSDraggableView.		view @ RSDraggableView right.	view canvas announce: (TSMouseDragStart new).	view canvas announce: (TSMouseDragging step: 10 @ 5).	view canvas announce: (TSMouseDragEnd new).	self assert: (view canvas camera position closeTo: (0 @ 0)).		view canvas announce: (TSMouseRightDragStart new).	view canvas announce: (TSMouseDragging step: 10 @ 5).	view canvas announce: (TSMouseDragEnd new).	self assert: (view canvas camera position closeTo: (-10 @ -5)).! !!RSDraggableViewTest methodsFor: 'tests'!testDraggingOnDraggable	view @ RSDraggableView.	view canvas announce: (TSMouseDragStart new).	view canvas announce: (TSMouseDragging step: 10 @ 5).	view canvas announce: (TSMouseDragEnd new).	self assert: (view canvas camera position closeTo: (-10 @ -5))! !!RSDraggableViewTest methodsFor: 'tests'!testDraggingOnNotDraggable	view canvas announce: (TSMouseDragging step: 10 @ 5).	self assert: view canvas camera position = (0 @ 0)! !!RSEdgeBuilderTest methodsFor: 'tests'!expectedFailures	^ #(#testFromAll #testUseInLayout #testWithMoveBehind #testWithMoveBehind02)! !!RSEdgeBuilderTest methodsFor: 'running'!setUp	super setUp.	view := RSView new.	elements := RSShapeBuilder box elementsOn: (1 to: 10).	view addAll: elements. 	b := RSEdgeBuilder line.! !!RSEdgeBuilderTest methodsFor: 'tests'!testAllowRepetitionAndUseAssociations	| v eb |	v := RSView new.	v addAll: (RSShapeBuilder box elementsOn: (1 to: 3)).	eb := RSEdgeBuilder line.	eb view: v.	eb color: (Color red alpha: 0.5).	eb noRepetition.	eb useAssociations: (Array with: 1 -> 2 with: 2 -> 3 with: 1 -> 2).		RSGridLayout on: v elements.		self assert: v numberOfEdges equals: 2! !!RSEdgeBuilderTest methodsFor: 'tests'!testConnectFrom	| e |	b view: view.	b objects: #(1 2).	b connectFrom: [ :v | v - 1 ].		self assert: view numberOfEdges equals: 1.		e := view edges anyOne.	self assert: e from model equals: 1.	self assert: e to model equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testConnectTo	| e |	b view: view.	b objects: #(1 2).	b connectTo: [ :v | v - 1 ].		self assert: view numberOfEdges equals: 1.		e := view edges anyOne.	self assert: e from model equals: 2.	self assert: e to model equals: 1.! !!RSEdgeBuilderTest methodsFor: 'tests'!testConnectToAll	| eFrom eTo |	b view: view.	b objects: #(1 2 3).	b connectToAll: [ :v | Array with: v - 1 with: v - 2 ].		self assert: view numberOfEdges equals: 3.	 	eFrom := (view edges collect: [ :edge | edge from model ]) sorted asArray.	eTo := (view edges collect: [ :edge | edge to model ]) sorted asArray.	self assert: eFrom equals: #(2 3 3).	self assert: eTo equals: #(1 1 2).! !!RSEdgeBuilderTest methodsFor: 'tests'!testDefault	self assert: view numberOfEdges equals: 0! !!RSEdgeBuilderTest methodsFor: 'tests'!testElements	| es |	b := RSEdgeBuilder new.	b view: view.	self assert: b fromElements equals: view elements.		es := RSShapeBuilder box elementsOn: (1 to: 4).	b elements: es.	self assert: b fromElements equals: es.! !!RSEdgeBuilderTest methodsFor: 'tests'!testElementsToLookup	| es1 es2 edges v |	es1 := RSShapeBuilder circle elementsOn: #(1 2 3).	es2 := RSShapeBuilder box elementsOn: #(1 2 3).	v := RSView new.	v addAll: es1.	v addAll: es2.	edges := RSEdgeBuilder line					view: v;					fromElements: es1;					toElements: es2;					connectTo: #yourself.	self assert: edges size equals: 3.		self assert: edges first from equals: es1 first.	self assert: edges first to equals: es2 first.! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromAll	| v es |	v := RSView new.	es := (RSShapeBuilder circle size: 20) elementsOn: (1 to: 2).	v addAll: es.		self assert: v edges size equals: 0.	RSEdgeBuilder new		view: v;		objects: (1 to: 2);		connectFromAll: (Array with: 1) to: 2.			RSTreeLayout on: es.	self assert: v edges size equals: 1.	self assert: v edges first from position equals: (15.0@15.0).	self assert: v edges first to position equals: (15.0@55.0).! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjects	"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."	| edges |	b view: view.	b fromObjects: #(1 2).	b connectFrom: #yourself to: 10.	self assert: view numberOfEdges equals: 2.	edges := view edges.	self assert: edges first from model equals: 1.	self assert: edges first to model equals: 10.	self assert: b toObjects asArray equals: (1 to: 10) asArray.	self assert: b fromObjects asArray equals: #(1 2).! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjects02	"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."		b view: view.	b fromObjects: #(1).	b connectFrom: #yourself to: 10.	self assert: view numberOfEdges equals: 1.	self assert: b toObjects asArray equals: (1 to: 10) asArray.	self assert: b fromObjects asArray equals: #(1).! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjectsError"view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."	self should: [ RSEdgeBuilder new  fromObjects: #(1 2) ] raise: Error! !!RSEdgeBuilderTest methodsFor: 'tests'!testFromObjectsToElements	| edges |	b view: view.	edges := 		b fromObjects: #(1 2);			toElements: (elements copyFrom: 10 to: 10);			connectTo: 10.	self assert: edges size equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testInit	| eb |	eb := RSEdgeBuilder new.	self deny: eb shouldAllowRepetition.	eb allowRepetition.	self assert: eb shouldAllowRepetition.! !!RSEdgeBuilderTest methodsFor: 'tests'!testNoMoveBehind	RSEdgeBuilder line		view: view;		useAssociations: (Array 									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: (view canvas shapes collect: [ :c | c class name ]) asArray equals: #(#TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSLine #TSLine #TSLine)! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjectFrom	| e |	b view: view.	b objects: #(1 2); connectFrom: [ :v | v - 1 ].		self assert: view numberOfEdges equals: 1.		e := view edges anyOne.	self assert: e from model equals: 1.	self assert: e to model equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjectTo	| e |	b view: view.	b objects: #(1 2); connectTo: [ :v | v - 1 ].		self assert: view numberOfEdges equals: 1.		e := view edges anyOne.	self assert: e from model equals: 2.	self assert: e to model equals: 1.! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjects	b view: view.	b objects: (1 to: 5).	self assert: b fromElements equals: (elements copyFrom: 1 to: 5)"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjects02	b view: view.	b objects: #even.	self assert: (b fromElements collect: #model) asArray equals: #(2 4 6 8 10)"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."! !!RSEdgeBuilderTest methodsFor: 'tests'!testObjects03	b view: view.	b objects: #odd.	self assert: (b fromElements collect: #model) asArray equals: #(1 3 5 7 9)"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."! !!RSEdgeBuilderTest methodsFor: 'tests'!testShouldAllowBidirection	self assert: view numberOfEdges equals: 0.	self assert: b isBidirectional.	b view: view.	b noBidirectional.	b objects: #(1 2).	b useAssociations: (Array with: 1 -> 2 with: 2 -> 1 ).	self deny: b isBidirectional. 		elements := view elementsFromModels: #(1 2).	self assert: elements size equals: 2.	self assert: (b shouldCreateEdgeFrom: elements first to: elements second).		self assert: view numberOfEdges equals: 1.	self assert: view edges anyOne from model equals: 1.	self assert: view edges anyOne to model equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testShouldNotAllowBidirection	self assert: view numberOfEdges equals: 0.	b view: view.	b objects: #(1 2).	b useAssociations: (Array with: 1 -> 2 with: 2 -> 1).	self assert: view numberOfEdges equals: 2.! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple	RSEdgeBuilder line		view: view;		useElementAssociations: (Array 									with: elements first -> elements second									with: elements second -> elements third).	self assert: view numberOfEdges equals: 2! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple2	RSEdgeBuilder line		view: view;		useAssociations: (Array 									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: view numberOfEdges equals: 3! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple3	RSEdgeBuilder line		view: view;		fromObjects: #(1 2 3 6);		toObjects: (1 to: 10);		connectFrom: #yourself to: [ :v | v + 1 ].	self assert: view numberOfEdges equals: 4.	self assert: (view edges collect: [ :e | e from model -> e to model ]) asArray equals: ((Array new: 4) at: 1 put: (1->2); at: 2 put: (2->3); at: 3 put: (3->4); at: 4 put: (6->7); yourself)! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple4	RSEdgeBuilder line		view: view;		fromObjects: #(1 2 3 6);		toObjects: #(1 2 3 6);		connectFrom: #yourself to: [ :v | v + 1 ].	self assert: view numberOfEdges equals: 2.	self assert: (view edges collect: [ :e | e from model -> e to model ]) asArray equals: ((Array new: 2) at: 1 put: (1->2); at: 2 put: (2->3); yourself)! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple5	RSEdgeBuilder line		view: view;		fromObjects: #(1 2 3 6);		connectFrom: #yourself toAll: [ :v | Array with: v + 1 with: v + 2 ].			self assert: view numberOfEdges equals: 8.! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple6	RSEdgeBuilder line		view: view;		fromObjects: (Array with: 2);		connectFromAll: (Array with: 2) to: 3.	self assert: view numberOfEdges equals: 1.! !!RSEdgeBuilderTest methodsFor: 'tests'!testSimple7	RSEdgeBuilder line		view: view;		useAssociation: 1 -> 2;		useAssociation: 2 -> 3;		useAssociation: 5 -> 6.	self assert: view numberOfEdges equals: 3! !!RSEdgeBuilderTest methodsFor: 'tests'!testSource	| v es eb c |	v := RSView new.	es := RSShapeBuilder box elementsOn: #(1 2 3). 	v addAll: es.		eb := RSEdgeBuilder line.	eb view: v.		c := OrderedCollection new.	c add: 1 -> 2.	c add: 3 -> 1.	eb source: c connectFrom: #key to: #value.		self assert: v numberOfEdges equals: 2! !!RSEdgeBuilderTest methodsFor: 'tests'!testToObjects	"	view := RTView new.	elements := RTBox elementsOn: (1 to: 10).	view addAll: elements. 	b := RTEdgeBuilder new."	b view: view.	b toObjects: #(1 2).	b connectFrom: #yourself to: 10.	self assert: view numberOfEdges equals: 0.	self assert: b toObjects asArray equals: #(1 2).	self assert: b fromObjects asArray equals: (1 to: 10) asArray.! !!RSEdgeBuilderTest methodsFor: 'tests - use in layout'!testUseInLayout	b		view: view; 		notUseInLayout; 		connectTo: [ :v | v + 1 ].	RSTreeLayout on: view elements.		self assert: (view elements collect: #position) asArray equals: ((Array new: 10) at: 1 put: ((7.5@7.5)); at: 2 put: ((15.5@7.5)); at: 3 put: ((23.5@7.5)); at: 4 put: ((31.5@7.5)); at: 5 put: ((39.5@7.5)); at: 6 put: ((47.5@7.5)); at: 7 put: ((55.5@7.5)); at: 8 put: ((63.5@7.5)); at: 9 put: ((71.5@7.5)); at: 10 put: ((79.5@7.5)); yourself)! !!RSEdgeBuilderTest methodsFor: 'tests - use in layout'!testUseInLayoutDefault	b 		view: view;		connectTo: [ :v | v + 1 ].	RSTreeLayout on: view elements.		self assert: (view elements collect: #position) asArray equals: ((Array new: 10) at: 1 put: ((7.5@7.5)); at: 2 put: ((7.5@32.5)); at: 3 put: ((7.5@57.5)); at: 4 put: ((7.5@82.5)); at: 5 put: ((7.5@107.5)); at: 6 put: ((7.5@132.5)); at: 7 put: ((7.5@157.5)); at: 8 put: ((7.5@182.5)); at: 9 put: ((7.5@207.5)); at: 10 put: ((7.5@232.5)); yourself)! !!RSEdgeBuilderTest methodsFor: 'tests'!testWithMoveBehind	RSEdgeBuilder new		view: view;		moveBehind;		useAssociations: (Array 									with: 1 -> 2									with: 2 -> 3									with: 5 -> 6).	self assert: (view canvas shapes collect: [ :c | c class name ]) asArray equals: #(#TSLine #TSLine #TSLine #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox)! !!RSEdgeBuilderTest methodsFor: 'tests'!testWithMoveBehind02	RSEdgeBuilder new		view: view;		moveBehind;		connectFrom: [ :v | v - 1 ].	self assert: (view canvas shapes collect: [ :c | c class name ]) asArray equals: #(#TSLine #TSLine #TSLine #TSLine #TSLine #TSLine #TSLine #TSLine #TSLine #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox #TSBox)! !!RSEdgeBuilderTest methodsFor: 'tests'!testconnectFromToAll	| es1 es2 edges v |	es1 := RSShapeBuilder circle elementsOn: #(1 2 3).	es2 := RSShapeBuilder box elementsOn: #(1 2 3).	v := RSView new.	v addAll: es1; addAll: es2.	edges := RSEdgeBuilder line					view: v;					fromElements: es1;					toElements: es2;					connectFrom: #yourself toAll: [ :obj | Array with: obj ].	self assert: edges size equals: 3.		self assert: edges first from equals: es1 first.	self assert: edges first to equals: es2 first.! !!RSEdgeTest methodsFor: 'running'!setUp	super setUp.	el1 := RSShapeBuilder box element.	el2 := RSShapeBuilder box element.	el1 translateTo: 20 @ 20.	el2 translateTo: 60 @ 80.	edge := RSEdgeBuilder line from: el1; to: el2; edge.! !!RSEdgeTest methodsFor: 'tests'!testAddingEdgeAndGroup	| v g |	v := RSView new.	g := TSGroup new.		g		add: el1;		add: el2;		add: edge.	v addAll: g.	self assert: edge trachelShape notNil.	self assert: edge trachelShape color notNil.! !!RSRoassalTest methodsFor: 'tests - conditions'!testCommands	| shape removedCommands |	shape := RSShapeBuilder new.	self assert: shape commands size equals: 0.	shape shapeClass: TSBox.	self assert: shape commands size equals: 2.		shape := RSShapeBuilder box.	self assert: shape commands size equals: 2.	shape removeCommandsBySelector: #size:.	self assert: shape commands size equals: 1.		shape := RSShapeBuilder box		size: 10;		size: [ 100 ];		size: [ :m | m ];		size: #yourself.	self assert: shape commands size equals: 6.	removedCommands := shape removeCommandsBySelector: #size:.	self assert: shape commands size equals: 1.	self assert: removedCommands size equals: 5 	! !!RSRoassalTest methodsFor: 'tests - abstract'!testShapeDNU	| shape |	shape := RSShapeBuilder box.	shape size: 100.	self should: [ shape foo ] raise: Error! !!RSRoassalTest methodsFor: 'tests'!testViewBasic	| v e |	v := RSView new.	self assert: v canvas numberOfShapes equals: 0.	e := RSShapeBuilder box element.	v add: e.	self assert: v canvas numberOfShapes equals: 1.	v open delete.! !!RSRoassalTest methodsFor: 'tests - abstract'!testrsValue	"in roassal a parameter for one metric of the visualizacion can be anything"	| desireColor |	desireColor := Color red.	"in object"	self assert: desireColor equals: (Color red rsValue: nil).	"in symbol performs the method"	self assert: desireColor equals: (#red rsValue: Color).	"in blocck execute it"	self assert: desireColor equals: ([ :selector | Color perform: selector ] rsValue: #red)! !!RSViewTest methodsFor: 'running'!setUp	super setUp.	view := RSView new.! !!RSViewTest methodsFor: 'tests'!testElementFromModel	| els |	els := RSShapeBuilder box elementsOn: (1 to: 3).	view addAll: els.	self assert: (view elementFromModel: 1) == els first.	self assert: (view elementFromModel: 2) == els second.	self assert: (view elementFromModel: 3) == els third.! !!RSZoomableViewViewTest methodsFor: 'running'!setUp	view := RSView new.	view add: (RSShapeBuilder box width: 40; height: 20) element.	! !!RSZoomableViewViewTest methodsFor: 'running'!testDefault	self assert: view camera position equals: 0@0.	view @ RSZoomableView.	self assert: view camera position equals: 0@0.	view canvas announce: (TSMouseWheelEvent new 		direction: Character arrowUp; 		position: 0@0;		canvas: view canvas).	self assert: (view canvas camera position closeTo: (0 @ 0)).	self assert: (view canvas camera scale > 1).! !!TSAnimationTest methodsFor: 'tests'!basicAnimation: animation	self assert: animation loops equals: 1.	self deny: animation hasCompleted.		self deny: animation isRunning.	self assert: animation startTime isNil.	self deny: animation isPaused.	animation start.	self assert: animation isRunning.	self deny: animation startTime isNil.	self deny: animation isPaused.		animation pause.	self assert: animation isPaused.	animation continue.	self deny: animation isPaused.		self assert: animation loops equals: 1.	self should: [animation loops: 0 ] raise: Error.	animation loops: 3.	self assert: animation loops equals: 3.! !!TSAnimationTest methodsFor: 'running'!runAnimation: animation threshold: threshold	| time ended |		ended := false.	animation when: TSAnimationEndEvent do: [ :evt | ended := true ].	time := Time now asDuration.	[ ended ] whileFalse: [ 		(Time now asDuration - time) > threshold milliSeconds ifTrue: [ 			"time up"			self error: 'Time up'.			^ self ].		canvas playAnimations.		].! !!TSAnimationTest methodsFor: 'running'!setUp	canvas := TSCanvas new.! !!TSAnimationTest methodsFor: 'tests'!testSequentialAnimationCreation	| animation |	self assert: canvas animations size equals: 0.	animation := canvas animationFrom: {}.	self assert: canvas animations size equals: 1.	self assert: animation class equals: TSSequentialAnimation.! !!TSAnimationTest methodsFor: 'tests'!testTransitionAnimationCreation	| animation |	self assert: canvas animations size equals: 0.	animation := canvas animation.	self assert: canvas animations size equals: 1.	self assert: animation class equals: TSTransitionAnimation.! !!TSSequentialAnimationTest methodsFor: 'tests'!testAddingAnimations	|  animation |	animation := TSSequentialAnimation new.	animation		add: (TSTransitionAnimation new			duration: 1 second);		add: (TSTransitionAnimation new			duration: 2 seconds).	canvas addAnimation: animation.	self assert: animation isRunning.	self assert: animation duration equals: 3 seconds.! !!TSSequentialAnimationTest methodsFor: 'tests'!testBasic	self basicAnimation: TSSequentialAnimation new.! !!TSSequentialAnimationTest methodsFor: 'tests'!testBasicCanvas		|  animation |		self assert: canvas animations size equals: 0.	animation := canvas animation: TSSequentialAnimation new.	self assert: canvas animations size equals: 1.		self assert: animation isRunning.	self assert: animation duration equals: 0 asDuration.! !!TSSequentialAnimationTest methodsFor: 'tests'!testDelay		| animation |	animation := TSSequentialAnimation new		delay: 100 milliSeconds.	animation start.	self deny: animation isDelayDone.	(Delay forMilliseconds: 101) wait.	self assert: animation isDelayDone.	! !!TSSequentialAnimationTest methodsFor: 'tests'!testStep		| value animation |	value := 0.	animation := TSSequentialAnimation new		add: (TSTransitionAnimation new 			onStepDo: [ :t| value := value + 1 ]);		yourself.	canvas addAnimation: animation.	self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 1.! !!TSSequentialAnimationTest methodsFor: 'tests'!testStepEvent	| value loop animation |	canvas := TSCanvas new.	value := nil.	loop := 0.	animation := TSSequentialAnimation new		loops: 3;		add: (TSTransitionAnimation new 			duration: 100 milliSeconds;			onStepDo: [ :t| value := t ]);		when: TSAnimationLoopEvent do: [ :evt | loop := loop + 1.].	canvas addAnimation: animation.	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 310.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning.! !!TSTransitionAnimationTest methodsFor: 'tests'!testBasic 	self basicAnimation: TSTransitionAnimation new! !!TSTransitionAnimationTest methodsFor: 'tests'!testBasicCanvas		|  animation |		self assert: canvas animations size equals: 0.	animation := canvas animation.	self assert: canvas animations size equals: 1.		self assert: animation isRunning.	self assert: animation duration equals: 2 asSeconds.! !!TSTransitionAnimationTest methodsFor: 'tests'!testDelay		| animation |	animation := canvas animation		delay: 100 milliSeconds.	self deny: animation isDelayDone.	(Delay forMilliseconds: 101) wait.	self assert: animation isDelayDone.	! !!TSTransitionAnimationTest methodsFor: 'tests'!testStep		| value |	value := 0.	canvas animation		onStepDo: [ :t| value := value + 1 ].			self assert: value equals: 0.	canvas playAnimations.	self assert: value equals: 1.! !!TSTransitionAnimationTest methodsFor: 'tests'!testStepEvent		| value loop animation |	canvas := TSCanvas new.	value := nil.	loop := 0.	animation := canvas animation		duration: 100 milliSeconds;		loops: 3;		onStepDo: [ :t| value := t ];		when: TSAnimationLoopEvent do: [ :evt | loop := loop + 1.].	self assert: value isNil.	self assert: loop equals: 0.	self assert: animation endTime isNil.	self runAnimation: animation threshold: 310.	self deny: value isNil.	self assert: loop equals: 3.	self deny: animation endTime isNil.	self deny: animation isRunning.! !!TSTransitionAnimationTest methodsFor: 'tests'!testStepReset		| animation |	animation := canvas animation		duration: 100 milliSeconds.	self runAnimation: animation threshold: 110.		self deny: animation isRunning.	self assert: animation currentLoop equals: nil.	self assert: canvas animations size equals: 0.		animation reset;		duration: 100 milliSeconds.	canvas addAnimation: animation.		self assert: canvas animations size equals: 1.	self runAnimation: animation threshold: 110.! !!TSAthensRendererTest methodsFor: 'tests'!testArcCorner	| renderer |	renderer := TSAthensRenderer new.	self assert: (renderer		arcCornerTangets: -17.172947580489485@ -71.29423293069038		p1: -58.258908750504766 @ -212.1459392757739		r: 220		rc: 11.316433244555238		cw: true)				equals: (-54.9506649278924@ 200.80455223867077) -> (-46.47771241701749@ 215.03446758248086)! !!TSBoundingTest methodsFor: 'running'!testDrawBitamp	c addShape: (TSBitmap new		form: (ColorForm extent: 100@100 depth: 32)).	c createMorph drawOnMockCanvas.! !!TSBoundingTest methodsFor: 'running'!testDrawBorder	c addShape: (TSEllipse new		radius: 100;		border: TSBorder new;		yourself).	c createMorph drawOnMockCanvas.! !!TSBoundingTest methodsFor: 'running'!testDrawBoxCornerRadius	c addShape: (TSBox new		extent: 100@100;		cornerRadius: 5;		yourself).	c createMorph drawOnMockCanvas.! !!TSBoundingTest methodsFor: 'running'!testDrawPolygon	c addShape: (TSPolygon new).	c addShape: (TSPolygon new		points: { 200@10. 250@190. 160@210 };		yourself).	c addShape: (TSPolygon new		cornerRadii: 20;		points: { 200@10. 250@190. 160@210 };		yourself).	self assert: c shapes second points equals: {(-5@ -100). (45@80). (-45@100)}.	c createMorph drawOnMockCanvas.! !!TSBoundingTest methodsFor: 'running'!testDrawRing	| r |	r := TSPieSlice new.	"empty"	c addShape: r.	"circle"	c addShape: (TSPieSlice new		innerRadius: 0;		externalRadius: 100;		alphaAngle: 0;		betaAngle: 360).	"slice"	c addShape: (TSPieSlice new		externalRadius: 100;		alphaAngle: 30;		betaAngle: 90;		segmentSpacing: 5).	"donut"	c addShape: (TSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 360).	"corner radii"	c addShape: (TSPieSlice new		externalRadius: 100;		innerRadius: 50;		alphaAngle: 0;		betaAngle: 45;		cornerRadii: 20).	c createMorph drawOnMockCanvas.! !!TSBoundingTest methodsFor: 'running'!testDrawSVG	c addShape: (TSSVGPath new).	c addShape: (TSSVGPath new		svgPath: 'M 100 350 q 150 -300 300 0';		yourself).	c createMorph drawOnMockCanvas.! !!TSBoundingTest methodsFor: 'tests'!testPosition	| b |	b := TSBox new.	self assert: b position equals: 0@0.	b position: 0@0.! !!TSCanvasTest methodsFor: 'running'!setUp	super setUp.	c := TSCanvas new! !!TSCanvasTest methodsFor: 'running'!testAddOneShape	c addShape: TSBox new.	self assert: c numberOfShapes equals: 1.	self assert: c numberOfFixedShapes equals: 0! !!TSCanvasTest methodsFor: 'running'!testDrawCanvas	c addShape: (TSBox new		extent: 100@100;		yourself).	c addShape: (TSEllipse new		position: 100@100;		extent: 100@100;		yourself).	c createMorph drawOnMockCanvas.! !!TSCanvasTest methodsFor: 'running'!testDrawCanvasWithGroup	| g |	g := TSComposite new.	g add: (TSBox new		extent: 100@100;		yourself).	g add: (TSEllipse new		position: 100@100;		extent: 100@100;		yourself).	c addShape: g.	c createMorph drawOnMockCanvas.! !!TSCanvasTest methodsFor: 'running'!testDrawFixed	| box |	box := TSBox new		extent: 100@100;		yourself.	box isFixed: true.	c addShape: box.		box := TSBox new		extent: 100@100;		yourself.	c addShape: box.	self deny: box isFixed.	box setAsFixed.	self assert: box isFixed.	self assert: c numberOfShapes equals: 0.	self assert: c numberOfFixedShapes equals: 2.	c createMorph drawOnMockCanvas.! !!TSCanvasTest methodsFor: 'running'!testEmpty	self assert: c numberOfShapes equals: 0! !!TSCanvasTest methodsFor: 'events'!testEvent 	| box |	box := TSBox new.	box when: TSMouseClick do: [ :evt |  ]! !!TSCanvasTest methodsFor: 'events'!testLowLevelEvent	| box |	box := TSBox new size: 30.	box when: TSMouseDragging do: [ :evt | box  ].	c addShape: box.	self assert: (c shapeWithAction: TSMouseDragging forPositionInPixels: 250 @ 250) == box! !!TSCanvasTest methodsFor: 'running'!testOpening	c open delete! !!TSCanvasTest methodsFor: 'tests'!testRemovingShapes	| e |	e := TSEllipse new.	c addShape: e.	self assert: c shapes size equals: 1.	e remove.	self assert: c shapes size equals: 0.! !!TSLabelTest methodsFor: 'tests'!testDrawBorderLabel	|  |	c addShape: (TSLabel new		border: (TSBorder new);		color: (Color purple alpha: 0.5);		fontName: 'Source Sans Pro';		position: -50 @ 0;		text: 'Hello world!!';		yourself).	c createMorph drawOnMockCanvas.! !!TSLabelTest methodsFor: 'tests'!testDrawLabel		c addShape: (TSLabel new		color: (Color purple alpha: 0.5);		position: -50 @ 0;		text: 'Hello world!!';		yourself).	c createMorph drawOnMockCanvas.! !!TSLinesTest methodsFor: 'running'!testDrawBezierLine	c addShape: (TSBezier new		strokeColor: Color red;		width: 2). 	c createMorph drawOnMockCanvas.! !!TSLinesTest methodsFor: 'running'!testDrawLine	c addShape: (TSLine new		strokeColor: Color red;		width: 2). 	c createMorph drawOnMockCanvas.! !!TSLinesTest methodsFor: 'running'!testDrawMarkers	| line m |	m := TSPolygon new 		points: { -10@0. 0@ -10. 10@0 };		color: Color black;		size: 10.	line := TSLine new		startPoint: 50@50;		endPoint: 250@50.	line markerStart: m.	c addShape: line.	c createMorph drawOnMockCanvas.! !!TSLinesTest methodsFor: 'running'!testDrawSVGLine	c addShape: (TSSVGPathLine new		strokeColor: Color red;		svgPath: [ :a :b | 'M 100 100 L 200 200' ];		width: 2). 	c addShape: (TSSVGPathLine new		strokeColor: Color red;		svgPath: [:a :b | String streamContents: [:stream |			stream 				nextPutAll: 'M ';				nextPutAll: a x asString;				space;				nextPutAll: a y asString;				space;				nextPutAll: 'L ';				nextPutAll: b x asString;				space;				nextPutAll: b y asString.		] ];		startPoint: 100@100;		endPoint: 200@200;		width: 2). 	c addShape: (TSSVGPathLine new		strokeColor: Color red;		svgPath: [ :a :b | [ :canvas| 			canvas				absolute;				moveTo: a;				lineTo: b. ] ];		width: 2). 	c createMorph drawOnMockCanvas.! !!TSLinesTest methodsFor: 'running'!testPolyline	c addShape: (TSPolyline new		controlPoints: {0@0. 100@100. 100@ -100}).	c createMorph drawOnMockCanvas.! !!TSCompositeTest methodsFor: 'tests'!testPaddingOkay	"No error should be raised"		TSComposite new		shapes: (TSGroup new add: TSBox new; yourself);		padding: 5.	TSComposite new		shapes: (TSGroup new add: TSBox new; add: TSBox new; yourself);		padding: 5.			TSComposite new		shapes: (TSGroup new);		padding: 5.! !!TSGroupTest methodsFor: 'tests'!testAddShape	| g |	g := TSGroup new.	g add: TSBox new.! !!TSGroupTest methodsFor: 'tests'!testAsGroup	| t |	t := #(1 2 3) asGroup.	self assert: t asArray equals: #(1 2 3).	self assert: t class equals: TSGroup! !!TSGroupTest methodsFor: 'tests'!testCache01	| es el |	es := RSShapeBuilder box elementsOn: (1 to: 5).	self assert: es class equals: TSGroup.	self assert: es elementFromModelCache isEmpty.		el := es elementFromModel: 2.	self assert: el class equals: RSElement.	self assert: el model equals: 2.		self deny: es elementFromModelCache isEmpty.! !!TSGroupTest methodsFor: 'tests'!testCache02	| es el els |	es := RSShapeBuilder box elementsOn: #(1 1).		el := es elementFromModel: 1.	self assert: el class equals: RSElement.	self assert: el model equals: 1.		els := es elementsFromModel: 1.	self assert: els class equals: TSGroup.	self assert: els size equals: 2! !!TSGroupTest methodsFor: 'tests'!testCache03	| es el |	es := RSShapeBuilder box elementsOn: #(1 1).		es elementsFromModel: 1.	el := es elementFromModel: 1.	self assert: el class equals: RSElement.	self assert: el model equals: 1.	! !!TSGroupTest methodsFor: 'tests'!testCache04	| es |	es := RSShapeBuilder box elementsOn: #(1).	self assert: (es elementsFromModel: 1) size equals: 1.		es addAll: (RSShapeBuilder box elementsOn: #(1)). 	self assert: (es elementsFromModel: 1) size equals: 2.! !!TSGroupTest methodsFor: 'tests'!testDrawGroup	| g c com |	c := TSCanvas new.	g := TSGroup new.	g add: TSBox new.	com := TSComposite new		shapes: g.	c addShape: com.	self assert: c numberOfShapes equals: 1.	c createMorph drawOnMockCanvas.! !!TSGroupTest methodsFor: 'tests'!testElementFromModel	| group |	group := RSShapeBuilder box elementsOn: (1 to: 5).	self assert: (group elementFromModel: 1) == group first.	self assert: (group elementFromModel: 5) == group last.! !!TSNormalizerTest methodsFor: 'tests'!testBasic 	| elements |	elements := RSShapeBuilder box		elementsOn: #(1 2).		self assert: elements size equals: 2.	self assert: elements first color equals: Color gray.	RSNormalizer color		elements: elements;		normalize: #yourself.	self assert: elements first color equals: Color green.	RSNormalizer size		elements: elements;		from: 100;		to: 200;		normalize: #yourself.	self assert: elements first extent equals: 100@100.	self assert: elements first extent equals: 100@100.! !!TSScaleTest methodsFor: 'test - colors'!testCategories	| color |	color := TSScale category10.	self assert: color range size equals: 10.		1 to: 10 do: [ :i | 		self assert: (color scale: i) class equals: Color ].		1 to: 10 do: [ :i | 		self assert: (color scale: i) equals: (color scale: i + 10) ].		color := TSScale category20.		self assert: color range size equals: 20.	0 to: 19 do: [ :i | 		self assert: (color scale: i) class equals: Color ].	color := TSScale category20b.		self assert: color range size equals: 20.	color := TSScale category20c.	self assert: color range size equals: 20.		color := TSScale paired12.	self assert: color range size equals: 12.! !!TSScaleTest methodsFor: 'test - scales'!testLogScale	| log |	log := TSScale log.	self 		assert: log base equals: 10;		assert: log range equals: #(0 1);		assert: (log scale: 10) equals: 1;		assert: (log scale: 100) equals: 2;		assert: (log scale: 50) equals: 1.6989700043360185.	log := TSScale log		base: Float e;		domain: (#(0 9) collect: #exp);		range: #(200 0).	self assert: ((log scale: 50) closeTo: 113.06615543493011).	self assert: ((log scale: 0.01) closeTo: 302.3371152441798).	self assert: ((log scale: 100) closeTo: 97.66288475582019).	self assert: ((log invert: 10) closeTo: 5166.754427175983).		self assert: (log scale: 9000) closeTo: -2.3328856959635047.	log clamp: true.	self		assert: (log scale: 9000) closeTo: 0;		assert: log interpolate equals: TSInterpolator.	log interpolate: TSInterpolator	! !!TSScaleTest methodsFor: 'test - scales'!testOrdinalScale	| ordinal |	ordinal := TSScale ordinal		domain: #('a' 'b' 'c' 'd' 'e' 'f');		range: #(10 20 30 40 50 60).	self 		assert: (ordinal scale: 'a') equals: 10;		assert: (ordinal scale: 'd') equals: 40;		assert: (ordinal scale: 'f') equals: 60.		! !!TSScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangeBands	| ordinal |	ordinal := TSScale ordinal		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeBands: #(0 960).	self 		assert: ordinal rangeBand equals: 160;		assert: (ordinal scale: 'a') equals: 0;		assert: (ordinal scale: 'd') equals: 480;		assert: (ordinal scale: 'f') equals: 800;				assert: ordinal rangeExtent equals: #(0 960)		! !!TSScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangePoints	| ordinal |	ordinal := TSScale ordinal		domain: #('apple' 'orange' 'banana' 'grape');		rangePoints: #(0 960).	self 		assert: (ordinal scale: 'apple') equals: 0;		assert: (ordinal scale: 'orange') equals: 320;		assert: (ordinal scale: 'grape') equals: 960;				assert: ordinal rangeExtent equals: #(0 960)			! !!TSScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangeRoundBands	| ordinal |	ordinal := TSScale ordinal		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeRoundBands: #(0 960) padding: 0.1.	self 		assert: ordinal rangeBand equals: 141;		assert: (ordinal scale: 'a') equals: 17;		assert: (ordinal scale: 'd') equals: 488;		assert: (ordinal scale: 'f') equals: 802;		assert: ordinal rangeExtent equals: #(0 960).			ordinal := TSScale ordinal		domain: #('a' 'b' 'c' 'd' 'e' 'f');		rangeRoundBands: #(0 960).	self 		assert: ordinal rangeBand equals: 160;		assert: (ordinal scale: 'a') equals: 0;		assert: (ordinal scale: 'd') equals: 480;		assert: (ordinal scale: 'f') equals: 800;		assert: ordinal rangeExtent equals: #(0 960)! !!TSScaleTest methodsFor: 'test - scales'!testOrdinalScaleRangeRoundPoints	| ordinal |	ordinal := TSScale ordinal		domain: #(1 2 3 4);		rangeRoundPoints: #(0 100).	self 		assert: ordinal rangeBand equals: 0;		assert: (ordinal scale: 1) equals: 0;		assert: (ordinal scale: 2) equals: 33.333333333333333;		assert: (ordinal scale: 4) equals: 100.	! !!TSScaleTest methodsFor: 'test - scales'!testPowScale	| pow |	pow := TSScale pow.		self		assert: pow exponent equals: 1;		assert: (pow scale: 5) equals: 5.	pow exponent: 2.	self		assert: (pow scale: 5) equals: 25;		assert: (pow invert: 25) equals: 5;		assert: pow exponent equals: 2.		pow 		domain: #(0 100);		range: #(-10 10);		clamp: true.			self 		assert: (pow scale: 200) equals: 10;		assert: (pow scale: 99.9) closeTo: 9.960020000000004.	pow interpolate: TSRoundInterpolator.	self 		assert: pow interpolate equals: TSRoundInterpolator;		assert: (pow scale: 99.9) equals: 10;		assert: pow range equals: #(-10 10)! !!TSScaleTest methodsFor: 'test - linear'!testRandom	"Random uses TSScale linear"	| random value |	random := SharedRandom globalGenerator.	value := random rsNext: 10.	self assert: (value between: 0 and: 10).	value := random rsNext: -10 and: -5.	self assert: (value between: -10 and: -5 ).! !!TSScaleTest methodsFor: 'test - linear'!testScaleLinear	| linear |	linear := TSScale linear.	self 		assert: linear domain equals: #(0 1);		assert: linear range equals: #(0 1).	linear range: #(1 10).	self		assert: (linear scale: 1) equals: 10;		assert: (linear scale: 0.5) equals: 5.5.			self assert: linear interpolate equals: TSInterpolator.	self assert: linear uninterpolate equals: TSUninterpolateNumber.		! !!TSScaleTest methodsFor: 'test - linear'!testScaleLinearClamp	| linear |	linear := TSScale linear		domain: #(0 10);		range: #(0 100).	self assert: (linear scale: 11) equals: 110.	self assert: (linear scale: -5) equals: -50.	linear clamp: true.	self assert: (linear scale: 11) equals: 100.	self assert: (linear scale: -5) equals: 0.! !!TSScaleTest methodsFor: 'test - linear'!testScaleLinearColors	| linear |	linear := TSScale linear		domain: #(0 100);		range: #('white' 'black').	self assert: (linear scale: 50) equals: Color gray.	self assert: (linear scale: 0) equals: Color white.	self assert: (linear scale: 100) equals: Color black.	! !!TSScaleTest methodsFor: 'test - linear'!testScaleLinearInvert	| linear |	linear := TSScale linear		domain: #(-5 5);		range: #(40 50).	self 		assert: (linear scale: 0) equals: 45;		assert: (linear scale: 5) equals: 50;		assert: (linear invert: 50) equals: 5;		assert: (linear invert: 40) equals: -5	! !!TSScaleTest methodsFor: 'test - linear'!testScaleLinearRound	| linear |	linear := TSScale linear		domain: #(-5 5);		rangeRound: #(40 50).	self 		assert: (linear scale: 0.2) equals: 45;		assert: (linear scale: 5.1) equals: 50;		assert: (linear invert: 50) equals: 5;		assert: (linear invert: 40) equals: -5	! !!TSScaleTest methodsFor: 'test - linear'!testScalePolyLinear	| linear |	linear := TSScale linear		domain: #(0 0.5 1);		range: #(10 80 10).	self 		assert: (linear scale: 0) equals: 10;		assert: (linear scale: 0.5) equals: 80;		assert: (linear scale: 1) equals: 10;		assert: (linear scale: 1.5) equals: -60.	linear := TSScale linear		domain: #(0 0.5 1);		range: #('white' 'black' 'white').	self 		assert: (linear scale: 0) equals: Color white;		assert: (linear scale: 0.25) equals: Color gray;		assert: (linear scale: 0.75) equals: Color gray.			! !!TSScaleTest methodsFor: 'test - colors'!testSetInterpolator	| scale |	scale := TSScale linear		range: { 'white'. 'black' }.	self assert: (scale scale: 0.5) equals: Color gray.	scale interpolate: TSColorHSLAInterpolator.	self assert: (scale scale: 0.5) equals: Color gray.	scale interpolate: TSColorHSVAInterpolator.	self assert: (scale scale: 0.5) equals: Color gray.! !!TSScaleTest methodsFor: 'test - scales'!testSqrt	| sqrt |	sqrt := TSScale sqrt.	self 		assert: sqrt exponent equals: 0.5;		assert: ((sqrt scale: 9) closeTo: 3).		sqrt := TSScale sqrt		domain: #(0 36756666);		range: #(0 220).	self assert: (sqrt scale: 4661900) closeTo: 78.34947695663722	! !!TSTest class methodsFor: 'testing'!isAbstract	^ self = TSTest! !"Roassal3-Tests"!!ArrayOfArraysTest commentStamp: '<historical>' prior: 0!An ArrayOfArraysTest is a test class for testing the behavior of ArrayOfArrays!!COOSparseMatrixTest commentStamp: '<historical>' prior: 0!A COOSparseMatrixTest is a test class for testing the behavior of COOSparseMatrix!!LILSparseMatrixTest commentStamp: '<historical>' prior: 0!A LILSparseMatrixTest is a test class for testing the behavior of LILSparseMatrix!!ArrayOfArrays commentStamp: 'YaroslavKormushyn 4/18/2018 11:36' prior: 0!I represent a matrix of numbers.I store a table of numbers. l know my size.My main collaborator is Array, which is the internal representaion of my rows.Public API and Key Messages- columnNumber- rowNumber- at: at:- at:at:put:- removeAt:at:- transpose- copy- withAll:Instance creation:1) An empty matrix of size [ number_of_rows x number_of_columns ]- ArrayOfArrays rows: number_of_rows columns: number_of_columns2) Matrix of size 2x2			[ 1 0 ]			[ 2 0 ]- ArrayOfArrays withAll: { { 1 . 0 } . { 2 . 0 } }   Internal Representation and Key Implementation Points.    Instance Variables	columnNumber:		<SmallInteger>	rowNumber:			<SmallInteger>	rows:				<Array>!!COOSparseMatrix commentStamp: 'YaroslavKormushyn 4/18/2018 11:03' prior: 0!I represent a sparse matrix of numbers.I store a low-density table of numbers. l know my size, first and last element in the table as a sequence of rows left to right.My main collaborator is COOMatrixNode, which is the internal representaion of my elements.Public API and Key Messages- columnNumbers- rowNumbers- at: at:- at:at:put:- copy- removeAt:at:- transpose- copy- withAll:Instance creation:1) An empty matrix of size [ number_of_rows x number_of_columns ]- COOSparseMatrix rows: number_of_rows columns: number_of_columns2) Matrix of size 2x2			[ 1 0 ]			[ 2 0 ]- COOSparseMatrix withAll: { { 1 . 0 } . { 2 . 0 } }   Internal Representation and Key Implementation Points.    Instance Variables	columnNumber:		<SmallInteger>	rowNumber:			<SmallInteger>	first:				<COOMatrixNode>	last:					<COOMatrixNode>Implementation PointsMy internal representation of values is a sorted linked list, each node represented by COOSparseMatrixNode.!!COOSparseMatrixNode commentStamp: 'YaroslavKormushyn 4/16/2018 11:09' prior: 0!I represent a value wrapper for COOSparseMatrix.I store values of kind Number, row and column position in a COOSparseMatrix, my left and right neighbour.I'm used by COOSparseMatrix for storing values.Public API and Key Messages- column   - row - value- leftNeighbour - rightNeighbourInstance creation:1) From metaclass (with or without value):	COOMatrixNode row: num1 column: num2 [value: num3]	Internal Representation and Key Implementation Points.    Instance Variables	column:				<SmallInteger>	leftNeighbour:		<COOMatrixNode>	rightNeighbour:		<COOMatrixNode>	row:				<SmallInteger>	value:				<SmallInteger>!!LILSparseMatrix commentStamp: 'YaroslavKormushyn 4/18/2018 11:07' prior: 0!I represent a sparse matrix of numbers.I store a low-density table of numbers. l know my dimensions.My main collaborator is LILSparseMatrixNode, which is the internal representaion of my elements.Public API and Key Messages- columnNumber- rowNumber- at: at:- at:at:put:Instance creation:1) An empty matrix of size number_of_rows x number_of_columns- LILSparseMatrix rows: number_of_rows columns: number_of_columns2) Matrix of size 2x2			[ 1 0 ]			[ 2 0 ]- LILSparseMatrix withAll: { { 1 . 0 } . { 2 . 0 } }   Internal Representation and Key Implementation Points.    Instance Variables	columnNumber:		<SmallInteger>	rowNumber:			<SmallInteger>	rows:				<Array>    Implementation PointsI store my rows as elements of kind LinkedList in instance variable 'rows'.!!LILSparseMatrixNode commentStamp: 'YaroslavKormushyn 4/18/2018 11:05' prior: 0!I represent a value wrapper for LILSparseMatrix.I store values of kind Number, column position in a LILSparseMatrix.I'm used by LILSparseMatrix for storing values.Public API and Key Messages- column   - value - column:value:Internal Representation and Key Implementation Points.    Instance Variables	column:		<SmallIInteger>	value:		<Number>Instance creation:1) From metaclass:	LILMatrixNode column:num1 value: num2!!TWMatrixNode commentStamp: 'YaroslavKormushyn 4/18/2018 11:12' prior: 0!I represent a value wrapper for TWSparseMatrix.I store values of kind Number, row and column position in a TWSparseMatrix, right and below neighbour.I'm used by TWSparseMatrix for storing values.Public API and Key Messages- column  - row - value - value:row:column:- rightNeighbour:belowNeighbour:- copyInternal Representation and Key Implementation Points.    Instance Variables	row:		<SmallInteger>	column:		<SmallInteger>	value:		<Number>	rightNeighbour: <TWMatrixNode>	belowNeighbour: <TWMatrixNode>Instance creation:1) From metaclass:	TWMatrixNode row:num1 column:num2 value: num3OR	TWMatrixNode new: num1 atRow: num2 atColumn: num3!!TWSparseMatrix commentStamp: 'YaroslavKormushyn 4/18/2018 11:18' prior: 0!I represent a sparse matrix of numbers.I can be multiplied with other matrices, added to other matrices, multiplied by a number, transposed.I store a low-density table of numbers. l know my dimensions.My main collaborator is TWMatrixNode, which is the internal representaion of my elements.Public API and Key Messages- columnsNumber- rowsNumber- at: at:- at:at:put:- removeAt:at:- copy- transpose- isEmptyInstance creation:1) An empty matrix of size number_of_rows x number_of_columns- TWSparseMatrix rows: number_of_rows columns: number_of_columns2) Matrix of size 2x2			[ 1 0 ]			[ 2 0 ]- LILSparseMatrix withAll: { { 1 . 0 } . { 2 . 0 } }       Instance Variables	columnsNumber:		<SmallInteger>	rowsNumber:		<SmallInteger>	rows:				<Array>	columns:			<Array>!!ArrayOfArraysTest methodsFor: 'running' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 3.	columns := 3.	factor := 4.	empty := ArrayOfArrays rows: rows columns: columns.	twoByTwo := ArrayOfArrays withAll: { { 1 . 2 } . { 4 . 5 } }.	full := ArrayOfArrays withAll: { { 1 . 2 . 3 } . { 4 . 5 . 6 } . { 7 . 8 . 9 } }.	left := ArrayOfArrays withAll: { { 0 . 0 . 2 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.	right := ArrayOfArrays withAll: { { 1 . 0 . 0 } . { 2 . 0 . 4 } . { 0 . 1 . 0 } }.	leftPlusRight := ArrayOfArrays withAll: { { 1 . 0 . 2 } . { 4 . 0 . 4 } . { 5 . 1 . 0 } }.	leftByRight := ArrayOfArrays withAll: { { 0 . 2 . 0 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.! !!ArrayOfArraysTest methodsFor: 'tests-arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAddition	| result |	result := left + right.	self assert: (result at: 1 at: 1) equals: (leftPlusRight at: 1 at: 1).	self assert: (result at: 1 at: 2) equals: (leftPlusRight at: 1 at: 2).	self assert: (result at: 1 at: 3) equals: (leftPlusRight at: 1 at: 3).	self assert: (result at: 2 at: 1) equals: (leftPlusRight at: 2 at: 1).	self assert: (result at: 2 at: 2) equals: (leftPlusRight at: 2 at: 2).	self assert: (result at: 2 at: 3) equals: (leftPlusRight at: 2 at: 3).	self assert: (result at: 3 at: 1) equals: (leftPlusRight at: 3 at: 1).	self assert: (result at: 3 at: 2) equals: (leftPlusRight at: 3 at: 2).	self assert: (result at: 3 at: 3) equals: (leftPlusRight at: 3 at: 3)! !!ArrayOfArraysTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAt	self assert: (full at: 1 at: 1) equals: 1.	self assert: (full at: 3 at: 2) equals: 8.	self assert: (left at: 3 at: 2) equals: 0.	self should: [ left at: rows + 1 at: 3 ] raise: SubscriptOutOfBounds! !!ArrayOfArraysTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAtPut	self assert: (full at: 1 at: 1) equals: 1.	full at: 1 at: 1 put: 2.	self assert: (full at: 1 at: 1) equals: 2.	full at: 1 at: 1 put: 0.	self assert: (full at: 1 at: 1) equals: 0.	self should: [ full at: rows + 1 at: columns + 1 put: 1 ] raise: SubscriptOutOfBounds! !!ArrayOfArraysTest methodsFor: 'tests-private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByMatrix	| result |	result := left * right.	self assert: (result at: 1 at: 1) equals: (leftByRight at: 1 at: 1).	self assert: (result at: 1 at: 2) equals: (leftByRight at: 1 at: 2).	self should: [ twoByTwo * left ] raise: Error	! !!ArrayOfArraysTest methodsFor: 'tests-private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByNumber	| result |	result := full * factor.	self assert: (result at: 1 at: 1) equals: (full at: 1 at: 1) * factor.	self assert: (result at: 2 at: 2) equals: (full at: 2 at: 2) * factor.	self assert: (result at: 3 at: 2) equals: (full at: 3 at: 2) * factor! !!ArrayOfArraysTest methodsFor: 'tests-as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testColumnNumber 	self assert: left columnNumber equals: columns! !!ArrayOfArraysTest methodsFor: 'tests-as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testRowNumber	 self assert: left rowNumber equals: rows! !!ArrayOfArraysTest methodsFor: 'tests-as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testTranspose	| transposed |	transposed := full transpose.	self assert: (transposed at: 1 at: 1) equals: (full at: 1 at: 1).	self assert: (transposed at: 1 at: 3) equals: (full at: 3 at: 1).	self assert: (transposed at: 2 at: 3) equals: (full at: 3 at: 2).	self assert: (transposed at: 3 at: 2) equals: (full at: 2 at: 3)! !!ArrayOfArraysTest methodsFor: 'tests-instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testWithAll	| result |	result := ArrayOfArrays withAll: { { 1 . 2 } . { 0 . 1 } }.	self assert: result columnNumber equals: 2.	self assert: result rowNumber equals: 2.	self assert: (result at: 1 at: 1) equals: 1.! !!COOSparseMatrixTest methodsFor: 'running' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 3.	columns := 3.	factor := 4.	empty := COOSparseMatrix rows: rows columns: columns.	twoByTwo := COOSparseMatrix withAll: { { 1 . 2 } . { 4 . 5 } }.	full := COOSparseMatrix withAll: { { 1 . 2 . 3 } . { 4 . 5 . 6 } . { 7 . 8 . 9 } }.	left := COOSparseMatrix withAll: { { 0 . 0 . 2 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.	right := COOSparseMatrix withAll: { { 1 . 0 . 0 } . { 2 . 0 . 4 } . { 0 . 1 . 0 } }.	leftPlusRight := COOSparseMatrix withAll: { { 1 . 0 . 2 } . { 4 . 0 . 4 } . { 5 . 1 . 0 } }.	leftByRight := COOSparseMatrix withAll: { { 0 . 2 . 0 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.! !!COOSparseMatrixTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAddition	| result |	result := left + right.	self assert: (result at: 1 at: 1) equals: (leftPlusRight at: 1 at: 1).	self assert: (result at: 1 at: 2) equals: (leftPlusRight at: 1 at: 2).	self assert: (result at: 1 at: 3) equals: (leftPlusRight at: 1 at: 3).	self assert: (result at: 2 at: 1) equals: (leftPlusRight at: 2 at: 1).	self assert: (result at: 2 at: 2) equals: (leftPlusRight at: 2 at: 2).	self assert: (result at: 2 at: 3) equals: (leftPlusRight at: 2 at: 3).	self assert: (result at: 3 at: 1) equals: (leftPlusRight at: 3 at: 1).	self assert: (result at: 3 at: 2) equals: (leftPlusRight at: 3 at: 2).	self assert: (result at: 3 at: 3) equals: (leftPlusRight at: 3 at: 3)! !!COOSparseMatrixTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAdditionFail	self should: [ left + twoByTwo ] raise: Error! !!COOSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAt	self assert: (full at: 1 at: 1) equals: 1.	self assert: (full at: 3 at: 2) equals: 8.	self assert: (left at: 3 at: 2) equals: 0.	self should: [ left at: rows + 1 at: 3 ] raise: SubscriptOutOfBounds! !!COOSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAtPut	self assert: (full at: 1 at: 1) equals: 1.	full at: 1 at: 1 put: 2.	self assert: (full at: 1 at: 1) equals: 2.	full at: 1 at: 1 put: 0.	self assert: (full at: 1 at: 1) equals: 0.	self should: [ full at: rows + 1 at: columns + 1 put: 1 ] raise: SubscriptOutOfBounds! !!COOSparseMatrixTest methodsFor: 'tests-private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByMatrix	| result |	result := left * right.	self assert: (result at: 1 at: 1) equals: (leftByRight at: 1 at: 1).	self assert: (result at: 1 at: 2) equals: (leftByRight at: 1 at: 2).	self should: [ twoByTwo * left ] raise: Error	! !!COOSparseMatrixTest methodsFor: 'tests-private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByNumber	| result |	result := full * factor.	self assert: (result at: 1 at: 1) equals: (full at: 1 at: 1) * factor.	self assert: (result at: 2 at: 2) equals: (full at: 2 at: 2) * factor.	self assert: (result at: 3 at: 2) equals: (full at: 3 at: 2) * factor! !!COOSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testColumnNumber 	self assert: left columnNumber equals: columns! !!COOSparseMatrixTest methodsFor: 'tests-as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testCopy	| copy |	copy := left copy.	self assert: (left at: 3 at: 2) equals: (copy at: 3 at: 2).	self assert: (left at: 1 at: 2) equals: (copy at: 1 at: 2).	self assert: (left at: 2 at: 1) equals: (copy at: 2 at: 1).	self deny: (left first) == (copy first).	self deny: (left last) == (copy last).! !!COOSparseMatrixTest methodsFor: 'tests-testing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testIsEmpty	self assert: empty isEmpty .	self deny: full isEmpty! !!COOSparseMatrixTest methodsFor: 'tests-as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testRemoveAtAt	self assert: (full at: 1 at: 1) equals: 1.	full removeAt: 1 at:  1.	self assert: (full at: 1 at: 1) equals: 0	! !!COOSparseMatrixTest methodsFor: 'tests-transformation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testTranspose	| transposed |	transposed := full transpose.	self assert: (transposed at: 1 at: 1) equals: (full at: 1 at: 1).	self assert: (transposed at: 1 at: 3) equals: (full at: 3 at: 1).	self assert: (transposed at: 2 at: 3) equals: (full at: 3 at: 2).	self assert: (transposed at: 3 at: 2) equals: (full at: 2 at: 3)! !!COOSparseMatrixTest methodsFor: 'tests-private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testWithAll	| result |	result := COOSparseMatrix withAll: { { 1 . 2 } . { 0 . 1 } }.	self assert: result columnNumber equals: 2.	self assert: result rowNumber equals: 2.	self assert: (result at: 1 at: 1) equals: 1.! !!LILSparseMatrixTest methodsFor: 'running' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 3.	columns := 3.	factor := 2.	twoByTwo := LILSparseMatrix withAll: { { 1 . 2 } . { 4 . 5 } }.	empty := LILSparseMatrix rows: rows columns: columns.	full := LILSparseMatrix withAll: { { 1 . 2 . 3 } . { 4 . 5 . 6 } . { 7 . 8 . 9 } }.	left := LILSparseMatrix withAll: { { 0 . 0 . 2 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.	right := LILSparseMatrix withAll: { { 1 . 0 . 0 } . { 2 . 0 . 4 } . { 0 . 1 . 0 } }.		leftPlusRight := LILSparseMatrix withAll: { { 1 . 0 . 2 } . { 4 . 0 . 4 } . { 5 . 1 . 0 } }.	leftByRight := LILSparseMatrix withAll: { { 0 . 2 . 0 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.! !!LILSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAddition	| result |	result := left + right.	self assert: (result at: 1 at: 1) equals: (leftPlusRight at: 1 at: 1).	self assert: (result at: 2 at: 1) equals: (leftPlusRight at: 2 at: 1)! !!LILSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAt	self assert: (full at: 1 at: 1) equals: 1! !!LILSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAtPut	self assert: (full at: 1 at: 1) equals: 1.	full at: 1 at: 1 put: 2.	self assert: (full at: 1 at: 1) equals: 2.	full at: 1 at: 1 put: 0.	self assert: (full at: 1 at: 1) equals: 0.	self should: [ full at: rows + 1 at: columns + 1 put: 1 ] raise: SubscriptOutOfBounds! !!LILSparseMatrixTest methodsFor: 'tests-arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByMatrix	| result |	result := left * right.	self assert: (result at: 1 at: 1) equals: (leftByRight at: 1 at: 1).	self assert: (result at: 1 at: 2) equals: (leftByRight at: 1 at: 2).	self should: [ twoByTwo * left ] raise: Error! !!LILSparseMatrixTest methodsFor: 'tests-arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByNumber	| result |	result := left * factor.	self assert: (result at: 1 at: 1) equals: (left at: 1 at: 1) * factor.	self assert: (result at: 1 at: 3) equals: (left at: 1 at: 3) * factor.	self assert: (result at: 3 at: 1) equals: (left at: 3 at: 1) * factor.! !!LILSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testColumnNumberself assert: left columnNumber equals: columns! !!LILSparseMatrixTest methodsFor: 'tests-copying' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testCopy	| copy |	copy := left copy.	self assert: (copy at: 3 at: 1) equals: (left at: 3 at: 1).	self assert: (left at: 3 at: 2) equals: (copy at: 3 at: 2).	self assert: (left at: 1 at: 2) equals: (copy at: 1 at: 2).	self assert: (left at: 2 at: 1) equals: (copy at: 2 at: 1).	copy := copy * factor.	self assert: (copy at: 3 at: 1) equals: (left at: 3 at: 1) * factor.! !!LILSparseMatrixTest methodsFor: 'tests-removal' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testRemoveAtAt	self assert: (full at: 1 at: 1) equals: 1.	full removeAt: 1 at: 1.	self assert: (full at: 1 at: 1) equals: 0! !!LILSparseMatrixTest methodsFor: 'tests-transforming' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testTranspose	| transposed |	transposed := full transpose.	self assert: (transposed at: 1 at: 1) equals: (full at: 1 at: 1).	self assert: (transposed at: 1 at: 3) equals: (full at: 3 at: 1).	self assert: (transposed at: 2 at: 3) equals: (full at: 3 at: 2).	self assert: (transposed at: 3 at: 2) equals: (full at: 2 at: 3)! !!LILSparseMatrixTest methodsFor: 'tests-instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testWithAll	| matrix |	matrix := LILSparseMatrix withAll: { { 0 . 0 } . { 1 . 2 } }.	self assert: (matrix rowNumber) equals: 2.	self assert: (matrix columnNumber) equals: 2.	self assert: (matrix at: 1 at: 1) equals: 0.	self assert: (matrix at: 2 at: 1) equals: 1! !!SparseMatrixTest methodsFor: 'running' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 100.	columns := 100.	density := 0.1.	rand := Random new.	factor := 36.	! !!SparseMatrixTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testArrSparseMatrix		| matrix matrix2 matrix3 |	matrix := ArrayOfArrays rows: rows columns: columns element: 0.	matrix2 := ArrayOfArrays rows: rows columns: columns element: 0.		Transcript show: 'Array of Arrays Matrix Testing:'; cr;			    show: 'Size is ', rows asString, '*', columns asString; cr;			show: 'Density is ', density asString;cr;			    show: 'Time to set: ';			    show: 		[1 to: rows * columns * density do: [ :index | 			matrix 				at: (rand nextInt: rows)				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1).			matrix2 				at: (rand nextInt: rows)				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1)]		] timeToRun asMilliSeconds asString, ' ms'; cr.		Transcript show: 'Time to add: ';				show: [ matrix + matrix2 ] timeToRun asMilliSeconds asString, ' ms'; cr.					Transcript show: 'Time to multiply (by number): ';				show: [ matrix * factor ] timeToRun asMilliSeconds asString, ' ms'; cr.		Transcript show: 'Transposition: ';				show: [matrix3 := matrix2 transpose] timeToRun asMilliSeconds asString, ' ms'; cr.	Transcript show: 'Time to multiply (by matrix): ';				show: [ matrix * matrix3 ] timeToRun asMilliSeconds asString, ' ms'; cr; cr;	show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: matrix sizeInMemory;		cr;		show: 'Second matrix - ';		show: matrix2 sizeInMemory;		cr;cr;cr! !!SparseMatrixTest methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testCOOSparseMatrix	| coo coo2 coo3 |	coo := COOSparseMatrix rows: rows columns: columns.	coo2 := COOSparseMatrix rows: rows columns: columns.	Transcript		show: 'COOSparseMatrix Testing:';		cr;		show: 'Size is ', rows asString, '*', columns asString; cr;		show: 'Density is ', density asString;cr;		show: 'Time to set: ';		show:			[ 1 to: rows * columns *density do: [ :index | 				coo					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1).				coo2					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1) ] ] timeToRun asMilliSeconds asString, ' ms';		cr.	Transcript		show: 'Time to add: ';		show: [ coo + coo2 ] timeToRun asMilliSeconds asString, ' ms';		cr.	Transcript		show: 'Time to multiply (by number): ';		show: [ coo * factor ] timeToRun asMilliSeconds asString, ' ms';		cr.		Transcript show: 'Transposition: ';				show: [coo3 := coo2 transpose] timeToRun asMilliSeconds asString, ' ms'; cr.	Transcript		show: 'Time to multiply (by matrix): ';		show: [ coo *  coo3 ] timeToRun asMilliSeconds asString, ' ms';		cr;		cr.	Transcript		show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: coo sizeInMemory;		cr;		show: 'Second matrix - ';		show: coo2 sizeInMemory;		cr;cr;cr! !!SparseMatrixTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testLILSparseMatrix	| lil lil2 lil3 |	lil := LILSparseMatrix rows: rows columns: columns.	lil2 := LILSparseMatrix rows: rows columns: columns.		Transcript show: 'LILSparseMatrix Testing:'; cr;			    show: 'Size is ', rows asString, '*', columns asString; cr;			show: 'Density is ', density asString;cr;			    show: 'Time to set: ';			    show: 		[1 to: rows * columns * density do: [ :index | 			lil 				at: (rand nextInt: rows) 				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1).			lil2 				at: (rand nextInt: rows) 				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1)]		] timeToRun asMilliSeconds asString, ' ms' ; cr.		Transcript show: 'Time to add: ';				show: [ lil + lil2 ] timeToRun  asMilliSeconds asString, ' ms' ; cr.					Transcript show: 'Time to multiply (by number): ';				show: [ lil * factor ] timeToRun asMilliSeconds asString, ' ms'; cr.					Transcript show: 'Transposition: ';				show: [lil3 := lil2 transpose] timeToRun asMilliSeconds asString, ' ms'; cr.	Transcript show: 'Time to multiply (by matrix): ';				show: [ lil *  lil3 ] timeToRun asMilliSeconds asString, ' ms'; cr; cr.	Transcript		show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: lil sizeInMemory;		cr;		show: 'Second matrix - ';		show: lil2 sizeInMemory;		cr;cr;cr! !!SparseMatrixTest methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testTWSparseMatrix	| tw tw2 tw3 |	tw := TWSparseMatrix rows: rows columns: columns.	tw2 := TWSparseMatrix rows: rows columns: columns.	Transcript		show: 'TWSparseMatrix Testing:';		cr;		show: 'Size is ' , rows asString , '*' , columns asString;		cr;		show: 'Density is ' , density asString;		cr;		show: 'Time to set: ';		show:			[ 1 to: rows * columns * density do: [ :index | 				tw					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1).				tw2					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1) ] ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Time to add: ';		show: [ tw + tw2 ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Time to multiply (by number): ';		show: [ tw * factor ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Transposition: ';		show: [ tw3 := tw2 transpose ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Time to multiply (by matrix): ';		show: [ tw * tw3 ] timeToRun asMilliSeconds asString , ' ms';		cr;		cr.	Transcript		show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: tw sizeInMemory;		cr;		show: 'Second matrix - ';		show: tw2 sizeInMemory;		cr;		cr;		cr! !!SparseMatrixTestAOA methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 300.	columns := 300.	density := 0.45.	rand := Random new.	factor := 36.	! !!SparseMatrixTestAOA methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testArrSparseMatrix		| matrix matrix2 matrix3 |	matrix := ArrayOfArrays rows: rows columns: columns element: 0.	matrix2 := ArrayOfArrays rows: rows columns: columns element: 0.		Transcript show: 'Array of Arrays Matrix Testing:'; cr;			    show: 'Size is ', rows asString, '*', columns asString; cr;			show: 'Density is ', density asString;cr;			    show: 'Time to set: ';			    show: 		[1 to: rows * columns * density do: [ :index | 			matrix 				at: (rand nextInt: rows)				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1).			matrix2 				at: (rand nextInt: rows)				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1)]		] timeToRun asMilliSeconds asString, ' ms'; cr.		Transcript show: 'Time to add: ';				show: [ matrix + matrix2 ] timeToRun asMilliSeconds asString, ' ms'; cr.					Transcript show: 'Time to multiply (by number): ';				show: [ matrix * factor ] timeToRun asMilliSeconds asString, ' ms'; cr.		Transcript show: 'Transposition: ';				show: [matrix3 := matrix2 transpose] timeToRun asMilliSeconds asString, ' ms'; cr.	Transcript show: 'Time to multiply (by matrix): ';				show: [ matrix * matrix3 ] timeToRun asMilliSeconds asString, ' ms'; cr; cr;	show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: matrix sizeInMemory;		cr;		show: 'Second matrix - ';		show: matrix2 sizeInMemory;		cr;cr;cr! !!SparseMatrixTestCOO methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 300.	columns := 300.	density := 0.45.	rand := Random new.	factor := 36.	! !!SparseMatrixTestCOO methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testCOOSparseMatrix	| coo coo2 coo3 |	coo := COOSparseMatrix rows: rows columns: columns.	coo2 := COOSparseMatrix rows: rows columns: columns.	Transcript		show: 'COOSparseMatrix Testing:';		cr;		show: 'Size is ', rows asString, '*', columns asString; cr;		show: 'Density is ', density asString;cr;		show: 'Time to set: ';		show:			[ 1 to: rows * columns *density do: [ :index | 				coo					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1).				coo2					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1) ] ] timeToRun asMilliSeconds asString, ' ms';		cr.	Transcript		show: 'Time to add: ';		show: [ coo + coo2 ] timeToRun asMilliSeconds asString, ' ms';		cr.	Transcript		show: 'Time to multiply (by number): ';		show: [ coo * factor ] timeToRun asMilliSeconds asString, ' ms';		cr.		Transcript show: 'Transposition: ';				show: [coo3 := coo2 transpose] timeToRun asMilliSeconds asString, ' ms'; cr.	Transcript		show: 'Time to multiply (by matrix): ';		show: [ coo *  coo3 ] timeToRun asMilliSeconds asString, ' ms';		cr;		cr.	Transcript		show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: coo sizeInMemory;		cr;		show: 'Second matrix - ';		show: coo2 sizeInMemory;		cr;cr;cr! !!SparseMatrixTestLIL methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 300.	columns := 300.	density := 0.45.	rand := Random new.	factor := 36.	! !!SparseMatrixTestLIL methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testLILSparseMatrix	| lil lil2 lil3 |	lil := LILSparseMatrix rows: rows columns: columns.	lil2 := LILSparseMatrix rows: rows columns: columns.		Transcript show: 'LILSparseMatrix Testing:'; cr;			    show: 'Size is ', rows asString, '*', columns asString; cr;			show: 'Density is ', density asString;cr;			    show: 'Time to set: ';			    show: 		[1 to: rows * columns * density do: [ :index | 			lil 				at: (rand nextInt: rows) 				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1).			lil2 				at: (rand nextInt: rows) 				at: (rand nextInt: columns) 				put: ((rand next < 0.5) 					ifTrue: 1 					ifFalse: -1)]		] timeToRun asMilliSeconds asString, ' ms' ; cr.		Transcript show: 'Time to add: ';				show: [ lil + lil2 ] timeToRun  asMilliSeconds asString, ' ms' ; cr.					Transcript show: 'Time to multiply (by number): ';				show: [ lil * factor ] timeToRun asMilliSeconds asString, ' ms'; cr.					Transcript show: 'Transposition: ';				show: [lil3 := lil2 transpose] timeToRun asMilliSeconds asString, ' ms'; cr.	Transcript show: 'Time to multiply (by matrix): ';				show: [ lil *  lil3 ] timeToRun asMilliSeconds asString, ' ms'; cr; cr.	Transcript		show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: lil sizeInMemory;		cr;		show: 'Second matrix - ';		show: lil2 sizeInMemory;		cr;cr;cr! !!SparseMatrixTestTW methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp	rows := 300.	columns := 300.	density := 0.45.	rand := Random new.	factor := 36! !!SparseMatrixTestTW methodsFor: 'tests' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testTWSparseMatrix	| tw tw2 tw3 |	tw := TWSparseMatrix rows: rows columns: columns.	tw2 := TWSparseMatrix rows: rows columns: columns.	Transcript		show: 'TWSparseMatrix Testing:';		cr;		show: 'Size is ' , rows asString , '*' , columns asString;		cr;		show: 'Density is ' , density asString;		cr;		show: 'Time to set: ';		show:			[ 1 to: rows * columns * density do: [ :index | 				tw					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1).				tw2					at: (rand nextInt: rows)					at: (rand nextInt: columns)					put:						(rand next < 0.5							ifTrue: 1							ifFalse: -1) ] ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Time to add: ';		show: [ tw + tw2 ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Time to multiply (by number): ';		show: [ tw * factor ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Transposition: ';		show: [ tw3 := tw2 transpose ] timeToRun asMilliSeconds asString , ' ms';		cr.	Transcript		show: 'Time to multiply (by matrix): ';		show: [ tw * tw3 ] timeToRun asMilliSeconds asString , ' ms';		cr;		cr.	Transcript		show: 'Size in memory: ';		cr;		show: 'First matrix - ';		show: tw sizeInMemory;		cr;		show: 'Second matrix - ';		show: tw2 sizeInMemory;		cr;		cr;		cr! !!TWSparseMatrixTest methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setUp 	rows := 3.	columns := 3.	factor := 2.	twoByTwo := TWSparseMatrix withAll: { { 1 . 2 } . { 4 . 5 } }.	empty := TWSparseMatrix rows: rows columns: columns.	full := TWSparseMatrix withAll: { { 1 . 2 . 3 } . { 4 . 5 . 6 } . { 7 . 8 . 9 } }.	left := TWSparseMatrix withAll: { { 0 . 0 . 2 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.	right := TWSparseMatrix withAll: { { 1 . 0 . 0 } . { 2 . 0 . 4 } . { 0 . 1 . 0 } }.		leftPlusRight := TWSparseMatrix withAll: { { 1 . 0 . 2 } . { 4 . 0 . 4 } . { 5 . 1 . 0 } }.	leftByRight := TWSparseMatrix withAll: { { 0 . 2 . 0 } . { 2 . 0 . 0 } . { 5 . 0 . 0 } }.! !!TWSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAddition	| result |	result := left + right.	self assert: (result at: 1 at: 1) equals: (leftPlusRight at: 1 at: 1).	self assert: (result at: 2 at: 1) equals: (leftPlusRight at: 2 at: 1)! !!TWSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAt	self assert: (full at: 1 at: 1) equals: 1! !!TWSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testAtAtPut	self assert: (full at: 1 at: 1) equals: 1.	full at: 1 at: 1 put: 2.	self assert: (full at: 1 at: 1) equals: 2.	full at: 1 at: 1 put: 0.	self assert: (full at: 1 at: 1) equals: 0.	self should: [ full at: rows + 1 at: columns + 1 put: 1 ] raise: SubscriptOutOfBounds! !!TWSparseMatrixTest methodsFor: 'tests-arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByMatrix	| result |	result := left * right.	self assert: (result at: 1 at: 1) equals: (leftByRight at: 1 at: 1).	self assert: (result at: 1 at: 2) equals: (leftByRight at: 1 at: 2).	self should: [ twoByTwo * left ] raise: Error! !!TWSparseMatrixTest methodsFor: 'tests-arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testByNumber	| result |	result := left * factor.	self assert: (result at: 1 at: 1) equals: (left at: 1 at: 1) * factor.	self assert: (result at: 1 at: 3) equals: (left at: 1 at: 3) * factor.	self assert: (result at: 3 at: 1) equals: (left at: 3 at: 1) * factor.! !!TWSparseMatrixTest methodsFor: 'tests-accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testColumnNumberself assert: left columnsNumber equals: columns! !!TWSparseMatrixTest methodsFor: 'tests-copying' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testCopy	| copy |	copy := left copy.	self assert: (copy at: 3 at: 1) equals: (left at: 3 at: 1).	self assert: (left at: 3 at: 2) equals: (copy at: 3 at: 2).	self assert: (left at: 1 at: 2) equals: (copy at: 1 at: 2).	self assert: (left at: 2 at: 1) equals: (copy at: 2 at: 1).	copy := copy * factor.	self assert: (copy at: 3 at: 1) equals: (left at: 3 at: 1) * factor.! !!TWSparseMatrixTest methodsFor: 'tests-removal' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testRemoveAtAt	self assert: (full at: 1 at: 1) equals: 1.	full removeAt: 1 at: 1.	self assert: (full at: 1 at: 1) equals: 0! !!TWSparseMatrixTest methodsFor: 'tests-transforming' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testTranspose	| transposed |	transposed := full transpose.	self assert: (transposed at: 1 at: 1) equals: (full at: 1 at: 1).	self assert: (transposed at: 1 at: 3) equals: (full at: 3 at: 1).	self assert: (transposed at: 2 at: 3) equals: (full at: 3 at: 2).	self assert: (transposed at: 3 at: 2) equals: (full at: 2 at: 3)! !!TWSparseMatrixTest methodsFor: 'tests-instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!testWithAll	| matrix |	matrix := TWSparseMatrix		withAll:			{{0 . 0}.			{1 . 2}}.	self assert: matrix rowsNumber equals: 2.	self assert: matrix columnsNumber equals: 2.	self assert: (matrix at: 1 at: 1) equals: 0.	self assert: (matrix at: 2 at: 1) equals: 1! !!ArrayOfArrays class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rowNum columns: columnNum	^ self new rows: rowNum columns: columnNum ! !!ArrayOfArrays class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rowNum columns: columnNum element: aNumber	^ self new rows: rowNum columns: columnNum element: aNumber! !!ArrayOfArrays class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection^ (self new 		rows: aCollection size 		columns: (aCollection detectMax: [ :element | element size ]) size) 	withAll: aCollection! !!ArrayOfArrays methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!* anOperand	(anOperand isNumber)		ifTrue: [ ^ self byNumber: anOperand ].	(anOperand isMemberOf: self class)		ifTrue: [ ^ self byMatrix: anOperand ].	Error signal: 'Unknown type of operand for this operation'! !!ArrayOfArrays methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!+ aMatrix	| result |	(rowNumber = aMatrix rowNumber) & (columnNumber = aMatrix columnNumber)		ifFalse: [ Error signal: 'Matrices must be of the same size.' ].		result := self class rows: rowNumber columns: columnNumber.	1 to: result rowNumber do: [ :rowIndex |		1 to: result columnNumber do: [ :columnIndex |			result at: rowIndex at: columnIndex put: 				( self at: rowIndex at: columnIndex )				+ (aMatrix at: rowIndex at: columnIndex) ] ].	^ result! !!ArrayOfArrays methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowIndex at: columnIndex	(self validAt: rowIndex at: columnIndex )			ifFalse: [ SubscriptOutOfBounds signal: 'Indices must be of valid range.' ].		^ (rows at: rowIndex) at: columnIndex ! !!ArrayOfArrays methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowIndex at: columnIndex put: aValue	(self validAt: rowIndex at: columnIndex )			ifFalse: [ SubscriptOutOfBounds signal: 'Indices must be of valid range.' ].		^ (rows at: rowIndex) at: columnIndex put: aValue! !!ArrayOfArrays methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byMatrix: aMatrix	| result sum |	(columnNumber = aMatrix rowNumber)		ifFalse: [ Error signal: 'Invalid matrix sizes' ].			result := self class rows: rowNumber columns: aMatrix columnNumber.	1 to: result rowNumber do: [ :rowIndex |		1 to: result columnNumber do: [ :columnIndex |			sum := (1 to: columnNumber) inject: 0 into: [ :total :k |				total + 					((self at: rowIndex at: k) 					* (aMatrix at: k at: columnIndex )) ].			result at: rowIndex at: columnIndex put: sum ] ].	^ result! !!ArrayOfArrays methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byNumber: aNumber	| result |		result := self class rows: rowNumber columns: columnNumber.	aNumber = 0		ifTrue: [ ^ result ].			1 to: rowNumber do: [ :rowIndex |	 	1 to: columnNumber do: [ :columnIndex |			 result 				at: rowIndex 				at: columnIndex 				put: (self at: rowIndex at: columnIndex) * aNumber ]].	^ result! !!ArrayOfArrays methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!columnNumber ^ columnNumber! !!ArrayOfArrays methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!columnNumber: aNumber	columnNumber  := aNumber! !!ArrayOfArrays methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!removeAt: rowIndex at: columnIndex	(self validAt: rowIndex at: columnIndex)		ifFalse: [ SubscriptOutOfBounds signal: 'Indices must be of valid range.' ].	^ (rows at: rowIndex) at: columnIndex put: 0! !!ArrayOfArrays methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rowNumber	^ rowNumber ! !!ArrayOfArrays methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rowNumber: aNumber	rowNumber := aNumber! !!ArrayOfArrays methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rowNum columns: colNum	rowNumber := rowNum.	columnNumber := colNum.	rows := (1 to: rowNumber) collect: [ :index | Array new: columnNumber ]! !!ArrayOfArrays methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rowNum columns: colNum element: aNumber	rowNumber := rowNum.	columnNumber := colNum.	rows := (1 to: rowNumber) collect: [ :index | (Array new: columnNumber) atAllPut: aNumber].! !!ArrayOfArrays methodsFor: 'transformation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!transpose	| result |	result := self class rows: columnNumber columns: rowNumber.	result withAll: ((1 to: result rowNumber) collect: [ :rowIndex |	(1 to: result columnNumber) collect: [ :columnIndex |		self at: columnIndex at: rowIndex ] ]).		^ result! !!ArrayOfArrays methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!validAt: rowIndex at: columnIndex	^ (rowIndex <= rowNumber) & (rowIndex > 0) & (columnIndex <= columnNumber) & (columnIndex > 0)! !!ArrayOfArrays methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection	rows := Array new: aCollection size.	rowNumber := aCollection size.	columnNumber := (aCollection detectMax: [ :array | array size ]) size.	1 to: rowNumber do: [ :index | rows at: index put: (Array new: columnNumber )].	1 to: rowNumber do: [ :rowIndex | 		1 to: columnNumber do: [ :columnIndex | 			(rows at: rowIndex ) 				at: columnIndex 				put: ((aCollection at: rowIndex ) 							at: columnIndex) ] ]	! !!COOSparseMatrix class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rowsNumber columns: columnsNumber	^ COOSparseMatrix new rows: rowsNumber columns: columnsNumber ! !!COOSparseMatrix class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection	^ (self new 		rows: aCollection size 		columns: (aCollection detectMax: [ :element | element size ]) size) 	withAll: aCollection! !!COOSparseMatrix methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!* anOperand	(anOperand isKindOf: Number)		ifTrue: [ ^ self byNumber: anOperand ].	(anOperand isMemberOf: COOSparseMatrix)		ifTrue: [ ^ self byMatrix: anOperand ].	Error signal: 'Operand must be a number or of type COOSparseMatrix'! !!COOSparseMatrix methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!+ aCOOMatrix	| leftMatrixMarker rightMatrixMarker result head tail newNode continue |	(aCOOMatrix isMemberOf: self class)		ifFalse: [ Error signal: 'Convert matrix'].	(rowNumber = aCOOMatrix rowNumber and: [ columnNumber = aCOOMatrix columnNumber ])		ifFalse: [ Error signal: 'Matrices must be of same size' ].	result := self class rows: rowNumber columns: columnNumber.	leftMatrixMarker := first.	rightMatrixMarker := aCOOMatrix first.	(leftMatrixMarker preceeds: rightMatrixMarker)		ifTrue: [ head := leftMatrixMarker copy.			tail := head.			leftMatrixMarker := leftMatrixMarker rightNeighbour ]		ifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)				ifTrue: [ head := rightMatrixMarker copy.					tail := head.					rightMatrixMarker := rightMatrixMarker rightNeighbour ]				ifFalse: [ rightMatrixMarker value + leftMatrixMarker value = 0						ifTrue: [ tail := head := COOSparseMatrixNode row: 0 column: 0 value: 0 ]						ifFalse: [ head := rightMatrixMarker copy value: rightMatrixMarker value + leftMatrixMarker value.							tail := head ].					rightMatrixMarker := rightMatrixMarker rightNeighbour.					leftMatrixMarker := leftMatrixMarker rightNeighbour ] ].	[ leftMatrixMarker isNotNil and: [ rightMatrixMarker isNotNil ] ]		whileTrue: [ (leftMatrixMarker preceeds: rightMatrixMarker)				ifTrue: [ newNode := COOSparseMatrixNode						row: leftMatrixMarker row						column: leftMatrixMarker column						value: leftMatrixMarker value.					leftMatrixMarker := leftMatrixMarker rightNeighbour ]				ifFalse: [ (leftMatrixMarker follows: rightMatrixMarker)						ifTrue: [ newNode := COOSparseMatrixNode								row: rightMatrixMarker row								column: rightMatrixMarker column								value: rightMatrixMarker value.							rightMatrixMarker := rightMatrixMarker rightNeighbour ]						ifFalse: [ (leftMatrixMarker row = rightMatrixMarker row								and: [ leftMatrixMarker column = rightMatrixMarker column ])								ifTrue: [ leftMatrixMarker value + rightMatrixMarker value = 0										ifTrue: [ continue := true ]										ifFalse: [ newNode := COOSparseMatrixNode												row: leftMatrixMarker row												column: leftMatrixMarker column												value: leftMatrixMarker value + rightMatrixMarker value ].									rightMatrixMarker := rightMatrixMarker rightNeighbour.									leftMatrixMarker := leftMatrixMarker rightNeighbour ] ] ].			newNode isNil				ifFalse: [ tail rightNeighbour: newNode.					newNode leftNeighbour: tail.					tail := newNode.					newNode := nil ] ].	[ leftMatrixMarker isNotNil ]		whileTrue: [ newNode := COOSparseMatrixNode				row: leftMatrixMarker row				column: leftMatrixMarker column				value: leftMatrixMarker value.			leftMatrixMarker := leftMatrixMarker rightNeighbour.			tail rightNeighbour: newNode.			newNode leftNeighbour: tail.			tail := newNode ].	[ rightMatrixMarker isNotNil ]		whileTrue: [ newNode := COOSparseMatrixNode				row: rightMatrixMarker row				column: rightMatrixMarker column				value: rightMatrixMarker value.			rightMatrixMarker := rightMatrixMarker rightNeighbour.			tail rightNeighbour: newNode.			newNode leftNeighbour: tail.			tail := newNode ].	"remove the dummy head if zero"	head value = 0		ifTrue: [ head := head rightNeighbour ].	result		first: head;		last: tail.	^ result! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowIndex at: columnIndex	| marker |	( self validAt: rowIndex at: columnIndex )		ifFalse: [ SubscriptOutOfBounds signal: 'Invalid index.' ].	self isEmpty 		ifTrue: [ ^ 0 ].		marker := first .	[(marker rightNeighbour isNotNil) 	and: [(marker rightNeighbour row < rowIndex) 		or: [ marker rightNeighbour row = rowIndex 			and: [ marker rightNeighbour column < columnIndex  ] ] ] ]						whileTrue: [ marker := marker rightNeighbour ].		marker rightNeighbour isNil 		ifFalse: [ marker rightNeighbour row = rowIndex			ifTrue: [ marker rightNeighbour column = columnIndex 				ifTrue: [ ^ marker rightNeighbour value ] ] ].	(marker row = rowIndex and: [ marker column = columnIndex ])		ifTrue: [ ^ marker value ]. 	^ 0! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowIndex at: columnIndex put: aValue	| leftNeighbour rightNeighbour newNode |	(self validAt: rowIndex at: columnIndex)		ifFalse: [ SubscriptOutOfBounds signal: 'Invalid index.' ].	aValue = 0		ifTrue: [ ^ self removeAt: rowIndex at: columnIndex ].	newNode := COOSparseMatrixNode row: rowIndex column: columnIndex value: aValue.	self isEmpty		ifTrue: [ first := newNode.			last := newNode.			^ self ].	(newNode row < first row or: [ newNode row = first row and: [ newNode column < first column ] ])		ifTrue: [ first leftNeighbour: newNode.			newNode rightNeighbour: first.			first := newNode.			^ self ].	(newNode row > last row or: [ newNode row = last row and: [ newNode column > last column ] ])		ifTrue: [ last rightNeighbour: newNode.			newNode leftNeighbour: last.			last := newNode.			^ self ].	leftNeighbour := first.	leftNeighbour row = rowIndex & (leftNeighbour column = columnIndex)		ifTrue: [ leftNeighbour value: aValue.			^ self ].	[ leftNeighbour rightNeighbour isNotNil		and: [ leftNeighbour rightNeighbour row < rowIndex or: [ leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column < columnIndex ] ] ] ]		whileTrue: [ leftNeighbour := leftNeighbour rightNeighbour ].	(leftNeighbour rightNeighbour row = rowIndex and: [ leftNeighbour rightNeighbour column = columnIndex ])		ifTrue: [ leftNeighbour rightNeighbour value: aValue.			^ self ].	rightNeighbour := leftNeighbour rightNeighbour.	newNode rightNeighbour: rightNeighbour leftNeighbour: leftNeighbour.	rightNeighbour leftNeighbour: newNode.	leftNeighbour rightNeighbour: newNode! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byMatrix: aCOOSparseMatrix	| result currentLeftRow currentRightColumn priorityColumn leftMatrixMarker leftSavedMatrixMarker rightMatrixMarker transposed newNode head tail sum |		columnNumber = aCOOSparseMatrix rowNumber		ifFalse: [ Error signal: 'Invalid matrix size' ].	( aCOOSparseMatrix isEmpty or: [ self isEmpty ] )		ifTrue: [ ^ self class rows: rowNumber columns: aCOOSparseMatrix columnNumber ].		result := self class rows: rowNumber columns: aCOOSparseMatrix columnNumber.	transposed := aCOOSparseMatrix transpose.		leftSavedMatrixMarker := leftMatrixMarker := first.	rightMatrixMarker := transposed first.		currentLeftRow := leftMatrixMarker row.	currentRightColumn := rightMatrixMarker row.		head := tail := COOSparseMatrixNode new rightNeighbour: nil.	sum := 0.		self withEscaper: [ :end | 			[ rightMatrixMarker isNotNil and: [ leftMatrixMarker isNotNil ] ] whileTrue: [ 				self withEscaper: [ :outer |					"Switch to next row in left and reset right marker if right ended"					rightMatrixMarker isNil 						ifTrue: [ leftSavedMatrixMarker := leftMatrixMarker.								 rightMatrixMarker := transposed first. ].					"reset left marker to row beginning"					leftMatrixMarker := leftSavedMatrixMarker.					currentLeftRow := leftMatrixMarker row.					currentRightColumn := rightMatrixMarker row.										self withEscaper: [ :next | 						[ leftMatrixMarker isNotNil 						and: [ rightMatrixMarker isNotNil 							and: [ leftMatrixMarker row = currentLeftRow 								and: [ rightMatrixMarker row = currentRightColumn  ] ] ] ] 					whileTrue: [ 					priorityColumn := { leftMatrixMarker column . rightMatrixMarker column } max.					"Find same column as prioritized or higher in left"					[ leftMatrixMarker isNotNil 						and: [ leftMatrixMarker row = currentLeftRow 							and: [ leftMatrixMarker column < priorityColumn ] ] ]						whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].									leftMatrixMarker isNil 						ifTrue: [  							[ rightMatrixMarker isNotNil 								and: [ rightMatrixMarker row = currentRightColumn ] ]							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].														"If no intersection - end"							rightMatrixMarker isNil 								ifTrue: [ end value ].							"Else - continue loop"							next value].											leftMatrixMarker row ~= currentLeftRow						ifTrue: [ 							[rightMatrixMarker isNotNil 								and: [ rightMatrixMarker row = currentRightColumn ] ]							whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].														next value ].											priorityColumn := leftMatrixMarker column.										"Find same column as prioritized or higher in right"					[ rightMatrixMarker isNotNil 						and: [ rightMatrixMarker row = currentRightColumn 							and: [ rightMatrixMarker column < priorityColumn ] ] ]						whileTrue: [ rightMatrixMarker := rightMatrixMarker rightNeighbour ].									rightMatrixMarker isNil 						ifTrue: [  							[ leftMatrixMarker isNotNil 								and: [ leftMatrixMarker row = currentLeftRow ] ]							whileTrue: [ leftMatrixMarker := leftMatrixMarker rightNeighbour ].														"If no intersections - end"							leftMatrixMarker isNil 								ifTrue: [ end value ].							"Else - continue loop"							next value].											rightMatrixMarker row ~= currentRightColumn						ifTrue: [ next value ].										leftMatrixMarker column = rightMatrixMarker column						ifTrue: [ 							sum := sum + ( leftMatrixMarker value * rightMatrixMarker value ).							leftMatrixMarker := leftMatrixMarker rightNeighbour.							rightMatrixMarker := rightMatrixMarker rightNeighbour]						ifFalse: [							priorityColumn := rightMatrixMarker column ] ] ].												sum = 0							ifFalse: [ 								newNode := COOSparseMatrixNode row: currentLeftRow column: currentRightColumn value: sum.								tail rightNeighbour: newNode.								newNode leftNeighbour: tail.								tail := newNode.								sum := 0] 							].						sum = 0							ifFalse: [ 								 newNode := COOSparseMatrixNode row: currentLeftRow column: currentRightColumn value: sum.								tail rightNeighbour: newNode.								newNode leftNeighbour: tail.								tail := newNode.								sum := 0]						] ].	"nil the reference to dummy head"	head rightNeighbour leftNeighbour: nil.	result first: head rightNeighbour; last: tail.	^ result! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byNumber: aNumber	| result marker |	aNumber = 0		ifTrue: [ ^ self class class rows: rowNumber columns: rowNumber ].		result := self copy.	marker := result first.	[ marker isNotNil ]		whileTrue:		[ marker value: (marker value * aNumber).		  marker := marker rightNeighbour ].		^ result! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!columnNumber	^ columnNumber! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!columnNumber: aValue	columnNumber := aValue! !!COOSparseMatrix methodsFor: 'copying' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!copy	| copy head tail marker newNode |	copy := COOSparseMatrix rows: rowNumber columns: columnNumber.		marker := first.	head := first copy.	tail := head.	marker := marker rightNeighbour.		[ marker isNotNil ]		whileTrue: 		[ newNode := marker copy.		  tail rightNeighbour: newNode.		  newNode leftNeighbour: tail.		  tail := newNode.		  marker := marker rightNeighbour].		copy first: head; last: tail.	^ copy! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!elementsAsCollection	| marker result |	self isEmpty		ifTrue: [ ^ Collection new ].	marker := self first.	result := OrderedCollection new.	[ marker isNotNil ] whileTrue: [ result add: marker. marker := marker rightNeighbour ].	^ result! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!first	^ first! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!first: aCOOMatrixNode	first := aCOOMatrixNode ! !!COOSparseMatrix methodsFor: 'testing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!isEmpty	^ first isNil & last isNil! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!last	^ last! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!last: aCOOMatrixNode	last := aCOOMatrixNode ! !!COOSparseMatrix methodsFor: 'removal' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!removeAt: rowIndex at: columnIndex	| marker |	(self validAt: rowIndex at: columnIndex)		ifFalse: [SubscriptOutOfBounds signal: 'Invalid index'].	self isEmpty		ifTrue: [ ^ self ].		( first row = rowIndex ) & ( first column = columnIndex )		ifTrue: [ first rightNeighbour isNotNil					ifTrue: [ first rightNeighbour leftNeighbour: nil. 							first := first rightNeighbour]					ifFalse: [ first := nil.							last := nil ] ].		( last row = rowIndex ) & ( last column = columnIndex )		ifTrue: [ last leftNeighbour isNotNil					ifTrue: [ last leftNeighbour rightNeighbour: nil. 							last := last leftNeighbour ]					ifFalse: [ last := nil.							first := nil ] ].		marker := first .	[(marker rightNeighbour isNotNil) and: [(marker rightNeighbour row < rowIndex)]]						whileTrue: [ marker := marker rightNeighbour ].		(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex])		ifTrue: [			[(marker rightNeighbour isNotNil) and: [ (marker rightNeighbour row = rowIndex) and: [(marker rightNeighbour column < columnIndex)]]]						whileTrue: [ marker := marker rightNeighbour ]]		ifFalse: [ ^ self ].	(marker rightNeighbour isNotNil and: [marker rightNeighbour row = rowIndex and: [(marker rightNeighbour column < columnIndex)]])	ifTrue: [		marker leftNeighbour rightNeighbour: marker rightNeighbour.		marker rightNeighbour leftNeighbour: marker leftNeighbour].	^ self! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rowNumber	^ rowNumber ! !!COOSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rowNumber: aValue	rowNumber := aValue! !!COOSparseMatrix methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rows columns: columns	self rowNumber: rows; columnNumber: columns! !!COOSparseMatrix methodsFor: 'memory usage' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!sizeInMemory 	| size marker |	size := 0.	self isEmpty ifFalse: [ 		marker := first.		[ marker rightNeighbour isNotNil ] 			whileTrue: [ 				size := size + marker sizeInMemory. 				marker := marker rightNeighbour ].	].	^ super sizeInMemory + size! !!COOSparseMatrix methodsFor: 'transformation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!transpose	| result tempList marker |	result := self class rows: columnNumber columns: rowNumber.	self isEmpty  		ifFalse: [ 			marker := first.			tempList := SortedCollection new sortBlock: [ 				:left :right | left row < right row or: [ left row = right row and: [ left column < right column ] ] ]. 			[ marker isNotNil ]				whileTrue: [ tempList add:( COOSparseMatrixNode 											row: marker column 											column: marker row 											value: marker value).							marker := marker rightNeighbour ].			tempList reSort.			tempList keysAndValuesDo: [ :index :element | 				(index - 1) > 0				ifTrue:					[ element  						leftNeighbour: (tempList at: index - 1)  ].				index < tempList size 				ifTrue: 					[ element 					rightNeighbour: (tempList at: index + 1) ].				].			result first: tempList first.			result last: tempList last].	^ result! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!validAt: rowIndex at: columnIndex	^ (rowIndex <= rowNumber) & (rowIndex ~= 0) & (columnIndex <= columnNumber) & (columnIndex ~= 0)! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection	| list |	list := ((1 to: aCollection size)		collect: [ :rowIndex | 			(1 to: (aCollection at: rowIndex) size)				collect: [ :colIndex | 					COOSparseMatrixNode						row: rowIndex						column: colIndex						value: ((aCollection at: rowIndex) at: colIndex) ]				thenReject: [ :node | node value = 0 or: [ node value isNil ] ] ]) asOrderedCollection.	list := list inject: OrderedCollection new into: [ :array :each | array , each ].	(list at: 1) rightNeighbour: (list at: 2).	list at: list size put: ((list at: list size) leftNeighbour: (list at: list size - 1)).	(2 to: list size - 1)		do:			[ :index | (list at: index) rightNeighbour: (list at: index + 1) leftNeighbour: (list at: index - 1) ].	first := list at: 1.	last := list at: list size! !!COOSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withEscaper: aBlock   aBlock value: [ ^ nil ]! !!COOSparseMatrixNode class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row: rowNumber column: columnNumber value: aValue	^ self new row: rowNumber column: columnNumber value: aValue! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column	^ column ! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column: columnIndex	column := columnIndex  ! !!COOSparseMatrixNode methodsFor: 'relative position' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!follows: aCOOMatrixNode	^ (row > aCOOMatrixNode row) | ((row = aCOOMatrixNode row) & (column > aCOOMatrixNode column))! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!leftNeighbour	^ leftNeighbour! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!leftNeighbour: aNode	leftNeighbour := aNode! !!COOSparseMatrixNode methodsFor: 'relative position' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!preceeds: aCOOMatrixNode	^ (row < aCOOMatrixNode row) | ((row = aCOOMatrixNode row) & (column < aCOOMatrixNode column))! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rightNeighbour	^ rightNeighbour! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rightNeighbour: aNode	rightNeighbour := aNode! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rightNeighbour: rightNode leftNeighbour: leftNode	rightNeighbour := rightNode.	leftNeighbour := leftNode! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row	^ row! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row: rowNumber column: columnNumber	row := rowNumber.	column := columnNumber! !!COOSparseMatrixNode methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row: rowNumber column: columnNumber value: aValue 	value := aValue.	row := rowNumber.	column := columnNumber! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value	^ value ! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value: aValue	value := aValue.! !!COOSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value: aValue row: rowNumber column: columnNumber	value := aValue.	row := rowNumber.	column := columnNumber! !!LILSparseMatrix class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rowNum columns: colNum	^ LILSparseMatrix new rows: rowNum columns: colNum! !!LILSparseMatrix class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection	^ (LILSparseMatrix new 		rows: (aCollection size) 		columns: ((aCollection 			detectMax: [ :array | array size ]) size))	   withAll: aCollection! !!LILSparseMatrix methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!* anOperand	(anOperand isNumber)		ifTrue: [ ^ self byNumber: anOperand ].	(anOperand isMemberOf: self class)		ifTrue: [ ^ self byMatrix: anOperand ].	Error signal: 'Unknown type of operand for this operation'! !!LILSparseMatrix methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!+ aLILSparseMatrix	| result arr list |	(rowNumber = aLILSparseMatrix rowNumber) & (columnNumber = aLILSparseMatrix columnNumber)		ifFalse: [ Error signal: 'Matrices must be of the same size.' ].		result := self class rows: rowNumber columns: columnNumber .	arr := (1 to: result rowNumber) collect: [ :row | arr := (rows at: row) union: (aLILSparseMatrix rows at: row).													arr := (1 to: columnNumber) 													collect: [ :columnIndex | 														LILSparseMatrixNode 															column: columnIndex 															value: ((arr select: [ :node | node column = columnIndex ]) 																	inject: 0 																	into: [ :sum :element | sum + element value ])] 													thenReject: [ :node | node value = 0 ].											list := LinkedList new. 											arr do: [ :node | list addLast: node ].											list].	1 to: result rowNumber do: [ :rowIndex | result rows at: rowIndex put: (arr at: rowIndex)].	^ result! !!LILSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowIndex at: columnIndex	| index |	(self validAt: rowIndex at: columnIndex )		ifFalse: [ SubscriptOutOfBounds signal: 'Indices must be of valid range.' ].		index := (rows at: rowIndex) isEmpty 				ifTrue: [ ^ 0 ]				ifFalse: [ 					(rows at: rowIndex)						findFirst: [ :link | link column = columnIndex ]].		index = 0		ifFalse: [ ^ ((rows at: rowIndex) at: index) value].	^ 0! !!LILSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowIndex at: columnIndex put: aValue	|row index|	(self validAt: rowIndex at: columnIndex)		ifFalse: [ SubscriptOutOfBounds signal: 'Indices must be of valid range.' ].		row := rows at: rowIndex.	aValue = 0	ifTrue: [ 		row			removeAllSuchThat: [ :link | link column = columnIndex]. 			^ self].	row isEmpty 	ifTrue: [ row			addFirst: (LILSparseMatrixNode 						column: columnIndex 						value: aValue) ]	ifFalse: [ index := row findLast: [:link | link column <= columnIndex ].			index = 0				ifTrue: [ row					addFirst: (LILSparseMatrixNode 						column: columnIndex 						value: aValue).						 ^ self].			index = columnIndex 			ifTrue: [ (row at: index) value: aValue]			ifFalse: [				row					add: (LILSparseMatrixNode 						column: columnIndex 						value: aValue) 					afterLink:  (row linkAt: index)]].	^ self! !!LILSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byMatrix: aLILSparseMatrix	| result other index sum list arr cachedLeftRow cachedRightColumn |	(columnNumber = aLILSparseMatrix rowNumber)		ifFalse: [ Error signal: 'Invalid matrix sizes' ].	(aLILSparseMatrix isEmpty or: [self isEmpty])		ifTrue: [ ^ self class rows: rowNumber columns: aLILSparseMatrix columnNumber ].			other := aLILSparseMatrix transpose.	result := self class rows: rowNumber columns: aLILSparseMatrix columnNumber.		arr := (1 to: result rowNumber) collect: [ :rowIndex |		list := LinkedList with: LILSparseMatrixNode new.		cachedLeftRow := rows at: rowIndex.		(1 to: result columnNumber) do: [ :columnIndex | 			cachedRightColumn := other rows at: columnIndex.			sum := (cachedLeftRow 					collect: [ :leftNode | 								index := cachedRightColumn											findFirst: [ :rightNode | rightNode column = leftNode column ].								index = 0									ifFalse: [ leftNode value * (cachedRightColumn at: index) value ]] 					thenReject: [:el | el isNil ])			detectSum: [ :each | each ].			sum = 0				ifFalse: [ list addLast: (LILSparseMatrixNode										column: columnIndex 										value: sum).						sum := 0 ]			 ].				list].				arr keysAndValuesDo: [ :i :li | result rows at: i put: li ].	^ result! !!LILSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byNumber: aNumber	| result |	aNumber = 0		ifTrue: [ ^ self class rows: rowNumber columns: columnNumber ].		result := self copy.	result rows do: [ :list | list do: [ :node | node value: (node value * aNumber) ] ].	^ result! !!LILSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!columnNumber	^ columnNumber ! !!LILSparseMatrix methodsFor: 'copying' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!copy	| copy |	copy := self class rows: rowNumber columns: columnNumber.	1 to: copy rows size do: [ :row | 		copy rows at: row put: (			(self rows at: row) 			collect: [ :node | LILSparseMatrixNode 								column: node column 								value: node value ] 			as: LinkedList) ].	^ copy! !!LILSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!elementsAsCollection	| result |	self isEmpty		ifTrue: [ ^ rows				collectWithIndex: [ :head :rowIndex | MatrixElement row: rowIndex column: 0 value: nil ] ]		ifFalse: [ ^ (rows				collectWithIndex: [ :head :rowIndex | 					result := OrderedCollection with: (MatrixElement row: rowIndex column: 0 value: nil).					result						addAll:							(head asOrderedCollection								collectWithIndex: [ :el :ind | MatrixElement row: rowIndex column: el column value: el value ]).					result						withIndexDo: [ :el :ind | 							ind % result size = 0								ifFalse: [ el next: (result at: ind + 1) ] ].					result ]) flattened ]! !!LILSparseMatrix methodsFor: 'testing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!isEmpty	^ rows allSatisfy: [ :row | row isEmpty ]! !!LILSparseMatrix methodsFor: 'removal' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!removeAt: rowIndex at: columnIndex	^ self at: rowIndex at: columnIndex put: 0! !!LILSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rowNumber	^ rowNumber ! !!LILSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows	^ rows! !!LILSparseMatrix methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: rowNum columns: colNum	rows := (1 to: rowNum) collect: [ :each | LinkedList new ].	rowNumber := rowNum.	columnNumber := colNum.	^ self! !!LILSparseMatrix methodsFor: 'memory usage' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!sizeInMemory 	| size |	size := rows inject: 0 into: [ :sum :list | sum + list sizeInMemory ].	^ super sizeInMemory + size! !!LILSparseMatrix methodsFor: 'transformation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!transpose	| result tempList index |	result := self class rows: columnNumber columns: rowNumber.	1 to: columnNumber do: [ :columnIndex |		tempList := LinkedList new.		1 to: rowNumber do: [ :rowIndex | 			(self rows at: rowIndex) isEmpty 			ifFalse: [			(self rows at: rowIndex) first 				ifNotNil: [index := (self rows at: rowIndex) 								   findFirst: [ :element | element column = columnIndex ].						index = 0							ifFalse: [ tempList addLast: (LILSparseMatrixNode 															column: rowIndex 															value: ((self rows at: rowIndex) at: index) value)]]]].		result rows at: columnIndex put: tempList].	^ result! !!LILSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!validAt: rowIndex at: columnIndex	^ (rowIndex <= rowNumber) & (rowIndex > 0) & (columnIndex <= columnNumber) & (columnIndex > 0)! !!LILSparseMatrix methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection	(1 to: rows size)		do: [ :row | 			(((1 to: (aCollection at: row) size)				collect: [ :column | 					(((aCollection at: row) at: column) = 0 or: [ ((aCollection at: row) at: column) isNil ])						ifFalse:							[ LILSparseMatrixNode column: column value: ((aCollection at: row) at: column) ] ])				reject: [ :el | el isNil ]) do: [ :node | (rows at: row) addLast: node ] ]! !!LILSparseMatrixNode class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column: index value: aValue	^ self new column: index value: aValue! !!LILSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column	^ column! !!LILSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column: index 	column := index! !!LILSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column: index value: aValue	column := index.	value := aValue! !!LILSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value	^ value! !!LILSparseMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value: aValue 	value := aValue! !!MatrixElement class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row: rowInd column: colInd value: aValue	^ self new row: rowInd column: colInd value: aValue! !!MatrixElement methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column ^ column! !!MatrixElement methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!next	^ next! !!MatrixElement methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!next: aNode	next := aNode.	^ self! !!MatrixElement methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row	^ row! !!MatrixElement methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row: rowInd column: colInd value: aValue	row := rowInd.	column := colInd.	value := aValue.	^ self! !!MatrixElement methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value	^ value! !!COOSparseMatrixVisualizer class methodsFor: 'example' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!example	"An example of creating a visualizer on a matrix"	| mat vis |	mat := COOSparseMatrix		withAll:			{{1 . 2 . 0}.			{1 . 0 . 2}.			{0 . 0 . 5}}.	vis := self on: mat.	^ vis open! !!COOSparseMatrixVisualizer class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!multiply: leftMatrix by: rightMatrix	| composer innerContext |	composer := RTComposer new.	composer gap: 35.	MatrixVisualizer on: leftMatrix withView: composer view.	composer group: #left.	MatrixVisualizer on: rightMatrix withView: composer view.	composer group: #right.	composer move: #left onTheLeftOf: #right.	composer nameGroup: #left as: 'left'.	composer nameGroup: #right as: 'second'.		innerContext := [ leftMatrix * rightMatrix ].		^ composer view! !!COOSparseMatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aCOOSparseMatrix	(aCOOSparseMatrix isMemberOf: COOSparseMatrix)		ifFalse: [ Error signal: 'Matrix should be of class ' , COOSparseMatrix className ].	^ self new on: aCOOSparseMatrix! !!COOSparseMatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aCOOSparseMatrix withView: aView	(aCOOSparseMatrix isMemberOf: COOSparseMatrix)		ifFalse: [ Error				signal: 'Matrix should be of class ' , COOSparseMatrix className ].	^ (self new withView: aView) on: aCOOSparseMatrix! !!COOSparseMatrixVisualizer methodsFor: 'adding' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!add: firstMatrix to: secondMatrix	| firstView secondView sumView |	firstView := self class on: firstMatrix.	secondView := self class on: secondMatrix.	! !!COOSparseMatrixVisualizer methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!drawEdgesWith: elements	| edgeBuilder arrowHead arrowTail |	edgeBuilder := RTEdgeBuilder new.	edgeBuilder view: view.	edgeBuilder elements: elements.	arrowHead := RTSimpleArrow asHead		size: 1;		baseSize: 3.		arrowTail := RTSimpleArrow asTail		size: 1;		baseSize: 3.	edgeBuilder shape styledLine		orthoHorizontalLine;		horizontalAttachPoint;		head: arrowHead;		tail: arrowTail;		color: Color black.	edgeBuilder		connectTo: [ :el | 			(el rightNeighbour isNotNil and: [ el rightNeighbour row = el row ])				ifTrue: [ el rightNeighbour ] ].	arrowHead := RTSimpleArrow asHead		size: 1;		baseSize: 3.		arrowTail := RTSimpleArrow asTail		size: 1;		baseSize: 3.	edgeBuilder shape styledLine		orthoVerticalLine;		verticalAttachPoint;		head: arrowHead;		tail: arrowTail;		color: Color black.	edgeBuilder		connectTo: [ :el | 			(el rightNeighbour isNotNil and: [ el rightNeighbour row > el row ])				ifTrue: [ el rightNeighbour ] ]! !!COOSparseMatrixVisualizer methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aCOOSparseMatrix	| comp nodes elements |	comp := self getElementShape.	nodes := aCOOSparseMatrix elementsAsCollection.	elements := comp elementsOn: nodes.	elements @ RTDraggable.	elements @ RTPopup.	view addAll: elements.	RTGridLayout on: elements.	self drawEdgesWith: elements.	self setPositions! !!LILSparseMatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aLILSparseMatrix	(aLILSparseMatrix isMemberOf: LILSparseMatrix)		ifFalse: [ Error signal: 'Matrix should be of class ' , LILSparseMatrix className ].	^ self new on: aLILSparseMatrix! !!LILSparseMatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aLILSparseMatrix withView: aView	(aLILSparseMatrix isMemberOf: LILSparseMatrix)		ifFalse: [ Error				signal: 'Matrix should be of class ' , LILSparseMatrix className ].	^ (self new withView: aView) on: aLILSparseMatrix! !!LILSparseMatrixVisualizer methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!drawEdgesWith: elements	| edgeBuilder arrowHead |	edgeBuilder := RTEdgeBuilder new.	edgeBuilder view: view.	edgeBuilder elements: elements.	arrowHead := RTSimpleArrow asHead		size: 1;		baseSize: 3.	edgeBuilder shape styledLine		orthoHorizontalLine;		horizontalAttachPoint;		head: arrowHead;		color: Color black.	edgeBuilder		connectTo: [ :el | 			el next isNotNil				ifTrue: [ el next ] ]! !!LILSparseMatrixVisualizer methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!getHeaderShape	| comp box valueLabel indexLabel |	comp := RTCompositeShape new.	box := RTBox new		color: Color green;		size: elementSize.	valueLabel := RTLabel new text: 'H';		color: Color white.	indexLabel := RTLabel new		height: 5;		text: [ :el | el row @ el column ];		color: Color white.	comp		add: box;		add: valueLabel;		add: indexLabel translateBy: 0 @ 10.	^ comp! !!LILSparseMatrixVisualizer methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aLILSparseMatrix	| elementShape headerShape elements |	elementShape := self getElementShape.	headerShape := self getHeaderShape.	elements := RTGroup new		addAll:			(aLILSparseMatrix elementsAsCollection				collect: [ :el | 					(el row = 0 or: [ el column = 0 ])						ifTrue: [ headerShape elementOn: el ]						ifFalse: [ elementShape elementOn: el ] ]);		yourself.	elements @ RTDraggable.	elements @ RTPopup.	view addAll: elements.	self drawEdgesWith: elements.	RTGridLayout on: elements.	self setPositions! !!MatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!multiply: leftMatrix by: rightMatrix	| composer innerContext |	composer := RTComposer new.	composer gap: 35.	MatrixVisualizer on: leftMatrix withView: composer view.	composer group: #left.	MatrixVisualizer on: rightMatrix withView: composer view.	composer group: #right.	composer move: #left onTheLeftOf: #right.	composer nameGroup: #left as: 'left'.	composer nameGroup: #right as: 'second'.	innerContext := [ leftMatrix * rightMatrix ].	innerContext := innerContext value.	^ composer view! !!MatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aMatrix	subclasses		do: [ :subclass | 			((''				join:					{aMatrix class .					'Visualizer'}) = (subclass name substrings: '#') first )				ifTrue: [ ^ subclass on: aMatrix ] ]! !!MatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aMatrix withView: aView	subclasses		do: [ :subclass | 			(''				join:					{aMatrix class.					'Visualizer'}) = (subclass name substrings: '#') first				ifTrue: [ ^ subclass on: aMatrix withView: aView] ]! !!MatrixVisualizer methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!drawEdgesWith: elements	self subclassResponsibility! !!MatrixVisualizer methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!elementSize	^ elementSize! !!MatrixVisualizer methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!elementSize: size	elementSize := size! !!MatrixVisualizer methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!getElementShape	| comp box valueLabel indexLabel |	comp := RTCompositeShape new.	box := RTBox new		color: Color blue;		size: elementSize.	valueLabel := RTLabel new		text: [ :el | el value ];		color: Color white.	indexLabel := RTLabel new		height: 5;		text: [ :el | el row @ el column ];		color: Color white.	comp		add: box;		add: valueLabel;		add: indexLabel translateBy: 0 @ 10.	^ comp! !!MatrixVisualizer methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!initialize	elementSize := 30.	view := RTView new.	view @ RTDraggableView! !!MatrixVisualizer methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aMatrix	self subclassResponsibility! !!MatrixVisualizer methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!open	view isNotNil		ifTrue: [ ^ view ]! !!MatrixVisualizer methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!setPositions	| gap |	gap := 10.	view elements		do: [ :e | 			| aNode |			aNode := e model.			e translateTo: (elementSize + gap) * (aNode column @ aNode row) ]! !!MatrixVisualizer methodsFor: 'initialization' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withView: aView	view := aView! !!TWSparseMatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aTWSparseMatrix	(aTWSparseMatrix isMemberOf: TWSparseMatrix)		ifFalse: [ Error signal: 'Matrix should be of class ' , TWSparseMatrix className ].	^ self new on: aTWSparseMatrix! !!TWSparseMatrixVisualizer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aTWSparseMatrix withView: aView	(aTWSparseMatrix isMemberOf: TWSparseMatrix)		ifFalse: [ Error signal: 'Matrix should be of class ' , TWSparseMatrix className ].	^ (self new withView: aView) on: aTWSparseMatrix! !!TWSparseMatrixVisualizer methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!drawEdgesWith: elements	| edgeBuilder arrowHead offset |	edgeBuilder := RTEdgeBuilder new.	edgeBuilder view: view.	edgeBuilder elements: elements.	arrowHead := RTSimpleArrow asHead		size: 1;		baseSize: 3.	"Draw edges for row elements excluding headers"	edgeBuilder shape styledLine		orthoHorizontalLine;		horizontalAttachPoint;		head: arrowHead;		color: Color black.	edgeBuilder		connectTo: [ :el | 			(el rightNeighbour isNotNil and: [ el rightNeighbour column > el column ])				ifTrue: [ el rightNeighbour ] ].	"Draw row edges for row headers"	offset := 4.	arrowHead := RTSimpleArrow asHead		size: 1;		baseSize: 3.	edgeBuilder shape styledLine		orthoHorizontalLineBottommostWithOffset: offset;		horizontalRightAttachPoint;		head: arrowHead;		color: Color red.	edgeBuilder		connectTo: [ :el | 			(el belowNeighbour isNotNil and: [ el belowNeighbour row <= el row ])				ifTrue: [ el belowNeighbour ] ].	"Draw edges for columns excluding headers"	arrowHead := RTSimpleArrow asHead		size: 1;		baseSize: 3.	edgeBuilder shape styledLine		orthoVerticalLine;		verticalAttachPoint;		head: arrowHead;		color: Color black.	edgeBuilder		connectTo: [ :el | 			(el belowNeighbour isNotNil and: [ el belowNeighbour row > el row ])				ifTrue: [ el belowNeighbour ] ].	"Draw edges for column headers"	arrowHead := RTSimpleArrow asHead		size: 1;		baseSize: 3.	edgeBuilder shape styledLine		orthoVerticalLineRightmostWithOffset: offset;		verticalBottomAttachPoint;		head: arrowHead;		color: Color red.	edgeBuilder		connectTo: [ :el | 			(el rightNeighbour isNotNil and: [ el rightNeighbour column <= el column ])				ifTrue: [ el rightNeighbour ] ]! !!TWSparseMatrixVisualizer methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!getHeaderShape	| comp box valueLabel indexLabel |	comp := RTCompositeShape new.	box := RTBox new		color: Color green;		size: elementSize.	valueLabel := RTLabel new text: 'H';		color: Color white.	indexLabel := RTLabel new		height: 5;		text: [ :el | el row @ el column ];		color: Color white.	comp		add: box;		add: valueLabel;		add: indexLabel translateBy: 0 @ 10.	^ comp! !!TWSparseMatrixVisualizer methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!on: aTWSparseMatrix	| elementShape headerShape nodes elements |	elementShape := self getElementShape.	headerShape := self getHeaderShape.	nodes := aTWSparseMatrix elementsAsCollection		collect: [ :el | 			(el row = 0 or: [ el column = 0 ])				ifTrue: [ headerShape elementOn: el ]				ifFalse: [ elementShape elementOn: el ] ].	elements := RTGroup new		addAll: nodes;		yourself.	elements @ RTDraggable.	elements @ RTPopup.	view addAll: elements.	self drawEdgesWith: elements.	RTGridLayout on: elements.	self setPositions! !!TWMatrixNode class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!new: aValue atRow: rowNumber atColumn: columnNumber	rowNumber isInteger & columnNumber isInteger		ifFalse: [ Error signal: 'Row and column indices must be integer values' ].	(rowNumber > 0 & columnNumber > 0)		ifFalse: [ DomainError signal: 'Indices must be a positive value' from: 1 ].	^ self new value: aValue row: rowNumber column: columnNumber! !!TWMatrixNode class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row: rowNumber column: columnNumber value: aValue	rowNumber isInteger & columnNumber isInteger		ifFalse: [ Error signal: 'Row and column indices must be integer values' ].	(rowNumber > 0 & columnNumber > 0)		ifFalse: [ DomainError signal: 'Indices must be a positive value' from: 1 ].	^ self new value: aValue row: rowNumber column: columnNumber! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!belowNeighbour	^ belowNeighbour! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!belowNeighbour: aNode	belowNeighbour := aNode! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!column	^ column ! !!TWMatrixNode methodsFor: 'copying' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!copy	^ self class row: row column: column value: value! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rightNeighbour	^ rightNeighbour! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rightNeighbour: aNode	rightNeighbour := aNode! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rightNeighbour: rightNode belowNeighbour: belowNode	rightNeighbour := rightNode.	belowNeighbour := belowNode! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row	^ row! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!row: rowNumber column: columnNumber	row := rowNumber.	column := columnNumber! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value	^ value ! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value: aValue	value := aValue.! !!TWMatrixNode methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!value: aValue row: rowNumber column: columnNumber	value := aValue.	row := rowNumber.	column := columnNumber! !!TWSparseMatrix class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: numberOfRows columns: numberOfColumns	^ self new rows: numberOfRows columns: numberOfColumns ! !!TWSparseMatrix class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection	^ (TWSparseMatrix new		rows: (aCollection size) 		columns: ((aCollection 			detectMax: [ :array | array size ]) size))	   withAll: aCollection! !!TWSparseMatrix methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!* anOperand	(anOperand isNumber)		ifTrue: [ ^ self byNumber: anOperand ].	(anOperand isMemberOf: self class)		ifTrue: [ ^ self byMatrix: anOperand ].	Error signal: 'Unknown type of operand for this operation'! !!TWSparseMatrix methodsFor: 'arithmetic' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!+ aMatrix	"Addition of matrices of the same type"	| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail |	(rowsNumber = aMatrix rowsNumber and: [ columnsNumber = aMatrix columnsNumber ])		ifFalse: [ Error signal: 'Matrices must be of same size.' ].	result := self class rows: rowsNumber columns: columnsNumber.	"Filter out the rows and columns that don't have elements"	rowNumbers := ((rows reject: [ :rowHead | rowHead rightNeighbour isNil ]) collect: [ :rowHead | rowHead row ])		union: ((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ]) collect: [ :rowHead | rowHead row ]).	colNumbers := ((columns reject: [ :colHead | colHead belowNeighbour isNil ]) collect: [ :colHead | colHead column ])		union: ((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ]) collect: [ :colHead | colHead column ]).	"Initialize an array that has all the last elements in columns"	colLast := result columns select: [ :colHead | colNumbers includes: colHead column ].	"loop through each row"	rowNumbers		do: [ :rowIndex | 			leftRowMarker := (rows at: rowIndex) rightNeighbour.			rightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.			tail := result rows at: rowIndex.			[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]				whileTrue: [ leftRowMarker column < rightRowMarker column						ifTrue: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: leftRowMarker column value: leftRowMarker value).							leftRowMarker := leftRowMarker rightNeighbour ]						ifFalse: [ leftRowMarker column > rightRowMarker column								ifTrue: [ "if there's an element on the same index"									tail rightNeighbour: (TWMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value).									rightRowMarker := rightRowMarker rightNeighbour ]								ifFalse: [ (rightRowMarker value + leftRowMarker value) = 0										ifFalse: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value + leftRowMarker value) ].									rightRowMarker := rightRowMarker rightNeighbour.									leftRowMarker := leftRowMarker rightNeighbour ] ].					tail rightNeighbour isNotNil						ifTrue: [ tail := tail rightNeighbour ] ].			"gather leftovers from left matrix"			[ leftRowMarker column ~= 0 ]				whileTrue: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: leftRowMarker column value: leftRowMarker value).					leftRowMarker := leftRowMarker rightNeighbour.					tail := tail rightNeighbour ].			"gather leftovers from right matrix"			[ rightRowMarker column ~= 0 ]				whileTrue: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value).					rightRowMarker := rightRowMarker rightNeighbour.					tail := tail rightNeighbour ].			"close loop the row"			tail rightNeighbour: (result rows at: rowIndex).			"shift last elements in columns up-to-down"			tail := (result rows at: rowIndex) rightNeighbour.			[ tail column ~= 0 ]				whileTrue: [ (colLast at: tail column) belowNeighbour: tail.					tail := tail rightNeighbour ] ].	"close loop on the columns"	colLast do: [ :colLastElement | colLastElement belowNeighbour: (result columns at: colLastElement column) ].	^ result! !!TWSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowNumber at: columnNumber	| rowMarker colMarker |	rowMarker := rows at: rowNumber.	colMarker := columns at: columnNumber.	[ (rowMarker rightNeighbour column ~= 0 ) & (rowMarker rightNeighbour column < columnNumber) ]		whileTrue: [ rowMarker := rowMarker rightNeighbour ].	rowMarker rightNeighbour column = columnNumber		ifTrue: [ ^ rowMarker rightNeighbour value].	^ 0.	 	"[ colMarker belowNeighbour isNotNil & (colMarker belowNeighbour row < rowNumber) ]		whileTrue: [ colMarker := colMarker belowNeighbour ].	colMarker belowNeighbour row = rowNumber		ifTrue: [ ^ colMarker belowNeighbour value]"! !!TWSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!at: rowNumber at: columnNumber put: aValue	| rowMarker colMarker newNode |	"if the indices are invalid"	(aValue = 0 & (self existsAt: rowNumber at: columnNumber ) not) | (rowNumber = 0) | (columnNumber = 0)		ifTrue: [ ^ self ].	rowMarker := rows at: rowNumber.	colMarker := columns at: columnNumber.	"find elements pointing to the desired element"	[ rowMarker rightNeighbour column ~= 0 and: [ rowMarker rightNeighbour column < columnNumber ] ] whileTrue: [ rowMarker := rowMarker rightNeighbour ].	[ colMarker belowNeighbour row ~= 0 and: [ colMarker belowNeighbour row < rowNumber ] ] whileTrue: [ colMarker := colMarker belowNeighbour ].	"if the element exists - erase it or update its value, otherwise - insert a new element"	rowMarker rightNeighbour column = columnNumber		ifTrue: [ colMarker belowNeighbour row = rowNumber				ifTrue: [ aValue = 0						ifTrue: [ rowMarker rightNeighbour: rowMarker rightNeighbour rightNeighbour.							colMarker belowNeighbour: colMarker belowNeighbour belowNeighbour ]						ifFalse: [ colMarker belowNeighbour value: aValue ] ] ]		ifFalse: [ aValue ~= 0				ifTrue: [ newNode := TWMatrixNode row: rowNumber column: columnNumber value: aValue.					newNode rightNeighbour: rowMarker rightNeighbour belowNeighbour: colMarker belowNeighbour.					rowMarker rightNeighbour: newNode.					colMarker belowNeighbour: newNode ] ].	^ self! !!TWSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byMatrix: aMatrix	| result rowNumbers columnNumbers lastInRowMarkers lastInColumnMarkers leftMarker rightMarker sum newNode |	self columnsNumber ~= aMatrix rowsNumber		ifTrue: [ Error signal: 'Size mismatch. Left: ' , self columnsNumber , ' Right: ' , aMatrix rowsNumber ].	result := self class new rows: self rowsNumber columns: aMatrix columnsNumber.	(self isEmpty or: aMatrix isEmpty)		ifTrue: [ ^ result ].	lastInRowMarkers := result rows copy.	lastInColumnMarkers := result columns copy.	rowNumbers := self rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ] thenCollect: [ :rowHead | rowHead row ].	columnNumbers := aMatrix rows reject: [ :colHead | colHead belowNeighbour = colHead ] thenCollect: [ :colHead | colHead row ].	rowNumbers		do: [ :rowIndex | 			columnNumbers				do: [ :columnIndex | 					leftMarker := (self rows at: rowIndex) rightNeighbour.					rightMarker := (aMatrix columns at: columnIndex) belowNeighbour.					sum := 0.					[ leftMarker column ~= 0 and: [ rightMarker row ~= 0 ] ]						whileTrue: [ leftMarker column < rightMarker row								ifTrue: [ leftMarker := leftMarker rightNeighbour ]								ifFalse: [ leftMarker column > rightMarker row										ifTrue: [ rightMarker := rightMarker belowNeighbour ]										ifFalse: [ sum := sum + (leftMarker value * rightMarker value).											rightMarker := rightMarker belowNeighbour.											leftMarker := leftMarker rightNeighbour. ] ] ].					sum ~= 0						ifTrue: [ newNode := TWMatrixNode new value: sum row: rowIndex column: columnIndex.							(lastInRowMarkers at: rowIndex) rightNeighbour: newNode.							(lastInColumnMarkers at: columnIndex) belowNeighbour: newNode.							lastInRowMarkers at: rowIndex put: newNode.							lastInColumnMarkers at: columnIndex put: newNode ] ] ].				result rows withIndexDo: [ :rowHead :rowIndex | (lastInRowMarkers at: rowIndex) rightNeighbour: rowHead ].				result columns withIndexDo: [ :colHead :colIndex | (lastInColumnMarkers at: colIndex ) belowNeighbour: colHead ].	^ result! !!TWSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!byNumber: aNumber | result marker |	aNumber = 0		ifTrue: [ ^ self class rows: rowsNumber columns: columnsNumber ].			result := self copy.	result rows do: [ :rowHead | 		marker := rowHead rightNeighbour.		[ marker ~= rowHead ] whileTrue: [ 			marker value: (marker value * aNumber).			marker := marker rightNeighbour ] ].		^ result.! !!TWSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!columns	^ columns! !!TWSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!columnsNumber	^ columnsNumber ! !!TWSparseMatrix methodsFor: 'copying' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!copy	| result rowMarker marker colMarkers |	result := self class rows: rowsNumber columns: columnsNumber.	colMarkers := result columns copy.	rows		do: [ :rowHead | 			rowMarker := result rows at: rowHead row.			marker := rowHead.			[ marker rightNeighbour column ~= 0 ]				whileTrue: [ rowMarker rightNeighbour: (TWMatrixNode row: marker rightNeighbour row column: marker rightNeighbour column value: marker rightNeighbour value).					(colMarkers at: marker rightNeighbour column) belowNeighbour: rowMarker rightNeighbour.					colMarkers at: marker rightNeighbour column put: rowMarker rightNeighbour.					rowMarker := rowMarker rightNeighbour.					marker := marker rightNeighbour ].			rowMarker rightNeighbour: (result rows at: rowHead row) ].	colMarkers 		do: [ :colMarker | colMarker belowNeighbour: (result columns at: colMarker column) ].	^ result! !!TWSparseMatrix methodsFor: 'private' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!elementsAsCollection	| result marker |	self isEmpty		ifTrue: [ result := rows asOrderedCollection.			result addAll: columns ]		ifFalse: [ result := rows asOrderedCollection.			result addAll: columns.			1 to: rows size do: [ :rowInd | 				marker := (rows at: rowInd) rightNeighbour.				[ marker column ~= 0 ]					whileTrue: [ result add: marker.						marker := marker rightNeighbour ] ] ].	^ result! !!TWSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!existsAt: rowIndex at: columnIndex	| rowMarker |	rowMarker := rows at: rowIndex.	[ rowMarker rightNeighbour column ~= 0 and: [ rowMarker rightNeighbour column < columnIndex ] ] whileTrue: [ rowMarker := rowMarker rightNeighbour ].	^ rowMarker rightNeighbour column = columnIndex! !!TWSparseMatrix methodsFor: 'testing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!isEmpty	^ (rows allSatisfy: [ :el | el rightNeighbour = el ]) 		and: [ columns allSatisfy: [ :el | el belowNeighbour = el ] ]! !!TWSparseMatrix methodsFor: 'printing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!printOn: aStream	aStream nextPut: $(.	1 to: self rowsNumber do: [ :rowIndex | 		(1 to: self columnsNumber) do: [ :colIndex | aStream print: (self at: rowIndex at: colIndex) ] separatedBy: [ aStream space ].		aStream cr ].	aStream nextPut: $)! !!TWSparseMatrix methodsFor: 'removing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!removeAt: row at: column	| rowMarker colMarker |	(self existsAt: row at: column)		ifFalse: [ ^ self ].	rowMarker := rows at: row.	colMarker := columns at: column.	[ rowMarker rightNeighbour column ~= 0 and: [rowMarker rightNeighbour column < column] ]		whileTrue: [ rowMarker := rowMarker rightNeighbour ].	(rowMarker rightNeighbour column = column)		ifTrue: [ rowMarker rightNeighbour: rowMarker rightNeighbour rightNeighbour.			^ self ].	[ colMarker belowNeighbour row ~= 0 and: [colMarker belowNeighbour row < row] ]		whileTrue: [ colMarker := colMarker belowNeighbour ].	(colMarker belowNeighbour row = row)		ifTrue: [ colMarker belowNeighbour: colMarker belowNeighbour belowNeighbour].		^ self! !!TWSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows 	^ rows! !!TWSparseMatrix methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rows: numberOfRows columns: numberOfColumns	rowsNumber := numberOfRows.	columnsNumber := numberOfColumns.	rows := (1 to: numberOfRows) collect: [ :each | TWMatrixNode new value: nil row: each column: 0].	columns := (1 to: numberOfColumns) collect: [ :each | TWMatrixNode new value: nil row: 0 column: each].	rows := rows collect: [ :each | each rightNeighbour: each belowNeighbour: nil ].	columns := columns collect: [ :each | each rightNeighbour: nil belowNeighbour: each ].! !!TWSparseMatrix methodsFor: 'accessing' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!rowsNumber	^ rowsNumber ! !!TWSparseMatrix methodsFor: 'memory usage' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!sizeInMemory	| size marker count |	size := rows		inject: 0		into: [ :sum :rowHead | 			marker := rowHead rightNeighbour.			count := 0.			[ marker column ~= 0 ] whileTrue: [ count := count + 1. marker := marker rightNeighbour ].			sum + (marker rightNeighbour sizeInMemory * count) ].	^ super sizeInMemory + size! !!TWSparseMatrix methodsFor: 'transformation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!transpose	| copy rowMarker result columnMarkers |	result := self class rows: columnsNumber columns: rowsNumber.	self isEmpty		ifTrue: [ ^ result ].	columnMarkers := result columns copy.	result rows		withIndexDo: [ :each :rowIndex | 			copy := self columns at: rowIndex.			rowMarker := each.			[ copy belowNeighbour row ~= 0 ]				whileTrue: [ copy := copy belowNeighbour.					rowMarker rightNeighbour: (TWMatrixNode new value: copy value row: copy column column: copy row).					(columnMarkers at: copy row) belowNeighbour: rowMarker rightNeighbour.					columnMarkers at: copy row put: rowMarker rightNeighbour.					rowMarker := rowMarker rightNeighbour ].			rowMarker rightNeighbour: each ].	result columns withIndexDo: [ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].	^ result! !!TWSparseMatrix methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/29/2019 13:46:56'!withAll: aCollection	| columnMarkers rawArr |	columnMarkers := self columns copy.	1 to: rowsNumber do: [ :rowIndex | 		rawArr := ((1 to: (aCollection at: rowIndex) size)			collect: [ :columnIndex | 				(((aCollection at: rowIndex) at: columnIndex) = 0 or: [ ((aCollection at: rowIndex) at: columnIndex) isNil ])					ifFalse: [ TWMatrixNode row: rowIndex column: columnIndex value: ((aCollection at: rowIndex) at: columnIndex) ] ]) reject: [ :el | el isNil ].		rawArr isEmpty			ifTrue: [ (self rows at: rowIndex) rightNeighbour: (self rows at: rowIndex) ]			ifFalse: [ 1 to: rawArr size - 1 do: [ :colIndex | 					(rawArr at: colIndex) rightNeighbour: (rawArr at: colIndex + 1).					(columnMarkers at: (rawArr at: colIndex) column) belowNeighbour: (rawArr at: colIndex).					columnMarkers at: (rawArr at: colIndex) column put: (rawArr at: colIndex) ].				(self rows at: rowIndex) rightNeighbour: rawArr first.				rawArr last rightNeighbour: (self rows at: rowIndex).				(columnMarkers at: rawArr last column) belowNeighbour: rawArr last.				columnMarkers at: rawArr last column put: rawArr last ] ].	self columns withIndexDo: [ :columnHead :colIndex | (columnMarkers at: colIndex) belowNeighbour: columnHead ]! !"LNU-SparseMatrix"!!COOSparseMatrixVisualizer methodsFor: 'instance creation' stamp: 'YaroslavKormushyn 4/26/2019 21:17' prior: 34381395!on: aCOOSparseMatrix	| comp nodes elements |	comp := self getElementShape.	nodes := aCOOSparseMatrix elementsAsCollection.	elements := comp elementsOn: nodes.	elements @ RSDraggable.	elements @ RSPopup.	view addAll: elements.	RSGridLayout on: elements.	self drawEdgesWith: elements.	self setPositions! !----QUIT----2019-04-26T21:20:28.759694+03:00 7.0 64bit.image priorSource: 95!----QUIT----2019-04-27T00:15:34.986053+03:00 Stable 7.0 x64 Roassal3.image priorSource: 854914!