OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2019-05-17T18:37:25.841435+03:00' ],		#prior : OmReference [ 'Pharo7.0.3-0-32bit-0903ade.2v0s4afuxdghi68d5yllvptdk', '4' ],		#self : OmReference [ '1' ]	},	#content : EpBehaviorNameChange {		#oldName : #TWMatrixNode,		#newName : #TWSparseMatrixNode,		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #TWSparseMatrixNode\r\tinstanceVariableNames: \'value row column rightNeighbour belowNeighbour\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'LNU-SparseMatrix-Data\'',				#superclassName : 'Object'			},			#name : #TWSparseMatrixNode,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixNode,						#isMetaSide : false					},					#name : #value,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixNode,						#isMetaSide : false					},					#name : #row,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixNode,						#isMetaSide : false					},					#name : #column,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixNode,						#isMetaSide : false					},					#name : #rightNeighbour,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #TWSparseMatrixNode,						#isMetaSide : false					},					#name : #belowNeighbour,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TWSparseMatrixNode class\r\tinstanceVariableNames: \'\''				},				#name : #'TWSparseMatrixNode class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TWSparseMatrixNode,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a value wrapper for TWSparseMatrix.\r\rI store values of kind Number, row and column position in a TWSparseMatrix, right and below neighbour.\r\rI\'m used by TWSparseMatrix for storing values.\r\rPublic API and Key Messages\r\r- column  \r- row \r- value \r- value:row:column:\r- rightNeighbour:belowNeighbour:\r- copy\r\rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\trow:\t\t<SmallInteger>\r\tcolumn:\t\t<SmallInteger>\r\tvalue:\t\t<Number>\r\trightNeighbour: <TWMatrixNode>\r\tbelowNeighbour: <TWMatrixNode>\r\rInstance creation:\r1) From metaclass:\r\tTWMatrixNode row:num1 column:\u0005num2 value: num3\rOR\r\tTWMatrixNode new: num1 atRow: num2 atColumn: num3',				#stamp : 'YaroslavKormushyn 4/18/2018 11:12'			},			#classVariables : OrderedCollection [ ],			#category : #LNU-SparseMatrix-Data,			#package : #LNU-SparseMatrix,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.419435+03:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t(leftRowMarker column ~= 0) ifTrue: [ vis composer\r\t\t\t\tselectModel:\r\t\t\t\t\tleftRowMarker ].\r(rightRowMarker column ~= 0) ifTrue: [ vis composer\r\t\t\t\tselectModel:\r\t\t\t\t\trightRowMarker ].\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [vis composer selectModel: leftRowMarker] ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer selectModel: rightRowMarker] ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\t\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer selectModel: rightRowMarker].\r\t\t\t\t\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [vis composer selectModel: leftRowMarker].\r\t\t\t\t\t\t\t\t\t\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [leftRowMarker := leftRowMarker rightNeighbour].\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer deselectModel: rightRowMarker].\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/8/2019 15:47',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'addAnimated:delay:',			#protocol : #arithmetic,			#sourceCode : 'addAnimated: aMatrix delay: delay\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex |\r\t(rowsNumber = aMatrix rowsNumber\r\t\tand: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: aMatrix result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\t"Filter out the rows and columns that don\'t have elements"\r\toperationProcess := [ "rowNumbers, colNumbers - indices which exist"\r\trowNumbers := ((rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\tcollect: [ :rowHead | rowHead row ])\r\t\tunion:\r\t\t\t((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ])\r\t\t\t\tcollect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\tcollect: [ :colHead | colHead column ])\r\t\tunion:\r\t\t\t((aMatrix columns\r\t\t\t\treject: [ :colHead | colHead belowNeighbour = colHead ])\r\t\t\t\tcollect: [ :colHead | colHead column ]).\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #right) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #right) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (aMatrix rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: colNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #left) extent y + outterGap.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (aMatrix rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns\r\t\tselect: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t(leftRowMarker column ~= 0) ifTrue: [ vis composer\r\t\t\t\tselectModel:\r\t\t\t\t\tleftRowMarker ].\r(rightRowMarker column ~= 0) ifTrue: [ vis composer\r\t\t\t\tselectModel:\r\t\t\t\t\trightRowMarker ].\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t(TWSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [vis composer selectModel: leftRowMarker] ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ tail\r\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t(TWSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer selectModel: rightRowMarker] ]\r\t\t\t\t\t\t\t\tifFalse: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\trightRowMarker value + leftRowMarker value = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail\r\t\t\t\t\t\t\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t\t\t\t\t\t\t(TWSparseMatrixNode\r\t\t\t\t\t\t\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: rightRowMarker value + leftRowMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\t\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\t\t\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\t\t\t\t\t\t\t\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer selectModel: rightRowMarker].\r\t\t\t\t\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [vis composer selectModel: leftRowMarker].\r\t\t\t\t\t\t\t\t\t\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t\t\t\t\tvis delay wait ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWSparseMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: leftRowMarker column\r\t\t\t\t\t\t\t\tvalue: leftRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tleftRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: leftRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: leftRowMarker.\r\t\t\t\t\t(leftRowMarker column ~= 0) ifTrue: [leftRowMarker := leftRowMarker rightNeighbour].\r\t\t\tleftMarkerElement updateModelAndRedraw: leftRowMarker.\r\t\t\t\t\tvis composer selectModel: leftRowMarker.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWSparseMatrixNode\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: rightRowMarker column\r\t\t\t\t\t\t\t\tvalue: rightRowMarker value).\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\trightRowMarker column}.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tvis composer highlightModel: rightRowMarker.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis composer deselectModel: rightRowMarker.\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\trightMarkerElement updateModelAndRedraw: rightRowMarker.\r\t\t\t\t\t(rightRowMarker column ~= 0) ifTrue: [vis composer deselectModel: rightRowMarker].\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait.\r\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\t"bind the new elements to the column headers"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\tcolLast at: tail column put: tail.\r\t\t\t\t\ttail := tail rightNeighbour.\r\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\t"close loop on the columns"\r\tcolLast\r\t\tdo: [ :colLastElement | \r\t\t\tcolLastElement\r\t\t\t\tbelowNeighbour: (result columns at: colLastElement column).\r\t\t\tvis updateResultWith: result.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ] ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.443435+03:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'instance creation',			#sourceCode : 'withAll: aCollection\r\t| columnMarkers rawArr |\r\tcolumnMarkers := self columns copy.\r\t1 to: rowsNumber do: [ :rowIndex | \r\t\trawArr := ((1 to: (aCollection at: rowIndex) size)\r\t\t\tcollect: [ :columnIndex | \r\t\t\t\t(((aCollection at: rowIndex) at: columnIndex) = 0 or: [ ((aCollection at: rowIndex) at: columnIndex) isNil ])\r\t\t\t\t\tifFalse: [ TWMatrixNode row: rowIndex column: columnIndex value: ((aCollection at: rowIndex) at: columnIndex) ] ]) reject: [ :el | el isNil ].\r\t\trawArr isEmpty\r\t\t\tifTrue: [ (self rows at: rowIndex) rightNeighbour: (self rows at: rowIndex) ]\r\t\t\tifFalse: [ 1 to: rawArr size - 1 do: [ :colIndex | \r\t\t\t\t\t(rawArr at: colIndex) rightNeighbour: (rawArr at: colIndex + 1).\r\t\t\t\t\t(columnMarkers at: (rawArr at: colIndex) column) belowNeighbour: (rawArr at: colIndex).\r\t\t\t\t\tcolumnMarkers at: (rawArr at: colIndex) column put: (rawArr at: colIndex) ].\r\t\t\t\t(self rows at: rowIndex) rightNeighbour: rawArr first.\r\t\t\t\trawArr last rightNeighbour: (self rows at: rowIndex).\r\t\t\t\t(columnMarkers at: rawArr last column) belowNeighbour: rawArr last.\r\t\t\t\tcolumnMarkers at: rawArr last column put: rawArr last ] ].\r\tself columns withIndexDo: [ :columnHead :colIndex | (columnMarkers at: colIndex) belowNeighbour: columnHead ]',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'withAll:',			#protocol : #'instance creation',			#sourceCode : 'withAll: aCollection\r\t| columnMarkers rawArr |\r\tcolumnMarkers := self columns copy.\r\t1 to: rowsNumber do: [ :rowIndex | \r\t\trawArr := ((1 to: (aCollection at: rowIndex) size)\r\t\t\tcollect: [ :columnIndex | \r\t\t\t\t(((aCollection at: rowIndex) at: columnIndex) = 0 or: [ ((aCollection at: rowIndex) at: columnIndex) isNil ])\r\t\t\t\t\tifFalse: [ TWSparseMatrixNode row: rowIndex column: columnIndex value: ((aCollection at: rowIndex) at: columnIndex) ] ]) reject: [ :el | el isNil ].\r\t\trawArr isEmpty\r\t\t\tifTrue: [ (self rows at: rowIndex) rightNeighbour: (self rows at: rowIndex) ]\r\t\t\tifFalse: [ 1 to: rawArr size - 1 do: [ :colIndex | \r\t\t\t\t\t(rawArr at: colIndex) rightNeighbour: (rawArr at: colIndex + 1).\r\t\t\t\t\t(columnMarkers at: (rawArr at: colIndex) column) belowNeighbour: (rawArr at: colIndex).\r\t\t\t\t\tcolumnMarkers at: (rawArr at: colIndex) column put: (rawArr at: colIndex) ].\r\t\t\t\t(self rows at: rowIndex) rightNeighbour: rawArr first.\r\t\t\t\trawArr last rightNeighbour: (self rows at: rowIndex).\r\t\t\t\t(columnMarkers at: rawArr last column) belowNeighbour: rawArr last.\r\t\t\t\tcolumnMarkers at: rawArr last column put: rawArr last ] ].\r\tself columns withIndexDo: [ :columnHead :colIndex | (columnMarkers at: colIndex) belowNeighbour: columnHead ]',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.457435+03:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #copy,			#protocol : #copying,			#sourceCode : 'copy\r\t| result rowMarker marker colMarkers |\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tcolMarkers := result columns copy.\r\trows\r\t\tdo: [ :rowHead | \r\t\t\trowMarker := result rows at: rowHead row.\r\t\t\tmarker := rowHead.\r\t\t\t[ marker rightNeighbour column ~= 0 ]\r\t\t\t\twhileTrue: [ rowMarker rightNeighbour: (TWMatrixNode row: marker rightNeighbour row column: marker rightNeighbour column value: marker rightNeighbour value).\r\t\t\t\t\t(colMarkers at: marker rightNeighbour column) belowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tcolMarkers at: marker rightNeighbour column put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour.\r\t\t\t\t\tmarker := marker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: (result rows at: rowHead row) ].\r\tcolMarkers \r\t\tdo: [ :colMarker | colMarker belowNeighbour: (result columns at: colMarker column) ].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #copy,			#protocol : #copying,			#sourceCode : 'copy\r\t| result rowMarker marker colMarkers |\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\tcolMarkers := result columns copy.\r\trows\r\t\tdo: [ :rowHead | \r\t\t\trowMarker := result rows at: rowHead row.\r\t\t\tmarker := rowHead.\r\t\t\t[ marker rightNeighbour column ~= 0 ]\r\t\t\t\twhileTrue: [ rowMarker rightNeighbour: (TWSparseMatrixNode row: marker rightNeighbour row column: marker rightNeighbour column value: marker rightNeighbour value).\r\t\t\t\t\t(colMarkers at: marker rightNeighbour column) belowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tcolMarkers at: marker rightNeighbour column put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour.\r\t\t\t\t\tmarker := marker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: (result rows at: rowHead row) ].\r\tcolMarkers \r\t\tdo: [ :colMarker | colMarker belowNeighbour: (result columns at: colMarker column) ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.476435+03:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber put: aValue\r\t| rowMarker colMarker newNode |\r\t"if the indices are invalid"\r\t(aValue = 0 & (self existsAt: rowNumber at: columnNumber ) not) | (rowNumber = 0) | (columnNumber = 0)\r\t\tifTrue: [ ^ self ].\r\trowMarker := rows at: rowNumber.\r\tcolMarker := columns at: columnNumber.\r\t"find elements pointing to the desired element"\r\t[ rowMarker rightNeighbour column ~= 0 and: [ rowMarker rightNeighbour column < columnNumber ] ] whileTrue: [ rowMarker := rowMarker rightNeighbour ].\r\t[ colMarker belowNeighbour row ~= 0 and: [ colMarker belowNeighbour row < rowNumber ] ] whileTrue: [ colMarker := colMarker belowNeighbour ].\r\t"if the element exists - erase it or update its value, otherwise - insert a new element"\r\trowMarker rightNeighbour column = columnNumber\r\t\tifTrue: [ colMarker belowNeighbour row = rowNumber\r\t\t\t\tifTrue: [ aValue = 0\r\t\t\t\t\t\tifTrue: [ rowMarker rightNeighbour: rowMarker rightNeighbour rightNeighbour.\r\t\t\t\t\t\t\tcolMarker belowNeighbour: colMarker belowNeighbour belowNeighbour ]\r\t\t\t\t\t\tifFalse: [ colMarker belowNeighbour value: aValue ] ] ]\r\t\tifFalse: [ aValue ~= 0\r\t\t\t\tifTrue: [ newNode := TWMatrixNode row: rowNumber column: columnNumber value: aValue.\r\t\t\t\t\tnewNode rightNeighbour: rowMarker rightNeighbour belowNeighbour: colMarker belowNeighbour.\r\t\t\t\t\trowMarker rightNeighbour: newNode.\r\t\t\t\t\tcolMarker belowNeighbour: newNode ] ].\r\t^ self',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'at:at:put:',			#protocol : #accessing,			#sourceCode : 'at: rowNumber at: columnNumber put: aValue\r\t| rowMarker colMarker newNode |\r\t"if the indices are invalid"\r\t(aValue = 0 & (self existsAt: rowNumber at: columnNumber ) not) | (rowNumber = 0) | (columnNumber = 0)\r\t\tifTrue: [ ^ self ].\r\trowMarker := rows at: rowNumber.\r\tcolMarker := columns at: columnNumber.\r\t"find elements pointing to the desired element"\r\t[ rowMarker rightNeighbour column ~= 0 and: [ rowMarker rightNeighbour column < columnNumber ] ] whileTrue: [ rowMarker := rowMarker rightNeighbour ].\r\t[ colMarker belowNeighbour row ~= 0 and: [ colMarker belowNeighbour row < rowNumber ] ] whileTrue: [ colMarker := colMarker belowNeighbour ].\r\t"if the element exists - erase it or update its value, otherwise - insert a new element"\r\trowMarker rightNeighbour column = columnNumber\r\t\tifTrue: [ colMarker belowNeighbour row = rowNumber\r\t\t\t\tifTrue: [ aValue = 0\r\t\t\t\t\t\tifTrue: [ rowMarker rightNeighbour: rowMarker rightNeighbour rightNeighbour.\r\t\t\t\t\t\t\tcolMarker belowNeighbour: colMarker belowNeighbour belowNeighbour ]\r\t\t\t\t\t\tifFalse: [ colMarker belowNeighbour value: aValue ] ] ]\r\t\tifFalse: [ aValue ~= 0\r\t\t\t\tifTrue: [ newNode := TWSparseMatrixNode row: rowNumber column: columnNumber value: aValue.\r\t\t\t\t\tnewNode rightNeighbour: rowMarker rightNeighbour belowNeighbour: colMarker belowNeighbour.\r\t\t\t\t\trowMarker rightNeighbour: newNode.\r\t\t\t\t\tcolMarker belowNeighbour: newNode ] ].\r\t^ self',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.500435+03:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'transposeAnimatedDelay:',			#protocol : #transformation,			#sourceCode : 'transposeAnimatedDelay: delay\r\t| copy rowMarker result columnMarkers vis operationProcess sourceMarker |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tMatrixVisualizer on: self withView: vis view.\r\tvis composer group: #source.\r\tMatrixVisualizer on: result withView: vis view.\r\tvis composer group: #result.\r\tsourceMarker := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: sourceMarker.\r\tvis group: #sourceMarker.\r\tvis composer move: #sourceMarker below: #source.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis namedGroups: #(#source #result #sourceMarker).\r\tvis backgroundGroups: #(#source #result).\r\tvis redrawNamesAndBackgrounds.\r\toperationProcess := [ columnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\tvis selectModel: copy.\r\t\t\t\t\trowMarker\r\t\t\t\t\t\trightNeighbour: (TWMatrixNode new value: copy value row: copy column column: copy row).\r\t\t\t\t\t(columnMarkers at: copy row)\r\t\t\t\t\t\tbelowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis deselectModel: copy.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each.\r\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ].\r\tresult columns\r\t\twithIndexDo:\r\t\t\t[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\tvis composer removeGroup: #sourceMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithout: #sourceMarker).\r\tvis redrawNamesAndBackgrounds.\r\tvis composer replaceElementsInGroup: #result with: result.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis composer view canvas focusOnCenterScaled.\r\tvis delay wait ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : '',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'transposeAnimatedDelay:',			#protocol : #transformation,			#sourceCode : 'transposeAnimatedDelay: delay\r\t| copy rowMarker result columnMarkers vis operationProcess sourceMarker |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tMatrixVisualizer on: self withView: vis view.\r\tvis composer group: #source.\r\tMatrixVisualizer on: result withView: vis view.\r\tvis composer group: #result.\r\tsourceMarker := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: sourceMarker.\r\tvis group: #sourceMarker.\r\tvis composer move: #sourceMarker below: #source.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis namedGroups: #(#source #result #sourceMarker).\r\tvis backgroundGroups: #(#source #result).\r\tvis redrawNamesAndBackgrounds.\r\toperationProcess := [ columnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\tvis selectModel: copy.\r\t\t\t\t\trowMarker\r\t\t\t\t\t\trightNeighbour: (TWSparseMatrixNode new value: copy value row: copy column column: copy row).\r\t\t\t\t\t(columnMarkers at: copy row)\r\t\t\t\t\t\tbelowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis deselectModel: copy.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each.\r\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ].\r\tresult columns\r\t\twithIndexDo:\r\t\t\t[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\tvis composer removeGroup: #sourceMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithout: #sourceMarker).\r\tvis redrawNamesAndBackgrounds.\r\tvis composer replaceElementsInGroup: #result with: result.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis composer view canvas focusOnCenterScaled.\r\tvis delay wait ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.523435+03:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aMatrix\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail |\r\t(rowsNumber = aMatrix rowsNumber and: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\r\t"Filter out the rows and columns that don\'t have elements"\r\trowNumbers := ((rows reject: [ :rowHead | rowHead rightNeighbour isNil ]) collect: [ :rowHead | rowHead row ])\r\t\tunion: ((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ]) collect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns reject: [ :colHead | colHead belowNeighbour isNil ]) collect: [ :colHead | colHead column ])\r\t\tunion: ((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ]) collect: [ :colHead | colHead column ]).\r\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns select: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: leftRowMarker column value: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail rightNeighbour: (TWMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ (rightRowMarker value + leftRowMarker value) = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: leftRowMarker column value: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail rightNeighbour: (TWMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast do: [ :colLastElement | colLastElement belowNeighbour: (result columns at: colLastElement column) ].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'+',			#protocol : #arithmetic,			#sourceCode : '+ aMatrix\r\t"Addition of matrices of the same type"\r\r\t| result rowNumbers colNumbers colLast leftRowMarker rightRowMarker tail |\r\t(rowsNumber = aMatrix rowsNumber and: [ columnsNumber = aMatrix columnsNumber ])\r\t\tifFalse: [ Error signal: \'Matrices must be of same size.\' ].\r\tresult := self class rows: rowsNumber columns: columnsNumber.\r\r\t"Filter out the rows and columns that don\'t have elements"\r\trowNumbers := ((rows reject: [ :rowHead | rowHead rightNeighbour isNil ]) collect: [ :rowHead | rowHead row ])\r\t\tunion: ((aMatrix rows reject: [ :rowHead | rowHead rightNeighbour isNil ]) collect: [ :rowHead | rowHead row ]).\r\tcolNumbers := ((columns reject: [ :colHead | colHead belowNeighbour isNil ]) collect: [ :colHead | colHead column ])\r\t\tunion: ((aMatrix columns reject: [ :colHead | colHead belowNeighbour isNil ]) collect: [ :colHead | colHead column ]).\r\r\t"Initialize an array that has all the last elements in columns"\r\tcolLast := result columns select: [ :colHead | colNumbers includes: colHead column ].\r\r\t"loop through each row"\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tleftRowMarker := (rows at: rowIndex) rightNeighbour.\r\t\t\trightRowMarker := (aMatrix rows at: rowIndex) rightNeighbour.\r\t\t\ttail := result rows at: rowIndex.\r\t\t\t[ leftRowMarker column ~= 0 and: [ rightRowMarker column ~= 0 ] ]\r\t\t\t\twhileTrue: [ leftRowMarker column < rightRowMarker column\r\t\t\t\t\t\tifTrue: [ tail rightNeighbour: (TWSparseMatrixNode row: rowIndex column: leftRowMarker column value: leftRowMarker value).\r\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ]\r\t\t\t\t\t\tifFalse: [ leftRowMarker column > rightRowMarker column\r\t\t\t\t\t\t\t\tifTrue: [ "if there\'s an element on the same index"\r\t\t\t\t\t\t\t\t\ttail rightNeighbour: (TWSparseMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value).\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ (rightRowMarker value + leftRowMarker value) = 0\r\t\t\t\t\t\t\t\t\t\tifFalse: [ tail rightNeighbour: (TWSparseMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value + leftRowMarker value) ].\r\t\t\t\t\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour ] ].\r\t\t\t\t\ttail rightNeighbour isNotNil\r\t\t\t\t\t\tifTrue: [ tail := tail rightNeighbour ] ].\r\r\t\t\t"gather leftovers from left matrix"\r\t\t\t[ leftRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail rightNeighbour: (TWSparseMatrixNode row: rowIndex column: leftRowMarker column value: leftRowMarker value).\r\t\t\t\t\tleftRowMarker := leftRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"gather leftovers from right matrix"\r\t\t\t[ rightRowMarker column ~= 0 ]\r\t\t\t\twhileTrue: [ tail rightNeighbour: (TWSparseMatrixNode row: rowIndex column: rightRowMarker column value: rightRowMarker value).\r\t\t\t\t\trightRowMarker := rightRowMarker rightNeighbour.\r\t\t\t\t\ttail := tail rightNeighbour ].\r\r\t\t\t"close loop the row"\r\t\t\ttail rightNeighbour: (result rows at: rowIndex).\r\t\t\t"shift last elements in columns up-to-down"\r\t\t\ttail := (result rows at: rowIndex) rightNeighbour.\r\t\t\t[ tail column ~= 0 ]\r\t\t\t\twhileTrue: [ (colLast at: tail column) belowNeighbour: tail.\r\t\t\t\t\ttail := tail rightNeighbour ] ].\r\t"close loop on the columns"\r\tcolLast do: [ :colLastElement | colLastElement belowNeighbour: (result columns at: colLastElement column) ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.554435+03:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aMatrix delay: delay\r\t| result rowNumbers columnNumbers lastInRowMarkers lastInColumnMarkers leftMarker rightMarker sum newNode vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue leftCopy |\r\tself columnsNumber ~= aMatrix rowsNumber\r\t\tifTrue: [ Error\r\t\t\t\tsignal:\r\t\t\t\t\t\'Size mismatch. Left: \' , self columnsNumber , \' Right: \'\r\t\t\t\t\t\t, aMatrix rowsNumber ].\r\tresult := self class new\r\t\trows: self rowsNumber\r\t\tcolumns: aMatrix columnsNumber.\r\t(self isEmpty or: aMatrix isEmpty)\r\t\tifTrue: [ ^ result ].\r\tleftCopy := aMatrix copy.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: leftCopy result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\tlastInRowMarkers := result rows copy.\r\tlastInColumnMarkers := result columns copy.\r\trowNumbers := self rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ]\r\t\tthenCollect: [ :rowHead | rowHead row ].\r\tcolumnNumbers := leftCopy rows\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ]\r\t\tthenCollect: [ :colHead | colHead row ].\r\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxResult outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxResult := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxResult color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxResult strokeWidth: 0.\r\t\t\tbackgroundBoxResult borderRadius: 5.\r\t\t\tbackgroundBoxResult\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #result) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (result rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxResult\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #result) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (result rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxResult.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: columnNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxResult backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (leftCopy rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (leftCopy rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tbackgroundBoxResult := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxResult color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxResult strokeWidth: 0.\r\t\t\tbackgroundBoxResult borderRadius: 5.\r\t\t\tbackgroundBoxResult\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (result rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #result) center y.\r\t\t\tbackgroundBoxResult\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (result rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #result) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\tvis view canvas addShape: backgroundBoxResult.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\toperationProcess := [ rowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tcolumnNumbers\r\t\t\t\tdo: [ :columnIndex | \r\t\t\t\t\tleftMarker := (self rows at: rowIndex) rightNeighbour.\r\t\t\t\t\trightMarker := (leftCopy columns at: columnIndex) belowNeighbour.\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\t\tsum := 0.\r\t\t\t\t\tnewElementValue model: sum.\r\t\t\t\t\tnewElementValue update.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftMarker.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: rightMarker.\r\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer selectModel: leftMarker.\r\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer selectModel: rightMarker.\r\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\t[ leftMarker column ~= 0 and: [ rightMarker row ~= 0 ] ]\r\t\t\t\t\t\twhileTrue: [ leftMarker column < rightMarker row\r\t\t\t\t\t\t\t\tifTrue: [ vis composer deselectModel: leftMarker.\r\t\t\t\t\t\t\t\t\tleftMarker := leftMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftMarker.\r\t\t\t\t\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ] ]\r\t\t\t\t\t\t\t\tifFalse: [ leftMarker column > rightMarker row\r\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer deselectModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarker := rightMarker belowNeighbour.\r\t\t\t\t\t\t\t\t\t\t\trightMarkerElement updateModelAndRedraw: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\t\t\tvis delay wait ] ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ vis composer highlightModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\t\t\tsum := sum + (leftMarker value * rightMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnewElementValue model: sum.\r\t\t\t\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarker := rightMarker belowNeighbour.\r\t\t\t\t\t\t\t\t\t\t\tleftMarker := leftMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: rightMarker ].\r\t\t\t\t\t\t\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: leftMarker ].\r\t\t\t\t\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarkerElement updateModelAndRedraw: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ] ] ].\r\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer deselectModel: rightMarker ].\r\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer deselectModel: leftMarker ].\r\t\t\t\t\tsum ~= 0\r\t\t\t\t\t\tifTrue: [ newNode := TWMatrixNode new\r\t\t\t\t\t\t\t\tvalue: sum\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: columnIndex.\r\t\t\t\t\t\t\t(lastInRowMarkers at: rowIndex) rightNeighbour: newNode.\r\t\t\t\t\t\t\t(lastInColumnMarkers at: columnIndex) belowNeighbour: newNode.\r\t\t\t\t\t\t\tlastInRowMarkers at: rowIndex put: newNode.\r\t\t\t\t\t\t\tlastInColumnMarkers at: columnIndex put: newNode.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait ] ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis composer removeGroup: #nowProcessing.\r\tvis composer removeGroup: #newElementValue.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\tresult rows\r\t\twithIndexDo: [ :rowHead :rowIndex | \r\t\t\t(lastInRowMarkers at: rowIndex) rightNeighbour: rowHead\r\t\t\t"vis updateResultWith: result.\r\t\t\tvis delay wait " ].\r\tresult columns\r\t\twithIndexDo: [ :colHead :colIndex | \r\t\t\t(lastInColumnMarkers at: colIndex) belowNeighbour: colHead\r\t\t\t"vis updateResultWith: result.\r\t\t\tvis delay wait" ].\r\tvis updateResultWith: result ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : '',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrixAnimated:delay:',			#protocol : #private,			#sourceCode : 'byMatrixAnimated: aMatrix delay: delay\r\t| result rowNumbers columnNumbers lastInRowMarkers lastInColumnMarkers leftMarker rightMarker sum newNode vis operationProcess leftMarkerElement rightMarkerElement nowProcessingElementIndex newElementValue leftCopy |\r\tself columnsNumber ~= aMatrix rowsNumber\r\t\tifTrue: [ Error\r\t\t\t\tsignal:\r\t\t\t\t\t\'Size mismatch. Left: \' , self columnsNumber , \' Right: \'\r\t\t\t\t\t\t, aMatrix rowsNumber ].\r\tresult := self class new\r\t\trows: self rowsNumber\r\t\tcolumns: aMatrix columnsNumber.\r\t(self isEmpty or: aMatrix isEmpty)\r\t\tifTrue: [ ^ result ].\r\tleftCopy := aMatrix copy.\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tvis getComposedViewOf: self with: leftCopy result: result.\r\tvis namedGroups: #(#left #result #right #leftMarker #rightMarker).\r\tvis backgroundGroups: #(#left #result #right).\r\tleftMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: leftMarkerElement.\r\tvis group: #leftMarker.\r\trightMarkerElement := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: rightMarkerElement.\r\tvis group: #rightMarker.\r\tnowProcessingElementIndex := (RTLabel\r\t\ttext:\r\t\t\t[ :indices | \'Now processing \' , (indices first @ indices last) asString ])\r\t\telementOn: {0 . 0}.\r\tvis add: nowProcessingElementIndex.\r\tvis group: #nowProcessing.\r\tnewElementValue := (RTLabel\r\t\ttext: [ :value | \'New element value: \' , value asString ])\r\t\telementOn: 0.\r\tvis add: newElementValue.\r\tvis group: #newElementValue.\r\tvis composer move: #leftMarker below: #left.\r\tvis composer move: #rightMarker below: #right.\r\tvis composer move: #nowProcessing above: #right.\r\tvis composer move: #newElementValue onTheRightOf: #nowProcessing.\r\tvis redrawNamesAndBackgrounds.\r\tvis composer groupToExisting: #labels.\r\tvis update.\r\tlastInRowMarkers := result rows copy.\r\tlastInColumnMarkers := result columns copy.\r\trowNumbers := self rows\r\t\treject: [ :rowHead | rowHead rightNeighbour = rowHead ]\r\t\tthenCollect: [ :rowHead | rowHead row ].\r\tcolumnNumbers := leftCopy rows\r\t\treject: [ :colHead | colHead belowNeighbour = colHead ]\r\t\tthenCollect: [ :colHead | colHead row ].\r\r\t"gray out rows which are empty"\r\t((1 to: self rowsNumber) copyWithoutAll: rowNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxLeft backgroundBoxResult outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxLeft := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxLeft color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxLeft strokeWidth: 0.\r\t\t\tbackgroundBoxLeft borderRadius: 5.\r\t\t\tbackgroundBoxLeft\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #left) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxLeft\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #left) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tbackgroundBoxResult := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxResult color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxResult strokeWidth: 0.\r\t\t\tbackgroundBoxResult borderRadius: 5.\r\t\t\tbackgroundBoxResult\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis composer getGroup: #result) center x\r\t\t\t\t\t\t@ (vis view elementFromModel: (result rows at: rowIndex)) center y.\r\t\t\tbackgroundBoxResult\r\t\t\t\textent:\r\t\t\t\t\t(vis composer getGroup: #result) extent x\r\t\t\t\t\t\t@ (vis view elementFromModel: (result rows at: rowIndex)) extent y\r\t\t\t\t\t\t+ outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxLeft.\r\t\t\tvis view canvas addShape: backgroundBoxResult.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\t"gray out empty columns"\r\t((1 to: self columnsNumber) copyWithoutAll: columnNumbers)\r\t\tdo: [ :rowIndex | \r\t\t\t| backgroundBoxResult backgroundBoxRight outterGap |\r\t\t\toutterGap := 5 @ 5.\r\t\t\tbackgroundBoxRight := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxRight color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxRight strokeWidth: 0.\r\t\t\tbackgroundBoxRight borderRadius: 5.\r\t\t\tbackgroundBoxRight\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (leftCopy rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) center y.\r\t\t\tbackgroundBoxRight\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (leftCopy rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #right) extent y + outterGap.\r\t\t\tbackgroundBoxResult := TRRoundedBoxShape new.\r\t\t\tbackgroundBoxResult color: (Color gray alpha: 0.5).\r\t\t\tbackgroundBoxResult strokeWidth: 0.\r\t\t\tbackgroundBoxResult borderRadius: 5.\r\t\t\tbackgroundBoxResult\r\t\t\t\ttranslateTo:\r\t\t\t\t\t(vis view elementFromModel: (result rows at: rowIndex)) center x\r\t\t\t\t\t\t@ (vis composer getGroup: #result) center y.\r\t\t\tbackgroundBoxResult\r\t\t\t\textent:\r\t\t\t\t\t(vis view elementFromModel: (result rows at: rowIndex)) extent x\r\t\t\t\t\t\t@ (vis composer getGroup: #result) extent y + outterGap.\r\t\t\tvis view canvas addShape: backgroundBoxRight.\r\t\t\tvis view canvas addShape: backgroundBoxResult.\r\t\t\t(vis composer hasGroup: #shade)\r\t\t\t\tifTrue: [ vis composer groupToExisting: #shade ]\r\t\t\t\tifFalse: [ vis group: #shade ] ].\r\toperationProcess := [ rowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tcolumnNumbers\r\t\t\t\tdo: [ :columnIndex | \r\t\t\t\t\tleftMarker := (self rows at: rowIndex) rightNeighbour.\r\t\t\t\t\trightMarker := (leftCopy columns at: columnIndex) belowNeighbour.\r\t\t\t\t\tnowProcessingElementIndex\r\t\t\t\t\t\tmodel:\r\t\t\t\t\t\t\t{rowIndex.\r\t\t\t\t\t\t\tcolumnIndex}.\r\t\t\t\t\tsum := 0.\r\t\t\t\t\tnewElementValue model: sum.\r\t\t\t\t\tnewElementValue update.\r\t\t\t\t\tnowProcessingElementIndex update.\r\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftMarker.\r\t\t\t\t\trightMarkerElement updateModelAndRedraw: rightMarker.\r\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer selectModel: leftMarker.\r\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer selectModel: rightMarker.\r\t\t\t\t\t\t\tvis delay wait ].\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\t[ leftMarker column ~= 0 and: [ rightMarker row ~= 0 ] ]\r\t\t\t\t\t\twhileTrue: [ leftMarker column < rightMarker row\r\t\t\t\t\t\t\t\tifTrue: [ vis composer deselectModel: leftMarker.\r\t\t\t\t\t\t\t\t\tleftMarker := leftMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftMarker.\r\t\t\t\t\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ] ]\r\t\t\t\t\t\t\t\tifFalse: [ leftMarker column > rightMarker row\r\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer deselectModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarker := rightMarker belowNeighbour.\r\t\t\t\t\t\t\t\t\t\t\trightMarkerElement updateModelAndRedraw: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\t\t\tvis delay wait ] ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ vis composer highlightModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer highlightModel: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait.\r\t\t\t\t\t\t\t\t\t\t\tsum := sum + (leftMarker value * rightMarker value).\r\t\t\t\t\t\t\t\t\t\t\tnewElementValue model: sum.\r\t\t\t\t\t\t\t\t\t\t\tnewElementValue update.\r\t\t\t\t\t\t\t\t\t\t\tvis composer deselectModel: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis composer deselectModel: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarker := rightMarker belowNeighbour.\r\t\t\t\t\t\t\t\t\t\t\tleftMarker := leftMarker rightNeighbour.\r\t\t\t\t\t\t\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: rightMarker ].\r\t\t\t\t\t\t\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\t\t\t\t\t\t\tifTrue: [ vis composer selectModel: leftMarker ].\r\t\t\t\t\t\t\t\t\t\t\tleftMarkerElement updateModelAndRedraw: leftMarker.\r\t\t\t\t\t\t\t\t\t\t\trightMarkerElement updateModelAndRedraw: rightMarker.\r\t\t\t\t\t\t\t\t\t\t\tvis delay wait ] ] ].\r\t\t\t\t\trightMarker row ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer deselectModel: rightMarker ].\r\t\t\t\t\tleftMarker column ~= 0\r\t\t\t\t\t\tifTrue: [ vis composer deselectModel: leftMarker ].\r\t\t\t\t\tsum ~= 0\r\t\t\t\t\t\tifTrue: [ newNode := TWSparseMatrixNode new\r\t\t\t\t\t\t\t\tvalue: sum\r\t\t\t\t\t\t\t\trow: rowIndex\r\t\t\t\t\t\t\t\tcolumn: columnIndex.\r\t\t\t\t\t\t\t(lastInRowMarkers at: rowIndex) rightNeighbour: newNode.\r\t\t\t\t\t\t\t(lastInColumnMarkers at: columnIndex) belowNeighbour: newNode.\r\t\t\t\t\t\t\tlastInRowMarkers at: rowIndex put: newNode.\r\t\t\t\t\t\t\tlastInColumnMarkers at: columnIndex put: newNode.\r\t\t\t\t\t\t\tvis updateResultWith: result.\r\t\t\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\t\t\tvis delay wait ] ] ].\r\tvis composer removeGroup: #leftMarker.\r\tvis composer removeGroup: #rightMarker.\r\tvis composer removeGroup: #nowProcessing.\r\tvis composer removeGroup: #newElementValue.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithoutAll: #(#leftMarker #rightMarker)).\r\tvis redrawNamesAndBackgrounds.\r\tresult rows\r\t\twithIndexDo: [ :rowHead :rowIndex | \r\t\t\t(lastInRowMarkers at: rowIndex) rightNeighbour: rowHead\r\t\t\t"vis updateResultWith: result.\r\t\t\tvis delay wait " ].\r\tresult columns\r\t\twithIndexDo: [ :colHead :colIndex | \r\t\t\t(lastInColumnMarkers at: colIndex) belowNeighbour: colHead\r\t\t\t"vis updateResultWith: result.\r\t\t\tvis delay wait" ].\r\tvis updateResultWith: result ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.577435+03:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #private,			#sourceCode : 'byMatrix: aMatrix\r\t| result rowNumbers columnNumbers lastInRowMarkers lastInColumnMarkers leftMarker rightMarker sum newNode |\r\tself columnsNumber ~= aMatrix rowsNumber\r\t\tifTrue: [ Error signal: \'Size mismatch. Left: \' , self columnsNumber , \' Right: \' , aMatrix rowsNumber ].\r\tresult := self class new rows: self rowsNumber columns: aMatrix columnsNumber.\r\t(self isEmpty or: aMatrix isEmpty)\r\t\tifTrue: [ ^ result ].\r\tlastInRowMarkers := result rows copy.\r\tlastInColumnMarkers := result columns copy.\r\trowNumbers := self rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ] thenCollect: [ :rowHead | rowHead row ].\r\tcolumnNumbers := aMatrix rows reject: [ :colHead | colHead belowNeighbour = colHead ] thenCollect: [ :colHead | colHead row ].\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tcolumnNumbers\r\t\t\t\tdo: [ :columnIndex | \r\t\t\t\t\tleftMarker := (self rows at: rowIndex) rightNeighbour.\r\t\t\t\t\trightMarker := (aMatrix columns at: columnIndex) belowNeighbour.\r\t\t\t\t\tsum := 0.\r\t\t\t\t\t[ leftMarker column ~= 0 and: [ rightMarker row ~= 0 ] ]\r\t\t\t\t\t\twhileTrue: [ leftMarker column < rightMarker row\r\t\t\t\t\t\t\t\tifTrue: [ leftMarker := leftMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ leftMarker column > rightMarker row\r\t\t\t\t\t\t\t\t\t\tifTrue: [ rightMarker := rightMarker belowNeighbour ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ sum := sum + (leftMarker value * rightMarker value).\r\t\t\t\t\t\t\t\t\t\t\trightMarker := rightMarker belowNeighbour.\r\t\t\t\t\t\t\t\t\t\t\tleftMarker := leftMarker rightNeighbour. ] ] ].\r\t\t\t\t\tsum ~= 0\r\t\t\t\t\t\tifTrue: [ newNode := TWMatrixNode new value: sum row: rowIndex column: columnIndex.\r\t\t\t\t\t\t\t(lastInRowMarkers at: rowIndex) rightNeighbour: newNode.\r\t\t\t\t\t\t\t(lastInColumnMarkers at: columnIndex) belowNeighbour: newNode.\r\t\t\t\t\t\t\tlastInRowMarkers at: rowIndex put: newNode.\r\t\t\t\t\t\t\tlastInColumnMarkers at: columnIndex put: newNode ] ] ].\r\t\t\t\tresult rows withIndexDo: [ :rowHead :rowIndex | (lastInRowMarkers at: rowIndex) rightNeighbour: rowHead ].\r\t\t\t\tresult columns withIndexDo: [ :colHead :colIndex | (lastInColumnMarkers at: colIndex ) belowNeighbour: colHead ].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'byMatrix:',			#protocol : #private,			#sourceCode : 'byMatrix: aMatrix\r\t| result rowNumbers columnNumbers lastInRowMarkers lastInColumnMarkers leftMarker rightMarker sum newNode |\r\tself columnsNumber ~= aMatrix rowsNumber\r\t\tifTrue: [ Error signal: \'Size mismatch. Left: \' , self columnsNumber , \' Right: \' , aMatrix rowsNumber ].\r\tresult := self class new rows: self rowsNumber columns: aMatrix columnsNumber.\r\t(self isEmpty or: aMatrix isEmpty)\r\t\tifTrue: [ ^ result ].\r\tlastInRowMarkers := result rows copy.\r\tlastInColumnMarkers := result columns copy.\r\trowNumbers := self rows reject: [ :rowHead | rowHead rightNeighbour = rowHead ] thenCollect: [ :rowHead | rowHead row ].\r\tcolumnNumbers := aMatrix rows reject: [ :colHead | colHead belowNeighbour = colHead ] thenCollect: [ :colHead | colHead row ].\r\trowNumbers\r\t\tdo: [ :rowIndex | \r\t\t\tcolumnNumbers\r\t\t\t\tdo: [ :columnIndex | \r\t\t\t\t\tleftMarker := (self rows at: rowIndex) rightNeighbour.\r\t\t\t\t\trightMarker := (aMatrix columns at: columnIndex) belowNeighbour.\r\t\t\t\t\tsum := 0.\r\t\t\t\t\t[ leftMarker column ~= 0 and: [ rightMarker row ~= 0 ] ]\r\t\t\t\t\t\twhileTrue: [ leftMarker column < rightMarker row\r\t\t\t\t\t\t\t\tifTrue: [ leftMarker := leftMarker rightNeighbour ]\r\t\t\t\t\t\t\t\tifFalse: [ leftMarker column > rightMarker row\r\t\t\t\t\t\t\t\t\t\tifTrue: [ rightMarker := rightMarker belowNeighbour ]\r\t\t\t\t\t\t\t\t\t\tifFalse: [ sum := sum + (leftMarker value * rightMarker value).\r\t\t\t\t\t\t\t\t\t\t\trightMarker := rightMarker belowNeighbour.\r\t\t\t\t\t\t\t\t\t\t\tleftMarker := leftMarker rightNeighbour. ] ] ].\r\t\t\t\t\tsum ~= 0\r\t\t\t\t\t\tifTrue: [ newNode := TWSparseMatrixNode new value: sum row: rowIndex column: columnIndex.\r\t\t\t\t\t\t\t(lastInRowMarkers at: rowIndex) rightNeighbour: newNode.\r\t\t\t\t\t\t\t(lastInColumnMarkers at: columnIndex) belowNeighbour: newNode.\r\t\t\t\t\t\t\tlastInRowMarkers at: rowIndex put: newNode.\r\t\t\t\t\t\t\tlastInColumnMarkers at: columnIndex put: newNode ] ] ].\r\t\t\t\tresult rows withIndexDo: [ :rowHead :rowIndex | (lastInRowMarkers at: rowIndex) rightNeighbour: rowHead ].\r\t\t\t\tresult columns withIndexDo: [ :colHead :colIndex | (lastInColumnMarkers at: colIndex ) belowNeighbour: colHead ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.588435+03:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'rows:columns:',			#protocol : #'instance creation',			#sourceCode : 'rows: numberOfRows columns: numberOfColumns\r\trowsNumber := numberOfRows.\r\tcolumnsNumber := numberOfColumns.\r\trows := (1 to: numberOfRows) collect: [ :each | TWMatrixNode new value: nil row: each column: 0].\r\tcolumns := (1 to: numberOfColumns) collect: [ :each | TWMatrixNode new value: nil row: 0 column: each].\r\trows := rows collect: [ :each | each rightNeighbour: each belowNeighbour: nil ].\r\tcolumns := columns collect: [ :each | each rightNeighbour: nil belowNeighbour: each ].',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'rows:columns:',			#protocol : #'instance creation',			#sourceCode : 'rows: numberOfRows columns: numberOfColumns\r\trowsNumber := numberOfRows.\r\tcolumnsNumber := numberOfColumns.\r\trows := (1 to: numberOfRows) collect: [ :each | TWSparseMatrixNode new value: nil row: each column: 0].\r\tcolumns := (1 to: numberOfColumns) collect: [ :each | TWSparseMatrixNode new value: nil row: 0 column: each].\r\trows := rows collect: [ :each | each rightNeighbour: each belowNeighbour: nil ].\r\tcolumns := columns collect: [ :each | each rightNeighbour: nil belowNeighbour: each ].',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T18:37:30.610435+03:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #transpose,			#protocol : #transformation,			#sourceCode : 'transpose\r\t| copy rowMarker result columnMarkers |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tcolumnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\trowMarker rightNeighbour: (TWMatrixNode new value: copy value row: copy column column: copy row).\r\t\t\t\t\t(columnMarkers at: copy row) belowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each ].\r\tresult columns withIndexDo: [ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\t^ result',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #transpose,			#protocol : #transformation,			#sourceCode : 'transpose\r\t| copy rowMarker result columnMarkers |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tcolumnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\trowMarker rightNeighbour: (TWSparseMatrixNode new value: copy value row: copy column column: copy row).\r\t\t\t\t\t(columnMarkers at: copy row) belowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each ].\r\tresult columns withIndexDo: [ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\t^ result',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:46:41.611435+03:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:46',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:46:43.739435+03:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:46',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:47:27.563435+03:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:47:29.755435+03:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:47:31.894435+03:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:47:34.102435+03:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:47:36.205435+03:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:47:38.344435+03:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 19:47',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:57:00.131435+03:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'transposeAnimatedDelay:',			#protocol : #transformation,			#sourceCode : 'transposeAnimatedDelay: delay\r\t| copy rowMarker result columnMarkers vis operationProcess sourceMarker |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tMatrixVisualizer on: self withView: vis view.\r\tvis composer group: #source.\r\tMatrixVisualizer on: result withView: vis view.\r\tvis composer group: #result.\r\tsourceMarker := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: sourceMarker.\r\tvis group: #sourceMarker.\r\tvis composer move: #sourceMarker below: #source.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis namedGroups: #(#source #result #sourceMarker).\r\tvis backgroundGroups: #(#source #result).\r\tvis redrawNamesAndBackgrounds.\r\toperationProcess := [ columnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\tvis selectModel: copy.\r\t\t\t\t\trowMarker\r\t\t\t\t\t\trightNeighbour: (TWSparseMatrixNode new value: copy value row: copy column column: copy row).\r\t\t\t\t\t(columnMarkers at: copy row)\r\t\t\t\t\t\tbelowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis deselectModel: copy.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each.\r\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ].\r\tresult columns\r\t\twithIndexDo:\r\t\t\t[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\tvis composer removeGroup: #sourceMarker.\r\tvis\r\t\tnamedGroups: (vis namedGroups copyWithout: #sourceMarker).\r\tvis redrawNamesAndBackgrounds.\r\tvis composer replaceElementsInGroup: #result with: result.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis composer view canvas focusOnCenterScaled.\r\tvis delay wait ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/17/2019 18:37',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'transposeAnimatedDelay:',			#protocol : #transformation,			#sourceCode : 'transposeAnimatedDelay: delay\r\t| copy rowMarker result columnMarkers vis operationProcess sourceMarker |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tMatrixVisualizer on: self withView: vis view.\r\tvis composer group: #source.\r\tMatrixVisualizer on: result withView: vis view.\r\tvis composer group: #result.\r\tsourceMarker := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: sourceMarker.\r\tvis group: #sourceMarker.\r\tvis composer move: #sourceMarker below: #source.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis namedGroups: #(#source #result #sourceMarker).\r\tvis backgroundGroups: #(#source #result).\r\tvis redrawNamesAndBackgrounds.\r\toperationProcess := [ columnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\tsourceMarker updateModelAndRedraw: rowMarker.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\tvis selectModel: copy.\r\t\t\t\t\trowMarker\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWSparseMatrixNode new\r\t\t\t\t\t\t\t\tvalue: copy value\r\t\t\t\t\t\t\t\trow: copy column\r\t\t\t\t\t\t\t\tcolumn: copy row).\r\t\t\t\t\t(columnMarkers at: copy row)\r\t\t\t\t\t\tbelowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis deselectModel: copy.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each.\r\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ].\r\tresult columns\r\t\twithIndexDo:\r\t\t\t[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\tvis composer removeGroup: #sourceMarker.\r\tvis namedGroups: (vis namedGroups copyWithout: #sourceMarker).\r\tvis redrawNamesAndBackgrounds.\r\tvis composer replaceElementsInGroup: #result with: result.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis composer view canvas focusOnCenterScaled.\r\tvis delay wait ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/17/2019 19:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T19:57:56.322435+03:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'transposeAnimatedDelay:',			#protocol : #transformation,			#sourceCode : 'transposeAnimatedDelay: delay\r\t| copy rowMarker result columnMarkers vis operationProcess sourceMarker |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tMatrixVisualizer on: self withView: vis view.\r\tvis composer group: #source.\r\tMatrixVisualizer on: result withView: vis view.\r\tvis composer group: #result.\r\tsourceMarker := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: sourceMarker.\r\tvis group: #sourceMarker.\r\tvis composer move: #sourceMarker below: #source.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis namedGroups: #(#source #result #sourceMarker).\r\tvis backgroundGroups: #(#source #result).\r\tvis redrawNamesAndBackgrounds.\r\toperationProcess := [ columnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\tsourceMarker updateModelAndRedraw: rowMarker.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\tvis selectModel: copy.\r\t\t\t\t\trowMarker\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWSparseMatrixNode new\r\t\t\t\t\t\t\t\tvalue: copy value\r\t\t\t\t\t\t\t\trow: copy column\r\t\t\t\t\t\t\t\tcolumn: copy row).\r\t\t\t\t\t(columnMarkers at: copy row)\r\t\t\t\t\t\tbelowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis deselectModel: copy.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each.\r\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ].\r\tresult columns\r\t\twithIndexDo:\r\t\t\t[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\tvis composer removeGroup: #sourceMarker.\r\tvis namedGroups: (vis namedGroups copyWithout: #sourceMarker).\r\tvis redrawNamesAndBackgrounds.\r\tvis composer replaceElementsInGroup: #result with: result.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis composer view canvas focusOnCenterScaled.\r\tvis delay wait ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/17/2019 19:57',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TWSparseMatrix,				#isMetaSide : false			},			#name : #'transposeAnimatedDelay:',			#protocol : #transformation,			#sourceCode : 'transposeAnimatedDelay: delay\r\t| copy rowMarker result columnMarkers vis operationProcess sourceMarker |\r\tresult := self class rows: columnsNumber columns: rowsNumber.\r\tself isEmpty\r\t\tifTrue: [ ^ result ].\r\tvis := MatrixOperationVisualizer new.\r\tvis delay: delay.\r\tMatrixVisualizer on: self withView: vis view.\r\tvis composer group: #source.\r\tMatrixVisualizer on: result withView: vis view.\r\tvis composer group: #result.\r\tsourceMarker := (TWSparseMatrixVisualizer new\r\t\tgetElementShapeScaled: 5)\r\t\telementOn: (TWSparseMatrixNode new value: 0 row: 0 column: 0).\r\tvis add: sourceMarker.\r\tvis group: #sourceMarker.\r\tvis composer move: #sourceMarker below: #source.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis namedGroups: #(#source #result #sourceMarker).\r\tvis backgroundGroups: #(#source #result).\r\tvis redrawNamesAndBackgrounds.\r\toperationProcess := [ columnMarkers := result columns copy.\r\tresult rows\r\t\twithIndexDo: [ :each :rowIndex | \r\t\t\tcopy := self columns at: rowIndex.\r\t\t\trowMarker := each.\r\t\t\tsourceMarker updateModelAndRedraw: rowMarker.\r\t\t\t[ copy belowNeighbour row ~= 0 ]\r\t\t\t\twhileTrue: [ copy := copy belowNeighbour.\r\t\t\t\t\tvis selectModel: copy.\r\t\t\tsourceMarker updateModelAndRedraw: copy.\r\t\t\t\t\trowMarker\r\t\t\t\t\t\trightNeighbour:\r\t\t\t\t\t\t\t(TWSparseMatrixNode new\r\t\t\t\t\t\t\t\tvalue: copy value\r\t\t\t\t\t\t\t\trow: copy column\r\t\t\t\t\t\t\t\tcolumn: copy row).\r\t\t\t\t\t(columnMarkers at: copy row)\r\t\t\t\t\t\tbelowNeighbour: rowMarker rightNeighbour.\r\t\t\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\t\t\tvis delay wait.\r\t\t\t\t\tvis deselectModel: copy.\r\t\t\t\t\tcolumnMarkers at: copy row put: rowMarker rightNeighbour.\r\t\t\t\t\trowMarker := rowMarker rightNeighbour ].\r\t\t\trowMarker rightNeighbour: each.\r\t\t\tvis composer replaceElementsInGroup: #result with: result.\r\t\t\tvis composer move: #result onTheRightOf: #source.\r\t\t\tvis composer view canvas focusOnCenterScaled.\r\t\t\tvis delay wait ].\r\tresult columns\r\t\twithIndexDo:\r\t\t\t[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].\r\tvis composer removeGroup: #sourceMarker.\r\tvis namedGroups: (vis namedGroups copyWithout: #sourceMarker).\r\tvis redrawNamesAndBackgrounds.\r\tvis composer replaceElementsInGroup: #result with: result.\r\tvis composer move: #result onTheRightOf: #source.\r\tvis composer view canvas focusOnCenterScaled.\r\tvis delay wait ] newProcess.\r\tvis setUpMenuWithProcess: operationProcess.\r\t^ vis view',			#stamp : 'YaroslavKormushyn 5/17/2019 19:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T20:54:18.515435+03:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 20:54',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T20:54:20.637435+03:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/17/2019 20:54',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T20:57:15.897435+03:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeAdditionView,			#protocol : #initialization,			#sourceCode : 'initializeAdditionView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\tself add: nowProcessingElementIndex.\r\tself group: #nowProcessing.\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\tself\r\t\tselectModels:\r\t\t\t{leftMarkerElement model.\r\t\t\trightMarkerElement model}',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #initializeAdditionView,			#protocol : #initialization,			#sourceCode : 'initializeAdditionView\r\tnamedGroups := #(#left #result #right #leftMarker #rightMarker).\r\tbackgroundGroups := #(#left #result #right).\r\tMatrixVisualizer on: leftMatrix withView: composer view.\r\tcomposer group: #left.\r\tMatrixVisualizer on: rightMatrix withView: composer view.\r\tcomposer group: #right.\r\tMatrixVisualizer on: resultMatrix withView: composer view.\r\tcomposer group: #result.\r\t"self add: nowProcessingElementIndex.\r\tself group: #nowProcessing."\r\tself add: leftMarkerElement.\r\tself group: #leftMarker.\r\tself add: rightMarkerElement.\r\tself group: #rightMarker.\r\tself\r\t\tselectModels:\r\t\t\t{leftMarkerElement model.\r\t\t\trightMarkerElement model}',			#stamp : 'YaroslavKormushyn 5/17/2019 20:57',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T21:01:02.282435+03:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 20:57',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T21:01:26.690435+03:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForAddition,			#protocol : #initialization,			#sourceCode : 'setPositionsForAddition\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\tcomposer move: #nowProcessing above: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'CompatibleUserName 5/5/2019 13:26:27',			#package : #LNU-SparseMatrix		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #COOSparseMatrixOperationVisualizer,				#isMetaSide : false			},			#name : #setPositionsForAddition,			#protocol : #initialization,			#sourceCode : 'setPositionsForAddition\r\tcomposer move: #left onTheLeftOf: #right.\r\tcomposer move: #result onTheRightOf: #right.\r\tcomposer move: #leftMarker below: #left.\r\tcomposer move: #rightMarker below: #right.\r\t"composer move: #nowProcessing above: #right."\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #right.\r\tcomposer setBackgroundColor: (Color gray alpha: 0.2) forGroup: #left.\r\tcomposer\r\t\tsetBackgroundColor: (Color gray alpha: 0.2)\r\t\tforGroup: #result.\r\tcomposer nameGroup: #left as: \'left\'.\r\tcomposer nameGroup: #right as: \'right\'.\r\tcomposer nameGroup: #result as: \'result\'.\r\tcomposer nameGroup: #leftMarker as: \'left marker\'.\r\tcomposer nameGroup: #rightMarker as: \'right marker\'.\r\tcomposer group: #labels',			#stamp : 'YaroslavKormushyn 5/17/2019 21:01',			#package : #LNU-SparseMatrix		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T21:01:32.925435+03:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrixNode',				#isMetaSide : false			},			#name : #copy,			#protocol : #'as yet unclassified',			#sourceCode : 'copy\r^ self class row: row column: column value: value ',			#stamp : 'YaroslavKormushyn 5/17/2019 21:01',			#package : #_UnpackagedPackage		}	}}OmEntry {	#tags : {		#author : 'YaroslavKormushyn',		#time : DateAndTime [ '2019-05-17T21:01:35.048435+03:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'a subclass of COOSparseMatrix',				#isMetaSide : false			},			#name : #'last:',			#protocol : #'as yet unclassified',			#sourceCode : 'last: aCOOMatrixNode\r\tlast := aCOOMatrixNode ',			#stamp : 'YaroslavKormushyn 5/17/2019 21:01',			#package : #_UnpackagedPackage		}	}}