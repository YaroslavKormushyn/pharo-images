[31mAssertionFailure: Project location does not seems to be a valid git repository.
[0mIceTipLocalRepositoryPanel(Object)>>assert:description:
IceTipLocalRepositoryPanel>>validate
[ dialog validate.
self repositoryModel updateLocation: dialog location.
true ] in IceTipRepairLocateRepository>>basicExecute in Block: [ dialog validate....
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock in Block: [ okAction value value == false...
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[0m[31mWarning
[0mIceGitCommit(IceCommitish)>>validateCanMerge
IceMerge>>execute
IceAttachedSingleVersionWorkingCopy>>mergeCommit:
IceWorkingCopy>>mergeCommit:
IceGitCommit(IceCommitish)>>merge
IceGitLocalBranch(IceCommitish)>>switchAndMergeWorkingCopy
[ self entity switchAndMergeWorkingCopy ] in IceTipBranchModel>>switchAndMergeThen: in Block: [ self entity switchAndMergeWorkingCopy ]
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during: in Block: [ :bar | ...
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring: in Block: [ :bar | aBlock value: bar ]
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ ^ block cull: self ]
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during: in Block: [ activeProcess psValueAt: index put: anObject....
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ self prepareForRunning....
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute in Block: [ self basicExecute....
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipBranchModel>>switchAndMergeThen:
IceTipSwitchAndMergeType>>mergeOn:then:
IceTipMergeModel>>merge
[0m[31mWarning
[0mIceGitCommit(IceCommitish)>>validateCanMerge
IceMerge>>execute
IceAttachedSingleVersionWorkingCopy>>mergeCommit:
IceWorkingCopy>>mergeCommit:
IceGitCommit(IceCommitish)>>merge
IceGitLocalBranch(IceCommitish)>>switchAndMergeWorkingCopy
[ self entity switchAndMergeWorkingCopy ] in IceTipBranchModel>>switchAndMergeThen: in Block: [ self entity switchAndMergeWorkingCopy ]
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during: in Block: [ :bar | ...
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring: in Block: [ :bar | aBlock value: bar ]
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ ^ block cull: self ]
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during: in Block: [ activeProcess psValueAt: index put: anObject....
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ self prepareForRunning....
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute in Block: [ self basicExecute....
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipBranchModel>>switchAndMergeThen:
IceTipSwitchAndMergeType>>mergeOn:then:
IceTipMergeModel>>merge
[0mpareForRunning....
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
[0m[31mUser Interrupt
[0mAlien class>>invokeCallbackContext:
LGitRepository>>clone:url:local_path:options:
FFICalloutAPI>>function:module:
LGitRepository(LGitExternalObject)>>callUnchecked:options:
LGitRepository>>clone:url:local_path:options:
[ self
	clone: self
	url: aString
	local_path: aFileReference pathString
	options: cloneOptions ] in LGitRepository>>clone:options:to: in Block: [ self...
LGitRepository(LGitExternalObject)>>withReturnHandlerDo:
LGitRepository>>clone:options:to:
LGitRepository>>clone:options:
[ location ensureCreateDirectory.
repo := LGitRepository on: location.
cloneOptions := LGitCloneOptions
	withCredentialsProvider: (IceCredentialsProvider defaultForRemoteUrl: url).

"Keeping references, because if not the GC take them."
checkoutOptions := cloneOptions checkoutOptions.
callbacks := cloneOptions fetchOptions callbacks.
callbacks transferProgress: IceGitTransferProgress new.
checkoutOptions
	checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force.
checkoutOptions progressCallback: IceGitCheckoutProgress new.
repo clone: url options: cloneOptions.
(LGitRemote of: repo named: 'origin')
	lookup;
	setUrl: url ] in IceGitClone>>execute in Block: [ location ensureCreateDirectory....
BlockClosure>>on:do:
IceGitClone>>execute
IceRepositoryCreator>>cloneRepository
[ self validate.
self isCloning
	ifTrue: [ self cloneRepository ]
	ifFalse: [ self addLocalRepository ] ] in IceRepositoryCreator>>createRepository in Block: [ self validate....
BlockClosure>>on:do:
IceRepositoryCreator>>createRepository
[ ^ IceRepositoryCreator new
	repository: repository;
	remote: (IceGitRemote url: self remoteUrl);
	location: self projectLocation location;
	createRepository ] in IceTipGitHubRepositoryPanel(IceTipGitRepositoryPanel)>>newRepository in Block: [ ^ IceRepositoryCreator new...
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during: in Block: [ :bar | ...
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring: in Block: [ :bar | aBlock value: bar ]
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ ^ block cull: self ]
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during: in Block: [ activeProcess psValueAt: index put: anObject....
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ self prepareForRunning....
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
[0m[31mUser Interrupt
[0mAlien class>>invokeCallbackContext:
LGitRepository>>clone:url:local_path:options:
FFICalloutAPI>>function:module:
LGitRepository(LGitExternalObject)>>callUnchecked:options:
LGitRepository>>clone:url:local_path:options:
[ self
	clone: self
	url: aString
	local_path: aFileReference pathString
	options: cloneOptions ] in LGitRepository>>clone:options:to: in Block: [ self...
LGitRepository(LGitExternalObject)>>withReturnHandlerDo:
LGitRepository>>clone:options:to:
LGitRepository>>clone:options:
[ location ensureCreateDirectory.
repo := LGitRepository on: location.
cloneOptions := LGitCloneOptions
	withCredentialsProvider: (IceCredentialsProvider defaultForRemoteUrl: url).

"Keeping references, because if not the GC take them."
checkoutOptions := cloneOptions checkoutOptions.
callbacks := cloneOptions fetchOptions callbacks.
callbacks transferProgress: IceGitTransferProgress new.
checkoutOptions
	checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force.
checkoutOptions progressCallback: IceGitCheckoutProgress new.
repo clone: url options: cloneOptions.
(LGitRemote of: repo named: 'origin')
	lookup;
	setUrl: url ] in IceGitClone>>execute in Block: [ location ensureCreateDirectory....
BlockClosure>>on:do:
IceGitClone>>execute
IceRepositoryCreator>>cloneRepository
[ self validate.
self isCloning
	ifTrue: [ self cloneRepository ]
	ifFalse: [ self addLocalRepository ] ] in IceRepositoryCreator>>createRepository in Block: [ self validate....
BlockClosure>>on:do:
IceRepositoryCreator>>createRepository
[ ^ IceRepositoryCreator new
	repository: repository;
	remote: (IceGitRemote url: self remoteUrl);
	location: self projectLocation location;
	createRepository ] in IceTipGitHubRepositoryPanel(IceTipGitRepositoryPanel)>>newRepository in Block: [ ^ IceRepositoryCreator new...
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during: in Block: [ :bar | ...
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring: in Block: [ :bar | aBlock value: bar ]
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ ^ block cull: self ]
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during: in Block: [ activeProcess psValueAt: index put: anObject....
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run in Block: [ self prepareForRunning....
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
[0m(UIManager)>>informUser:during:
IceTipGitHubRepositoryPanel(IceTipGitRepositoryPanel)>>newRepository
IceTipGitHubRepositoryPanel>>newRepository
[0m[31mInstance of IceExternalJob did not understand #isRunning
[0mIceExternalJob(Object)>>doesNotUnderstand: #isRunning
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>mouseUp:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of IceExternalJob did not understand #isRunning
[0mIceExternalJob(Object)>>doesNotUnderstand: #isRunning
JobProgressMorph>>debug
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
JobProgressBarMorph(Morph)>>mouseUp:
JobProgressBarMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
JobProgressBarMorph(Morph)>>handleEvent:
JobProgressBarMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0merScaled.
		vis delay wait ].
result columns
	withIndexDo:
		[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].
vis composer removeGroup: #sourceMarker.
vis namedGroups: (vis namedGroups copyWithout: #sourceMarker).
vis redrawNamesAndBackgrounds.
vis composer replaceElementsInGroup: #result with: result.
vis composer move: #result onTheRightOf: #source.
vis composer view canvas focusOnCenterScaled.
vis delay wait ] in TWSparseMatrix>>transposeAnimatedDelay: in Block: [ :each :rowIndex | ...
Array(SequenceableCollection)>>withIndexDo:
[ columnMarkers := result columns copy.
result rows
	withIndexDo: [ :each :rowIndex | 
		copy := self columns at: rowIndex.
		rowMarker := each.
		[ copy belowNeighbour row ~= 0 ]
			whileTrue: [ copy := copy belowNeighbour.
				vis selectModel: copy.
				rowMarker
					rightNeighbour:
						(TWSparseMatrixNode new
							value: copy value
							row: copy column
							column: copy row).
				(columnMarkers at: copy row)
					belowNeighbour: rowMarker rightNeighbour.
				vis composer replaceElementsInGroup: #result with: result.
				vis composer move: #result onTheRightOf: #source.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait.
				vis deselectModel: copy.
				columnMarkers at: copy row put: rowMarker rightNeighbour.
				rowMarker := rowMarker rightNeighbour ].
		rowMarker rightNeighbour: each.
		vis composer replaceElementsInGroup: #result with: result.
		vis composer move: #result onTheRightOf: #source.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
result columns
	withIndexDo:
		[ :each :columnIndex | (columnMarkers at: columnIndex) belowNeighbour: each ].
vis composer removeGroup: #sourceMarker.
vis namedGroups: (vis namedGroups copyWithout: #sourceMarker).
vis redrawNamesAndBackgrounds.
vis composer replaceElementsInGroup: #result with: result.
vis composer move: #result onTheRightOf: #source.
vis composer view canvas focusOnCenterScaled.
vis delay wait ] in TWSparseMatrix>>transposeAnimatedDelay: in Block: [ columnMarkers := result columns copy....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mKeyNotFound: key #nowProcessing not found in Dictionary
[0mDictionary>>errorKeyNotFound:
[ self errorKeyNotFound: key ] in Dictionary>>at: in Block: [ self errorKeyNotFound: key ]
Dictionary>>at:ifAbsent:
Dictionary>>at:
RTComposer>>move:above:
COOSparseMatrixOperationVisualizer>>setPositionsForAddition
[ :value | 
| resultMatrixUpdateLinkFirst resultMatrixUpdateLinkLast |
resultMatrix := value.
"initialize the view for the updates not to fail"
self initializeAdditionView.
self setPositionsForAddition.
resultMatrixUpdateLinkFirst := MetaLink new.
resultMatrixUpdateLinkFirst
	metaObject: [ self updateResultWith: value ].
resultMatrixUpdateLinkFirst selector: #value.
resultMatrixUpdateLinkFirst control: #after.
value
	link: resultMatrixUpdateLinkFirst
	toSlotNamed: #first
	option: #write.
resultMatrixUpdateLinkLast := MetaLink new.
resultMatrixUpdateLinkLast
	metaObject: [ | newResultUpdateLastLink |
		self updateResultWith: value.
		"uninstall the initial block which suspends the process"
		resultMatrixUpdateLinkLast uninstall.
		"replace it with a new one without the suspend"
		newResultUpdateLastLink := MetaLink new.
		newResultUpdateLastLink metaObject: [ self updateResultWith: value ].
		newResultUpdateLastLink selector: #value.
		newResultUpdateLastLink control: #after.
		value
			link: newResultUpdateLastLink
			toSlotNamed: #last
			option: #write.
		"signal to root multiplication method that we finished initializing"
		semaphore signal.
		"wait for input before starting the operation"
		process suspend ].
resultMatrixUpdateLinkLast selector: #value.
resultMatrixUpdateLinkLast control: #after.
value
	link: resultMatrixUpdateLinkLast
	toSlotNamed: #last
	option: #write.
metaLinks
	addAll:
		{resultMatrixUpdateLinkFirst.
		resultMatrixUpdateLinkLast} ] in COOSparseMatrixOperationVisualizer>>setAdditionLinksForResultOn:inMethod: in Block: [ :value | ...
a subclass of COOSparseMatrix>>+
ReflectiveMethod>>run:with:in:
[ leftMatrix + rightMatrix ] in [ [ leftMatrix + rightMatrix ]
	ensure: [ self unlink ] ] in COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>addAnimated:to: in Block: [ leftMatrix + rightMatrix ]
BlockClosure>>ensure:
[ [ leftMatrix + rightMatrix ]
	ensure: [ self unlink ] ] in COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>addAnimated:to: in Block: [ [ leftMatrix + rightMatrix ]...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self setAdditionLinksOn: leftMatrix.
process resume.
semaphore wait ] in COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>addAnimated:to: in Block: [ self setAdditionLinksOn: leftMatrix....
BlockClosure>>on:do:
BlockClosure>>on:fork:
COOSparseMatrixOperationVisualizer(MatrixOperationVisualizer)>>addAnimated:to:
COOSparseMatrixOperationVisualizer class>>exampleAddition
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
WorldState>>interCyclePause:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mWeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess in Block: [ self finalizationProcess ]
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDictionary>>at:ifAbsentPut:
FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
LabelMorph(StringMorph)>>fitContents
LabelMorph(StringMorph)>>contents:
LabelMorph(StringMorph)>>initWithContents:font:emphasis:
LabelMorph>>initWithContents:font:emphasis:
LabelMorph class(StringMorph class)>>contents:font:emphasis:
LabelMorph class(StringMorph class)>>contents:font:
LabelMorph class(StringMorph class)>>contents:
PharoLightTheme(UITheme)>>buttonLabelForText:
PharoLightTheme(UITheme)>>buttonLabelFor:
GLMPluggableButtonMorph(PluggableButtonMorph)>>newLabel
GLMPluggableButtonMorph(PluggableButtonMorph)>>newLabel:
GLMPluggableButtonMorph(PluggableButtonMorph)>>label:font:
GLMMorphicActionRenderer>>render:
GLMMorphicActionRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderAction:
GLMGenericAction(GLMAction)>>renderGlamorouslyOn:
[ :each | 
| actionMorph |
actionMorph := each renderGlamorouslyOn: self renderer.
actionMorph arguments
	ifNil: [ actionMorph arguments: {aPresentation} ]
	ifNotNil: [ actionMorph arguments: {aPresentation} , actionMorph arguments ].
actionMorph ] in GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>toolbarButtonsForPresentation: in Block: [ :each | ...
OrderedCollection>>collect:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>toolbarButtonsForPresentation:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderToolbarForPresentation:inMorph:
[ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ :each | ...
OrderedCollection>>do:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0mg in Block: [ :s | self gtDisplayOn: s ]
String class(SequenceableCollection class)>>streamContents:limitedTo:
LargePositiveInteger(Object)>>gtDisplayString
[ (anObject gtDisplayString
	copyReplaceAll: String cr
	with: String space) replaceAll: String lf with: String space ] in GTObjectPrinter class>>asTruncatedTextFrom: in Block: [ (anObject gtDisplayString...
BlockClosure>>on:do:
GTObjectPrinter class>>asTruncatedTextFrom:
[ :aNode | 
| rawValue displayValue |
[ rawValue := aNode rawValue ]
	on: Error
	do: [ displayValue := Text
			string: aNode errorMessage
			attribute: TextColor red ].
displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] in GTDebuggerVariablesBrowser>>variablesIn: in Block: [ :aNode | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMTablePresentation)>>column:valueFor:
[ self glamourPresentation
	column: aGlamourColumn
	valueFor:
		(self glamourPresentation isWithElementIndex
			ifTrue:
				[ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ]
			ifFalse: [ anElement ]) ] in GLMFastTableDataSource>>valueFor:withIndex:in: in Block: [ self glamourPresentation...
GLMFastTableDataSource(GLMFastListDataSource)>>cacheAt:for:ifAbsentPut:
GLMFastTableDataSource>>valueFor:withIndex:in:
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mLargePositiveInteger(LargeInteger)>>*
LargePositiveInteger>>printOn:base:
LargePositiveInteger(Number)>>printOn:
LargePositiveInteger(Object)>>gtDisplayOn:
[ :s | self gtDisplayOn: s ] in LargePositiveInteger(Object)>>gtDisplayString in Block: [ :s | self gtDisplayOn: s ]
String class(SequenceableCollection class)>>streamContents:limitedTo:
LargePositiveInteger(Object)>>gtDisplayString
[ (anObject gtDisplayString
	copyReplaceAll: String cr
	with: String space) replaceAll: String lf with: String space ] in GTObjectPrinter class>>asTruncatedTextFrom: in Block: [ (anObject gtDisplayString...
BlockClosure>>on:do:
GTObjectPrinter class>>asTruncatedTextFrom:
[ :aNode | 
| rawValue displayValue |
[ rawValue := aNode rawValue ]
	on: Error
	do: [ displayValue := Text
			string: aNode errorMessage
			attribute: TextColor red ].
displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] in GTDebuggerVariablesBrowser>>variablesIn: in Block: [ :aNode | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMTablePresentation)>>column:valueFor:
[ self glamourPresentation
	column: aGlamourColumn
	valueFor:
		(self glamourPresentation isWithElementIndex
			ifTrue:
				[ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ]
			ifFalse: [ anElement ]) ] in GLMFastTableDataSource>>valueFor:withIndex:in: in Block: [ self glamourPresentation...
GLMFastTableDataSource(GLMFastListDataSource)>>cacheAt:for:ifAbsentPut:
GLMFastTableDataSource>>valueFor:withIndex:in:
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRxMatcher>>restoreState:
RxmSubstring>>matchAgainst:
RxmMarker>>matchAgainst:
RxmLink>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
[0m[31mUser Interrupt
[0mSmallFloat64(Float)>>asTrueFraction
SmallFloat64(Float)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Rectangle>>intersects:
Rectangle>>intersect:ifNone:
GLMPanelMorph(Morph)>>invalidRect:from:
GLMPanelMorph(Morph)>>invalidRect:from:
GLMPanelMorph(Morph)>>invalidRect:from:
GLMPanelMorph(Morph)>>invalidRect:from:
FTTableMorph(Morph)>>invalidRect:from:
ScrollBar(Morph)>>invalidRect:from:
BorderedMorph(Morph)>>invalidRect:from:
BorderedMorph(Morph)>>invalidRect:
BorderedMorph(Morph)>>changed
BorderedMorph(Morph)>>fillStyle:
ScrollBar>>adoptGradientColor:
ScrollBar>>sliderColor:
ScrollBar>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in FTTableMorph(Morph)>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
FTTableMorph(Morph)>>submorphsDo:
FTTableMorph(Morph)>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in GLMPanelMorph>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
GLMPanelMorph>>adoptPaneColor:
[ :m | m adoptPaneColor: paneColor ] in GLMPanelMorph>>adoptPaneColor: in Block: [ :m | m adoptPaneColor: paneColor ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0mGLMFastTableDataSource(GLMFastListDataSource)>>selection:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
FTTableMorph(Morph)>>doAnnounce:
FTTableMorph>>selectRowIndexes:andMakeVisibleIf:
FTTableMorph>>selectRowIndexes:
FTTableMorph>>selectRowIndex:
GLMFastTableDataSource(GLMFastListDataSource)>>explicitSelection:
[ tableModel explicitSelection: aPresentation selection ] in GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>render: in Block: [ tableModel explicitSelection: aPresentation sele...etc...
BlockClosure>>ensure:
GLMAnnouncer>>suspendAll:while:
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>render:
GLMMorphicFastTableRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderFastTablePresentation:
GLMFastTablePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[ self renderObject: each ] in [ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ self renderObject: each ]
LazyTabPage>>actualPageMorph
[0m[31mUser Interrupt
[0mDictionary>>at:ifAbsent:
Dictionary>>at:ifAbsentPut:
FreeTypeCache>>atFont:charCode:type:ifAbsentPut:
FreeTypeFont>>linearWidthOf:
FreeTypeFont>>widthOf:
LogicalFont>>widthOf:
CompositionScanner(CharacterScanner)>>setFont
CompositionScanner>>setStopConditions
CompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:
TextComposer>>composeEachRectangleIn:
TextComposer>>composeAllRectangles:
TextComposer>>composeOneLine
TextComposer>>composeAllLines
TextComposer>>multiComposeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:wantsColumnBreaks:
Paragraph>>multiComposeLinesFrom:to:delta:into:priorLines:atY:
Paragraph>>composeAll
Paragraph>>compose:style:from:in:
TextMorph>>paragraph
TextMorph>>newContents:
TextMorph>>contentsAsIs:
Text>>asTextMorph
Text>>asMorph
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRubScrollBar(ScrollBar)>>totalSliderArea
RubScrollBar(Slider)>>roomToMove
RubScrollBar(Slider)>>computeSlider
RubScrollBar(Slider)>>value:
RubScrollBar(Slider)>>setValue:
RubScrollBar(GeneralScrollBar)>>setValue:
RubTextScrollPane(GeneralScrollPane)>>hSetScrollDelta
RubTextScrollPane(GeneralScrollPane)>>setScrollDeltas
RubTextScrollPane(GeneralScrollPane)>>updateScrollbars
RubTextScrollPane>>updateScrollbars
RubTextScrollPane(GeneralScrollPane)>>scrollTarget:
RubTextScrollPane>>scrollTarget:
RubTextScrollPane(GeneralScrollPane)>>initialize
RubTextScrollPane>>initialize
RubTextScrollPane class(Behavior)>>new
RubScrolledTextMorph>>newScrollPane
RubScrolledTextMorph>>initialize
RubScrolledTextMorph class(Behavior)>>new
GLMMorphicPharoMethodRenderer>>morph
GLMMorphicPharoMethodRenderer(GLMMorphicRubricTextRenderer)>>render:
GLMMorphicPharoMethodRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPharoMethodPresentation:
GLMPharoMethodPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[ self renderObject: each ] in [ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ self renderObject: each ]
LazyTabPage>>actualPageMorph
LazyTabGroupMorph>>pageAt:
LazyTabGroupMorph>>updatePageIndex:
LazyTabGroupMorph(TabGroupMorph)>>update:
[0m[31mUser Interrupt
[0mRubCompositionScanner(RubCharacterScanner)>>basicScanCharactersFrom:to:in:rightX:stopConditions:kern:
RubCompositionScanner(RubCharacterScanner)>>scanCharactersFrom:to:in:rightX:stopConditions:kern:
RubCompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:
RubTextComposer>>composeEachRectangleIn:
RubTextComposer>>composeAllRectangles:
RubTextComposer>>composeOneLine
RubTextComposer>>composeAllLines
RubTextComposer>>composeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:
RubTextComposer>>composeLinesFrom:to:delta:into:priorLines:atY:
[ self uptodateComposer
	composeLinesFrom: 1
	to: self text size
	delta: 0
	into: OrderedCollection new
	priorLines: Array new
	atY: self compositionRectangle top.
textArea
	ifNotNil: [ textArea paragraphWasComposedFrom: 1 to: self text size ] ] in RubParagraph>>compose in Block: [ self uptodateComposer...
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
RubParagraph>>compose
RubParagraph>>tabWidth:
Message>>sendTo:
[ aMessage sendTo: next ] in RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth:
Message>>sendTo:
[ aMessage sendTo: next ] in RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth:
Message>>sendTo:
[ aMessage sendTo: next ] in RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth:
Message>>sendTo:
[ aMessage sendTo: next ] in RubShoutStylerDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubShoutStylerDecorator(RubParagraphDecorator)>>doesNotUnderstand: #tabWidth:
[0m[31mUser Interrupt
[0m[ :line | 
line lineNumber: numberOfPhysicalLines.
line stopCondition = #cr
	ifTrue: [ numberOfPhysicalLines := numberOfPhysicalLines + 1 ].
actualWidth := line actualWidth max: actualWidth ] in RubTextComposer>>completeComposition in Block: [ :line | ...
OrderedCollection>>do:
RubTextComposer>>completeComposition
RubTextComposer>>composeLinesFrom:to:delta:into:priorLines:atY:
[ self uptodateComposer
	composeLinesFrom: 1
	to: self text size
	delta: 0
	into: OrderedCollection new
	priorLines: Array new
	atY: self compositionRectangle top.
textArea
	ifNotNil: [ textArea paragraphWasComposedFrom: 1 to: self text size ] ] in RubParagraph>>compose in Block: [ self uptodateComposer...
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
RubParagraph>>compose
RubParagraph>>extentFromClientBottomRight:
[ self wrapped
	ifTrue: [ (bounds notNil and: [ bounds width = aPoint x ])
			ifTrue: [ ^ self ].
		super
			extent:
				((self paragraph withoutDecorator extentFromClientBottomRight: aPoint)
					max: self minimumExtent).
		self recomputeSelection ] ] in RubEditingArea(RubAbstractTextArea)>>extent: in Block: [ self wrapped...
RubEditingArea(RubAbstractTextArea)>>handleBoundsChange:
RubEditingArea(RubAbstractTextArea)>>extent:
RubEditingArea(Morph)>>width:
RubTextScrollPane>>fitScrollTargetWidth
RubTextScrollPane>>updateScrollbars
RubTextScrollPane(GeneralScrollPane)>>extent:
RubTextScrollPane>>extent:
RubScrolledTextMorph>>manageLayoutInBounds:
RubScrolledTextMorph>>manageLayout
RubScrolledTextMorph>>extent:
RubScrolledTextMorph(Morph)>>bounds:
RubScrolledTextMorph(Morph)>>layoutInBounds:
TableLayout>>layoutTopToBottom:in:
TableLayout>>layout:in:
GLMPanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMPanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
GLMPanelMorph(Morph)>>computeFullBounds
GLMPanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in LazyTabGroupMorph(Morph)>>submorphBounds in Block: [ :m | ...
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mSmallFloat64(Float)>>adaptToInteger:andSend:
SmallInteger(Integer)>>*
SmallInteger>>*
SmallFloat64(Number)>>roundTo:
FreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
LabelMorph(StringMorph)>>measureContents
LabelMorph(StringMorph)>>fitContents
LabelMorph(StringMorph)>>font:emphasis:
LabelMorph(StringMorph)>>font:
PharoLightTheme(UITheme)>>buttonLabelFor:
GLMPluggableButtonMorph(PluggableButtonMorph)>>newLabel
GLMPluggableButtonMorph(PluggableButtonMorph)>>newLabel:
GLMPluggableButtonMorph(PluggableButtonMorph)>>label:font:
GLMMorphicActionRenderer>>render:
GLMMorphicActionRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderAction:
GLMGenericAction(GLMAction)>>renderGlamorouslyOn:
[ :each | 
| actionMorph |
actionMorph := each renderGlamorouslyOn: self renderer.
actionMorph arguments
	ifNil: [ actionMorph arguments: {aPresentation} ]
	ifNotNil: [ actionMorph arguments: {aPresentation} , actionMorph arguments ].
actionMorph ] in GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>toolbarButtonsForPresentation: in Block: [ :each | ...
OrderedCollection>>collect:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>toolbarButtonsForPresentation:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderToolbarForPresentation:inMorph:
[ :each :i | 
tabs
	updatePageAtIndex: i
	withLabel: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionMorphFor: each) ] in GLMMorphicTabbedRenderer>>actOnPresentationToolbarUpdated: in Block: [ :each :i | ...
OrderedCollection(SequenceableCollection)>>withIndexDo:
GLMMorphicTabbedRenderer>>actOnPresentationToolbarUpdated:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mExternalAddress>>isNull
FreeTypeFace(ExternalObject)>>isNull
FreeTypeFace(FT2Handle)>>isValid
FreeTypeFace>>validate
FreeTypeFont>>face
FreeTypeFont>>validate
LogicalFont>>realFont
LogicalFont>>height
LabelMorph(StringMorph)>>minHeight
LabelMorph>>minHeight
LabelMorph(Morph)>>minExtent
[ :m | 
| sizeY sizeX props |
props := m layoutProperties ifNil: [ m ].
props disableTableLayout
	ifFalse: [ n := n + 1.
		cell := LayoutCell new target: m.
		props hResizing == #spaceFill
			ifTrue: [ cell hSpaceFill: true.
				extra := m spaceFillWeight.
				cell extraSpace: extra.
				sum := sum + extra ]
			ifFalse: [ cell hSpaceFill: false ].
		props vResizing == #spaceFill
			ifTrue: [ vFill := true ].
		size := m minExtent.
		sizeX := size x.
		sizeY := size y.
		sizeX < minX
			ifTrue: [ sizeX := minX ]
			ifFalse: [ sizeX > maxX
					ifTrue: [ sizeX := maxX ] ].
		sizeY < minY
			ifTrue: [ sizeY := minY ]
			ifFalse: [ sizeY > maxY
					ifTrue: [ sizeY := maxY ] ].
		cell cellSize: sizeX.
		last ifNil: [ first := cell ] ifNotNil: [ last nextCell: cell ].
		last := cell.
		width := width + sizeX.
		sizeY > height
			ifTrue: [ height := sizeY ] ] ] in TableLayout>>layoutLeftToRight:in: in Block: [ :m | ...
Array(SequenceableCollection)>>do:
AlignmentMorph(Morph)>>submorphsDo:
TableLayout>>layoutLeftToRight:in:
TableLayout>>layout:in:
AlignmentMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in AlignmentMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
AlignmentMorph(Morph)>>computeFullBounds
AlignmentMorph(Morph)>>fullBounds
AlignmentMorph(Morph)>>position:
AlignmentMorph(Morph)>>bounds:
AlignmentMorph(Morph)>>layoutInBounds:
TableLayout>>layoutTopToBottom:in:
TableLayout>>layout:in:
GLMPluggableButtonMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMPluggableButtonMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
GLMPluggableButtonMorph(Morph)>>computeFullBounds
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRubCharacterBlockScanner(RubCharacterScanner)>>setConditionArray:
RubCharacterBlockScanner>>setStopConditions
RubCharacterBlockScanner>>characterBlockAtPoint:index:in:
RubParagraph>>characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
Message>>sendTo:
[ aMessage sendTo: next ] in RubShoutStylerDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubShoutStylerDecorator(RubParagraphDecorator)>>doesNotUnderstand: #characterBlockForIndex:
RubEditingState>>markIndex:pointIndex:
[ self editingState markIndex: markIndex pointIndex: pointIndex ] in RubEditingArea(RubAbstractTextArea)>>markIndex:pointIndex: in Block: [ self editingState markIndex: markIndex pointInde...etc...
RubEditingArea(RubAbstractTextArea)>>handleSelectionChange:
RubEditingArea(RubAbstractTextArea)>>markIndex:pointIndex:
RubEditingArea(RubAbstractTextArea)>>recomputeSelection
[ self wrapped
	ifTrue: [ (bounds notNil and: [ bounds width = aPoint x ])
			ifTrue: [ ^ self ].
		super
			extent:
				((self paragraph withoutDecorator extentFromClientBottomRight: aPoint)
					max: self minimumExtent).
		self recomputeSelection ] ] in RubEditingArea(RubAbstractTextArea)>>extent: in Block: [ self wrapped...
RubEditingArea(RubAbstractTextArea)>>handleBoundsChange:
RubEditingArea(RubAbstractTextArea)>>extent:
RubEditingArea(Morph)>>width:
RubTextScrollPane>>fitScrollTargetWidth
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mWindowEdgeGripMorph(Morph)>>hasDropShadow
WindowEdgeGripMorph(Morph)>>outerBounds
WindowEdgeGripMorph(Morph)>>privateFullBounds
WindowEdgeGripMorph(Morph)>>changed
WindowEdgeGripMorph(Morph)>>extent:
WindowEdgeGripMorph(EdgeGripMorph)>>extent:
WindowEdgeGripMorph(Morph)>>bounds:
WindowEdgeGripMorph(Morph)>>layoutInBounds:
WindowEdgeGripMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMSystemWindow(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
GLMSystemWindow(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMSystemWindow(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
GLMSystemWindow(Morph)>>computeFullBounds
GLMSystemWindow(Morph)>>fullBounds
GLMSystemWindow>>extent:
GLMSystemWindow(Morph)>>bounds:
GLMSystemWindow(SystemWindow)>>openInWorld:
GLMSystemWindow(Morph)>>openInWorld
GLMMorphicRenderer>>open:
GTGenericStackDebugger(GLMCompositePresentation)>>openWith:
GTGenericStackDebugger(GLMCompositePresentation)>>open
GTGenericStackDebugger(GTMoldableDebugger)>>open
GTGenericStackDebugger>>openWithFullView
GTGenericStackDebugger class(GTMoldableDebugger class)>>openOn:withFullView:andNotification:
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ] in [ "schedule debugger in deferred UI message to address
			redraw problems after opening a debugger e.g. from
			the testrunner."
[ Smalltalk tools debugger
	openOn: debugSession
	withFullView: bool
	andNotification: notificationString ]
	on: Error
	do: [ :ex | debugSession signalDebuggerError: ex ] ] in MorphicUIManager>>debugProcess:context:label:fullView:notification: in Block: [ Smalltalk tools debugger...
BlockClosure>>on:do:
[0m[31mUser Interrupt
[0mLargePositiveInteger(LargeInteger)>>*
LargePositiveInteger>>printOn:base:
LargePositiveInteger(Number)>>printOn:
LargePositiveInteger(Object)>>gtDisplayOn:
[ :s | self gtDisplayOn: s ] in LargePositiveInteger(Object)>>gtDisplayString in Block: [ :s | self gtDisplayOn: s ]
String class(SequenceableCollection class)>>streamContents:limitedTo:
LargePositiveInteger(Object)>>gtDisplayString
[ (anObject gtDisplayString
	copyReplaceAll: String cr
	with: String space) replaceAll: String lf with: String space ] in GTObjectPrinter class>>asTruncatedTextFrom: in Block: [ (anObject gtDisplayString...
BlockClosure>>on:do:
GTObjectPrinter class>>asTruncatedTextFrom:
[ :aNode | 
| rawValue displayValue |
[ rawValue := aNode rawValue ]
	on: Error
	do: [ displayValue := Text
			string: aNode errorMessage
			attribute: TextColor red ].
displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] in GTDebuggerVariablesBrowser>>variablesIn: in Block: [ :aNode | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMTablePresentation)>>column:valueFor:
[ self glamourPresentation
	column: aGlamourColumn
	valueFor:
		(self glamourPresentation isWithElementIndex
			ifTrue:
				[ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ]
			ifFalse: [ anElement ]) ] in GLMFastTableDataSource>>valueFor:withIndex:in: in Block: [ self glamourPresentation...
GLMFastTableDataSource(GLMFastListDataSource)>>cacheAt:for:ifAbsentPut:
GLMFastTableDataSource>>valueFor:withIndex:in:
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableContainerMorph>>updateAllRows
FTTableContainerMorph>>drawOn:
FormCanvas(Canvas)>>draw:
FormCanvas(Canvas)>>drawMorph:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in FTTableContainerMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in FTTableContainerMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mColor class>>transparent
FTTableRowMorph>>defaultColor
FTTableRowMorph(Morph)>>initialize
FTTableRowMorph>>initialize
FTTableRowMorph>>initializeTable:
FTTableRowMorph class>>table:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resetPosition
FTTableMorph>>dataSource:
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>initializeTableMorph
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>render:
GLMMorphicFastTableRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderFastTablePresentation:
GLMFastTablePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[ self renderObject: each ] in [ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ self renderObject: each ]
LazyTabPage>>actualPageMorph
LazyTabGroupMorph>>pageAt:
LazyTabGroupMorph>>updatePageIndex:
LazyTabGroupMorph(TabGroupMorph)>>update:
LazyTabGroupMorph(Object)>>update:with:
MorphChangedWithArguments>>deliverTo:
LazyTabGroupMorph(Morph)>>handleUpdate:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mLargePositiveInteger(LargeInteger)>>*
LargePositiveInteger>>printOn:base:
LargePositiveInteger(Number)>>printOn:
LargePositiveInteger(Object)>>gtDisplayOn:
[ :s | self gtDisplayOn: s ] in LargePositiveInteger(Object)>>gtDisplayString in Block: [ :s | self gtDisplayOn: s ]
String class(SequenceableCollection class)>>streamContents:limitedTo:
LargePositiveInteger(Object)>>gtDisplayString
[ (anObject gtDisplayString
	copyReplaceAll: String cr
	with: String space) replaceAll: String lf with: String space ] in GTObjectPrinter class>>asTruncatedTextFrom: in Block: [ (anObject gtDisplayString...
BlockClosure>>on:do:
GTObjectPrinter class>>asTruncatedTextFrom:
[ :aNode | 
| rawValue displayValue |
[ rawValue := aNode rawValue ]
	on: Error
	do: [ displayValue := Text
			string: aNode errorMessage
			attribute: TextColor red ].
displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] in GTDebuggerVariablesBrowser>>variablesIn: in Block: [ :aNode | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMTablePresentation)>>column:valueFor:
[ self glamourPresentation
	column: aGlamourColumn
	valueFor:
		(self glamourPresentation isWithElementIndex
			ifTrue:
				[ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ]
			ifFalse: [ anElement ]) ] in GLMFastTableDataSource>>valueFor:withIndex:in: in Block: [ self glamourPresentation...
GLMFastTableDataSource(GLMFastListDataSource)>>cacheAt:for:ifAbsentPut:
GLMFastTableDataSource>>valueFor:withIndex:in:
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableContainerMorph>>updateAllRows
FTTableContainerMorph>>drawOn:
FormCanvas(Canvas)>>draw:
FormCanvas(Canvas)>>drawMorph:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in FTTableContainerMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in FTTableContainerMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection(SequenceableCollection)>>hash
KMComposedModifier>>hash
KMModifiedKeyCombination>>hash
OrderedCollection(SequenceableCollection)>>hash
KMKeyCombinationSequence>>hash
KMKeymap>>hash
Set>>scanFor:
Set>>add:
[ :each | self add: each ] in Set(Collection)>>addAll: in Block: [ :each | self add: each ]
Array(SequenceableCollection)>>do:
Set(Collection)>>addAll:
Set(Collection)>>,
KMStorage>>keymaps
KMStorage>>,
KMCategory>>allEntries
KMCategory>>keymaps
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch: in Block: [ :aTarget | ...
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch: in Block: [ :targetToDispatch | ...
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
FTTableMorph(Morph)>>dispatchKeystrokeForEvent:
FTTableMorph(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
FTTableMorph(Morph)>>handleKeystroke:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mCharacter>>asUppercase
ByteString(String)>>capitalized
ByteSymbol(Symbol)>>capitalized
[ :aSymbol | #gt , aSymbol capitalized ] in [ :presentation | 
self
	actionsForPragmas: (aSymbolsCollection collect: [ :aSymbol | #gt , aSymbol capitalized ]) ] in GTGenericStackDebugger(GTMoldableDebugger)>>installActionsForRootPragmas:in: in Block: [ :aSymbol | #gt , aSymbol capitalized ]
Array(SequenceableCollection)>>collect:
[ :presentation | 
self
	actionsForPragmas: (aSymbolsCollection collect: [ :aSymbol | #gt , aSymbol capitalized ]) ] in GTGenericStackDebugger(GTMoldableDebugger)>>installActionsForRootPragmas:in: in Block: [ :presentation | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMPresentation)>>dynamicActions
GLMFastTablePresentation(GLMPresentation)>>allActions
GLMFastTablePresentation(GLMPresentation)>>allActionsWithShortcuts
GLMMorphicFastTableRenderer(GLMMorphicWidgetRenderer)>>installKeystrokeActionsOnMorph:fromPresentation:
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>initializeAnnouncementForDataSource
GLMMorphicFastTableRenderer(GLMMorphicFTRenderer)>>dataSourceUpdated:
MessageSend>>value:
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
GLMFastTablePresentation(Announcer)>>announce:
GLMFastTablePresentation(GLMAnnouncer)>>announce:
GLMFastTablePresentation(GLMLoggedObject)>>announce:
GLMFastTableDataSource(GLMFastListDataSource)>>readyToBeDisplayed
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mTextMethodLink>>initialize
TextMethodLink class(Behavior)>>new
TextMethodLink class>>sourceNode:
SHRBTextStyler>>visitMessageNode:
RBMessageNode>>acceptVisitor:
SHRBTextStyler>>visitNode:
SHRBTextStyler>>visitReturnNode:
RBReturnNode>>acceptVisitor:
SHRBTextStyler>>visitNode:
[ :each | self visitNode: each ] in SHRBTextStyler>>visitSequenceNode: in Block: [ :each | self visitNode: each ]
OrderedCollection>>do:
SHRBTextStyler>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
SHRBTextStyler>>visitNode:
SHRBTextStyler>>visitMethodNode:
RBMethodNode>>acceptVisitor:
SHRBTextStyler>>style:ast:
SHRBTextStyler>>privateStyle:
SHRBTextStyler(SHTextStyler)>>style:
[ ^ self styler style: aText ] in RubShoutStylerDecorator>>style: in Block: [ ^ self styler style: aText ]
BlockClosure>>on:do:
RubShoutStylerDecorator>>style:
[ aText addAttribute: self defaultFontChange.
next text: (text := self styler format: aText).
replaceStart := 1.
replaceStop := text size.
self style: text ] in RubShoutStylerDecorator>>text: in Block: [ aText addAttribute: self defaultFontChange....
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
Message>>sendTo:
[ aMessage sendTo: next ] in RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile:
Message>>sendTo:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mGLMBrickBounds>>extent
GLMBrickBounds>>outerOrigin:
GLMBrickWrapper>>outerOrigin:
[ :origin :each | 
each outerOrigin: origin.
each outerBounds width @ 0 ] in GLMHorizontalLinearLayout>>layout:in: in Block: [ :origin :each | ...
BlockClosure>>cull:cull:
[ :origin :each | 
| result |
result := origin
	+
		((self isFloating: each)
			ifFalse: [ aBlock cull: origin cull: each ]
			ifTrue: [ self layoutFloating: each in: aRectangle ]).
"applying aligning: #none, #left, #center, #right"
self
	align: each
	in: aBrick
	anchorPoint: origin
	inContext: nil.
each onLayouted.
result ] in GLMHorizontalLinearLayout(GLMLinearLayout)>>layout:in:inject:into: in Block: [ :origin :each | ...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in OrderedCollection(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
OrderedCollection>>do:
OrderedCollection(Collection)>>inject:into:
GLMHorizontalLinearLayout(GLMLinearLayout)>>layout:in:inject:into:
GLMHorizontalLinearLayout>>layout:in:
GLMBrick>>invalidateLayout
GLMBrickWrapper>>invalidateLayout
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutSubbricks:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutAround:inContext:
[ :each | self layoutAround: each inContext: aBrick ] in GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf: in Block: [ :each | self layoutAround: each inContext: aBric...etc...
OrderedCollection>>do:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf:
GLMBrickLayoutParentState>>layout:on:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutAround:inContext:
[ :each | self layoutAround: each inContext: aBrick ] in GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf: in Block: [ :each | self layoutAround: each inContext: aBric...etc...
OrderedCollection>>do:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf:
GLMBrickLayoutParentState>>layout:on:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutAround:inContext:
[ :each | self layoutAround: each inContext: aBrick ] in GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf: in Block: [ :each | self layoutAround: each inContext: aBric...etc...
OrderedCollection>>do:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutChildrenOf:
GLMBrickLayoutMyselfState>>layout:on:
GLMBrickHeightTraverser(GLMBrickLayoutTraverser)>>layoutAround:inContext:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRunArray class>>runs:values:
RunArray class>>new
RunArray class>>new:withAll:
Text class>>string:attributes:
Text class>>fromString:
ByteString(String)>>asText
RubTextComposer>>unplug
RubParagraph>>releaseComposer
RubParagraph>>unplug
RubEditingArea(RubAbstractTextArea)>>releaseParagraph
RubEditingArea(RubAbstractTextArea)>>unplug
RubTextScrollPane>>unregisterTextArea
RubTextScrollPane>>scrollTarget:
RubScrolledTextMorph>>newScrollPane
RubScrolledTextMorph>>initialize
RubScrolledTextMorph class(Behavior)>>new
GLMMorphicPharoMethodRenderer>>morph
GLMMorphicPharoMethodRenderer(GLMMorphicRubricTextRenderer)>>render:
GLMMorphicPharoMethodRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPharoMethodPresentation:
GLMPharoMethodPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[ self renderObject: each ] in [ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ self renderObject: each ]
LazyTabPage>>actualPageMorph
LazyTabGroupMorph>>pageAt:
LazyTabGroupMorph>>updatePageIndex:
LazyTabGroupMorph(TabGroupMorph)>>update:
LazyTabGroupMorph(Object)>>update:with:
MorphChangedWithArguments>>deliverTo:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mSmallInteger(Magnitude)>>max:
Rectangle>>setPoint:point:
Rectangle class>>origin:extent:
Point>>extent:
PanelMorph(Morph)>>adjustLayoutBounds
PanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in PanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
PanelMorph(Morph)>>computeFullBounds
PanelMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in FTCellMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
FTCellMorph(Morph)>>submorphBounds
FTCellMorph(Morph)>>privateFullBounds
FTCellMorph(Morph)>>changed
FTCellMorph(Morph)>>extent:
FTCellMorph(Morph)>>width:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
GLMPanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMPanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>do:
RubCompositionScanner(RubCharacterScanner)>>setFont
RubCompositionScanner>>setFont
RubCompositionScanner>>setStopConditions
RubCompositionScanner>>endOfRun
RubCompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:
RubTextComposer>>composeEachRectangleIn:
RubTextComposer>>composeAllRectangles:
RubTextComposer>>composeOneLine
RubTextComposer>>composeAllLines
RubTextComposer>>composeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:
RubTextComposer>>composeLinesFrom:to:delta:into:priorLines:atY:
[ self uptodateComposer
	composeLinesFrom: 1
	to: self text size
	delta: 0
	into: OrderedCollection new
	priorLines: Array new
	atY: self compositionRectangle top.
textArea
	ifNotNil: [ textArea paragraphWasComposedFrom: 1 to: self text size ] ] in RubParagraph>>compose in Block: [ self uptodateComposer...
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
RubParagraph>>compose
RubParagraph>>extentFromClientBottomRight:
[ self wrapped
	ifTrue: [ (bounds notNil and: [ bounds width = aPoint x ])
			ifTrue: [ ^ self ].
		super
			extent:
				((self paragraph withoutDecorator extentFromClientBottomRight: aPoint)
					max: self minimumExtent).
		self recomputeSelection ] ] in RubEditingArea(RubAbstractTextArea)>>extent: in Block: [ self wrapped...
RubEditingArea(RubAbstractTextArea)>>handleBoundsChange:
RubEditingArea(RubAbstractTextArea)>>extent:
RubEditingArea(Morph)>>width:
RubTextScrollPane>>fitScrollTargetWidth
RubTextScrollPane>>updateScrollbars
RubTextScrollPane(GeneralScrollPane)>>extent:
RubTextScrollPane>>extent:
RubScrolledTextMorph>>manageLayoutInBounds:
RubScrolledTextMorph>>manageLayout
RubScrolledTextMorph>>extent:
RubScrolledTextMorph(Morph)>>bounds:
RubScrolledTextMorph(Morph)>>layoutInBounds:
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mPoint>>dotProduct:
StringMorph(Morph)>>bounds:
[ :m :ext | 
| pos vr box cell |
width := m hResizing == #spaceFill
	ifTrue: [ fillCount := fillCount - 1.
		ext x
			+
				(fillCount > 0
					ifTrue: [ spare ]
					ifFalse: [ extra ]) ]
	ifFalse: [ ext x ].
cell := x @ newBounds top extent: width @ height.
((vr := m vResizing) == #shrinkWrap or: [ m bounds ~= cell ])
	ifTrue: [ ((vr == #shrinkWrap) not and: [ m extent = cell extent ])
			ifTrue: [ m position: cell origin ]
			ifFalse: [ box := m bounds.
				m hResizing == #spaceFill
					ifTrue: [ box := cell origin extent: cell width @ box height ].
				vr == #spaceFill
					ifTrue: [ box := box origin extent: box width @ cell height ].
				vr == #shrinkWrap
					ifTrue: [ box := box origin extent: box width @ ext y ].
				pos := props cellPositioning.
				box := box align: (box perform: pos) with: (cell perform: pos).
				m bounds: box ] ].
x := x + width + inset ] in RowLayout>>layout:in: in Block: [ :m :ext | ...
Array(SequenceableCollection)>>with:do:
RowLayout>>layout:in:
SimpleButtonMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in SimpleButtonMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
SimpleButtonMorph(Morph)>>computeFullBounds
SimpleButtonMorph(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in FTTableRowMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
FTTableRowMorph(Morph)>>submorphBounds
FTTableRowMorph(Morph)>>privateFullBounds
FTTableRowMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in FTTableRowMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
FTTableRowMorph(Morph)>>computeFullBounds
FTTableRowMorph(Morph)>>fullBounds
FTTableRowMorph(Morph)>>fullDrawOn:
FormCanvas(Canvas)>>fullDraw:
FormCanvas(Canvas)>>fullDrawMorph:
[ :m | canvas fullDrawMorph: m ] in [ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in FTTableContainerMorph(Morph)>>drawSubmorphsOn: in Block: [ :m | canvas fullDrawMorph: m ]
Array(SequenceableCollection)>>reverseDo:
[ :canvas | submorphs reverseDo: [ :m | canvas fullDrawMorph: m ] ] in FTTableContainerMorph(Morph)>>drawSubmorphsOn: in Block: [ :canvas | submorphs reverseDo: [ :m | canvas ful...etc...
FormCanvas>>clipBy:during:
FTTableContainerMorph(Morph)>>drawSubmorphsOn:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in FTTableContainerMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[0m[31mUser Interrupt
[0mLargePositiveInteger(LargeInteger)>>*
LargePositiveInteger>>printOn:base:
LargePositiveInteger(Number)>>printOn:
LargePositiveInteger(Object)>>gtDisplayOn:
[ :s | self gtDisplayOn: s ] in LargePositiveInteger(Object)>>gtDisplayString in Block: [ :s | self gtDisplayOn: s ]
String class(SequenceableCollection class)>>streamContents:limitedTo:
LargePositiveInteger(Object)>>gtDisplayString
[ (anObject gtDisplayString
	copyReplaceAll: String cr
	with: String space) replaceAll: String lf with: String space ] in GTObjectPrinter class>>asTruncatedTextFrom: in Block: [ (anObject gtDisplayString...
BlockClosure>>on:do:
GTObjectPrinter class>>asTruncatedTextFrom:
[ :aNode | 
| rawValue displayValue |
[ rawValue := aNode rawValue ]
	on: Error
	do: [ displayValue := Text
			string: aNode errorMessage
			attribute: TextColor red ].
displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] in GTDebuggerVariablesBrowser>>variablesIn: in Block: [ :aNode | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMTablePresentation)>>column:valueFor:
[ self glamourPresentation
	column: aGlamourColumn
	valueFor:
		(self glamourPresentation isWithElementIndex
			ifTrue:
				[ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ]
			ifFalse: [ anElement ]) ] in GLMFastTableDataSource>>valueFor:withIndex:in: in Block: [ self glamourPresentation...
GLMFastTableDataSource(GLMFastListDataSource)>>cacheAt:for:ifAbsentPut:
GLMFastTableDataSource>>valueFor:withIndex:in:
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mFreeTypeFont>>widthOfString:from:to:
FreeTypeFont(AbstractFont)>>widthOfString:
LogicalFont>>widthOfString:
GLMStringBrick>>sizeOf:
GLMStringBrick>>textSize
GLMStringBrick>>approximateWidth
ByteSymbol(Symbol)>>cull:
ByteSymbol(Symbol)>>brickValue:
GLMStringBrick(GLMBrick)>>customWidth
[ self bounds: (self brickBounds withWidth: self customWidth) ] in GLMStringBrick(GLMBrick)>>updateWidth in Block: [ self bounds: (self brickBounds withWidth: self c...etc...
BlockClosure>>on:do:
GLMStringBrick(GLMBrick)>>updateWidth
GLMStringBrick(GLMBrick)>>width:
GLMStringBrick>>hShrinkWrap
GLMLabelBrick>>hShrinkWrap
GLMLabelBrick>>initialize
GLMLabelBrick class(Behavior)>>new
LazyTabGroupMorph>>buildLabelFrom:withAction:
LazyTabGroupMorph>>addLazyPage:label:toolbar:action:
[ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ :each | ...
OrderedCollection>>do:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
GLMMorphicPaneRenderer>>render:
[0m[31mUser Interrupt
[0mTextComposer>>composeOneLine
TextComposer>>composeAllLines
TextComposer>>multiComposeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:wantsColumnBreaks:
Paragraph>>multiComposeLinesFrom:to:delta:into:priorLines:atY:
Paragraph>>composeAll
Paragraph>>compose:style:from:in:
TextMorph>>paragraph
TextMorph>>newContents:
TextMorph>>contentsAsIs:
Text>>asTextMorph
Text>>asMorph
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
GLMPanelMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMPanelMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
GLMPanelMorph(Morph)>>computeFullBounds
GLMPanelMorph(Morph)>>fullBounds
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRBScanner>>stripComment
RBScanner>>stripSeparators
RBScanner>>next
RBParser>>step
RBParser>>scanner:
RBParser>>initializeParserWith:
RBParser class>>parseMethod:onError:
RBParser class>>parseFaultyMethod:
[ root := RBParser parseFaultyMethod: aText asString.
root methodNode methodClass: classOrMetaClass.
^ root ] in SHRBTextStyler>>parse:isMethod: in Block: [ root := RBParser parseFaultyMethod: aText asStri...etc...
BlockClosure>>on:do:
SHRBTextStyler>>parse:isMethod:
SHRBTextStyler>>privateStyle:
SHRBTextStyler(SHTextStyler)>>style:
[ ^ self styler style: aText ] in RubShoutStylerDecorator>>style: in Block: [ ^ self styler style: aText ]
BlockClosure>>on:do:
RubShoutStylerDecorator>>style:
[ aText addAttribute: self defaultFontChange.
next text: (text := self styler format: aText).
replaceStart := 1.
replaceStop := text size.
self style: text ] in RubShoutStylerDecorator>>text: in Block: [ aText addAttribute: self defaultFontChange....
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
Message>>sendTo:
[ aMessage sendTo: next ] in RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile:
Message>>sendTo:
[ aMessage sendTo: next ] in RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile:
Message>>sendTo:
[ aMessage sendTo: next ] in RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile: in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mSmallInteger>>=
Point>>=
Rectangle>>=
WindowEdgeGripMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMSystemWindow(Morph)>>submorphsDo:
ProportionalLayout>>layout:in:
GLMSystemWindow(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in GLMSystemWindow(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
GLMSystemWindow(Morph)>>computeFullBounds
GLMSystemWindow(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in WorldMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
WorldMorph(Morph)>>submorphBounds
WorldMorph(Morph)>>privateFullBounds
WorldMorph(Morph)>>doLayoutIn:
[ self doLayoutIn: self layoutBounds ] in WorldMorph(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
WorldMorph(Morph)>>computeFullBounds
WorldMorph(Morph)>>fullBounds
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseOver:
MouseEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mMetaclass(Behavior)>>hasAbstractMethods
GTBrowseDebugAction class(Class)>>hasAbstractMethods
[ :each | each hasAbstractMethods ] in DebugSession class>>debuggingActionsForPragma:for: in Block: [ :each | each hasAbstractMethods ]
OrderedCollection>>reject:
DebugSession class>>debuggingActionsForPragma:for:
[ :currentActions :aSymbol | 
currentActions
	addAll: (self debuggingActionsForPragma: aSymbol for: aDebugger);
	yourself ] in DebugSession class>>debuggingActionsForPragmas:for: in Block: [ :currentActions :aSymbol | ...
[ :each | nextValue := binaryBlock value: nextValue value: each ] in Array(Collection)>>inject:into: in Block: [ :each | nextValue := binaryBlock value: nextValu...etc...
Array(SequenceableCollection)>>do:
Array(Collection)>>inject:into:
DebugSession class>>debuggingActionsForPragmas:for:
GTGenericStackDebugger(GTMoldableDebugger)>>allActionsForPragmas:
GTGenericStackDebugger(GTMoldableDebugger)>>actionsForPragmas:
[ :presentation | 
self
	actionsForPragmas: (aSymbolsCollection collect: [ :aSymbol | #gt , aSymbol capitalized ]) ] in GTGenericStackDebugger(GTMoldableDebugger)>>installActionsForRootPragmas:in: in Block: [ :presentation | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMPresentation)>>dynamicActions
GLMFastTablePresentation(GLMPresentation)>>allActions
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>toolbarButtonsForPresentation:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderToolbarForPresentation:inMorph:
[ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ :each | ...
OrderedCollection>>do:
GLMMorphicTabbedRenderer>>render:
GLMMorphicTabbedRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderTabbedCompositePresentation:
GLMTabbedArrangement>>renderGlamorouslyOn:
GLMCompositePresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicPaneRenderer(GLMMorphicWidgetRenderer)>>renderObject:
GLMMorphicPaneRenderer>>renderContainerFor:
GLMMorphicPaneRenderer>>render:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDictionary>>at:ifAbsent:
Dictionary>>at:ifAbsentPut:
FreeTypeFont>>widthAndKernedWidthOfLeft:right:into:
LogicalFont>>widthAndKernedWidthOfLeft:right:into:
RubCompositionScanner(RubCharacterScanner)>>basicScanCharactersFrom:to:in:rightX:stopConditions:kern:
RubCompositionScanner(RubCharacterScanner)>>scanCharactersFrom:to:in:rightX:stopConditions:kern:
RubCompositionScanner>>composeFrom:inRectangle:firstLine:leftSide:rightSide:
RubTextComposer>>composeEachRectangleIn:
RubTextComposer>>composeAllRectangles:
RubTextComposer>>composeOneLine
RubTextComposer>>composeAllLines
RubTextComposer>>composeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:
RubTextComposer>>composeLinesFrom:to:delta:into:priorLines:atY:
[ self uptodateComposer
	composeLinesFrom: 1
	to: self text size
	delta: 0
	into: OrderedCollection new
	priorLines: Array new
	atY: self compositionRectangle top.
textArea
	ifNotNil: [ textArea paragraphWasComposedFrom: 1 to: self text size ] ] in RubParagraph>>compose in Block: [ self uptodateComposer...
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
RubParagraph>>compose
Message>>sendTo:
[ aMessage sendTo: next ] in RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #compose in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #compose
Message>>sendTo:
[ aMessage sendTo: next ] in RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #compose in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubExtraSelectionDecorator(RubParagraphDecorator)>>doesNotUnderstand: #compose
Message>>sendTo:
[ aMessage sendTo: next ] in RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #compose in Block: [ aMessage sendTo: next ]
BlockClosure>>on:do:
RubCurrentLineBarDecorator(RubParagraphDecorator)>>doesNotUnderstand: #compose
Message>>sendTo:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mOrderedCollection>>resetTo:
OrderedCollection>>reset
OrderedCollection>>setCollection:
OrderedCollection class>>new:
OrderedCollection class>>new
RxMatcher>>tryMatch
RxMatcher>>searchStream:
RxMatcher>>matchesOnStream:do:
RxMatcher>>matchesIn:do:
RxMatcher>>matchingRangesIn:
PharoDocCommentNode class>>docCommentRangesIn:
PharoDocCommentNode class>>parseDocComments:
RBComment>>pharoDocCommentNodes
SHRBTextStyler>>styleDocComment:
[ :comment | self styleDocComment: comment ] in SHRBTextStyler>>visitMethodComments: in Block: [ :comment | self styleDocComment: comment ]
Array(SequenceableCollection)>>do:
SHRBTextStyler>>visitMethodComments:
SHRBTextStyler>>visitMethodNode:
RBMethodNode>>acceptVisitor:
SHRBTextStyler>>style:ast:
SHRBTextStyler>>privateStyle:
SHRBTextStyler(SHTextStyler)>>style:
[ ^ self styler style: aText ] in RubShoutStylerDecorator>>style: in Block: [ ^ self styler style: aText ]
BlockClosure>>on:do:
RubShoutStylerDecorator>>style:
[ aText addAttribute: self defaultFontChange.
next text: (text := self styler format: aText).
replaceStart := 1.
replaceStop := text size.
self style: text ] in RubShoutStylerDecorator>>text: in Block: [ aText addAttribute: self defaultFontChange....
BlockClosure>>ensure:
RubParagraph>>disableDrawingWhile:
Message>>sendTo:
[ aMessage sendTo: next ] in RubOpeningClosingDelimiterDecorator(RubParagraphDecorator)>>doesNotUnderstand: #disableDrawingWhile: in Block: [ aMessage sendTo: next ]
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRxMatcher>>next
RxmSubstring>>matchAgainst:
RxmMarker>>matchAgainst:
RxmLink>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmBranch>>matchAgainst:
RxmMarker>>matchAgainst:
RxmBranch>>matchAgainst:
RxmMarker>>matchAgainst:
RxmBranch>>matchAgainst:
RxmMarker>>matchAgainst:
RxMatcher>>tryMatch
RxMatcher>>searchStream:
RxMatcher>>matchesOnStream:do:
RxMatcher>>matchesIn:do:
RxMatcher>>matchingRangesIn:
PharoDocCommentNode class>>docCommentRangesIn:
PharoDocCommentNode class>>parseDocComments:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRxmSubstring>>sampleStream
RxmSubstring>>matchAgainst:
RxmMarker>>matchAgainst:
RxmLink>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmBranch>>matchAgainst:
RxmMarker>>matchAgainst:
RxmBranch>>matchAgainst:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRxMatcher>>atEnd
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmBranch>>matchAgainst:
RxmMarker>>matchAgainst:
RxmBranch>>matchAgainst:
RxmMarker>>matchAgainst:
RxmBranch>>matchAgainst:
RxmMarker>>matchAgainst:
RxMatcher>>tryMatch
RxMatcher>>searchStream:
RxMatcher>>matchesOnStream:do:
RxMatcher>>matchesIn:do:
RxMatcher>>matchingRangesIn:
PharoDocCommentNode class>>docCommentRangesIn:
PharoDocCommentNode class>>parseDocComments:
RBComment>>pharoDocCommentNodes
SHRBTextStyler>>styleDocComment:
[ :comment | self styleDocComment: comment ] in SHRBTextStyler>>visitMethodComments: in Block: [ :comment | self styleDocComment: comment ]
Array(SequenceableCollection)>>do:
SHRBTextStyler>>visitMethodComments:
SHRBTextStyler>>visitMethodNode:
RBMethodNode>>acceptVisitor:
SHRBTextStyler>>style:ast:
SHRBTextStyler>>privateStyle:
SHRBTextStyler(SHTextStyler)>>style:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mReadStream(PositionableStream)>>position:
[ stream position: origPosition ] in RxMatcher>>currentState in Block: [ stream position: origPosition ]
RxMatcher>>restoreState:
RxmSubstring>>matchAgainst:
RxmMarker>>matchAgainst:
RxmLink>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
RxmBranch>>matchAgainst:
RxmPredicate>>matchAgainst:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:ifAbsent:
Array(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
RubScrolledTextMorph(Morph)>>valueOfProperty:
RubScrolledTextMorph(Morph)>>theme
RubTextScrollPane(Morph)>>theme
RubTextScrollPane(GeneralScrollPane)>>scrollBarThickness
RubTextScrollPane(GeneralScrollPane)>>vResizeScrollbar
RubTextScrollPane(GeneralScrollPane)>>vUpdateScrollbar
RubTextScrollPane(GeneralScrollPane)>>updateScrollbars
RubTextScrollPane>>updateScrollbars
RubTextScrollPane(GeneralScrollPane)>>extent:
RubTextScrollPane>>extent:
RubScrolledTextMorph>>manageLayoutInBounds:
RubScrolledTextMorph>>manageLayout
RubScrolledTextMorph>>withRuler:
RubScrolledTextMorph>>withRulerNamed:
RubScrolledTextMorph>>withTextSegmentIcons
RubScrolledTextMorph>>beForSmalltalkCode
GLMMorphicPharoMethodRenderer>>morph
GLMMorphicPharoMethodRenderer(GLMMorphicRubricTextRenderer)>>render:
GLMMorphicPharoMethodRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPharoMethodPresentation:
GLMPharoMethodPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[ self renderObject: each ] in [ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ self renderObject: each ]
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mLargePositiveInteger(LargeInteger)>>-
LargePositiveInteger>>printOn:base:
LargePositiveInteger(Number)>>printOn:
LargePositiveInteger(Object)>>gtDisplayOn:
[ :s | self gtDisplayOn: s ] in LargePositiveInteger(Object)>>gtDisplayString in Block: [ :s | self gtDisplayOn: s ]
String class(SequenceableCollection class)>>streamContents:limitedTo:
LargePositiveInteger(Object)>>gtDisplayString
[ (anObject gtDisplayString
	copyReplaceAll: String cr
	with: String space) replaceAll: String lf with: String space ] in GTObjectPrinter class>>asTruncatedTextFrom: in Block: [ (anObject gtDisplayString...
BlockClosure>>on:do:
GTObjectPrinter class>>asTruncatedTextFrom:
[ :aNode | 
| rawValue displayValue |
[ rawValue := aNode rawValue ]
	on: Error
	do: [ displayValue := Text
			string: aNode errorMessage
			attribute: TextColor red ].
displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] in GTDebuggerVariablesBrowser>>variablesIn: in Block: [ :aNode | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMTablePresentation)>>column:valueFor:
[ self glamourPresentation
	column: aGlamourColumn
	valueFor:
		(self glamourPresentation isWithElementIndex
			ifTrue:
				[ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ]
			ifFalse: [ anElement ]) ] in GLMFastTableDataSource>>valueFor:withIndex:in: in Block: [ self glamourPresentation...
GLMFastTableDataSource(GLMFastListDataSource)>>cacheAt:for:ifAbsentPut:
GLMFastTableDataSource>>valueFor:withIndex:in:
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableMorph>>resizeAllSubviews
FTTableMorph>>extent:
FTTableMorph(Morph)>>bounds:
FTTableMorph(Morph)>>layoutInBounds:
FTTableMorph(Morph)>>layoutProportionallyIn:
[ :m | m layoutProportionallyIn: newBounds ] in ProportionalLayout>>layout:in: in Block: [ :m | m layoutProportionallyIn: newBounds ]
Array(SequenceableCollection)>>do:
GLMPanelMorph(Morph)>>submorphsDo:
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mSmallInteger(Number)>>raisedToInteger:
LargePositiveInteger>>printOn:base:
LargePositiveInteger(Number)>>printOn:
LargePositiveInteger(Object)>>gtDisplayOn:
[ :s | self gtDisplayOn: s ] in LargePositiveInteger(Object)>>gtDisplayString in Block: [ :s | self gtDisplayOn: s ]
String class(SequenceableCollection class)>>streamContents:limitedTo:
LargePositiveInteger(Object)>>gtDisplayString
[ (anObject gtDisplayString
	copyReplaceAll: String cr
	with: String space) replaceAll: String lf with: String space ] in GTObjectPrinter class>>asTruncatedTextFrom: in Block: [ (anObject gtDisplayString...
BlockClosure>>on:do:
GTObjectPrinter class>>asTruncatedTextFrom:
[ :aNode | 
| rawValue displayValue |
[ rawValue := aNode rawValue ]
	on: Error
	do: [ displayValue := Text
			string: aNode errorMessage
			attribute: TextColor red ].
displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] in GTDebuggerVariablesBrowser>>variablesIn: in Block: [ :aNode | ...
BlockClosure>>glamourValueWithArgs:
BlockClosure(ProtoObject)>>glamourValue:
GLMFastTablePresentation(GLMTablePresentation)>>column:valueFor:
[ self glamourPresentation
	column: aGlamourColumn
	valueFor:
		(self glamourPresentation isWithElementIndex
			ifTrue:
				[ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ]
			ifFalse: [ anElement ]) ] in GLMFastTableDataSource>>valueFor:withIndex:in: in Block: [ self glamourPresentation...
GLMFastTableDataSource(GLMFastListDataSource)>>cacheAt:for:ifAbsentPut:
GLMFastTableDataSource>>valueFor:withIndex:in:
GLMFastTableDataSource>>viewRowMorphForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphElementsForColumn:node:withIndex:
GLMFastTableDataSource>>rowMorphForColumn:item:withIndex:
GLMFastTableDataSource>>cellColumn:row:
FTTableContainerMorph>>updateExposedRows
FTTableContainerMorph>>updateAllRows
FTTableContainerMorph>>drawOn:
FormCanvas(Canvas)>>draw:
FormCanvas(Canvas)>>drawMorph:
[ (aCanvas isVisible: self bounds)
	ifTrue: [ aCanvas drawMorph: self ].
self drawSubmorphsOn: aCanvas.
self drawDropHighlightOn: aCanvas.
self drawMouseDownHighlightOn: aCanvas ] in [ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in FTTableContainerMorph(Morph)>>fullDrawOn: in Block: [ (aCanvas isVisible: self bounds)...
FormCanvas>>roundCornersOf:in:during:
FormCanvas(Canvas)>>roundCornersOf:during:
[ "Note: At some point we should generalize this into some sort of 
		multi-canvas so that we can cross-optimize some drawing operations."
"Pass 1: Draw eventual drop-shadow"
self hasDropShadow
	ifTrue: [ self drawDropShadowOn: aCanvas ].

"Pass 2: Draw receiver itself"
aCanvas
	roundCornersOf: self
	during: [ (aCanvas isVisible: self bounds)
			ifTrue: [ aCanvas drawMorph: self ].
		self drawSubmorphsOn: aCanvas.
		self drawDropHighlightOn: aCanvas.
		self drawMouseDownHighlightOn: aCanvas ] ] in FTTableContainerMorph(Morph)>>fullDrawOn: in Block: [ "Note: At some point we should generalize this i...etc...
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mRubTextSegmentIconDisplayer(Morph)>>borderWidth
RubTextSegmentIconDisplayer(Morph)>>innerBounds
RubTextSegmentIconDisplayer(Morph)>>layoutBounds
[ self doLayoutIn: self layoutBounds ] in RubTextSegmentIconDisplayer(Morph)>>computeFullBounds in Block: [ self doLayoutIn: self layoutBounds ]
BlockClosure>>on:do:
RubTextSegmentIconDisplayer(Morph)>>computeFullBounds
RubTextSegmentIconDisplayer(Morph)>>fullBounds
[ :m | 
| subBox |
m visible
	ifTrue: [ subBox := m fullBounds.
		box
			ifNil: [ box := subBox copy ]
			ifNotNil: [ box := box quickMerge: subBox ] ] ] in RubScrolledTextMorph(Morph)>>submorphBounds in Block: [ :m | ...
Array(SequenceableCollection)>>do:
RubScrolledTextMorph(Morph)>>submorphBounds
RubScrolledTextMorph(Morph)>>privateFullBounds
RubScrolledTextMorph(Morph)>>changed
RubScrolledTextMorph>>resetState
RubScrolledTextMorph>>setTextWith:
RubScrolledTextMorph>>model:
GLMMorphicPharoMethodRenderer>>morph
GLMMorphicPharoMethodRenderer(GLMMorphicRubricTextRenderer)>>render:
GLMMorphicPharoMethodRenderer class(GLMMorphicWidgetRenderer class)>>render:from:
GLMMorphicRenderer>>renderPharoMethodPresentation:
GLMPharoMethodPresentation>>renderGlamorouslyOn:
GLMMorphicRenderer(GLMRenderer)>>render:
GLMMorphicTabbedRenderer(GLMMorphicWidgetRenderer)>>renderObject:
[ self renderObject: each ] in [ :each | 
tabs
	addLazyPage: [ self renderObject: each ]
	label: (self titleOrIconOf: each in: tabs)
	toolbar: (self renderToolbarForPresentation: each inMorph: tabs)
	action: (self labelActionBrickFor: each) ] in GLMMorphicTabbedRenderer>>render: in Block: [ self renderObject: each ]
LazyTabPage>>actualPageMorph
LazyTabGroupMorph>>pageAt:
LazyTabGroupMorph>>updatePageIndex:
LazyTabGroupMorph(TabGroupMorph)>>update:
LazyTabGroupMorph(Object)>>update:with:
MorphChangedWithArguments>>deliverTo:
LazyTabGroupMorph(Morph)>>handleUpdate:
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0mArray(SequenceableCollection)>>identityIndexOf:ifAbsent:
Array(SequenceableCollection)>>identityIndexOf:
SmallIdentityDictionary>>findIndexForKey:
SmallIdentityDictionary(SmallDictionary)>>at:ifAbsent:
MorphExtension>>valueOfProperty:ifAbsent:
MorphExtension>>valueOfProperty:
GLMPanelMorph(Morph)>>valueOfProperty:
GLMPanelMorph(Morph)>>theme
RubScrolledTextMorph(Morph)>>theme
RubTextScrollPane(Morph)>>theme
RubScrollBar(Morph)>>theme
RubScrollBar(Slider)>>initializeSlider
RubScrollBar(ScrollBar)>>initializeSlider
RubScrollBar(Slider)>>extent:
RubScrollBar(ScrollBar)>>extent:
RubScrollBar(Morph)>>bounds:
RubTextScrollPane(GeneralScrollPane)>>vResizeScrollbar
RubTextScrollPane(GeneralScrollPane)>>vShowScrollbar
RubTextScrollPane(GeneralScrollPane)>>vUpdateScrollbar
RubTextScrollPane(GeneralScrollPane)>>updateScrollbars
RubTextScrollPane>>updateScrollbars
RubTextScrollPane(GeneralScrollPane)>>extent:
RubTextScrollPane>>extent:
RubScrolledTextMorph>>manageLayoutInBounds:
RubScrolledTextMorph>>manageLayout
RubScrolledTextMorph>>extent:
RubScrolledTextMorph(Morph)>>bounds:
RubScrolledTextMorph(Morph)>>layoutInBounds:
TableLayout>>layoutTopToBottom:in:
TableLayout>>layout:in:
[0m[31mUser Interrupt
[0mDelaySemaphoreScheduler>>schedule:
Delay>>schedule
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mUser Interrupt
[0m[ delaySemaphore wait ] in Delay>>wait in Block: [ delaySemaphore wait ]
BlockClosure>>ifCurtailed:
Delay>>wait
Duration>>wait
[ | result |
anIntegerMilliseconds > 0
	ifTrue: [ anIntegerMilliseconds milliSeconds wait ].
result := aBlock valueWithEnoughArguments: aCollection.
"we use it to pass result from background thread and execute callback block in UI thread"
UIManager default
	defer: [ self complete: result callback: callbackBlock ] ] in GLMAsyncTask>>execute:withArguments:callback:priority:delay: in Block: [ | result |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0mser
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :previousRow | ...
BlockClosure>>cull:
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in Interval(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
Interval>>do:
Interval(Collection)>>detect:ifFound:ifNone:
Interval(Collection)>>detect:ifFound:
[ :break | 
(row - 1 to: 1)
	detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
	ifFound: [ :previousRow | 
		self halt.
		vis composer move: newRowGroup below: #newRow , previousRow asString.
		break value ] ] in [ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :row | ...
Interval>>collect:
[ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ | unionLabel nowProcLabel |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		self halt.
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :row | ...
Interval>>collect:
[ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ | unionLabel nowProcLabel |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		self halt.
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :row | ...
Interval>>collect:
[ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group:[31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		self halt.
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :row | ...
Interval>>collect:
[ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ | unionLabel nowProcLabel |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :previousRow | 
self halt.
vis composer move: newRowGroup below: #newRow , previousRow asString.
break value ] in [ :break | 
(row - 1 to: 1)
	detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
	ifFound: [ :previousRow | 
		self halt.
		vis composer move: newRowGroup below: #newRow , previousRow asString.
		break value ] ] in [ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		self halt.
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :previousRow | ...
BlockClosure>>cull:
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in Interval(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
Interval>>do:
Interval(Collection)>>detect:ifFound:ifNone:
Interval(Collection)>>detect:ifFound:
[ :break | 
(row - 1 to: 1)
	detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
	ifFound: [ :previousRow | 
		self halt.
		vis composer move: newRowGroup below: #newRow , previousRow asString.
		break value ] ] in [31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		self halt.
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :row | ...
Interval>>collect:
[ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: ri[31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		self halt.
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :row | ...
Interval>>collect:
[ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ | unionLabel nowProcLabel |...
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		self halt.
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		self halt.
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				self halt.
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				self halt.
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :row | ...
Interval>>collect:
[ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSpar[31mHalt
[0mLILSparseMatrix(Object)>>halt
[ :previousRow | 
self halt.
vis composer move: newRowGroup below: #newRow , previousRow asString.
break value ] in [ :break | 
(row - 1 to: 1)
	detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
	ifFound: [ :previousRow | 
		self halt.
		vis composer move: newRowGroup below: #newRow , previousRow asString.
		break value ] ] in [ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: nowProcLabel.
vis group: #nowProc.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer nameGroup: #leftRow as: 'leftRow'.
vis composer nameGroup: #rightRow as: 'rightRow'.
vis composer groupToExisting: 'labels'.
vis namedGroups: #(#left #result #right #leftRow #rightRow).
vis backgroundGroups: #(#left #result #right #leftRow #rightRow).
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
vis update.
vis delay wait.
arr := (1 to: result rowNumber)
	collect: [ :row | 
		| newRowGroup |
		vis composer removeGroup: #leftRow.
		LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
		vis group: #leftRow.
		vis composer removeGroup: #rightRow.
		LILSparseMatrixVisualizer
			onRow: row
			in: rightMatrix
			withView: vis view.
		vis group: #rightRow.
		vis composer move: #leftRow below: #left.
		vis composer move: #rightRow below: #right.
		vis composer move: #unionLabel between: #leftRow and: #rightRow.
		vis composer move: #nowProc below: #unionLabel.
		vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
		vis group: #labels.
		arr := (rows at: row) union: (rightMatrix rows at: row).
		arr := (1 to: columnNumber)
			collect: [ :columnIndex | 
				nowProcLabel model: columnIndex.
				nowProcLabel update.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #leftRow.
				vis composer
					deselectUsing: [ :model | model column = (columnIndex - 1) ]
					inGroup: #rightRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #leftRow.
				vis composer
					selectUsing: [ :model | model column = columnIndex ]
					inGroup: #rightRow.
				vis delay wait.
				LILSparseMatrixNode
					column: columnIndex
					value:
						((arr select: [ :node | node column = columnIndex ])
							inject: 0
							into: [ :sum :element | sum + element value ]) ]
			thenReject: [ :node | node value = 0 ].
		"last column was not deselected"
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = columnNumber ]
			inGroup: #rightRow.
		nowProcLabel model: 'none'.
		nowProcLabel update.
		vis delay wait.
		list := LinkedList new.
		newRowGroup := #newRow , row asString.
		arr
			do: [ :node | 
				list addLast: node.
				(vis composer hasGroup: newRowGroup)
					ifTrue: [ vis composer removeGroup: newRowGroup ].
				LILSparseMatrixVisualizer
					onLinkedList: list
					inRow: row
					withView: vis view.
				vis group: newRowGroup.
				vis composer move: newRowGroup below: #nowProc.
				vis composer redrawNamesFor: vis namedGroups.
				vis composer redrawBackgroundsFor: vis backgroundGroups.
				vis composer view canvas focusOnCenterScaled.
				vis delay wait ].
		list isEmpty
			ifFalse: [ | captionLabel |
				row = 1
					ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
					ifFalse: [ self
							withEscaper: [ :break | 
								(row - 1 to: 1)
									detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
									ifFound: [ :previousRow | 
										self halt.
										vis composer
											move: newRowGroup
											below: #newRow , previousRow asString.
										break value ] ] ].
				captionLabel := (RTLabel
					text: Character arrowLeft asString , 'List for row ' , row asString)
					element.
				vis add: captionLabel.
				vis group: #newRow , row asString , #Caption.
				vis composer
					move: #newRow , row asString , #Caption
					onTheRightOf: newRowGroup ].
		vis composer view canvas focusOnCenterScaled.
		list ].
vis composer removeGroup: #leftRow.
vis composer removeGroup: #rightRow.
vis composer removeGroup: #unionLabel.
vis composer removeGroup: #nowProc.
vis
	namedGroups: (vis namedGroups copyWithoutAll: #(#leftRow #rightRow)).
vis
	backgroundGroups: (vis backgroundGroups copyWithoutAll: #(#leftRow #rightRow)).
vis redrawNamesAndBackgrounds.
1 to: result rowNumber do: [ :rowIndex | 
	(vis composer hasGroup: #newRow , rowIndex asString)
		ifTrue: [ vis composer removeGroup: #newRow , rowIndex asString.
			vis composer removeGroup: #newRow , rowIndex asString , #Caption ].
	result rows at: rowIndex put: (arr at: rowIndex).
	vis updateResultWith: result.
	vis composer view canvas focusOnCenterScaled.
	vis delay wait ] ] in LILSparseMatrix>>addAnimated:delay: in Block: [ :previousRow | ...
BlockClosure>>cull:
[ :each | 
(aBlock value: each)
	ifTrue: [ ^ foundBlock cull: each ] ] in Interval(Collection)>>detect:ifFound:ifNone: in Block: [ :each | ...
Interval>>do:
Interval(Collection)>>detect:ifFound:ifNone:
Interval(Collection)>>detect:ifFound:
[ :break | 
(row - 1 to: 1)
	detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
	ifFound: [ :previousRow | 
		self halt.
		vis composer move: newRowGroup below: #newRow , previousRow asString.
		break value ] ] in [ :row | 
| newRowGroup |
vis composer removeGroup: #leftRow.
LILSparseMatrixVisualizer onRow: row in: self withView: vis view.
vis group: #leftRow.
vis composer removeGroup: #rightRow.
LILSparseMatrixVisualizer
	onRow: row
	in: rightMatrix
	withView: vis view.
vis group: #rightRow.
vis composer move: #leftRow below: #left.
vis composer move: #rightRow below: #right.
vis composer move: #unionLabel between: #leftRow and: #rightRow.
vis composer move: #nowProc below: #unionLabel.
vis composer redrawNamesAndBackgroundsFor: vis namedGroups.
vis group: #labels.
arr := (rows at: row) union: (rightMatrix rows at: row).
arr := (1 to: columnNumber)
	collect: [ :columnIndex | 
		nowProcLabel model: columnIndex.
		nowProcLabel update.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #leftRow.
		vis composer
			deselectUsing: [ :model | model column = (columnIndex - 1) ]
			inGroup: #rightRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #leftRow.
		vis composer
			selectUsing: [ :model | model column = columnIndex ]
			inGroup: #rightRow.
		vis delay wait.
		LILSparseMatrixNode
			column: columnIndex
			value:
				((arr select: [ :node | node column = columnIndex ])
					inject: 0
					into: [ :sum :element | sum + element value ]) ]
	thenReject: [ :node | node value = 0 ].
"last column was not deselected"
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #leftRow.
vis composer
	deselectUsing: [ :model | model column = columnNumber ]
	inGroup: #rightRow.
nowProcLabel model: 'none'.
nowProcLabel update.
vis delay wait.
list := LinkedList new.
newRowGroup := #newRow , row asString.
arr
	do: [ :node | 
		list addLast: node.
		(vis composer hasGroup: newRowGroup)
			ifTrue: [ vis composer removeGroup: newRowGroup ].
		LILSparseMatrixVisualizer
			onLinkedList: list
			inRow: row
			withView: vis view.
		vis group: newRowGroup.
		vis composer move: newRowGroup below: #nowProc.
		vis composer redrawNamesFor: vis namedGroups.
		vis composer redrawBackgroundsFor: vis backgroundGroups.
		vis composer view canvas focusOnCenterScaled.
		vis delay wait ].
list isEmpty
	ifFalse: [ | captionLabel |
		row = 1
			ifTrue: [ vis composer move: newRowGroup onTheRightBelowOf: #result ]
			ifFalse: [ self
					withEscaper: [ :break | 
						(row - 1 to: 1)
							detect: [ :rowIndex | vis composer hasGroup: #newRow , rowIndex asString ]
							ifFound: [ :previousRow | 
								self halt.
								vis composer
									move: newRowGroup
									below: #newRow , previousRow asString.
								break value ] ] ].
		captionLabel := (RTLabel
			text: Character arrowLeft asString , 'List for row ' , row asString)
			element.
		vis add: captionLabel.
		vis group: #newRow , row asString , #Caption.
		vis composer
			move: #newRow , row asString , #Caption
			onTheRightOf: newRowGroup ].
vis composer view canvas focusOnCenterScaled.
list ] in [ | unionLabel nowProcLabel |
unionLabel := (RTLabel text: 'U') element.
vis add: unionLabel.
vis group: #unionLabel.
LILSparseMatrixVisualizer onRow: 1 in: self withView: vis view.
vis group: #leftRow.
LILSparseMatrixVisualizer onRow: 1 in: rightMatrix withView: vis view.
vis group: #rightRow.
nowProcLabel := (RTLabel
	text: [ :col | 'Processing column ' , col asString ]) elementOn: 0.
vis add: n[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m